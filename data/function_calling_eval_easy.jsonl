{"difficulty": "easy", "function_schema_python": "def check_calendar_availability(start_date: str, end_date: str) -> dict:\n    \"\"\"Checks calendar availability for a given date range.\n\n    :param start_date: Start date in 'YYYY-MM-DD' format\n    :param end_date: End date in 'YYYY-MM-DD' format\n    :return: Dictionary containing availability status and conflicting events\n    :raises ValueError: If dates are invalid or in wrong format\"\"\"\n    pass\ndef get_conflicting_appointments(start_date: str, end_date: str) -> list:\n    \"\"\"Retrieves all appointments within a date range that need rescheduling.\n\n    :param start_date: Start date in 'YYYY-MM-DD' format\n    :param end_date: End date in 'YYYY-MM-DD' format\n    :return: List of appointment dictionaries\n    :raises ValueError: If dates are invalid\"\"\"\n    pass\ndef reschedule_appointment(appointment_id: str, new_date: str, new_time: str) -> bool:\n    \"\"\"Reschedules an existing appointment to a new date and time.\n\n    :param appointment_id: Unique identifier for the appointment\n    :param new_date: New date in 'YYYY-MM-DD' format\n    :param new_time: New time in 'HH:MM' format\n    :return: True if rescheduling successful, False otherwise\n    :raises ValueError: If appointment_id is invalid or date/time format incorrect\"\"\"\n    pass\n", "function_schema_json": [{"name": "check_calendar_availability", "description": "Checks calendar availability for a given date range.", "parameters": {"type": "object", "properties": {"start_date": {"type": "string", "description": "Start date in 'YYYY-MM-DD' format"}, "end_date": {"type": "string", "description": "End date in 'YYYY-MM-DD' format"}}, "required": ["start_date", "end_date"], "additionalProperties": false}}, {"name": "get_conflicting_appointments", "description": "Retrieves all appointments within a date range that need rescheduling.", "parameters": {"type": "object", "properties": {"start_date": {"type": "string", "description": "Start date in 'YYYY-MM-DD' format"}, "end_date": {"type": "string", "description": "End date in 'YYYY-MM-DD' format"}}, "required": ["start_date", "end_date"], "additionalProperties": false}}, {"name": "reschedule_appointment", "description": "Reschedules an existing appointment to a new date and time.", "parameters": {"type": "object", "properties": {"appointment_id": {"type": "string", "description": "Unique identifier for the appointment"}, "new_date": {"type": "string", "description": "New date in 'YYYY-MM-DD' format"}, "new_time": {"type": "string", "description": "New time in 'HH:MM' format"}}, "required": ["appointment_id", "new_date", "new_time"], "additionalProperties": false}}], "mock_functions": "def check_calendar_availability(start_date: str, end_date: str) -> dict:\n    \"\"\"\n    Checks calendar availability for a given date range.\n    \n    :param start_date: Start date in 'YYYY-MM-DD' format\n    :param end_date: End date in 'YYYY-MM-DD' format\n    :return: Dictionary containing availability status and conflicting events\n    :raises ValueError: If dates are invalid or in wrong format\n    \"\"\"\n    if not all(date.count('-') == 2 for date in [start_date, end_date]):\n        raise ValueError(\"Dates must be in YYYY-MM-DD format\")\n        \n    if start_date == \"2023-10-14\" and end_date == \"2023-10-14\":\n        return {\n            \"is_available\": True,\n            \"conflicts\": []\n        }\n    return {\n        \"is_available\": False,\n        \"conflicts\": [\"Meeting with Marketing Team at 2 PM\"]\n    }\ndef get_conflicting_appointments(start_date: str, end_date: str) -> list:\n    \"\"\"\n    Retrieves all appointments within a date range that need rescheduling.\n    \n    :param start_date: Start date in 'YYYY-MM-DD' format\n    :param end_date: End date in 'YYYY-MM-DD' format\n    :return: List of appointment dictionaries\n    :raises ValueError: If dates are invalid\n    \"\"\"\n    if start_date == \"2023-10-15\" and end_date == \"2023-10-20\":\n        return [\n            {\n                \"date\": \"2023-10-16\",\n                \"time\": \"14:00\",\n                \"title\": \"Client Call with ABC Corp\",\n                \"duration\": 60\n            },\n            {\n                \"date\": \"2023-10-18\",\n                \"time\": \"10:00\",\n                \"title\": \"Weekly Team Sync\",\n                \"duration\": 30\n            }\n        ]\n    return []\ndef reschedule_appointment(appointment_id: str, new_date: str, new_time: str) -> bool:\n    \"\"\"\n    Reschedules an existing appointment to a new date and time.\n    \n    :param appointment_id: Unique identifier for the appointment\n    :param new_date: New date in 'YYYY-MM-DD' format\n    :param new_time: New time in 'HH:MM' format\n    :return: True if rescheduling successful, False otherwise\n    :raises ValueError: If appointment_id is invalid or date/time format incorrect\n    \"\"\"\n    if not appointment_id or not new_date or not new_time:\n        raise ValueError(\"All parameters must be provided\")\n    \n    valid_appointments = [\"ABC001\", \"TEAM002\"]\n    if appointment_id in valid_appointments:\n        return True\n    return False", "user_query": "Is Jenny available for a team meeting on 2023-10-14?", "checklist": {"functions": ["check_calendar_availability"], "values": [{"is_available": true, "conflicts": []}]}}
{"difficulty": "easy", "function_schema_python": "def check_calendar_availability(start_date: str, end_date: str) -> dict:\n    \"\"\"Checks calendar availability for a given date range.\n\n    :param start_date: Start date in 'YYYY-MM-DD' format\n    :param end_date: End date in 'YYYY-MM-DD' format\n    :return: Dictionary containing availability status and conflicting events\n    :raises ValueError: If dates are invalid or in wrong format\"\"\"\n    pass\ndef get_conflicting_appointments(start_date: str, end_date: str) -> list:\n    \"\"\"Retrieves all appointments within a date range that need rescheduling.\n\n    :param start_date: Start date in 'YYYY-MM-DD' format\n    :param end_date: End date in 'YYYY-MM-DD' format\n    :return: List of appointment dictionaries\n    :raises ValueError: If dates are invalid\"\"\"\n    pass\ndef reschedule_appointment(appointment_id: str, new_date: str, new_time: str) -> bool:\n    \"\"\"Reschedules an existing appointment to a new date and time.\n\n    :param appointment_id: Unique identifier for the appointment\n    :param new_date: New date in 'YYYY-MM-DD' format\n    :param new_time: New time in 'HH:MM' format\n    :return: True if rescheduling successful, False otherwise\n    :raises ValueError: If appointment_id is invalid or date/time format incorrect\"\"\"\n    pass\n", "function_schema_json": [{"name": "check_calendar_availability", "description": "Checks calendar availability for a given date range.", "parameters": {"type": "object", "properties": {"start_date": {"type": "string", "description": "Start date in 'YYYY-MM-DD' format"}, "end_date": {"type": "string", "description": "End date in 'YYYY-MM-DD' format"}}, "required": ["start_date", "end_date"], "additionalProperties": false}}, {"name": "get_conflicting_appointments", "description": "Retrieves all appointments within a date range that need rescheduling.", "parameters": {"type": "object", "properties": {"start_date": {"type": "string", "description": "Start date in 'YYYY-MM-DD' format"}, "end_date": {"type": "string", "description": "End date in 'YYYY-MM-DD' format"}}, "required": ["start_date", "end_date"], "additionalProperties": false}}, {"name": "reschedule_appointment", "description": "Reschedules an existing appointment to a new date and time.", "parameters": {"type": "object", "properties": {"appointment_id": {"type": "string", "description": "Unique identifier for the appointment"}, "new_date": {"type": "string", "description": "New date in 'YYYY-MM-DD' format"}, "new_time": {"type": "string", "description": "New time in 'HH:MM' format"}}, "required": ["appointment_id", "new_date", "new_time"], "additionalProperties": false}}], "mock_functions": "def check_calendar_availability(start_date: str, end_date: str) -> dict:\n    \"\"\"\n    Checks calendar availability for a given date range.\n    \n    :param start_date: Start date in 'YYYY-MM-DD' format\n    :param end_date: End date in 'YYYY-MM-DD' format\n    :return: Dictionary containing availability status and conflicting events\n    :raises ValueError: If dates are invalid or in wrong format\n    \"\"\"\n    if not all(date.count('-') == 2 for date in [start_date, end_date]):\n        raise ValueError(\"Dates must be in YYYY-MM-DD format\")\n        \n    if start_date == \"2023-10-14\" and end_date == \"2023-10-14\":\n        return {\n            \"is_available\": True,\n            \"conflicts\": []\n        }\n    return {\n        \"is_available\": False,\n        \"conflicts\": [\"Meeting with Marketing Team at 2 PM\"]\n    }\ndef get_conflicting_appointments(start_date: str, end_date: str) -> list:\n    \"\"\"\n    Retrieves all appointments within a date range that need rescheduling.\n    \n    :param start_date: Start date in 'YYYY-MM-DD' format\n    :param end_date: End date in 'YYYY-MM-DD' format\n    :return: List of appointment dictionaries\n    :raises ValueError: If dates are invalid\n    \"\"\"\n    if start_date == \"2023-10-15\" and end_date == \"2023-10-20\":\n        return [\n            {\n                \"date\": \"2023-10-16\",\n                \"time\": \"14:00\",\n                \"title\": \"Client Call with ABC Corp\",\n                \"duration\": 60\n            },\n            {\n                \"date\": \"2023-10-18\",\n                \"time\": \"10:00\",\n                \"title\": \"Weekly Team Sync\",\n                \"duration\": 30\n            }\n        ]\n    return []\ndef reschedule_appointment(appointment_id: str, new_date: str, new_time: str) -> bool:\n    \"\"\"\n    Reschedules an existing appointment to a new date and time.\n    \n    :param appointment_id: Unique identifier for the appointment\n    :param new_date: New date in 'YYYY-MM-DD' format\n    :param new_time: New time in 'HH:MM' format\n    :return: True if rescheduling successful, False otherwise\n    :raises ValueError: If appointment_id is invalid or date/time format incorrect\n    \"\"\"\n    if not appointment_id or not new_date or not new_time:\n        raise ValueError(\"All parameters must be provided\")\n    \n    valid_appointments = [\"ABC001\", \"TEAM002\"]\n    if appointment_id in valid_appointments:\n        return True\n    return False", "user_query": "What appointments conflict with Jenny's San Francisco conference trip from 2023-10-15 to 2023-10-20?", "checklist": {"functions": ["get_conflicting_appointments"], "values": [[{"date": "2023-10-16", "time": "14:00", "title": "Client Call with ABC Corp", "duration": 60}, {"date": "2023-10-18", "time": "10:00", "title": "Weekly Team Sync", "duration": 30}]]}}
{"difficulty": "easy", "function_schema_python": "def smartpal_open_food_ordering(app_name: str) -> bool:\n    \"\"\"Opens the food ordering section within the SmartPal app.\n\n    :param app_name: The name of the app to open (e.g., \"SmartPal\").\n    :return: True if the food ordering section was opened successfully, False otherwise.\"\"\"\n    pass\ndef smartpal_suggest_dishes(restaurant_name: str, cuisine_type: str, dietary_restrictions: List[str]) -> List[str]:\n    \"\"\"Suggests popular dishes from a specified restaurant based on cuisine type and dietary restrictions.\n\n    :param restaurant_name: The name of the restaurant (e.g., \"Bella Vita\").\n    :param cuisine_type: The type of cuisine (e.g., \"Italian\").\n    :param dietary_restrictions: A list of dietary restrictions (e.g., [\"vegetarian\"]).\n    :return: A list of suggested dishes.\"\"\"\n    pass\ndef smartpal_place_order(restaurant_name: str, dishes: List[str], budget: float, delivery_time: str) -> Dict:\n    \"\"\"Places a food order through SmartPal.\n\n    :param restaurant_name: The name of the restaurant.\n    :param dishes: A list of dishes to order.\n    :param budget: The maximum budget for the order.\n    :param delivery_time: The desired delivery time frame (e.g., \"2 hours\").\n    :return: A dictionary containing order details, including order ID and estimated delivery time.\n        dict: A dictionary with the following keys:\n            - order_id (int): The unique order identifier.\n            - estimated_delivery_time (str): Estimated delivery time.\"\"\"\n    pass\n", "function_schema_json": [{"name": "smartpal_open_food_ordering", "description": "Opens the food ordering section within the SmartPal app.", "parameters": {"type": "object", "properties": {"app_name": {"type": "string", "description": "The name of the app to open (e.g., \"SmartPal\")."}}, "required": ["app_name"], "additionalProperties": false}}, {"name": "smartpal_suggest_dishes", "description": "Suggests popular dishes from a specified restaurant based on cuisine type and dietary restrictions.", "parameters": {"type": "object", "properties": {"restaurant_name": {"type": "string", "description": "The name of the restaurant (e.g., \"Bella Vita\")."}, "cuisine_type": {"type": "string", "description": "The type of cuisine (e.g., \"Italian\")."}, "dietary_restrictions": {"type": "array", "items": {"type": "string"}, "description": "A list of dietary restrictions (e.g., [\"vegetarian\"])."}}, "required": ["restaurant_name", "cuisine_type", "dietary_restrictions"], "additionalProperties": false}}, {"name": "smartpal_place_order", "description": "Places a food order through SmartPal.", "parameters": {"type": "object", "properties": {"restaurant_name": {"type": "string", "description": "The name of the restaurant."}, "dishes": {"type": "array", "items": {"type": "string"}, "description": "A list of dishes to order."}, "budget": {"type": "number", "description": "The maximum budget for the order."}, "delivery_time": {"type": "string", "description": "The desired delivery time frame (e.g., \"2 hours\")."}}, "required": ["restaurant_name", "dishes", "budget", "delivery_time"], "additionalProperties": false}}], "mock_functions": "def smartpal_open_food_ordering(app_name: str) -> bool:\n    \"\"\"\n    Opens the food ordering section within the SmartPal app.\n\n    :param app_name: The name of the app to open (e.g., \"SmartPal\").\n    :return: True if the food ordering section was opened successfully, False otherwise.\n    \"\"\"\n    if app_name == \"SmartPal\":\n        return True\n    return False\ndef smartpal_suggest_dishes(restaurant_name: str, cuisine_type: str, dietary_restrictions: List[str]) -> List[str]:\n    \"\"\"\n    Suggests popular dishes from a specified restaurant based on cuisine type and dietary restrictions.\n\n    :param restaurant_name: The name of the restaurant (e.g., \"Bella Vita\").\n    :param cuisine_type: The type of cuisine (e.g., \"Italian\").\n    :param dietary_restrictions: A list of dietary restrictions (e.g., [\"vegetarian\"]).\n    :return: A list of suggested dishes.\n    \"\"\"\n    if restaurant_name == \"Bella Vita\" and cuisine_type == \"Italian\":\n        if \"vegetarian\" in dietary_restrictions:\n            return [\"Margherita Pizza\", \"Vegetarian Lasagna\", \"Caprese Salad\"]\n        else:\n            return [\"Spaghetti Carbonara\", \"Chicken Alfredo\", \"Pepperoni Pizza\", \"Margherita Pizza\"]\n    return []\ndef smartpal_place_order(restaurant_name: str, dishes: List[str], budget: float, delivery_time: str) -> Dict:\n    \"\"\"\n    Places a food order through SmartPal.\n\n    :param restaurant_name: The name of the restaurant.\n    :param dishes: A list of dishes to order.\n    :param budget: The maximum budget for the order.\n    :param delivery_time: The desired delivery time frame (e.g., \"2 hours\").\n    :return: A dictionary containing order details, including order ID and estimated delivery time.\n        dict: A dictionary with the following keys:\n            - order_id (int): The unique order identifier.\n            - estimated_delivery_time (str): Estimated delivery time.\n    \"\"\"\n    if restaurant_name == \"Bella Vita\" and budget == 200 and delivery_time == \"2 hours\":\n        return {\n            \"order_id\": 12345,\n            \"estimated_delivery_time\": \"1 hour 30 minutes\"\n        }\n    return {}", "user_query": "Can you open the food ordering section in SmartPal?", "checklist": {"functions": ["smartpal_open_food_ordering"], "values": [true]}}
{"difficulty": "easy", "function_schema_python": "def get_user_preferences(user_id: str) -> dict:\n    \"\"\"Retrieves user's dietary preferences and order history.\n\n    :param user_id: The unique identifier for the user.\n    :return: Dictionary containing user preferences and order history.\n    :raises ValueError: If user_id is invalid.\"\"\"\n    pass\ndef get_restaurant_menu(restaurant_id: str) -> dict:\n    \"\"\"Retrieves menu items from the specified restaurant.\n\n    :param restaurant_id: The unique identifier for the restaurant.\n    :return: Dictionary containing menu items and their details.\n    :raises ValueError: If restaurant_id is invalid.\"\"\"\n    pass\ndef get_active_promotions(restaurant_id: str) -> dict:\n    \"\"\"Retrieves active promotions for the specified restaurant.\n\n    :param restaurant_id: The unique identifier for the restaurant.\n    :return: Dictionary containing active promotions.\n    :raises ValueError: If restaurant_id is invalid.\"\"\"\n    pass\ndef place_food_order(user_id: str, restaurant_id: str, items: list, promo_code: str) -> dict:\n    \"\"\"Places a food order with the specified details.\n\n    :param user_id: The unique identifier for the user.\n    :param restaurant_id: The unique identifier for the restaurant.\n    :param items: List of items to order.\n    :param promo_code: Optional promotion code to apply.\n    :return: Dictionary containing order confirmation details.\n    :raises ValueError: If any parameters are invalid.\"\"\"\n    pass\n", "function_schema_json": [{"name": "get_user_preferences", "description": "Retrieves user's dietary preferences and order history.", "parameters": {"type": "object", "properties": {"user_id": {"type": "string", "description": "The unique identifier for the user."}}, "required": ["user_id"], "additionalProperties": false}}, {"name": "get_restaurant_menu", "description": "Retrieves menu items from the specified restaurant.", "parameters": {"type": "object", "properties": {"restaurant_id": {"type": "string", "description": "The unique identifier for the restaurant."}}, "required": ["restaurant_id"], "additionalProperties": false}}, {"name": "get_active_promotions", "description": "Retrieves active promotions for the specified restaurant.", "parameters": {"type": "object", "properties": {"restaurant_id": {"type": "string", "description": "The unique identifier for the restaurant."}}, "required": ["restaurant_id"], "additionalProperties": false}}, {"name": "place_food_order", "description": "Places a food order with the specified details.", "parameters": {"type": "object", "properties": {"user_id": {"type": "string", "description": "The unique identifier for the user."}, "restaurant_id": {"type": "string", "description": "The unique identifier for the restaurant."}, "items": {"type": "array", "description": "List of items to order."}, "promo_code": {"type": "string", "description": "Optional promotion code to apply."}}, "required": ["user_id", "restaurant_id", "items", "promo_code"], "additionalProperties": false}}], "mock_functions": "def get_user_preferences(user_id: str) -> dict:\n    \"\"\"\n    Retrieves user's dietary preferences and order history.\n    \n    :param user_id: The unique identifier for the user.\n    :return: Dictionary containing user preferences and order history.\n    :raises ValueError: If user_id is invalid.\n    \"\"\"\n    if not user_id:\n        raise ValueError(\"User ID must not be empty\")\n    if user_id == \"david_123\":\n        return {\n            \"dietary_preferences\": [\"vegan\", \"gluten-free\"],\n            \"favorite_cuisines\": [\"Mediterranean\", \"Asian\"],\n            \"previous_orders\": [\"Buddha Bowl\", \"Quinoa Salad\"]\n        }\n    raise ValueError(\"User not found\")\ndef get_restaurant_menu(restaurant_id: str) -> dict:\n    \"\"\"\n    Retrieves menu items from the specified restaurant.\n    \n    :param restaurant_id: The unique identifier for the restaurant.\n    :return: Dictionary containing menu items and their details.\n    :raises ValueError: If restaurant_id is invalid.\n    \"\"\"\n    if restaurant_id == \"green_bites_01\":\n        return {\n            \"items\": [\n                {\"name\": \"Buddha Bowl\", \"price\": 15.99, \"dietary\": [\"vegan\", \"gluten-free\"]},\n                {\"name\": \"Quinoa Salad\", \"price\": 12.99, \"dietary\": [\"vegan\", \"gluten-free\"]}\n            ],\n            \"available\": True\n        }\n    raise ValueError(\"Restaurant not found\")\ndef get_active_promotions(restaurant_id: str) -> dict:\n    \"\"\"\n    Retrieves active promotions for the specified restaurant.\n    \n    :param restaurant_id: The unique identifier for the restaurant.\n    :return: Dictionary containing active promotions.\n    :raises ValueError: If restaurant_id is invalid.\n    \"\"\"\n    if restaurant_id == \"green_bites_01\":\n        return {\n            \"promotions\": [\n                {\"code\": \"SUNDAY20\", \"discount\": 20, \"minimum_order\": 25.00},\n                {\"code\": \"HEALTHY10\", \"discount\": 10, \"minimum_order\": 15.00}\n            ]\n        }\n    raise ValueError(\"Restaurant not found\")\ndef place_food_order(user_id: str, restaurant_id: str, items: list, promo_code: str = None) -> dict:\n    \"\"\"\n    Places a food order with the specified details.\n    \n    :param user_id: The unique identifier for the user.\n    :param restaurant_id: The unique identifier for the restaurant.\n    :param items: List of items to order.\n    :param promo_code: Optional promotion code to apply.\n    :return: Dictionary containing order confirmation details.\n    :raises ValueError: If any parameters are invalid.\n    \"\"\"\n    if user_id == \"david_123\" and restaurant_id == \"green_bites_01\":\n        if items == [\"Buddha Bowl\"]:\n            return {\n                \"order_id\": \"ORD123456\",\n                \"estimated_delivery\": \"30 minutes\",\n                \"total_price\": 15.99,\n                \"status\": \"confirmed\"\n            }\n    raise ValueError(\"Invalid order parameters\")", "user_query": "What are my dietary preferences and past orders (user ID: david_123)?", "checklist": {"functions": ["get_user_preferences"], "values": [{"dietary_preferences": ["vegan", "gluten-free"], "favorite_cuisines": ["Mediterranean", "Asian"], "previous_orders": ["Buddha Bowl", "Quinoa Salad"]}]}}
{"difficulty": "easy", "function_schema_python": "def get_user_preferences(user_id: str) -> dict:\n    \"\"\"Retrieves user's dietary preferences and order history.\n\n    :param user_id: The unique identifier for the user.\n    :return: Dictionary containing user preferences and order history.\n    :raises ValueError: If user_id is invalid.\"\"\"\n    pass\ndef get_restaurant_menu(restaurant_id: str) -> dict:\n    \"\"\"Retrieves menu items from the specified restaurant.\n\n    :param restaurant_id: The unique identifier for the restaurant.\n    :return: Dictionary containing menu items and their details.\n    :raises ValueError: If restaurant_id is invalid.\"\"\"\n    pass\ndef get_active_promotions(restaurant_id: str) -> dict:\n    \"\"\"Retrieves active promotions for the specified restaurant.\n\n    :param restaurant_id: The unique identifier for the restaurant.\n    :return: Dictionary containing active promotions.\n    :raises ValueError: If restaurant_id is invalid.\"\"\"\n    pass\ndef place_food_order(user_id: str, restaurant_id: str, items: list, promo_code: str) -> dict:\n    \"\"\"Places a food order with the specified details.\n\n    :param user_id: The unique identifier for the user.\n    :param restaurant_id: The unique identifier for the restaurant.\n    :param items: List of items to order.\n    :param promo_code: Optional promotion code to apply.\n    :return: Dictionary containing order confirmation details.\n    :raises ValueError: If any parameters are invalid.\"\"\"\n    pass\n", "function_schema_json": [{"name": "get_user_preferences", "description": "Retrieves user's dietary preferences and order history.", "parameters": {"type": "object", "properties": {"user_id": {"type": "string", "description": "The unique identifier for the user."}}, "required": ["user_id"], "additionalProperties": false}}, {"name": "get_restaurant_menu", "description": "Retrieves menu items from the specified restaurant.", "parameters": {"type": "object", "properties": {"restaurant_id": {"type": "string", "description": "The unique identifier for the restaurant."}}, "required": ["restaurant_id"], "additionalProperties": false}}, {"name": "get_active_promotions", "description": "Retrieves active promotions for the specified restaurant.", "parameters": {"type": "object", "properties": {"restaurant_id": {"type": "string", "description": "The unique identifier for the restaurant."}}, "required": ["restaurant_id"], "additionalProperties": false}}, {"name": "place_food_order", "description": "Places a food order with the specified details.", "parameters": {"type": "object", "properties": {"user_id": {"type": "string", "description": "The unique identifier for the user."}, "restaurant_id": {"type": "string", "description": "The unique identifier for the restaurant."}, "items": {"type": "array", "description": "List of items to order."}, "promo_code": {"type": "string", "description": "Optional promotion code to apply."}}, "required": ["user_id", "restaurant_id", "items", "promo_code"], "additionalProperties": false}}], "mock_functions": "def get_user_preferences(user_id: str) -> dict:\n    \"\"\"\n    Retrieves user's dietary preferences and order history.\n    \n    :param user_id: The unique identifier for the user.\n    :return: Dictionary containing user preferences and order history.\n    :raises ValueError: If user_id is invalid.\n    \"\"\"\n    if not user_id:\n        raise ValueError(\"User ID must not be empty\")\n    if user_id == \"david_123\":\n        return {\n            \"dietary_preferences\": [\"vegan\", \"gluten-free\"],\n            \"favorite_cuisines\": [\"Mediterranean\", \"Asian\"],\n            \"previous_orders\": [\"Buddha Bowl\", \"Quinoa Salad\"]\n        }\n    raise ValueError(\"User not found\")\ndef get_restaurant_menu(restaurant_id: str) -> dict:\n    \"\"\"\n    Retrieves menu items from the specified restaurant.\n    \n    :param restaurant_id: The unique identifier for the restaurant.\n    :return: Dictionary containing menu items and their details.\n    :raises ValueError: If restaurant_id is invalid.\n    \"\"\"\n    if restaurant_id == \"green_bites_01\":\n        return {\n            \"items\": [\n                {\"name\": \"Buddha Bowl\", \"price\": 15.99, \"dietary\": [\"vegan\", \"gluten-free\"]},\n                {\"name\": \"Quinoa Salad\", \"price\": 12.99, \"dietary\": [\"vegan\", \"gluten-free\"]}\n            ],\n            \"available\": True\n        }\n    raise ValueError(\"Restaurant not found\")\ndef get_active_promotions(restaurant_id: str) -> dict:\n    \"\"\"\n    Retrieves active promotions for the specified restaurant.\n    \n    :param restaurant_id: The unique identifier for the restaurant.\n    :return: Dictionary containing active promotions.\n    :raises ValueError: If restaurant_id is invalid.\n    \"\"\"\n    if restaurant_id == \"green_bites_01\":\n        return {\n            \"promotions\": [\n                {\"code\": \"SUNDAY20\", \"discount\": 20, \"minimum_order\": 25.00},\n                {\"code\": \"HEALTHY10\", \"discount\": 10, \"minimum_order\": 15.00}\n            ]\n        }\n    raise ValueError(\"Restaurant not found\")\ndef place_food_order(user_id: str, restaurant_id: str, items: list, promo_code: str = None) -> dict:\n    \"\"\"\n    Places a food order with the specified details.\n    \n    :param user_id: The unique identifier for the user.\n    :param restaurant_id: The unique identifier for the restaurant.\n    :param items: List of items to order.\n    :param promo_code: Optional promotion code to apply.\n    :return: Dictionary containing order confirmation details.\n    :raises ValueError: If any parameters are invalid.\n    \"\"\"\n    if user_id == \"david_123\" and restaurant_id == \"green_bites_01\":\n        if items == [\"Buddha Bowl\"]:\n            return {\n                \"order_id\": \"ORD123456\",\n                \"estimated_delivery\": \"30 minutes\",\n                \"total_price\": 15.99,\n                \"status\": \"confirmed\"\n            }\n    raise ValueError(\"Invalid order parameters\")", "user_query": "Can you check if Green Bites (restaurant ID: green_bites_01) has any active promotions today?", "checklist": {"functions": ["get_active_promotions"], "values": [{"promotions": [{"code": "SUNDAY20", "discount": 20, "minimum_order": 25.0}, {"code": "HEALTHY10", "discount": 10, "minimum_order": 15.0}]}]}}
{"difficulty": "easy", "function_schema_python": "def check_cpu_usage(server_id: str) -> float:\n    \"\"\"Checks the current CPU usage of a specified server.\n\n    :param server_id: The unique identifier of the server.\n    :return: The CPU usage percentage as a float.\n    :raises ValueError: If server_id is empty or invalid.\"\"\"\n    pass\ndef get_server_metrics(server_id: str) -> dict:\n    \"\"\"Retrieves the metrics for a specified server.\n\n    :param server_id: The unique identifier of the server.\n    :return: A dictionary with the following keys:\n        - cpu_usage (float): The CPU usage percentage.\n        - memory_usage (float): The memory usage percentage.\n        - disk_usage (float): The disk usage percentage.\n    :raises ValueError: If server_id is empty or invalid.\"\"\"\n    pass\ndef list_running_applications(server_id: str) -> list:\n    \"\"\"Lists all running applications on a specified server.\n\n    :param server_id: The unique identifier of the server.\n    :return: A list of application names running on the server.\n    :raises ValueError: If server_id is empty or invalid.\"\"\"\n    pass\ndef identify_problematic_applications(server_id: str) -> list:\n    \"\"\"Identifies applications causing high CPU usage on a specified server.\n\n    :param server_id: The unique identifier of the server.\n    :return: A list of application names that are consuming high CPU resources.\n    :raises ValueError: If server_id is empty or invalid.\"\"\"\n    pass\ndef restart_application(server_id: str, app_name: str) -> bool:\n    \"\"\"Restarts a specified application on a server.\n\n    :param server_id: The unique identifier of the server.\n    :param app_name: The name of the application to restart.\n    :return: True if the application was successfully restarted, False otherwise.\n    :raises ValueError: If server_id or app_name is empty or invalid.\"\"\"\n    pass\ndef log_event(description: str, server_id: str) -> None:\n    \"\"\"Logs an event related to server operations.\n\n    :param description: A description of the event.\n    :param server_id: The unique identifier of the server.\n    :raises ValueError: If description or server_id is empty.\"\"\"\n    pass\ndef check_disk_space(server_id: str) -> float:\n    \"\"\"Checks the available disk space on a specified server.\n\n    :param server_id: The unique identifier of the server.\n    :return: The percentage of available disk space.\n    :raises ValueError: If server_id is empty or invalid.\"\"\"\n    pass\ndef check_memory_usage(server_id: str) -> float:\n    \"\"\"Checks the current memory usage of a specified server.\n\n    :param server_id: The unique identifier of the server.\n    :return: The memory usage percentage as a float.\n    :raises ValueError: If server_id is empty or invalid.\"\"\"\n    pass\n", "function_schema_json": [{"name": "check_cpu_usage", "description": "Checks the current CPU usage of a specified server.", "parameters": {"type": "object", "properties": {"server_id": {"type": "string", "description": "The unique identifier of the server."}}, "required": ["server_id"], "additionalProperties": false}}, {"name": "get_server_metrics", "description": "Retrieves the metrics for a specified server.", "parameters": {"type": "object", "properties": {"server_id": {"type": "string", "description": "The unique identifier of the server."}}, "required": ["server_id"], "additionalProperties": false}}, {"name": "list_running_applications", "description": "Lists all running applications on a specified server.", "parameters": {"type": "object", "properties": {"server_id": {"type": "string", "description": "The unique identifier of the server."}}, "required": ["server_id"], "additionalProperties": false}}, {"name": "identify_problematic_applications", "description": "Identifies applications causing high CPU usage on a specified server.", "parameters": {"type": "object", "properties": {"server_id": {"type": "string", "description": "The unique identifier of the server."}}, "required": ["server_id"], "additionalProperties": false}}, {"name": "restart_application", "description": "Restarts a specified application on a server.", "parameters": {"type": "object", "properties": {"server_id": {"type": "string", "description": "The unique identifier of the server."}, "app_name": {"type": "string", "description": "The name of the application to restart."}}, "required": ["server_id", "app_name"], "additionalProperties": false}}, {"name": "log_event", "description": "Logs an event related to server operations.", "parameters": {"type": "object", "properties": {"description": {"type": "string", "description": "A description of the event."}, "server_id": {"type": "string", "description": "The unique identifier of the server."}}, "required": ["description", "server_id"], "additionalProperties": false}}, {"name": "check_disk_space", "description": "Checks the available disk space on a specified server.", "parameters": {"type": "object", "properties": {"server_id": {"type": "string", "description": "The unique identifier of the server."}}, "required": ["server_id"], "additionalProperties": false}}, {"name": "check_memory_usage", "description": "Checks the current memory usage of a specified server.", "parameters": {"type": "object", "properties": {"server_id": {"type": "string", "description": "The unique identifier of the server."}}, "required": ["server_id"], "additionalProperties": false}}], "mock_functions": "def check_cpu_usage(server_id: str) -> float:\n    \"\"\"\n    Checks the current CPU usage of a specified server.\n    \n    :param server_id: The unique identifier of the server.\n    :return: The CPU usage percentage as a float.\n    :raises ValueError: If server_id is empty or invalid.\n    \"\"\"\n    if not server_id or server_id != \"server_01\":\n        raise ValueError(\"Invalid server ID.\")\n    return 95.0  # Simulating high CPU usage\ndef get_server_metrics(server_id: str) -> dict:\n    \"\"\"\n    Retrieves the metrics for a specified server.\n    \n    :param server_id: The unique identifier of the server.\n    :return: A dictionary with the following keys:\n        - cpu_usage (float): The CPU usage percentage.\n        - memory_usage (float): The memory usage percentage.\n        - disk_usage (float): The disk usage percentage.\n    :raises ValueError: If server_id is empty or invalid.\n    \"\"\"\n    if not server_id or server_id != \"server_01\":\n        raise ValueError(\"Invalid server ID.\")\n    return {\n        \"cpu_usage\": 95.0,\n        \"memory_usage\": 75.0,\n        \"disk_usage\": 80.0\n    }\ndef list_running_applications(server_id: str) -> list:\n    \"\"\"\n    Lists all running applications on a specified server.\n    \n    :param server_id: The unique identifier of the server.\n    :return: A list of application names running on the server.\n    :raises ValueError: If server_id is empty or invalid.\n    \"\"\"\n    if not server_id or server_id != \"server_01\":\n        raise ValueError(\"Invalid server ID.\")\n    return [\"web_app\", \"database_service\", \"cron_jobs\"]\ndef identify_problematic_applications(server_id: str) -> list:\n    \"\"\"\n    Identifies applications causing high CPU usage on a specified server.\n    \n    :param server_id: The unique identifier of the server.\n    :return: A list of application names that are consuming high CPU resources.\n    :raises ValueError: If server_id is empty or invalid.\n    \"\"\"\n    if not server_id or server_id != \"server_01\":\n        raise ValueError(\"Invalid server ID.\")\n    return [\"web_app\"]\ndef restart_application(server_id: str, app_name: str) -> bool:\n    \"\"\"\n    Restarts a specified application on a server.\n    \n    :param server_id: The unique identifier of the server.\n    :param app_name: The name of the application to restart.\n    :return: True if the application was successfully restarted, False otherwise.\n    :raises ValueError: If server_id or app_name is empty or invalid.\n    \"\"\"\n    if not server_id or server_id != \"server_01\" or not app_name:\n        raise ValueError(\"Invalid server ID or application name.\")\n    if app_name == \"web_app\":\n        return True\n    return False\ndef log_event(description: str, server_id: str) -> None:\n    \"\"\"\n    Logs an event related to server operations.\n    \n    :param description: A description of the event.\n    :param server_id: The unique identifier of the server.\n    :raises ValueError: If description or server_id is empty.\n    \"\"\"\n    if not description or not server_id:\n        raise ValueError(\"Description and server ID must be provided.\")\n    print(f\"Event logged: {description} on server {server_id}\")\ndef check_disk_space(server_id: str) -> float:\n    \"\"\"\n    Checks the available disk space on a specified server.\n    \n    :param server_id: The unique identifier of the server.\n    :return: The percentage of available disk space.\n    :raises ValueError: If server_id is empty or invalid.\n    \"\"\"\n    if not server_id or server_id != \"server_01\":\n        raise ValueError(\"Invalid server ID.\")\n    return 20.0  # Simulating low disk space\ndef check_memory_usage(server_id: str) -> float:\n    \"\"\"\n    Checks the current memory usage of a specified server.\n    \n    :param server_id: The unique identifier of the server.\n    :return: The memory usage percentage as a float.\n    :raises ValueError: If server_id is empty or invalid.\n    \"\"\"\n    if not server_id or server_id != \"server_01\":\n        raise ValueError(\"Invalid server ID.\")\n    return 75.0  # Simulating moderate memory usage", "user_query": "What is the current CPU usage for server_id 'server_01'?", "checklist": {"functions": ["check_cpu_usage"], "values": [95.0]}}
{"difficulty": "easy", "function_schema_python": "def get_database_metrics(server_id: str, time_range: str) -> dict:\n    \"\"\"Retrieves performance metrics for a specified database server.\n\n    :param server_id: The unique identifier of the database server.\n    :param time_range: Time range for metrics (e.g., '1h', '24h', '7d').\n    :return: Dictionary containing performance metrics.\n    :raises ValueError: If server_id is invalid or time_range is unsupported.\"\"\"\n    pass\ndef analyze_query_performance(query_logs: list) -> dict:\n    \"\"\"Analyzes database query performance from provided logs.\n\n    :param query_logs: List of query log entries.\n    :return: Dictionary containing query analysis results.\n    :raises ValueError: If query_logs is empty or invalid.\"\"\"\n    pass\ndef get_scaling_recommendations(metrics: dict) -> dict:\n    \"\"\"Provides scaling recommendations based on performance metrics.\n\n    :param metrics: Dictionary containing performance metrics.\n    :return: Dictionary containing scaling recommendations.\n    :raises ValueError: If metrics are invalid or incomplete.\"\"\"\n    pass\n", "function_schema_json": [{"name": "get_database_metrics", "description": "Retrieves performance metrics for a specified database server.", "parameters": {"type": "object", "properties": {"server_id": {"type": "string", "description": "The unique identifier of the database server."}, "time_range": {"type": "string", "description": "Time range for metrics (e.g., '1h', '24h', '7d')."}}, "required": ["server_id", "time_range"], "additionalProperties": false}}, {"name": "analyze_query_performance", "description": "Analyzes database query performance from provided logs.", "parameters": {"type": "object", "properties": {"query_logs": {"type": "array", "description": "List of query log entries."}}, "required": ["query_logs"], "additionalProperties": false}}, {"name": "get_scaling_recommendations", "description": "Provides scaling recommendations based on performance metrics.", "parameters": {"type": "object", "properties": {"metrics": {"type": "object", "description": "Dictionary containing performance metrics."}}, "required": ["metrics"], "additionalProperties": false}}], "mock_functions": "def get_database_metrics(server_id: str, time_range: str) -> dict:\n    \"\"\"\n    Retrieves performance metrics for a specified database server.\n    \n    :param server_id: The unique identifier of the database server.\n    :param time_range: Time range for metrics (e.g., '1h', '24h', '7d').\n    :return: Dictionary containing performance metrics.\n    :raises ValueError: If server_id is invalid or time_range is unsupported.\n    \"\"\"\n    if not server_id or not time_range:\n        raise ValueError(\"Server ID and time range must be provided.\")\n    \n    if server_id == \"db-prod-01\" and time_range in ['1h', '24h', '7d']:\n        return {\n            \"latency\": 250.5,  # milliseconds\n            \"cpu_utilization\": 85.5,  # percentage\n            \"memory_usage\": 78.3,  # percentage\n            \"disk_io\": 750.2,  # IOPS\n            \"active_connections\": 1250,\n            \"slow_queries\": 45\n        }\n    raise ValueError(\"Invalid server ID or time range.\")\ndef analyze_query_performance(query_logs: list) -> dict:\n    \"\"\"\n    Analyzes database query performance from provided logs.\n    \n    :param query_logs: List of query log entries.\n    :return: Dictionary containing query analysis results.\n    :raises ValueError: If query_logs is empty or invalid.\n    \"\"\"\n    if not query_logs or not isinstance(query_logs, list):\n        raise ValueError(\"Valid query logs must be provided.\")\n    \n    sample_logs = [\n        \"SELECT * FROM users WHERE id = 1\",\n        \"SELECT * FROM orders WHERE created_at > '2023-01-01'\"\n    ]\n    \n    if any(log in sample_logs for log in query_logs):\n        return {\n            \"slow_queries\": [\n                {\n                    \"query\": \"SELECT * FROM orders WHERE created_at > '2023-01-01'\",\n                    \"avg_execution_time\": 2.5,  # seconds\n                    \"frequency\": 120,  # per hour\n                    \"optimization_suggestions\": [\"Add index on created_at column\"]\n                }\n            ],\n            \"total_analyzed\": len(query_logs),\n            \"performance_impact\": \"high\"\n        }\n    return {}\ndef get_scaling_recommendations(metrics: dict) -> dict:\n    \"\"\"\n    Provides scaling recommendations based on performance metrics.\n    \n    :param metrics: Dictionary containing performance metrics.\n    :return: Dictionary containing scaling recommendations.\n    :raises ValueError: If metrics are invalid or incomplete.\n    \"\"\"\n    required_keys = [\"latency\", \"cpu_utilization\", \"memory_usage\"]\n    if not all(key in metrics for key in required_keys):\n        raise ValueError(\"Metrics must contain latency, CPU, and memory data.\")\n    \n    if metrics[\"cpu_utilization\"] > 80 and metrics[\"latency\"] > 200:\n        return {\n            \"recommendation\": \"scale_up\",\n            \"current_instance\": \"db.r5.2xlarge\",\n            \"suggested_instance\": \"db.r5.4xlarge\",\n            \"estimated_cost_increase\": 250.0,  # USD per month\n            \"expected_performance_gain\": 40,  # percentage\n            \"implementation_priority\": \"high\"\n        }\n    return {\n        \"recommendation\": \"optimize\",\n        \"suggested_actions\": [\"Query optimization\", \"Index tuning\"]\n    }", "user_query": "What's the database performance metrics for 'db-prod-01' in the last hour?", "checklist": {"functions": ["get_database_metrics"], "values": [{"latency": 250.5, "cpu_utilization": 85.5, "memory_usage": 78.3, "disk_io": 750.2, "active_connections": 1250, "slow_queries": 45}]}}
{"difficulty": "easy", "function_schema_python": "def get_database_metrics(server_id: str, time_range: str) -> dict:\n    \"\"\"Retrieves performance metrics for a specified database server.\n\n    :param server_id: The unique identifier of the database server.\n    :param time_range: Time range for metrics (e.g., '1h', '24h', '7d').\n    :return: Dictionary containing performance metrics.\n    :raises ValueError: If server_id is invalid or time_range is unsupported.\"\"\"\n    pass\ndef analyze_query_performance(query_logs: list) -> dict:\n    \"\"\"Analyzes database query performance from provided logs.\n\n    :param query_logs: List of query log entries.\n    :return: Dictionary containing query analysis results.\n    :raises ValueError: If query_logs is empty or invalid.\"\"\"\n    pass\ndef get_scaling_recommendations(metrics: dict) -> dict:\n    \"\"\"Provides scaling recommendations based on performance metrics.\n\n    :param metrics: Dictionary containing performance metrics.\n    :return: Dictionary containing scaling recommendations.\n    :raises ValueError: If metrics are invalid or incomplete.\"\"\"\n    pass\n", "function_schema_json": [{"name": "get_database_metrics", "description": "Retrieves performance metrics for a specified database server.", "parameters": {"type": "object", "properties": {"server_id": {"type": "string", "description": "The unique identifier of the database server."}, "time_range": {"type": "string", "description": "Time range for metrics (e.g., '1h', '24h', '7d')."}}, "required": ["server_id", "time_range"], "additionalProperties": false}}, {"name": "analyze_query_performance", "description": "Analyzes database query performance from provided logs.", "parameters": {"type": "object", "properties": {"query_logs": {"type": "array", "description": "List of query log entries."}}, "required": ["query_logs"], "additionalProperties": false}}, {"name": "get_scaling_recommendations", "description": "Provides scaling recommendations based on performance metrics.", "parameters": {"type": "object", "properties": {"metrics": {"type": "object", "description": "Dictionary containing performance metrics."}}, "required": ["metrics"], "additionalProperties": false}}], "mock_functions": "def get_database_metrics(server_id: str, time_range: str) -> dict:\n    \"\"\"\n    Retrieves performance metrics for a specified database server.\n    \n    :param server_id: The unique identifier of the database server.\n    :param time_range: Time range for metrics (e.g., '1h', '24h', '7d').\n    :return: Dictionary containing performance metrics.\n    :raises ValueError: If server_id is invalid or time_range is unsupported.\n    \"\"\"\n    if not server_id or not time_range:\n        raise ValueError(\"Server ID and time range must be provided.\")\n    \n    if server_id == \"db-prod-01\" and time_range in ['1h', '24h', '7d']:\n        return {\n            \"latency\": 250.5,  # milliseconds\n            \"cpu_utilization\": 85.5,  # percentage\n            \"memory_usage\": 78.3,  # percentage\n            \"disk_io\": 750.2,  # IOPS\n            \"active_connections\": 1250,\n            \"slow_queries\": 45\n        }\n    raise ValueError(\"Invalid server ID or time range.\")\ndef analyze_query_performance(query_logs: list) -> dict:\n    \"\"\"\n    Analyzes database query performance from provided logs.\n    \n    :param query_logs: List of query log entries.\n    :return: Dictionary containing query analysis results.\n    :raises ValueError: If query_logs is empty or invalid.\n    \"\"\"\n    if not query_logs or not isinstance(query_logs, list):\n        raise ValueError(\"Valid query logs must be provided.\")\n    \n    sample_logs = [\n        \"SELECT * FROM users WHERE id = 1\",\n        \"SELECT * FROM orders WHERE created_at > '2023-01-01'\"\n    ]\n    \n    if any(log in sample_logs for log in query_logs):\n        return {\n            \"slow_queries\": [\n                {\n                    \"query\": \"SELECT * FROM orders WHERE created_at > '2023-01-01'\",\n                    \"avg_execution_time\": 2.5,  # seconds\n                    \"frequency\": 120,  # per hour\n                    \"optimization_suggestions\": [\"Add index on created_at column\"]\n                }\n            ],\n            \"total_analyzed\": len(query_logs),\n            \"performance_impact\": \"high\"\n        }\n    return {}\ndef get_scaling_recommendations(metrics: dict) -> dict:\n    \"\"\"\n    Provides scaling recommendations based on performance metrics.\n    \n    :param metrics: Dictionary containing performance metrics.\n    :return: Dictionary containing scaling recommendations.\n    :raises ValueError: If metrics are invalid or incomplete.\n    \"\"\"\n    required_keys = [\"latency\", \"cpu_utilization\", \"memory_usage\"]\n    if not all(key in metrics for key in required_keys):\n        raise ValueError(\"Metrics must contain latency, CPU, and memory data.\")\n    \n    if metrics[\"cpu_utilization\"] > 80 and metrics[\"latency\"] > 200:\n        return {\n            \"recommendation\": \"scale_up\",\n            \"current_instance\": \"db.r5.2xlarge\",\n            \"suggested_instance\": \"db.r5.4xlarge\",\n            \"estimated_cost_increase\": 250.0,  # USD per month\n            \"expected_performance_gain\": 40,  # percentage\n            \"implementation_priority\": \"high\"\n        }\n    return {\n        \"recommendation\": \"optimize\",\n        \"suggested_actions\": [\"Query optimization\", \"Index tuning\"]\n    }", "user_query": "This is Emily. Can you analyze these query logs [\"SELECT * FROM users WHERE id = 1\", \"SELECT * FROM orders WHERE created_at > '2023-01-01'\"] to determine any performance issues?", "checklist": {"functions": ["analyze_query_performance"], "values": [{"slow_queries": [{"query": "SELECT * FROM orders WHERE created_at > '2023-01-01'", "avg_execution_time": 2.5, "frequency": 120, "optimization_suggestions": ["Add index on created_at column"]}], "total_analyzed": 2, "performance_impact": "high"}]}}
{"difficulty": "easy", "function_schema_python": "def monitor_cpu_usage(service_name: str, threshold: float) -> bool:\n    \"\"\"Monitors the CPU usage of a specified service.\n\n    :param service_name: The name of the service to monitor.\n    :param threshold: The CPU usage threshold percentage.\n    :return: True if CPU usage exceeds the threshold, False otherwise.\n    :raises ValueError: If the input parameters are invalid.\"\"\"\n    pass\ndef monitor_response_time(service_name: str, threshold: float) -> bool:\n    \"\"\"Monitors the response time of a specified service.\n\n    :param service_name: The name of the service to monitor.\n    :param threshold: The response time threshold in milliseconds.\n    :return: True if response time exceeds the threshold, False otherwise.\n    :raises ValueError: If the input parameters are invalid.\"\"\"\n    pass\ndef trigger_scaling_event(service_name: str, action: str) -> dict:\n    \"\"\"Triggers a scaling event for a specified service.\n\n    :param service_name: The name of the service to scale.\n    :param action: The scaling action to perform ('scale_up' or 'scale_down').\n    :return: A dictionary with the status of the scaling action.\n        dict: A dictionary with the following keys:\n            - success (bool): True if the action was successful, False otherwise.\n            - message (str): A message describing the outcome.\n    :raises ValueError: If the input parameters are invalid.\"\"\"\n    pass\ndef send_alert(service_name: str, alert_type: str) -> bool:\n    \"\"\"Sends an alert for a specified service.\n\n    :param service_name: The name of the service.\n    :param alert_type: The type of alert ('cpu_threshold_exceeded' or 'response_time_threshold_exceeded').\n    :return: True if the alert was sent successfully, False otherwise.\n    :raises ValueError: If the input parameters are invalid.\"\"\"\n    pass\ndef get_service_status(service_name: str) -> dict:\n    \"\"\"Retrieves the current status of a specified service.\n\n    :param service_name: The name of the service.\n    :return: A dictionary with the current status of the service.\n        dict: A dictionary with the following keys:\n            - cpu_usage (float): The current CPU usage percentage.\n            - response_time (float): The current response time in milliseconds.\n            - user_count (int): The current number of active users.\n    :raises ValueError: If the input parameters are invalid.\"\"\"\n    pass\n", "function_schema_json": [{"name": "monitor_cpu_usage", "description": "Monitors the CPU usage of a specified service.", "parameters": {"type": "object", "properties": {"service_name": {"type": "string", "description": "The name of the service to monitor."}, "threshold": {"type": "number", "description": "The CPU usage threshold percentage."}}, "required": ["service_name", "threshold"], "additionalProperties": false}}, {"name": "monitor_response_time", "description": "Monitors the response time of a specified service.", "parameters": {"type": "object", "properties": {"service_name": {"type": "string", "description": "The name of the service to monitor."}, "threshold": {"type": "number", "description": "The response time threshold in milliseconds."}}, "required": ["service_name", "threshold"], "additionalProperties": false}}, {"name": "trigger_scaling_event", "description": "Triggers a scaling event for a specified service.", "parameters": {"type": "object", "properties": {"service_name": {"type": "string", "description": "The name of the service to scale."}, "action": {"type": "string", "description": "The scaling action to perform ('scale_up' or 'scale_down')."}}, "required": ["service_name", "action"], "additionalProperties": false}}, {"name": "send_alert", "description": "Sends an alert for a specified service.", "parameters": {"type": "object", "properties": {"service_name": {"type": "string", "description": "The name of the service."}, "alert_type": {"type": "string", "description": "The type of alert ('cpu_threshold_exceeded' or 'response_time_threshold_exceeded')."}}, "required": ["service_name", "alert_type"], "additionalProperties": false}}, {"name": "get_service_status", "description": "Retrieves the current status of a specified service.", "parameters": {"type": "object", "properties": {"service_name": {"type": "string", "description": "The name of the service."}}, "required": ["service_name"], "additionalProperties": false}}], "mock_functions": "def monitor_cpu_usage(service_name: str, threshold: float) -> bool:\n    \"\"\"\n    Monitors the CPU usage of a specified service.\n\n    :param service_name: The name of the service to monitor.\n    :param threshold: The CPU usage threshold percentage.\n    :return: True if CPU usage exceeds the threshold, False otherwise.\n    :raises ValueError: If the input parameters are invalid.\n    \"\"\"\n    if not service_name or not isinstance(threshold, (int, float)):\n        raise ValueError(\"Service name must be a non-empty string and threshold must be a number.\")\n    # Mock logic: Assume CPU usage is 85% for 'webapp' service\n    mock_cpu_usage = {'webapp': 85.0}\n    return mock_cpu_usage.get(service_name, 0) > threshold\ndef monitor_response_time(service_name: str, threshold: float) -> bool:\n    \"\"\"\n    Monitors the response time of a specified service.\n\n    :param service_name: The name of the service to monitor.\n    :param threshold: The response time threshold in milliseconds.\n    :return: True if response time exceeds the threshold, False otherwise.\n    :raises ValueError: If the input parameters are invalid.\n    \"\"\"\n    if not service_name or not isinstance(threshold, (int, float)):\n        raise ValueError(\"Service name must be a non-empty string and threshold must be a number.\")\n    # Mock logic: Assume response time is 400 ms for 'webapp' service\n    mock_response_time = {'webapp': 400.0}\n    return mock_response_time.get(service_name, 0) > threshold\ndef trigger_scaling_event(service_name: str, action: str) -> dict:\n    \"\"\"\n    Triggers a scaling event for a specified service.\n\n    :param service_name: The name of the service to scale.\n    :param action: The scaling action to perform ('scale_up' or 'scale_down').\n    :return: A dictionary with the status of the scaling action.\n        dict: A dictionary with the following keys:\n            - success (bool): True if the action was successful, False otherwise.\n            - message (str): A message describing the outcome.\n    :raises ValueError: If the input parameters are invalid.\n    \"\"\"\n    if not service_name or action not in ('scale_up', 'scale_down'):\n        raise ValueError(\"Service name must be a non-empty string and action must be 'scale_up' or 'scale_down'.\")\n    # Mock logic: Assume scaling is always successful\n    return {\n        \"success\": True,\n        \"message\": f\"Scaling action '{action}' for service '{service_name}' was successful.\"\n    }\ndef send_alert(service_name: str, alert_type: str) -> bool:\n    \"\"\"\n    Sends an alert for a specified service.\n\n    :param service_name: The name of the service.\n    :param alert_type: The type of alert ('cpu_threshold_exceeded' or 'response_time_threshold_exceeded').\n    :return: True if the alert was sent successfully, False otherwise.\n    :raises ValueError: If the input parameters are invalid.\n    \"\"\"\n    if not service_name or alert_type not in ('cpu_threshold_exceeded', 'response_time_threshold_exceeded'):\n        raise ValueError(\"Service name must be a non-empty string and alert type must be valid.\")\n    # Mock logic: Assume alert sending is always successful\n    return True\ndef get_service_status(service_name: str) -> dict:\n    \"\"\"\n    Retrieves the current status of a specified service.\n\n    :param service_name: The name of the service.\n    :return: A dictionary with the current status of the service.\n        dict: A dictionary with the following keys:\n            - cpu_usage (float): The current CPU usage percentage.\n            - response_time (float): The current response time in milliseconds.\n            - user_count (int): The current number of active users.\n    :raises ValueError: If the input parameters are invalid.\n    \"\"\"\n    if not service_name:\n        raise ValueError(\"Service name must be a non-empty string.\")\n    # Mock logic: Assume current status for 'webapp' service\n    return {\n        \"cpu_usage\": 85.0,\n        \"response_time\": 400.0,\n        \"user_count\": 5000\n    }", "user_query": "Is the CPU usage for 'webapp' above 80% right now?", "checklist": {"functions": ["monitor_cpu_usage"], "values": [true]}}
{"difficulty": "easy", "function_schema_python": "def create_jenkins_pipeline(app_name: str, environments: list, services: list) -> dict:\n    \"\"\"Creates a Jenkins pipeline configuration for the specified application.\n\n    :param app_name: Name of the application\n    :param environments: List of deployment environments\n    :param services: List of microservices to be deployed\n    :return: Dictionary containing pipeline configuration details\n    :raises ValueError: If parameters are invalid or empty\"\"\"\n    pass\ndef run_sonarqube_scan(service_name: str, code_branch: str) -> dict:\n    \"\"\"Performs security scanning using SonarQube for a specific service.\n\n    :param service_name: Name of the microservice to scan\n    :param code_branch: Git branch to scan\n    :return: Dictionary containing scan results\n    :raises ValueError: If service name or branch is invalid\"\"\"\n    pass\ndef deploy_microservice(service_name: str, environment: str, version: str) -> dict:\n    \"\"\"Deploys a microservice to specified environment.\n\n    :param service_name: Name of the microservice\n    :param environment: Target environment (dev/staging/production)\n    :param version: Version tag of the service\n    :return: Dictionary containing deployment status\n    :raises RuntimeError: If deployment fails\"\"\"\n    pass\ndef check_container_registry(image_name: str, tag: str) -> dict:\n    \"\"\"Validates container image in registry.\n\n    :param image_name: Name of the container image\n    :param tag: Image tag to verify\n    :return: Dictionary containing image verification results\n    :raises ValueError: If image doesn't exist\"\"\"\n    pass\n", "function_schema_json": [{"name": "create_jenkins_pipeline", "description": "Creates a Jenkins pipeline configuration for the specified application.", "parameters": {"type": "object", "properties": {"app_name": {"type": "string", "description": "Name of the application"}, "environments": {"type": "array", "description": "List of deployment environments"}, "services": {"type": "array", "description": "List of microservices to be deployed"}}, "required": ["app_name", "environments", "services"], "additionalProperties": false}}, {"name": "run_sonarqube_scan", "description": "Performs security scanning using SonarQube for a specific service.", "parameters": {"type": "object", "properties": {"service_name": {"type": "string", "description": "Name of the microservice to scan"}, "code_branch": {"type": "string", "description": "Git branch to scan"}}, "required": ["service_name", "code_branch"], "additionalProperties": false}}, {"name": "deploy_microservice", "description": "Deploys a microservice to specified environment.", "parameters": {"type": "object", "properties": {"service_name": {"type": "string", "description": "Name of the microservice"}, "environment": {"type": "string", "description": "Target environment (dev/staging/production)"}, "version": {"type": "string", "description": "Version tag of the service"}}, "required": ["service_name", "environment", "version"], "additionalProperties": false}}, {"name": "check_container_registry", "description": "Validates container image in registry.", "parameters": {"type": "object", "properties": {"image_name": {"type": "string", "description": "Name of the container image"}, "tag": {"type": "string", "description": "Image tag to verify"}}, "required": ["image_name", "tag"], "additionalProperties": false}}], "mock_functions": "def create_jenkins_pipeline(app_name: str, environments: list, services: list) -> dict:\n    \"\"\"\n    Creates a Jenkins pipeline configuration for the specified application.\n    \n    :param app_name: Name of the application\n    :param environments: List of deployment environments\n    :param services: List of microservices to be deployed\n    :return: Dictionary containing pipeline configuration details\n    :raises ValueError: If parameters are invalid or empty\n    \"\"\"\n    if not app_name or not environments or not services:\n        raise ValueError(\"All parameters must be provided\")\n    \n    if app_name == \"PayQuick\" and \"production\" in environments:\n        return {\n            \"pipeline_id\": \"pq-001\",\n            \"status\": \"created\",\n            \"stages\": [\"build\", \"test\", \"security-scan\", \"deploy\"],\n            \"environments\": environments\n        }\n    return {\"status\": \"failed\", \"error\": \"Invalid configuration\"}\ndef run_sonarqube_scan(service_name: str, code_branch: str) -> dict:\n    \"\"\"\n    Performs security scanning using SonarQube for a specific service.\n    \n    :param service_name: Name of the microservice to scan\n    :param code_branch: Git branch to scan\n    :return: Dictionary containing scan results\n    :raises ValueError: If service name or branch is invalid\n    \"\"\"\n    valid_services = [\"payment-processor\", \"user-auth\", \"transaction-logger\"]\n    if service_name not in valid_services:\n        raise ValueError(\"Invalid service name\")\n    \n    return {\n        \"scan_id\": f\"sq-{service_name}-001\",\n        \"security_rating\": \"A\",\n        \"bugs\": 0,\n        \"vulnerabilities\": 0,\n        \"code_smells\": 5\n    }\ndef deploy_microservice(service_name: str, environment: str, version: str) -> dict:\n    \"\"\"\n    Deploys a microservice to specified environment.\n    \n    :param service_name: Name of the microservice\n    :param environment: Target environment (dev/staging/production)\n    :param version: Version tag of the service\n    :return: Dictionary containing deployment status\n    :raises RuntimeError: If deployment fails\n    \"\"\"\n    valid_services = [\"payment-processor\", \"user-auth\", \"transaction-logger\"]\n    valid_environments = [\"dev\", \"staging\", \"production\"]\n    \n    if service_name not in valid_services or environment not in valid_environments:\n        raise RuntimeError(\"Invalid service or environment\")\n        \n    if service_name == \"payment-processor\" and environment == \"production\":\n        return {\n            \"deployment_id\": \"dep-001\",\n            \"status\": \"success\",\n            \"health_check\": \"passed\",\n            \"rollback_ready\": True\n        }\n    return {\"status\": \"failed\", \"error\": \"Deployment failed\"}\ndef check_container_registry(image_name: str, tag: str) -> dict:\n    \"\"\"\n    Validates container image in registry.\n    \n    :param image_name: Name of the container image\n    :param tag: Image tag to verify\n    :return: Dictionary containing image verification results\n    :raises ValueError: If image doesn't exist\n    \"\"\"\n    if not image_name or not tag:\n        raise ValueError(\"Image name and tag must be provided\")\n        \n    return {\n        \"exists\": True,\n        \"vulnerability_scan\": \"passed\",\n        \"size\": \"256MB\",\n        \"last_updated\": \"2023-10-20T10:00:00Z\"\n    }", "user_query": "Could you create a Jenkins pipeline for \"PayQuick\" with environments [\"dev\", \"staging\", \"production\"] and services [\"payment-processor\", \"user-auth\", \"transaction-logger\"]?", "checklist": {"functions": ["create_jenkins_pipeline"], "values": [{"pipeline_id": "pq-001", "status": "created", "stages": ["build", "test", "security-scan", "deploy"], "environments": ["dev", "staging", "production"]}]}}
{"difficulty": "easy", "function_schema_python": "def validate_hipaa_compliance(deployment_data: str) -> bool:\n    \"\"\"Validates that the deployment data is compliant with HIPAA regulations.\n\n    :param deployment_data: A string representing the deployment data.\n    :return: True if the deployment data is HIPAA compliant, False otherwise.\n    :raises ValueError: If deployment_data is empty.\"\"\"\n    pass\ndef perform_database_migration_validation(current_db: str, new_db: str) -> dict:\n    \"\"\"Validates the migration of a database from current_db to new_db.\n\n    :param current_db: A string representing the current database.\n    :param new_db: A string representing the new database.\n    :return:\n        dict: A dictionary with the following keys:\n            - is_valid (bool): Whether the migration is valid.\n            - validation_details (str): Details about the validation.\n    :raises ValueError: If current_db or new_db is empty.\"\"\"\n    pass\ndef setup_blue_green_deployment(environment_name: str) -> bool:\n    \"\"\"Sets up a blue-green deployment for the given environment.\n\n    :param environment_name: A string representing the environment name.\n    :return: True if the blue-green deployment is set up successfully, False otherwise.\n    :raises ValueError: If environment_name is empty.\"\"\"\n    pass\ndef automate_code_deployment(commit_id: str) -> str:\n    \"\"\"Automates the deployment of code with the given commit_id.\n\n    :param commit_id: A string representing the commit ID.\n    :return: A string indicating the success or failure of the deployment.\n    :raises ValueError: If commit_id is empty.\"\"\"\n    pass\ndef run_security_protocol_checks(environment_name: str) -> bool:\n    \"\"\"Runs security protocol checks for the given environment.\n\n    :param environment_name: A string representing the environment name.\n    :return: True if all security protocols are maintained, False otherwise.\n    :raises ValueError: If environment_name is empty.\"\"\"\n    pass\n", "function_schema_json": [{"name": "validate_hipaa_compliance", "description": "Validates that the deployment data is compliant with HIPAA regulations.", "parameters": {"type": "object", "properties": {"deployment_data": {"type": "string", "description": "A string representing the deployment data."}}, "required": ["deployment_data"], "additionalProperties": false}}, {"name": "perform_database_migration_validation", "description": "Validates the migration of a database from current_db to new_db.", "parameters": {"type": "object", "properties": {"current_db": {"type": "string", "description": "A string representing the current database."}, "new_db": {"type": "string", "description": "A string representing the new database."}}, "required": ["current_db", "new_db"], "additionalProperties": false}}, {"name": "setup_blue_green_deployment", "description": "Sets up a blue-green deployment for the given environment.", "parameters": {"type": "object", "properties": {"environment_name": {"type": "string", "description": "A string representing the environment name."}}, "required": ["environment_name"], "additionalProperties": false}}, {"name": "automate_code_deployment", "description": "Automates the deployment of code with the given commit_id.", "parameters": {"type": "object", "properties": {"commit_id": {"type": "string", "description": "A string representing the commit ID."}}, "required": ["commit_id"], "additionalProperties": false}}, {"name": "run_security_protocol_checks", "description": "Runs security protocol checks for the given environment.", "parameters": {"type": "object", "properties": {"environment_name": {"type": "string", "description": "A string representing the environment name."}}, "required": ["environment_name"], "additionalProperties": false}}], "mock_functions": "def validate_hipaa_compliance(deployment_data: str) -> bool:\n    \"\"\"\n    Validates that the deployment data is compliant with HIPAA regulations.\n    \n    :param deployment_data: A string representing the deployment data.\n    :return: True if the deployment data is HIPAA compliant, False otherwise.\n    :raises ValueError: If deployment_data is empty.\n    \"\"\"\n    if not deployment_data:\n        raise ValueError(\"Deployment data must not be empty.\")\n    # Mock logic: Assume all data is compliant if it has the keyword \"secure\".\n    return \"secure\" in deployment_data.lower()\ndef perform_database_migration_validation(current_db: str, new_db: str) -> dict:\n    \"\"\"\n    Validates the migration of a database from current_db to new_db.\n    \n    :param current_db: A string representing the current database.\n    :param new_db: A string representing the new database.\n    :return:\n        dict: A dictionary with the following keys:\n            - is_valid (bool): Whether the migration is valid.\n            - validation_details (str): Details about the validation.\n    :raises ValueError: If current_db or new_db is empty.\n    \"\"\"\n    if not current_db or not new_db:\n        raise ValueError(\"Current and new database must not be empty.\")\n    # Mock logic: Assume migration is valid if both databases start with \"MedTrack\".\n    return {\n        \"is_valid\": current_db.startswith(\"MedTrack\") and new_db.startswith(\"MedTrack\"),\n        \"validation_details\": \"Migration validated successfully\" if current_db.startswith(\"MedTrack\") and new_db.startswith(\"MedTrack\") else \"Migration validation failed\"\n    }\ndef setup_blue_green_deployment(environment_name: str) -> bool:\n    \"\"\"\n    Sets up a blue-green deployment for the given environment.\n    \n    :param environment_name: A string representing the environment name.\n    :return: True if the blue-green deployment is set up successfully, False otherwise.\n    :raises ValueError: If environment_name is empty.\n    \"\"\"\n    if not environment_name:\n        raise ValueError(\"Environment name must not be empty.\")\n    # Mock logic: Assume setup is successful if environment is \"production\".\n    return environment_name.lower() == \"production\"\ndef automate_code_deployment(commit_id: str) -> str:\n    \"\"\"\n    Automates the deployment of code with the given commit_id.\n    \n    :param commit_id: A string representing the commit ID.\n    :return: A string indicating the success or failure of the deployment.\n    :raises ValueError: If commit_id is empty.\n    \"\"\"\n    if not commit_id:\n        raise ValueError(\"Commit ID must not be empty.\")\n    # Mock logic: Assume deployment is successful if commit Id starts with \"abc\".\n    return \"Deployment successful\" if commit_id.startswith(\"abc\") else \"Deployment failed\"\ndef run_security_protocol_checks(environment_name: str) -> bool:\n    \"\"\"\n    Runs security protocol checks for the given environment.\n    \n    :param environment_name: A string representing the environment name.\n    :return: True if all security protocols are maintained, False otherwise.\n    :raises ValueError: If environment_name is empty.\n    \"\"\"\n    if not environment_name:\n        raise ValueError(\"Environment name must not be empty.\")\n    # Mock logic: Assume checks pass if environment name is \"secure-env\".\n    return environment_name == \"secure-env\"", "user_query": "Can you validate HIPAA compliance for deployment data \"secure patient data transfer\"?", "checklist": {"functions": ["validate_hipaa_compliance"], "values": [true]}}
{"difficulty": "easy", "function_schema_python": "def get_optimal_container_configuration(application_name: str, peak_load: int) -> Dict:\n    \"\"\"Gets the optimal container configuration for a given application and peak load.\n\n    :param application_name: The name of the application.\n    :param peak_load: The expected peak load in concurrent users.\n    :return: A dictionary containing the optimal configuration.\n        Keys:\n            - cpu (str): CPU allocation.\n            - memory (str): Memory allocation.\n            - replicas (int): Number of replicas.\n    :raises ValueError: If application_name is empty or peak_load is invalid.\"\"\"\n    pass\ndef deploy_containers(configuration: Dict) -> bool:\n    \"\"\"Deploys containers with the specified configuration.\n\n    :param configuration: A dictionary containing the container configuration.\n        Expected keys: cpu, memory, replicas\n    :return: True if deployment is successful, False otherwise.\n    :raises ValueError: If configuration is invalid.\"\"\"\n    pass\ndef scale_containers(application_name: str, current_load: int) -> int:\n    \"\"\"Scales containers based on traffic demand.\n\n    :param application_name: The name of the application.\n    :param current_load: The current load in concurrent users.\n    :return: The new number of replicas.\n    :raises ValueError: If application_name is empty or current_load is invalid.\"\"\"\n    pass\n", "function_schema_json": [{"name": "get_optimal_container_configuration", "description": "Gets the optimal container configuration for a given application and peak load.", "parameters": {"type": "object", "properties": {"application_name": {"type": "string", "description": "The name of the application."}, "peak_load": {"type": "integer", "description": "The expected peak load in concurrent users."}}, "required": ["application_name", "peak_load"], "additionalProperties": false}}, {"name": "deploy_containers", "description": "Deploys containers with the specified configuration.", "parameters": {"type": "object", "properties": {"configuration": {"type": "object", "description": "A dictionary containing the container configuration."}}, "required": ["configuration"], "additionalProperties": false}}, {"name": "scale_containers", "description": "Scales containers based on traffic demand.", "parameters": {"type": "object", "properties": {"application_name": {"type": "string", "description": "The name of the application."}, "current_load": {"type": "integer", "description": "The current load in concurrent users."}}, "required": ["application_name", "current_load"], "additionalProperties": false}}], "mock_functions": "def get_optimal_container_configuration(application_name: str, peak_load: int) -> Dict:\n    \"\"\"\n    Gets the optimal container configuration for a given application and peak load.\n\n    :param application_name: The name of the application.\n    :param peak_load: The expected peak load in concurrent users.\n    :return: A dictionary containing the optimal configuration.\n        Keys:\n            - cpu (str): CPU allocation.\n            - memory (str): Memory allocation.\n            - replicas (int): Number of replicas.\n    :raises ValueError: If application_name is empty or peak_load is invalid.\n    \"\"\"\n    if not application_name or peak_load <= 0:\n        raise ValueError(\"Invalid input parameters.\")\n\n    if application_name == \"e-commerce\" and peak_load == 1000:\n        return {\n            \"cpu\": \"2 cores\",\n            \"memory\": \"4GB\",\n            \"replicas\": 3\n        }\n    elif application_name == \"e-commerce\" and peak_load >500 and peak_load < 1500:\n        return {\n            \"cpu\": \"4 cores\",\n            \"memory\": \"8GB\",\n            \"replicas\": 4\n        }\n    return {}\ndef deploy_containers(configuration: Dict) -> bool:\n    \"\"\"\n    Deploys containers with the specified configuration.\n\n    :param configuration: A dictionary containing the container configuration.\n        Expected keys: cpu, memory, replicas\n    :return: True if deployment is successful, False otherwise.\n    :raises ValueError: If configuration is invalid.\n    \"\"\"\n    if not configuration or not all(k in configuration for k in [\"cpu\", \"memory\", \"replicas\"]):\n        raise ValueError(\"Invalid configuration.\")\n\n    if configuration[\"cpu\"] == \"2 cores\" and configuration[\"memory\"] == \"4GB\" and configuration[\"replicas\"] == 3:\n        return True\n    elif configuration[\"cpu\"] == \"4 cores\" and configuration[\"memory\"] == \"8GB\" and configuration[\"replicas\"] == 4:\n        return True\n\n    return False\ndef scale_containers(application_name: str, current_load: int) -> int:\n    \"\"\"\n    Scales containers based on traffic demand.\n\n    :param application_name: The name of the application.\n    :param current_load: The current load in concurrent users.\n    :return: The new number of replicas.\n    :raises ValueError: If application_name is empty or current_load is invalid.\n    \"\"\"\n    if not application_name or current_load < 0:\n        raise ValueError(\"Invalid input parameters.\")\n\n    if application_name == \"e-commerce\" and current_load > 1000:\n        return 4\n    elif application_name == \"e-commerce\":\n        return 3\n    return 0", "user_query": "What is the optimal container configuration for the e-commerce application with a peak load of 1000 users?", "checklist": {"functions": ["get_optimal_container_configuration"], "values": [{"cpu": "2 cores", "memory": "4GB", "replicas": 3}]}}
{"difficulty": "easy", "function_schema_python": "def get_optimal_container_configuration(application_name: str, peak_load: int) -> Dict:\n    \"\"\"Gets the optimal container configuration for a given application and peak load.\n\n    :param application_name: The name of the application.\n    :param peak_load: The expected peak load in concurrent users.\n    :return: A dictionary containing the optimal configuration.\n        Keys:\n            - cpu (str): CPU allocation.\n            - memory (str): Memory allocation.\n            - replicas (int): Number of replicas.\n    :raises ValueError: If application_name is empty or peak_load is invalid.\"\"\"\n    pass\ndef deploy_containers(configuration: Dict) -> bool:\n    \"\"\"Deploys containers with the specified configuration.\n\n    :param configuration: A dictionary containing the container configuration.\n        Expected keys: cpu, memory, replicas\n    :return: True if deployment is successful, False otherwise.\n    :raises ValueError: If configuration is invalid.\"\"\"\n    pass\ndef scale_containers(application_name: str, current_load: int) -> int:\n    \"\"\"Scales containers based on traffic demand.\n\n    :param application_name: The name of the application.\n    :param current_load: The current load in concurrent users.\n    :return: The new number of replicas.\n    :raises ValueError: If application_name is empty or current_load is invalid.\"\"\"\n    pass\n", "function_schema_json": [{"name": "get_optimal_container_configuration", "description": "Gets the optimal container configuration for a given application and peak load.", "parameters": {"type": "object", "properties": {"application_name": {"type": "string", "description": "The name of the application."}, "peak_load": {"type": "integer", "description": "The expected peak load in concurrent users."}}, "required": ["application_name", "peak_load"], "additionalProperties": false}}, {"name": "deploy_containers", "description": "Deploys containers with the specified configuration.", "parameters": {"type": "object", "properties": {"configuration": {"type": "object", "description": "A dictionary containing the container configuration."}}, "required": ["configuration"], "additionalProperties": false}}, {"name": "scale_containers", "description": "Scales containers based on traffic demand.", "parameters": {"type": "object", "properties": {"application_name": {"type": "string", "description": "The name of the application."}, "current_load": {"type": "integer", "description": "The current load in concurrent users."}}, "required": ["application_name", "current_load"], "additionalProperties": false}}], "mock_functions": "def get_optimal_container_configuration(application_name: str, peak_load: int) -> Dict:\n    \"\"\"\n    Gets the optimal container configuration for a given application and peak load.\n\n    :param application_name: The name of the application.\n    :param peak_load: The expected peak load in concurrent users.\n    :return: A dictionary containing the optimal configuration.\n        Keys:\n            - cpu (str): CPU allocation.\n            - memory (str): Memory allocation.\n            - replicas (int): Number of replicas.\n    :raises ValueError: If application_name is empty or peak_load is invalid.\n    \"\"\"\n    if not application_name or peak_load <= 0:\n        raise ValueError(\"Invalid input parameters.\")\n\n    if application_name == \"e-commerce\" and peak_load == 1000:\n        return {\n            \"cpu\": \"2 cores\",\n            \"memory\": \"4GB\",\n            \"replicas\": 3\n        }\n    elif application_name == \"e-commerce\" and peak_load >500 and peak_load < 1500:\n        return {\n            \"cpu\": \"4 cores\",\n            \"memory\": \"8GB\",\n            \"replicas\": 4\n        }\n    return {}\ndef deploy_containers(configuration: Dict) -> bool:\n    \"\"\"\n    Deploys containers with the specified configuration.\n\n    :param configuration: A dictionary containing the container configuration.\n        Expected keys: cpu, memory, replicas\n    :return: True if deployment is successful, False otherwise.\n    :raises ValueError: If configuration is invalid.\n    \"\"\"\n    if not configuration or not all(k in configuration for k in [\"cpu\", \"memory\", \"replicas\"]):\n        raise ValueError(\"Invalid configuration.\")\n\n    if configuration[\"cpu\"] == \"2 cores\" and configuration[\"memory\"] == \"4GB\" and configuration[\"replicas\"] == 3:\n        return True\n    elif configuration[\"cpu\"] == \"4 cores\" and configuration[\"memory\"] == \"8GB\" and configuration[\"replicas\"] == 4:\n        return True\n\n    return False\ndef scale_containers(application_name: str, current_load: int) -> int:\n    \"\"\"\n    Scales containers based on traffic demand.\n\n    :param application_name: The name of the application.\n    :param current_load: The current load in concurrent users.\n    :return: The new number of replicas.\n    :raises ValueError: If application_name is empty or current_load is invalid.\n    \"\"\"\n    if not application_name or current_load < 0:\n        raise ValueError(\"Invalid input parameters.\")\n\n    if application_name == \"e-commerce\" and current_load > 1000:\n        return 4\n    elif application_name == \"e-commerce\":\n        return 3\n    return 0", "user_query": "This is Emily. Can you scale the e-commerce application containers based on the current load of 1200 concurrent users, and confirm how many replicas are needed?", "checklist": {"functions": ["scale_containers"], "values": [4]}}
{"difficulty": "easy", "function_schema_python": "def analyze_application_dependencies(app_path: str, scan_type: str) -> dict:\n    \"\"\"Analyzes the dependencies of a legacy application for containerization.\n\n    :param app_path: Path to the legacy application directory\n    :param scan_type: Type of scan ('full' or 'quick')\n    :return: Dictionary containing dependency analysis results\n    :raises ValueError: If app_path is invalid or scan_type is not supported\"\"\"\n    pass\ndef create_container_image(app_path: str, dependencies: dict) -> dict:\n    \"\"\"Creates a Docker container image with the specified dependencies.\n\n    :param app_path: Path to the application directory\n    :param dependencies: Dictionary containing dependency information\n    :return: Dictionary containing container image details\n    :raises ValueError: If dependencies are missing or invalid\"\"\"\n    pass\ndef migrate_to_kubernetes(image_details: dict, cluster_config: dict) -> dict:\n    \"\"\"Migrates a containerized application to a Kubernetes cluster.\n\n    :param image_details: Dictionary containing container image information\n    :param cluster_config: Dictionary containing Kubernetes cluster configuration\n    :return: Dictionary containing migration status and details\n    :raises ValueError: If image details or cluster configuration is invalid\"\"\"\n    pass\n", "function_schema_json": [{"name": "analyze_application_dependencies", "description": "Analyzes the dependencies of a legacy application for containerization.", "parameters": {"type": "object", "properties": {"app_path": {"type": "string", "description": "Path to the legacy application directory"}, "scan_type": {"type": "string", "description": "Type of scan ('full' or 'quick')"}}, "required": ["app_path", "scan_type"], "additionalProperties": false}}, {"name": "create_container_image", "description": "Creates a Docker container image with the specified dependencies.", "parameters": {"type": "object", "properties": {"app_path": {"type": "string", "description": "Path to the application directory"}, "dependencies": {"type": "object", "description": "Dictionary containing dependency information"}}, "required": ["app_path", "dependencies"], "additionalProperties": false}}, {"name": "migrate_to_kubernetes", "description": "Migrates a containerized application to a Kubernetes cluster.", "parameters": {"type": "object", "properties": {"image_details": {"type": "object", "description": "Dictionary containing container image information"}, "cluster_config": {"type": "object", "description": "Dictionary containing Kubernetes cluster configuration"}}, "required": ["image_details", "cluster_config"], "additionalProperties": false}}], "mock_functions": "def analyze_application_dependencies(app_path: str, scan_type: str = \"full\") -> dict:\n    \"\"\"\n    Analyzes the dependencies of a legacy application for containerization.\n    \n    :param app_path: Path to the legacy application directory\n    :param scan_type: Type of scan ('full' or 'quick')\n    :return: Dictionary containing dependency analysis results\n    :raises ValueError: If app_path is invalid or scan_type is not supported\n    \"\"\"\n    if not app_path or not isinstance(app_path, str):\n        raise ValueError(\"Invalid application path\")\n    \n    if scan_type not in ['full', 'quick']:\n        raise ValueError(\"Invalid scan type. Must be 'full' or 'quick'\")\n    \n    if app_path == \"/app/legacy-java\":\n        return {\n            \"os_dependencies\": [\"openjdk-11\", \"libc6\", \"openssl\"],\n            \"system_libraries\": [\"libssl1.1\", \"libc6\"],\n            \"java_dependencies\": [\"spring-boot:2.5.6\", \"hibernate:5.4.32\"],\n            \"compatibility_issues\": [],\n            \"recommended_base_image\": \"adoptopenjdk:11-jre-hotspot\"\n        }\n    return {\"error\": \"Application not found\"}\ndef create_container_image(app_path: str, dependencies: dict) -> dict:\n    \"\"\"\n    Creates a Docker container image with the specified dependencies.\n    \n    :param app_path: Path to the application directory\n    :param dependencies: Dictionary containing dependency information\n    :return: Dictionary containing container image details\n    :raises ValueError: If dependencies are missing or invalid\n    \"\"\"\n    required_keys = [\"os_dependencies\", \"system_libraries\", \"recommended_base_image\"]\n    if not all(key in dependencies for key in required_keys):\n        raise ValueError(\"Missing required dependency information\")\n\n    if app_path == \"/app/legacy-java\" and dependencies[\"recommended_base_image\"] == \"adoptopenjdk:11-jre-hotspot\":\n        return {\n            \"image_id\": \"sha256:a1b2c3d4e5f6\",\n            \"image_tag\": \"legacy-app:1.0\",\n            \"size\": \"750MB\",\n            \"layers\": 5,\n            \"build_status\": \"success\"\n        }\n    return {\"error\": \"Failed to create container image\"}\ndef migrate_to_kubernetes(image_details: dict, cluster_config: dict) -> dict:\n    \"\"\"\n    Migrates a containerized application to a Kubernetes cluster.\n    \n    :param image_details: Dictionary containing container image information\n    :param cluster_config: Dictionary containing Kubernetes cluster configuration\n    :return: Dictionary containing migration status and details\n    :raises ValueError: If image details or cluster configuration is invalid\n    \"\"\"\n    required_image_keys = [\"image_id\", \"image_tag\"]\n    required_cluster_keys = [\"namespace\", \"replicas\", \"resources\"]\n\n    if not all(key in image_details for key in required_image_keys):\n        raise ValueError(\"Invalid image details\")\n    if not all(key in cluster_config for key in required_cluster_keys):\n        raise ValueError(\"Invalid cluster configuration\")\n\n    if (image_details[\"image_tag\"] == \"legacy-app:1.0\" and \n        cluster_config[\"namespace\"] == \"production\"):\n        return {\n            \"deployment_name\": \"legacy-app-deployment\",\n            \"pod_status\": \"Running\",\n            \"replicas\": cluster_config[\"replicas\"],\n            \"services\": [\"legacy-app-svc\"],\n            \"ingress_configured\": True,\n            \"health_status\": \"Healthy\"\n        }\n    return {\"error\": \"Migration failed\"}", "user_query": "Can you analyze the application dependencies for /app/legacy-java with a full scan?", "checklist": {"functions": ["analyze_application_dependencies"], "values": [{"os_dependencies": ["openjdk-11", "libc6", "openssl"], "system_libraries": ["libssl1.1", "libc6"], "java_dependencies": ["spring-boot:2.5.6", "hibernate:5.4.32"], "compatibility_issues": [], "recommended_base_image": "adoptopenjdk:11-jre-hotspot"}]}}
{"difficulty": "easy", "function_schema_python": "def analyze_application_dependencies(app_path: str, scan_type: str) -> dict:\n    \"\"\"Analyzes the dependencies of a legacy application for containerization.\n\n    :param app_path: Path to the legacy application directory\n    :param scan_type: Type of scan ('full' or 'quick')\n    :return: Dictionary containing dependency analysis results\n    :raises ValueError: If app_path is invalid or scan_type is not supported\"\"\"\n    pass\ndef create_container_image(app_path: str, dependencies: dict) -> dict:\n    \"\"\"Creates a Docker container image with the specified dependencies.\n\n    :param app_path: Path to the application directory\n    :param dependencies: Dictionary containing dependency information\n    :return: Dictionary containing container image details\n    :raises ValueError: If dependencies are missing or invalid\"\"\"\n    pass\ndef migrate_to_kubernetes(image_details: dict, cluster_config: dict) -> dict:\n    \"\"\"Migrates a containerized application to a Kubernetes cluster.\n\n    :param image_details: Dictionary containing container image information\n    :param cluster_config: Dictionary containing Kubernetes cluster configuration\n    :return: Dictionary containing migration status and details\n    :raises ValueError: If image details or cluster configuration is invalid\"\"\"\n    pass\n", "function_schema_json": [{"name": "analyze_application_dependencies", "description": "Analyzes the dependencies of a legacy application for containerization.", "parameters": {"type": "object", "properties": {"app_path": {"type": "string", "description": "Path to the legacy application directory"}, "scan_type": {"type": "string", "description": "Type of scan ('full' or 'quick')"}}, "required": ["app_path", "scan_type"], "additionalProperties": false}}, {"name": "create_container_image", "description": "Creates a Docker container image with the specified dependencies.", "parameters": {"type": "object", "properties": {"app_path": {"type": "string", "description": "Path to the application directory"}, "dependencies": {"type": "object", "description": "Dictionary containing dependency information"}}, "required": ["app_path", "dependencies"], "additionalProperties": false}}, {"name": "migrate_to_kubernetes", "description": "Migrates a containerized application to a Kubernetes cluster.", "parameters": {"type": "object", "properties": {"image_details": {"type": "object", "description": "Dictionary containing container image information"}, "cluster_config": {"type": "object", "description": "Dictionary containing Kubernetes cluster configuration"}}, "required": ["image_details", "cluster_config"], "additionalProperties": false}}], "mock_functions": "def analyze_application_dependencies(app_path: str, scan_type: str = \"full\") -> dict:\n    \"\"\"\n    Analyzes the dependencies of a legacy application for containerization.\n    \n    :param app_path: Path to the legacy application directory\n    :param scan_type: Type of scan ('full' or 'quick')\n    :return: Dictionary containing dependency analysis results\n    :raises ValueError: If app_path is invalid or scan_type is not supported\n    \"\"\"\n    if not app_path or not isinstance(app_path, str):\n        raise ValueError(\"Invalid application path\")\n    \n    if scan_type not in ['full', 'quick']:\n        raise ValueError(\"Invalid scan type. Must be 'full' or 'quick'\")\n    \n    if app_path == \"/app/legacy-java\":\n        return {\n            \"os_dependencies\": [\"openjdk-11\", \"libc6\", \"openssl\"],\n            \"system_libraries\": [\"libssl1.1\", \"libc6\"],\n            \"java_dependencies\": [\"spring-boot:2.5.6\", \"hibernate:5.4.32\"],\n            \"compatibility_issues\": [],\n            \"recommended_base_image\": \"adoptopenjdk:11-jre-hotspot\"\n        }\n    return {\"error\": \"Application not found\"}\ndef create_container_image(app_path: str, dependencies: dict) -> dict:\n    \"\"\"\n    Creates a Docker container image with the specified dependencies.\n    \n    :param app_path: Path to the application directory\n    :param dependencies: Dictionary containing dependency information\n    :return: Dictionary containing container image details\n    :raises ValueError: If dependencies are missing or invalid\n    \"\"\"\n    required_keys = [\"os_dependencies\", \"system_libraries\", \"recommended_base_image\"]\n    if not all(key in dependencies for key in required_keys):\n        raise ValueError(\"Missing required dependency information\")\n\n    if app_path == \"/app/legacy-java\" and dependencies[\"recommended_base_image\"] == \"adoptopenjdk:11-jre-hotspot\":\n        return {\n            \"image_id\": \"sha256:a1b2c3d4e5f6\",\n            \"image_tag\": \"legacy-app:1.0\",\n            \"size\": \"750MB\",\n            \"layers\": 5,\n            \"build_status\": \"success\"\n        }\n    return {\"error\": \"Failed to create container image\"}\ndef migrate_to_kubernetes(image_details: dict, cluster_config: dict) -> dict:\n    \"\"\"\n    Migrates a containerized application to a Kubernetes cluster.\n    \n    :param image_details: Dictionary containing container image information\n    :param cluster_config: Dictionary containing Kubernetes cluster configuration\n    :return: Dictionary containing migration status and details\n    :raises ValueError: If image details or cluster configuration is invalid\n    \"\"\"\n    required_image_keys = [\"image_id\", \"image_tag\"]\n    required_cluster_keys = [\"namespace\", \"replicas\", \"resources\"]\n\n    if not all(key in image_details for key in required_image_keys):\n        raise ValueError(\"Invalid image details\")\n    if not all(key in cluster_config for key in required_cluster_keys):\n        raise ValueError(\"Invalid cluster configuration\")\n\n    if (image_details[\"image_tag\"] == \"legacy-app:1.0\" and \n        cluster_config[\"namespace\"] == \"production\"):\n        return {\n            \"deployment_name\": \"legacy-app-deployment\",\n            \"pod_status\": \"Running\",\n            \"replicas\": cluster_config[\"replicas\"],\n            \"services\": [\"legacy-app-svc\"],\n            \"ingress_configured\": True,\n            \"health_status\": \"Healthy\"\n        }\n    return {\"error\": \"Migration failed\"}", "user_query": "Could you create a Docker container image for /app/legacy-java using these dependencies: { \"os_dependencies\": [\"openjdk-11\", \"libc6\", \"openssl\"], \"system_libraries\": [\"libssl1.1\", \"libc6\"], \"recommended_base_image\": \"adoptopenjdk:11-jre-hotspot\" }?", "checklist": {"functions": ["create_container_image"], "values": [{"image_id": "sha256:a1b2c3d4e5f6", "image_tag": "legacy-app:1.0", "size": "750MB", "layers": 5, "build_status": "success"}]}}
{"difficulty": "easy", "function_schema_python": "def get_real_time_price_data(ticker: str, timeframe: str) -> dict:\n    \"\"\"Retrieves real-time price data for a specified ticker.\n\n    :param ticker: Stock ticker symbol\n    :param timeframe: Time period for data retrieval (e.g., '1h', '1d')\n    :return: Dictionary containing price data:\n        - timestamp (list[int]): List of Unix timestamps\n        - price (list[float]): List of prices\n        - volume (list[int]): List of trading volumes\n    :raises ValueError: If ticker is invalid or timeframe is not supported\"\"\"\n    pass\ndef analyze_price_spike(ticker: str, current_price: float, volume: int) -> dict:\n    \"\"\"Analyzes sudden price movements for a given ticker.\n\n    :param ticker: Stock ticker symbol\n    :param current_price: Current stock price\n    :param volume: Current trading volume\n    :return: Dictionary containing analysis results:\n        - spike_detected (bool): Whether a spike was detected\n        - magnitude (float): Percentage change\n        - volume_ratio (float): Current volume compared to average\n        - alert_level (str): 'Low', 'Medium', or 'High'\n    :raises ValueError: If parameters are invalid\"\"\"\n    pass\ndef stream_market_data(ticker: str) -> dict:\n    \"\"\"Initiates a market data stream for a specified ticker.\n\n    :param ticker: Stock ticker symbol\n    :return: Dictionary containing stream information:\n        - connection_status (str): Connection status\n        - latency (float): Data latency in milliseconds\n        - data_feed_type (str): Type of data feed\n    :raises RuntimeError: If unable to establish connection\"\"\"\n    pass\n", "function_schema_json": [{"name": "get_real_time_price_data", "description": "Retrieves real-time price data for a specified ticker.", "parameters": {"type": "object", "properties": {"ticker": {"type": "string", "description": "Stock ticker symbol"}, "timeframe": {"type": "string", "description": "Time period for data retrieval (e.g., '1h', '1d')"}}, "required": ["ticker", "timeframe"], "additionalProperties": false}}, {"name": "analyze_price_spike", "description": "Analyzes sudden price movements for a given ticker.", "parameters": {"type": "object", "properties": {"ticker": {"type": "string", "description": "Stock ticker symbol"}, "current_price": {"type": "number", "description": "Current stock price"}, "volume": {"type": "integer", "description": "Current trading volume"}}, "required": ["ticker", "current_price", "volume"], "additionalProperties": false}}, {"name": "stream_market_data", "description": "Initiates a market data stream for a specified ticker.", "parameters": {"type": "object", "properties": {"ticker": {"type": "string", "description": "Stock ticker symbol"}}, "required": ["ticker"], "additionalProperties": false}}], "mock_functions": "def get_real_time_price_data(ticker: str, timeframe: str) -> dict:\n    \"\"\"\n    Retrieves real-time price data for a specified ticker.\n    \n    :param ticker: Stock ticker symbol\n    :param timeframe: Time period for data retrieval (e.g., '1h', '1d')\n    :return: Dictionary containing price data:\n        - timestamp (list[int]): List of Unix timestamps\n        - price (list[float]): List of prices\n        - volume (list[int]): List of trading volumes\n    :raises ValueError: If ticker is invalid or timeframe is not supported\n    \"\"\"\n    if not ticker or ticker != \"TC1\":\n        raise ValueError(\"Invalid ticker symbol\")\n    if timeframe != \"1h\":\n        raise ValueError(\"Unsupported timeframe\")\n    \n    return {\n        \"timestamp\": [1681123200, 1681126800, 1681130400],\n        \"price\": [156.23, 158.45, 162.78],\n        \"volume\": [25000, 35000, 50000]\n    }\ndef analyze_price_spike(ticker: str, current_price: float, volume: int) -> dict:\n    \"\"\"\n    Analyzes sudden price movements for a given ticker.\n    \n    :param ticker: Stock ticker symbol\n    :param current_price: Current stock price\n    :param volume: Current trading volume\n    :return: Dictionary containing analysis results:\n        - spike_detected (bool): Whether a spike was detected\n        - magnitude (float): Percentage change\n        - volume_ratio (float): Current volume compared to average\n        - alert_level (str): 'Low', 'Medium', or 'High'\n    :raises ValueError: If parameters are invalid\n    \"\"\"\n    if not ticker or ticker != \"TC1\" or current_price <= 0 or volume <= 0:\n        raise ValueError(\"Invalid parameters\")\n\n    return {\n        \"spike_detected\": True,\n        \"magnitude\": 4.32,\n        \"volume_ratio\": 2.5,\n        \"alert_level\": \"High\"\n    }\ndef stream_market_data(ticker: str) -> dict:\n    \"\"\"\n    Initiates a market data stream for a specified ticker.\n    \n    :param ticker: Stock ticker symbol\n    :return: Dictionary containing stream information:\n        - connection_status (str): Connection status\n        - latency (float): Data latency in milliseconds\n        - data_feed_type (str): Type of data feed\n    :raises RuntimeError: If unable to establish connection\n    \"\"\"\n    if not ticker or ticker != \"TC1\":\n        raise ValueError(\"Invalid ticker symbol\")\n    \n    return {\n        \"connection_status\": \"active\",\n        \"latency\": 0.15,\n        \"data_feed_type\": \"real-time\"\n    }", "user_query": "Could you retrieve the real-time price data for TechCorp (TC1) for the last hour?", "checklist": {"functions": ["get_real_time_price_data"], "values": [{"timestamp": [1681123200, 1681126800, 1681130400], "price": [156.23, 158.45, 162.78], "volume": [25000, 35000, 50000]}]}}
{"difficulty": "easy", "function_schema_python": "def initialize_vwap_strategy(symbol: str, total_shares: int, time_window: int, vwap_threshold: float) -> dict:\n    \"\"\"Initializes a VWAP trading strategy for a given symbol.\n\n    :param symbol: Stock symbol (e.g., 'TSLA')\n    :param total_shares: Total number of shares to execute\n    :param time_window: Trading window in hours\n    :param vwap_threshold: Maximum allowed deviation from VWAP (as decimal)\n    :return: Dictionary containing strategy parameters and initial metrics\n    :raises ValueError: If parameters are invalid\"\"\"\n    pass\ndef calculate_order_chunks(total_shares: int, avg_daily_volume: float, time_window: int) -> dict:\n    \"\"\"Calculates optimal order chunks based on volume and time window.\n\n    :param total_shares: Total number of shares to execute\n    :param avg_daily_volume: Average daily trading volume\n    :param time_window: Trading window in hours\n    :return: Dictionary containing chunk calculations\n    :raises ValueError: If parameters are invalid\"\"\"\n    pass\ndef monitor_vwap_execution(strategy_id: str, current_price: float) -> dict:\n    \"\"\"Monitors the execution of a VWAP strategy.\n\n    :param strategy_id: The strategy identifier\n    :param current_price: Current market price\n    :return: Dictionary containing execution metrics\n    :raises ValueError: If strategy_id is invalid\"\"\"\n    pass\n", "function_schema_json": [{"name": "initialize_vwap_strategy", "description": "Initializes a VWAP trading strategy for a given symbol.", "parameters": {"type": "object", "properties": {"symbol": {"type": "string", "description": "Stock symbol (e.g., 'TSLA')"}, "total_shares": {"type": "integer", "description": "Total number of shares to execute"}, "time_window": {"type": "integer", "description": "Trading window in hours"}, "vwap_threshold": {"type": "number", "description": "Maximum allowed deviation from VWAP (as decimal)"}}, "required": ["symbol", "total_shares", "time_window", "vwap_threshold"], "additionalProperties": false}}, {"name": "calculate_order_chunks", "description": "Calculates optimal order chunks based on volume and time window.", "parameters": {"type": "object", "properties": {"total_shares": {"type": "integer", "description": "Total number of shares to execute"}, "avg_daily_volume": {"type": "number", "description": "Average daily trading volume"}, "time_window": {"type": "integer", "description": "Trading window in hours"}}, "required": ["total_shares", "avg_daily_volume", "time_window"], "additionalProperties": false}}, {"name": "monitor_vwap_execution", "description": "Monitors the execution of a VWAP strategy.", "parameters": {"type": "object", "properties": {"strategy_id": {"type": "string", "description": "The strategy identifier"}, "current_price": {"type": "number", "description": "Current market price"}}, "required": ["strategy_id", "current_price"], "additionalProperties": false}}], "mock_functions": "def initialize_vwap_strategy(\n    symbol: str, \n    total_shares: int, \n    time_window: int,\n    vwap_threshold: float\n) -> dict:\n    \"\"\"\n    Initializes a VWAP trading strategy for a given symbol.\n    \n    :param symbol: Stock symbol (e.g., 'TSLA')\n    :param total_shares: Total number of shares to execute\n    :param time_window: Trading window in hours\n    :param vwap_threshold: Maximum allowed deviation from VWAP (as decimal)\n    :return: Dictionary containing strategy parameters and initial metrics\n    :raises ValueError: If parameters are invalid\n    \"\"\"\n    if not symbol or total_shares <= 0 or time_window <= 0 or vwap_threshold <= 0:\n        raise ValueError(\"Invalid strategy parameters\")\n    \n    if symbol == \"TSLA\" and total_shares == 250000 and time_window == 4:\n        return {\n            \"strategy_id\": \"vwap_123\",\n            \"initial_price\": 242.50,\n            \"estimated_completion_time\": \"4 hours\",\n            \"max_deviation\": vwap_threshold,\n            \"status\": \"initialized\"\n        }\n    return {}\ndef calculate_order_chunks(\n    total_shares: int, \n    avg_daily_volume: float,\n    time_window: int\n) -> dict:\n    \"\"\"\n    Calculates optimal order chunks based on volume and time window.\n    \n    :param total_shares: Total number of shares to execute\n    :param avg_daily_volume: Average daily trading volume\n    :param time_window: Trading window in hours\n    :return: Dictionary containing chunk calculations\n    :raises ValueError: If parameters are invalid\n    \"\"\"\n    if total_shares <= 0 or avg_daily_volume <= 0 or time_window <= 0:\n        raise ValueError(\"Invalid chunk calculation parameters\")\n    \n    if total_shares == 250000 and avg_daily_volume == 3200000:\n        return {\n            \"num_chunks\": 16,\n            \"chunk_sizes\": [15625] * 16,\n            \"interval_minutes\": 15,\n            \"estimated_market_impact\": 0.015\n        }\n    return {}\ndef monitor_vwap_execution(\n    strategy_id: str,\n    current_price: float\n) -> dict:\n    \"\"\"\n    Monitors the execution of a VWAP strategy.\n    \n    :param strategy_id: The strategy identifier\n    :param current_price: Current market price\n    :return: Dictionary containing execution metrics\n    :raises ValueError: If strategy_id is invalid\n    \"\"\"\n    if not strategy_id or current_price <= 0:\n        raise ValueError(\"Invalid monitoring parameters\")\n    \n    if strategy_id == \"vwap_123\" and 240 <= current_price <= 245:\n        return {\n            \"current_vwap\": 242.35,\n            \"deviation\": 0.0062,\n            \"shares_executed\": 125000,\n            \"remaining_shares\": 125000,\n            \"completion_percentage\": 0.5,\n            \"within_threshold\": True\n        }\n    return {}", "user_query": "Can you initialize a VWAP strategy for TSLA with 250,000 shares over a 4-hour window with a 2% threshold?", "checklist": {"functions": ["initialize_vwap_strategy"], "values": [{"strategy_id": "vwap_123", "initial_price": 242.5, "estimated_completion_time": "4 hours", "max_deviation": 0.02, "status": "initialized"}]}}
{"difficulty": "easy", "function_schema_python": "def initialize_trading_agent(agent_name: str, risk_tolerance: float) -> dict:\n    \"\"\"Initializes an AI trading agent with specified parameters.\n\n    :param agent_name: Name of the AI agent (e.g., \"Astra\").\n    :param risk_tolerance: Risk tolerance level (0.0 to 1.0).\n    :return: Dictionary containing agent configuration.\n    :raises ValueError: If risk_tolerance is outside valid range.\"\"\"\n    pass\ndef set_dynamic_stop_loss(position_id: str, volatility_threshold: float) -> dict:\n    \"\"\"Configures dynamic stop-loss orders based on market volatility.\n\n    :param position_id: Unique identifier for the trading position.\n    :param volatility_threshold: Threshold for market volatility (percentage).\n    :return: Dictionary containing stop-loss configuration.\n    :raises ValueError: If volatility_threshold is invalid.\"\"\"\n    pass\ndef calculate_position_size(capital: float, risk_per_trade: float, current_volatility: float) -> dict:\n    \"\"\"Calculates optimal position size based on risk parameters.\n\n    :param capital: Available trading capital.\n    :param risk_per_trade: Maximum risk percentage per trade (0-100).\n    :param current_volatility: Current market volatility measure.\n    :return: Dictionary containing position sizing details.\n    :raises ValueError: If parameters are invalid.\"\"\"\n    pass\ndef monitor_market_conditions(market_id: str, timeframe: str) -> dict:\n    \"\"\"Monitors market conditions for specified instrument.\n\n    :param market_id: Market identifier (e.g., \"BTC-USD\").\n    :param timeframe: Time interval for analysis (e.g., \"1m\", \"5m\", \"1h\").\n    :return: Dictionary containing market analysis.\n    :raises ValueError: If parameters are invalid.\"\"\"\n    pass\n", "function_schema_json": [{"name": "initialize_trading_agent", "description": "Initializes an AI trading agent with specified parameters.", "parameters": {"type": "object", "properties": {"agent_name": {"type": "string", "description": "Name of the AI agent (e.g., \"Astra\")."}, "risk_tolerance": {"type": "number", "description": "Risk tolerance level (0.0 to 1.0)."}}, "required": ["agent_name", "risk_tolerance"], "additionalProperties": false}}, {"name": "set_dynamic_stop_loss", "description": "Configures dynamic stop-loss orders based on market volatility.", "parameters": {"type": "object", "properties": {"position_id": {"type": "string", "description": "Unique identifier for the trading position."}, "volatility_threshold": {"type": "number", "description": "Threshold for market volatility (percentage)."}}, "required": ["position_id", "volatility_threshold"], "additionalProperties": false}}, {"name": "calculate_position_size", "description": "Calculates optimal position size based on risk parameters.", "parameters": {"type": "object", "properties": {"capital": {"type": "number", "description": "Available trading capital."}, "risk_per_trade": {"type": "number", "description": "Maximum risk percentage per trade (0-100)."}, "current_volatility": {"type": "number", "description": "Current market volatility measure."}}, "required": ["capital", "risk_per_trade", "current_volatility"], "additionalProperties": false}}, {"name": "monitor_market_conditions", "description": "Monitors market conditions for specified instrument.", "parameters": {"type": "object", "properties": {"market_id": {"type": "string", "description": "Market identifier (e.g., \"BTC-USD\")."}, "timeframe": {"type": "string", "description": "Time interval for analysis (e.g., \"1m\", \"5m\", \"1h\")."}}, "required": ["market_id", "timeframe"], "additionalProperties": false}}], "mock_functions": "def initialize_trading_agent(agent_name: str, risk_tolerance: float) -> dict:\n    \"\"\"\n    Initializes an AI trading agent with specified parameters.\n    \n    :param agent_name: Name of the AI agent (e.g., \"Astra\").\n    :param risk_tolerance: Risk tolerance level (0.0 to 1.0).\n    :return: Dictionary containing agent configuration.\n    :raises ValueError: If risk_tolerance is outside valid range.\n    \"\"\"\n    if not (0 <= risk_tolerance <= 1):\n        raise ValueError(\"Risk tolerance must be between 0 and 1\")\n    if agent_name.lower() == \"astra\":\n        return {\n            \"agent_id\": \"AST001\",\n            \"name\": agent_name,\n            \"risk_tolerance\": risk_tolerance,\n            \"status\": \"active\"\n        }\n    raise ValueError(\"Unknown agent name\")\ndef set_dynamic_stop_loss(position_id: str, volatility_threshold: float) -> dict:\n    \"\"\"\n    Configures dynamic stop-loss orders based on market volatility.\n    \n    :param position_id: Unique identifier for the trading position.\n    :param volatility_threshold: Threshold for market volatility (percentage).\n    :return: Dictionary containing stop-loss configuration.\n    :raises ValueError: If volatility_threshold is invalid.\n    \"\"\"\n    if not (0 < volatility_threshold < 100):\n        raise ValueError(\"Invalid volatility threshold\")\n    if len(position_id) == 8:\n        return {\n            \"position_id\": position_id,\n            \"stop_loss_type\": \"dynamic\",\n            \"volatility_threshold\": volatility_threshold,\n            \"status\": \"configured\"\n        }\n    raise ValueError(\"Invalid position ID format\")\ndef calculate_position_size(\n    capital: float, \n    risk_per_trade: float, \n    current_volatility: float\n) -> dict:\n    \"\"\"\n    Calculates optimal position size based on risk parameters.\n    \n    :param capital: Available trading capital.\n    :param risk_per_trade: Maximum risk percentage per trade (0-100).\n    :param current_volatility: Current market volatility measure.\n    :return: Dictionary containing position sizing details.\n    :raises ValueError: If parameters are invalid.\n    \"\"\"\n    if not all([capital > 0, 0 < risk_per_trade < 100, current_volatility > 0]):\n        raise ValueError(\"Invalid parameters\")\n    \n    position_size = (capital * (risk_per_trade/100)) / current_volatility\n    return {\n        \"recommended_size\": position_size,\n        \"max_position_value\": capital * (risk_per_trade/100),\n        \"risk_level\": \"high\" if current_volatility > 30 else \"moderate\",\n        \"timestamp\": \"2024-01-20T10:30:00Z\"\n    }\ndef monitor_market_conditions(market_id: str, timeframe: str) -> dict:\n    \"\"\"\n    Monitors market conditions for specified instrument.\n    \n    :param market_id: Market identifier (e.g., \"BTC-USD\").\n    :param timeframe: Time interval for analysis (e.g., \"1m\", \"5m\", \"1h\").\n    :return: Dictionary containing market analysis.\n    :raises ValueError: If parameters are invalid.\n    \"\"\"\n    valid_timeframes = [\"1m\", \"5m\", \"15m\", \"1h\", \"4h\"]\n    if timeframe not in valid_timeframes:\n        raise ValueError(\"Invalid timeframe\")\n    \n    if \"-\" in market_id:\n        return {\n            \"market_id\": market_id,\n            \"volatility\": 25.5,\n            \"trend\": \"bullish\",\n            \"volume\": 1000000,\n            \"risk_score\": 7.5\n        }\n    raise ValueError(\"Invalid market ID format\")", "user_query": "Can you initialize the trading agent named 'Astra' with a risk tolerance of 0.6?", "checklist": {"functions": ["initialize_trading_agent"], "values": [{"agent_id": "AST001", "name": "Astra", "risk_tolerance": 0.6, "status": "active"}]}}
{"difficulty": "easy", "function_schema_python": "def fetch_market_data(asset: str) -> dict:\n    \"\"\"Fetches real-time market data for a given asset.\n\n    :param asset: The ticker symbol of the asset (e.g., \"AAPL\").\n    :return:\n        dict: A dictionary with the following keys:\n            - price (float): The current price of the asset.\n            - volatility (float): The current volatility of the asset.\n    :raises ValueError: If the asset symbol is invalid.\"\"\"\n    pass\ndef calculate_risk_exposure(portfolio: dict, risk_parameters: dict) -> dict:\n    \"\"\"Calculates the risk exposure of a portfolio based on given risk parameters.\n\n    :param portfolio: A dictionary with asset symbols as keys and their quantities as values.\n    :param risk_parameters: A dictionary with risk parameters, such as maximum allowed volatility.\n    :return:\n        dict: A dictionary with the following keys:\n            - total_value (float): The total value of the portfolio.\n            - risk_exposure (float): The overall risk exposure of the portfolio.\n    :raises ValueError: If portfolio or risk parameters are invalid.\"\"\"\n    pass\ndef adjust_risk_parameters(risk_parameters: dict, market_data: dict, economic_indicators: dict) -> dict:\n    \"\"\"Adjusts risk parameters based on real-time market data and economic indicators.\n\n    :param risk_parameters: Existing risk parameters to be adjusted.\n    :param market_data: Real-time market data for all assets in the portfolio.\n    :param economic_indicators: Economic indicators that might affect risk appetite.\n    :return:\n        dict: Adjusted risk parameters with the following keys:\n            - max_volatility (float): The new maximum allowed volatility.\n            - risk_tolerance (float): The new risk tolerance level.\n    :raises ValueError: If any parameters are invalid.\"\"\"\n    pass\ndef monitor_and_adjust_risk(portfolio: dict, market_data: dict, economic_indicators: dict) -> dict:\n    \"\"\"Monitors the risk of the trading portfolio and adjusts risk parameters if necessary.\n\n    :param portfolio: Current portfolio structure with asset symbols and quantities.\n    :param market_data: Latest market data for all assets in the portfolio.\n    :param economic_indicators: Current economic indicators affecting the market.\n    :return:\n        dict: Adjusted risk parameters with the following keys:\n            - max_volatility (float): The new maximum allowed volatility.\n            - risk_tolerance (float): The new risk tolerance level.\n    :raises ValueError: If any parameters are invalid.\"\"\"\n    pass\ndef fetch_economic_indicators() -> dict:\n    \"\"\"Fetches the latest economic indicators from a reliable source.\n\n    :return:\n        dict: A dictionary with the following keys:\n            - interest_rate (float): The current interest rate.\n            - gdp_growth (float): The GDP growth rate.\n            - unemployment_rate (float): The unemployment rate.\"\"\"\n    pass\n", "function_schema_json": [{"name": "fetch_market_data", "description": "Fetches real-time market data for a given asset.", "parameters": {"type": "object", "properties": {"asset": {"type": "string", "description": "The ticker symbol of the asset (e.g., \"AAPL\")."}}, "required": ["asset"], "additionalProperties": false}}, {"name": "calculate_risk_exposure", "description": "Calculates the risk exposure of a portfolio based on given risk parameters.", "parameters": {"type": "object", "properties": {"portfolio": {"type": "object", "description": "A dictionary with asset symbols as keys and their quantities as values."}, "risk_parameters": {"type": "object", "description": "A dictionary with risk parameters, such as maximum allowed volatility."}}, "required": ["portfolio", "risk_parameters"], "additionalProperties": false}}, {"name": "adjust_risk_parameters", "description": "Adjusts risk parameters based on real-time market data and economic indicators.", "parameters": {"type": "object", "properties": {"risk_parameters": {"type": "object", "description": "Existing risk parameters to be adjusted."}, "market_data": {"type": "object", "description": "Real-time market data for all assets in the portfolio."}, "economic_indicators": {"type": "object", "description": "Economic indicators that might affect risk appetite."}}, "required": ["risk_parameters", "market_data", "economic_indicators"], "additionalProperties": false}}, {"name": "monitor_and_adjust_risk", "description": "Monitors the risk of the trading portfolio and adjusts risk parameters if necessary.", "parameters": {"type": "object", "properties": {"portfolio": {"type": "object", "description": "Current portfolio structure with asset symbols and quantities."}, "market_data": {"type": "object", "description": "Latest market data for all assets in the portfolio."}, "economic_indicators": {"type": "object", "description": "Current economic indicators affecting the market."}}, "required": ["portfolio", "market_data", "economic_indicators"], "additionalProperties": false}}, {"name": "fetch_economic_indicators", "description": "Fetches the latest economic indicators from a reliable source.", "parameters": {"type": "object", "properties": {}, "required": [], "additionalProperties": false}}], "mock_functions": "def fetch_market_data(asset: str) -> dict:\n    \"\"\"\n    Fetches real-time market data for a given asset.\n    \n    :param asset: The ticker symbol of the asset (e.g., \"AAPL\").\n    :return:\n        dict: A dictionary with the following keys:\n            - price (float): The current price of the asset.\n            - volatility (float): The current volatility of the asset.\n    :raises ValueError: If the asset symbol is invalid.\n    \"\"\"\n    if not asset:\n        raise ValueError(\"Asset symbol must be provided.\")\n    if asset in [\"AAPL\", \"GOOGL\", \"MSFT\"]:\n        return {\n            \"price\": 150.25,\n            \"volatility\": 0.20\n        }\n    return {}\ndef calculate_risk_exposure(portfolio: dict, risk_parameters: dict) -> dict:\n    \"\"\"\n    Calculates the risk exposure of a portfolio based on given risk parameters.\n    \n    :param portfolio: A dictionary with asset symbols as keys and their quantities as values.\n    :param risk_parameters: A dictionary with risk parameters, such as maximum allowed volatility.\n    :return:\n        dict: A dictionary with the following keys:\n            - total_value (float): The total value of the portfolio.\n            - risk_exposure (float): The overall risk exposure of the portfolio.\n    :raises ValueError: If portfolio or risk parameters are invalid.\n    \"\"\"\n    if not portfolio or not risk_parameters:\n        raise ValueError(\"Portfolio and risk parameters must be provided.\")\n    if risk_parameters.get('max_volatility') is None:\n        raise ValueError(\"Risk parameters must include 'max_volatility'.\")\n    \n    total_value = 0.0\n    for asset, quantity in portfolio.items():\n        asset_data = fetch_market_data(asset)\n        if asset_data:\n            total_value += asset_data['price'] * quantity\n    \n    return {\n        \"total_value\": total_value,\n        \"risk_exposure\": 0.15  # Mocked risk exposure value\n    }\ndef adjust_risk_parameters(risk_parameters: dict, market_data: dict, economic_indicators: dict) -> dict:\n    \"\"\"\n    Adjusts risk parameters based on real-time market data and economic indicators.\n    \n    :param risk_parameters: Existing risk parameters to be adjusted.\n    :param market_data: Real-time market data for all assets in the portfolio.\n    :param economic_indicators: Economic indicators that might affect risk appetite.\n    :return:\n        dict: Adjusted risk parameters with the following keys:\n            - max_volatility (float): The new maximum allowed volatility.\n            - risk_tolerance (float): The new risk tolerance level.\n    :raises ValueError: If any parameters are invalid.\n    \"\"\"\n    if not risk_parameters or not market_data or not economic_indicators:\n        raise ValueError(\"Risk parameters, market data, and economic indicators must be provided.\")\n    \n    # Mock logic to adjust parameters based on market data and economic indicators\n    adjusted_max_volatility = 0.18  # Example adjustment\n    adjusted_risk_tolerance = 0.5\n    \n    return {\n        \"max_volatility\": adjusted_max_volatility,\n        \"risk_tolerance\": adjusted_risk_tolerance\n    }\ndef monitor_and_adjust_risk(portfolio: dict, market_data: dict, economic_indicators: dict) -> dict:\n    \"\"\"\n    Monitors the risk of the trading portfolio and adjusts risk parameters if necessary.\n    \n    :param portfolio: Current portfolio structure with asset symbols and quantities.\n    :param market_data: Latest market data for all assets in the portfolio.\n    :param economic_indicators: Current economic indicators affecting the market.\n    :return:\n        dict: Adjusted risk parameters with the following keys:\n            - max_volatility (float): The new maximum allowed volatility.\n            - risk_tolerance (float): The new risk tolerance level.\n    :raises ValueError: If any parameters are invalid.\n    \"\"\"\n    if not portfolio or not market_data or not economic_indicators:\n        raise ValueError(\"Portfolio, market data, and economic indicators must be provided.\")\n    \n    current_risk_parameters = {\n        \"max_volatility\": 0.20,\n        \"risk_tolerance\": 0.4\n    }\n    \n    adjusted_risk_parameters = adjust_risk_parameters(current_risk_parameters, market_data, economic_indicators)\n    \n    return adjusted_risk_parameters\ndef fetch_economic_indicators() -> dict:\n    \"\"\"\n    Fetches the latest economic indicators from a reliable source.\n    \n    :return:\n        dict: A dictionary with the following keys:\n            - interest_rate (float): The current interest rate.\n            - gdp_growth (float): The GDP growth rate.\n            - unemployment_rate (float): The unemployment rate.\n    \"\"\"\n    return {\n        \"interest_rate\": 2.5,\n        \"gdp_growth\": 2.3,\n        \"unemployment_rate\": 3.6\n    }", "user_query": "What's the current volatility for AAPL?", "checklist": {"functions": ["fetch_market_data"], "values": [{"price": 150.25, "volatility": 0.2}]}}
{"difficulty": "easy", "function_schema_python": "def validate_merchant_id(merchant_id: str) -> bool:\n    \"\"\"Validates the merchant ID against the expected PayZenith merchant ID.\n\n    :param merchant_id: The merchant ID provided by Sarah.\n    :return: True if the merchant ID is valid, False otherwise.\"\"\"\n    pass\ndef process_payment(merchant_id: str, order_id: str, amount: float) -> dict:\n    \"\"\"Processes a payment using the PayZenith API.\n\n    :param merchant_id: The merchant ID provided by Sarah.\n    :param order_id: The unique identifier for the customer's order.\n    :param amount: The total amount to be charged from the customer.\n    :return:\n        dict: A dictionary with the following keys:\n            - success (bool): Indicates whether the payment was successful.\n            - error_code (str or None): The error code if the payment failed.\n            - message (str): A message about the payment status.\"\"\"\n    pass\ndef troubleshoot_payment_error(error_code: str) -> str:\n    \"\"\"Provides guidance based on the error code encountered during payment processing.\n\n    :param error_code: The error code returned by the payment processing function.\n    :return: A string with guidance to resolve the issue.\"\"\"\n    pass\n", "function_schema_json": [{"name": "validate_merchant_id", "description": "Validates the merchant ID against the expected PayZenith merchant ID.", "parameters": {"type": "object", "properties": {"merchant_id": {"type": "string", "description": "The merchant ID provided by Sarah."}}, "required": ["merchant_id"], "additionalProperties": false}}, {"name": "process_payment", "description": "Processes a payment using the PayZenith API.", "parameters": {"type": "object", "properties": {"merchant_id": {"type": "string", "description": "The merchant ID provided by Sarah."}, "order_id": {"type": "string", "description": "The unique identifier for the customer's order."}, "amount": {"type": "number", "description": "The total amount to be charged from the customer."}}, "required": ["merchant_id", "order_id", "amount"], "additionalProperties": false}}, {"name": "troubleshoot_payment_error", "description": "Provides guidance based on the error code encountered during payment processing.", "parameters": {"type": "object", "properties": {"error_code": {"type": "string", "description": "The error code returned by the payment processing function."}}, "required": ["error_code"], "additionalProperties": false}}], "mock_functions": "def validate_merchant_id(merchant_id: str) -> bool:\n    \"\"\"\n    Validates the merchant ID against the expected PayZenith merchant ID.\n\n    :param merchant_id: The merchant ID provided by Sarah.\n    :return: True if the merchant ID is valid, False otherwise.\n    \"\"\"\n    # Mock logic: If merchant_id matches the expected one, return True.\n    if merchant_id == \"CZY12345\":\n        return True\n    return False\ndef process_payment(merchant_id: str, order_id: str, amount: float) -> dict:\n    \"\"\"\n    Processes a payment using the PayZenith API.\n\n    :param merchant_id: The merchant ID provided by Sarah.\n    :param order_id: The unique identifier for the customer's order.\n    :param amount: The total amount to be charged from the customer.\n    :return:\n        dict: A dictionary with the following keys:\n            - success (bool): Indicates whether the payment was successful.\n            - error_code (str or None): The error code if the payment failed.\n            - message (str): A message about the payment status.\n    \"\"\"\n    # Mock logic: If merchant_id is valid, process the payment.\n    if merchant_id == \"CZY12345\" and order_id == \"CC-001\" and amount == 35.50:\n        return {\n            \"success\": True,\n            \"error_code\": None,\n            \"message\": \"Payment processed successfully.\"\n        }\n    elif merchant_id != \"CZY12345\":\n        return {\n            \"success\": False,\n            \"error_code\": \"PZ-403\",\n            \"message\": \"Authentication failure due to invalid merchant ID.\"\n        }\n    return {\n        \"success\": False,\n        \"error_code\": \"PZ-400\",\n        \"message\": \"Invalid parameters provided.\"\n    }\ndef troubleshoot_payment_error(error_code: str) -> str:\n    \"\"\"\n    Provides guidance based on the error code encountered during payment processing.\n\n    :param error_code: The error code returned by the payment processing function.\n    :return: A string with guidance to resolve the issue.\n    \"\"\"\n    # Mock logic: Return specific guidance based on the error code.\n    if error_code == \"PZ-403\":\n        return (\"The payment failed due to an authentication failure. \"\n                \"Please verify that the merchant ID is correct and contact PayZenith support for assistance.\")\n    elif error_code == \"PZ-400\":\n        return (\"The payment failed due to invalid parameters. \"\n                \"Please check the order ID and amount and try again.\")\n    return \"An unknown error occurred. Please contact PayZenith support.\"", "user_query": "Can you validate if my merchant ID \"CZY12345\" is correct for PayZenith?", "checklist": {"functions": ["validate_merchant_id"], "values": [true]}}
{"difficulty": "easy", "function_schema_python": "def initiate_transaction(amount: str, customer_id: str, transaction_id: str) -> dict:\n    \"\"\"Modern platform's function to initiate a payment transaction.\n\n    :param amount: Transaction amount in format '$XX.XX'\n    :param customer_id: Customer identifier in format 'CUST-XXXX'\n    :param transaction_id: Transaction identifier in format 'TXN-XXXXXX'\n    :return: Dictionary containing transaction details and status\n    :raises ValueError: If parameters are in invalid format\"\"\"\n    pass\ndef process_payment(legacy_amount: int, legacy_customer: str, legacy_txn: str) -> int:\n    \"\"\"Legacy OldPay system's payment processing function.\n\n    :param legacy_amount: Amount in cents\n    :param legacy_customer: Legacy customer reference\n    :param legacy_txn: Legacy transaction reference\n    :return: Legacy status code (1: success, 2: pending, 3: failed, 4: invalid)\"\"\"\n    pass\ndef old_pay_adapter(amount: str, customer_id: str, transaction_id: str) -> dict:\n    \"\"\"Adapter function to translate between modern and legacy payment systems.\n\n    :param amount: Amount in format '$XX.XX'\n    :param customer_id: Customer ID in format 'CUST-XXXX'\n    :param transaction_id: Transaction ID in format 'TXN-XXXXXX'\n    :return: Dictionary containing HTTP status code and response\n    :raises ValueError: If input parameters are invalid\"\"\"\n    pass\n", "function_schema_json": [{"name": "initiate_transaction", "description": "Modern platform's function to initiate a payment transaction.", "parameters": {"type": "object", "properties": {"amount": {"type": "string", "description": "Transaction amount in format '$XX.XX'"}, "customer_id": {"type": "string", "description": "Customer identifier in format 'CUST-XXXX'"}, "transaction_id": {"type": "string", "description": "Transaction identifier in format 'TXN-XXXXXX'"}}, "required": ["amount", "customer_id", "transaction_id"], "additionalProperties": false}}, {"name": "process_payment", "description": "Legacy OldPay system's payment processing function.", "parameters": {"type": "object", "properties": {"legacy_amount": {"type": "integer", "description": "Amount in cents"}, "legacy_customer": {"type": "string", "description": "Legacy customer reference"}, "legacy_txn": {"type": "string", "description": "Legacy transaction reference"}}, "required": ["legacy_amount", "legacy_customer", "legacy_txn"], "additionalProperties": false}}, {"name": "old_pay_adapter", "description": "Adapter function to translate between modern and legacy payment systems.", "parameters": {"type": "object", "properties": {"amount": {"type": "string", "description": "Amount in format '$XX.XX'"}, "customer_id": {"type": "string", "description": "Customer ID in format 'CUST-XXXX'"}, "transaction_id": {"type": "string", "description": "Transaction ID in format 'TXN-XXXXXX'"}}, "required": ["amount", "customer_id", "transaction_id"], "additionalProperties": false}}], "mock_functions": "def initiate_transaction(amount: str, customer_id: str, transaction_id: str) -> dict:\n    \"\"\"\n    Modern platform's function to initiate a payment transaction.\n    \n    :param amount: Transaction amount in format '$XX.XX'\n    :param customer_id: Customer identifier in format 'CUST-XXXX'\n    :param transaction_id: Transaction identifier in format 'TXN-XXXXXX'\n    :return: Dictionary containing transaction details and status\n    :raises ValueError: If parameters are in invalid format\n    \"\"\"\n    if not (amount.startswith('$') and customer_id.startswith('CUST-') and transaction_id.startswith('TXN-')):\n        raise ValueError(\"Invalid parameter format\")\n    \n    return {\n        \"status\": \"success\",\n        \"code\": 200,\n        \"transaction_details\": {\n            \"amount\": amount,\n            \"customer_id\": customer_id,\n            \"transaction_id\": transaction_id,\n            \"timestamp\": \"2024-01-20T10:00:00Z\"\n        }\n    }\ndef process_payment(legacy_amount: int, legacy_customer: str, legacy_txn: str) -> int:\n    \"\"\"\n    Legacy OldPay system's payment processing function.\n    \n    :param legacy_amount: Amount in cents\n    :param legacy_customer: Legacy customer reference\n    :param legacy_txn: Legacy transaction reference\n    :return: Legacy status code (1: success, 2: pending, 3: failed, 4: invalid)\n    \"\"\"\n    if not isinstance(legacy_amount, int) or not legacy_customer or not legacy_txn:\n        return 4\n    \n    # Mock successful transaction for specific test case\n    if legacy_amount == 15000 and legacy_customer == \"9876\" and legacy_txn == \"A1B2C3\":\n        return 1\n    return 3\ndef old_pay_adapter(amount: str, customer_id: str, transaction_id: str) -> dict:\n    \"\"\"\n    Adapter function to translate between modern and legacy payment systems.\n    \n    :param amount: Amount in format '$XX.XX'\n    :param customer_id: Customer ID in format 'CUST-XXXX'\n    :param transaction_id: Transaction ID in format 'TXN-XXXXXX'\n    :return: Dictionary containing HTTP status code and response\n    :raises ValueError: If input parameters are invalid\n    \"\"\"\n    # Input validation\n    if not (amount.startswith('$') and customer_id.startswith('CUST-') and transaction_id.startswith('TXN-')):\n        raise ValueError(\"Invalid input format\")\n\n    # Transform modern format to legacy format\n    legacy_amount = int(float(amount.replace('$', '')) * 100)\n    legacy_customer = customer_id.replace('CUST-', '')\n    legacy_txn = transaction_id.replace('TXN-', '')\n\n    # Process payment through legacy system\n    legacy_status = process_payment(legacy_amount, legacy_customer, legacy_txn)\n\n    # Map legacy status codes to HTTP responses\n    status_mapping = {\n        1: {\"status_code\": 200, \"message\": \"Transaction successful\"},\n        2: {\"status_code\": 202, \"message\": \"Transaction pending\"},\n        3: {\"status_code\": 400, \"message\": \"Transaction failed\"},\n        4: {\"status_code\": 422, \"message\": \"Invalid transaction parameters\"}\n    }\n\n    return status_mapping.get(legacy_status, {\"status_code\": 500, \"message\": \"Unknown error\"})", "user_query": "Could you initiate a transaction with amount '$150.00', customer ID 'CUST-9876', and transaction ID 'TXN-A1B2C3'?", "checklist": {"functions": ["initiate_transaction"], "values": [{"status": "success", "code": 200, "transaction_details": {"amount": "$150.00", "customer_id": "CUST-9876", "transaction_id": "TXN-A1B2C3", "timestamp": "2024-01-20T10:00:00Z"}}]}}
{"difficulty": "easy", "function_schema_python": "def validate_transaction_pattern(account_id: str, amount: float, transaction_type: str) -> dict:\n    \"\"\"Validates if a transaction matches the user's historical pattern.\n\n    :param account_id: The account ID of the user.\n    :param amount: The transaction amount in USD.\n    :param transaction_type: Type of transaction (e.g., 'international_wire').\n    :return: Dictionary containing validation results:\n        - is_valid (bool): Whether the transaction matches normal patterns\n        - risk_score (float): Risk score from 0-1\n        - usual_amount (float): Average amount for this transaction type\n        - deviation_percentage (float): Percentage deviation from usual amount\n    :raises ValueError: If account_id is invalid or amount is negative.\"\"\"\n    pass\ndef verify_iban(iban: str) -> bool:\n    \"\"\"Verifies if the provided IBAN is valid and active.\n\n    :param iban: The IBAN number to verify.\n    :return: True if IBAN is valid and active, False otherwise.\n    :raises ValueError: If IBAN format is invalid.\"\"\"\n    pass\ndef check_aml_compliance(amount: float, sender_account: str, recipient_iban: str) -> dict:\n    \"\"\"Performs AML compliance check for international transfers.\n\n    :param amount: Transaction amount in USD.\n    :param sender_account: Sender's account ID.\n    :param recipient_iban: Recipient's IBAN.\n    :return: Dictionary containing compliance results:\n        - compliant (bool): Whether transaction is compliant\n        - requires_review (bool): If manual review is needed\n        - risk_level (str): Risk level assessment\n        - verification_id (str): Unique verification ID\n    :raises ValueError: If parameters are invalid.\"\"\"\n    pass\n", "function_schema_json": [{"name": "validate_transaction_pattern", "description": "Validates if a transaction matches the user's historical pattern.", "parameters": {"type": "object", "properties": {"account_id": {"type": "string", "description": "The account ID of the user."}, "amount": {"type": "number", "description": "The transaction amount in USD."}, "transaction_type": {"type": "string", "description": "Type of transaction (e.g., 'international_wire')."}}, "required": ["account_id", "amount", "transaction_type"], "additionalProperties": false}}, {"name": "verify_iban", "description": "Verifies if the provided IBAN is valid and active.", "parameters": {"type": "object", "properties": {"iban": {"type": "string", "description": "The IBAN number to verify."}}, "required": ["iban"], "additionalProperties": false}}, {"name": "check_aml_compliance", "description": "Performs AML compliance check for international transfers.", "parameters": {"type": "object", "properties": {"amount": {"type": "number", "description": "Transaction amount in USD."}, "sender_account": {"type": "string", "description": "Sender's account ID."}, "recipient_iban": {"type": "string", "description": "Recipient's IBAN."}}, "required": ["amount", "sender_account", "recipient_iban"], "additionalProperties": false}}], "mock_functions": "def validate_transaction_pattern(account_id: str, amount: float, transaction_type: str) -> dict:\n    \"\"\"\n    Validates if a transaction matches the user's historical pattern.\n    \n    :param account_id: The account ID of the user.\n    :param amount: The transaction amount in USD.\n    :param transaction_type: Type of transaction (e.g., 'international_wire').\n    :return: Dictionary containing validation results:\n        - is_valid (bool): Whether the transaction matches normal patterns\n        - risk_score (float): Risk score from 0-1\n        - usual_amount (float): Average amount for this transaction type\n        - deviation_percentage (float): Percentage deviation from usual amount\n    :raises ValueError: If account_id is invalid or amount is negative.\n    \"\"\"\n    if not account_id.startswith('AC-') or amount < 0:\n        raise ValueError(\"Invalid account ID or amount\")\n    \n    if account_id == \"AC-458792\" and amount == 12850.00:\n        return {\n            \"is_valid\": False,\n            \"risk_score\": 0.75,\n            \"usual_amount\": 2570.00,\n            \"deviation_percentage\": 400.0\n        }\n    return {\"is_valid\": True, \"risk_score\": 0.1, \"usual_amount\": 0, \"deviation_percentage\": 0}\ndef verify_iban(iban: str) -> bool:\n    \"\"\"\n    Verifies if the provided IBAN is valid and active.\n    \n    :param iban: The IBAN number to verify.\n    :return: True if IBAN is valid and active, False otherwise.\n    :raises ValueError: If IBAN format is invalid.\n    \"\"\"\n    # Remove spaces for validation\n    iban_clean = iban.replace(\" \", \"\")\n    if not iban_clean.startswith(\"DE\"):\n        raise ValueError(\"Invalid IBAN format\")\n    \n    return iban_clean == \"DE89370400440532013000\"\ndef check_aml_compliance(amount: float, sender_account: str, recipient_iban: str) -> dict:\n    \"\"\"\n    Performs AML compliance check for international transfers.\n    \n    :param amount: Transaction amount in USD.\n    :param sender_account: Sender's account ID.\n    :param recipient_iban: Recipient's IBAN.\n    :return: Dictionary containing compliance results:\n        - compliant (bool): Whether transaction is compliant\n        - requires_review (bool): If manual review is needed\n        - risk_level (str): Risk level assessment\n        - verification_id (str): Unique verification ID\n    :raises ValueError: If parameters are invalid.\n    \"\"\"\n    if amount < 0 or not sender_account.startswith('AC-'):\n        raise ValueError(\"Invalid parameters\")\n    \n    if (sender_account == \"AC-458792\" and \n        recipient_iban.replace(\" \", \"\") == \"DE89370400440532013000\" and \n        amount == 12850.00):\n        return {\n            \"compliant\": True,\n            \"requires_review\": True,\n            \"risk_level\": \"MEDIUM\",\n            \"verification_id\": \"VRF-78945612\"\n        }\n    return {\"compliant\": False, \"requires_review\": False, \"risk_level\": \"LOW\", \"verification_id\": \"\"}", "user_query": "Can you verify the IBAN DE89 3704 0044 0532 0130 00 for an international wire transfer?", "checklist": {"functions": ["verify_iban"], "values": [true]}}
{"difficulty": "easy", "function_schema_python": "def verify_transactions(card_number: str, transaction_count: int, time_window: int, amount: float) -> dict:\n    \"\"\"Verifies if a series of transactions matches fraud patterns.\n\n    :param card_number: Last 4 digits of the credit card\n    :param transaction_count: Number of transactions\n    :param time_window: Time window in minutes\n    :param amount: Transaction amount\n    :return: Dictionary containing verification status and risk assessment\n    :raises ValueError: If invalid parameters are provided\"\"\"\n    pass\ndef validate_merchant(merchant_id: str) -> dict:\n    \"\"\"Validates a merchant's details and risk profile.\n\n    :param merchant_id: Unique merchant identifier\n    :return: Dictionary containing merchant validation details\n    :raises ValueError: If merchant ID is invalid\"\"\"\n    pass\ndef check_transaction_threshold(amount: float, transaction_count: int) -> dict:\n    \"\"\"Evaluates transactions against threshold policies.\n\n    :param amount: Individual transaction amount\n    :param transaction_count: Number of transactions\n    :return: Dictionary containing threshold analysis\"\"\"\n    pass\n", "function_schema_json": [{"name": "verify_transactions", "description": "Verifies if a series of transactions matches fraud patterns.", "parameters": {"type": "object", "properties": {"card_number": {"type": "string", "description": "Last 4 digits of the credit card"}, "transaction_count": {"type": "integer", "description": "Number of transactions"}, "time_window": {"type": "integer", "description": "Time window in minutes"}, "amount": {"type": "number", "description": "Transaction amount"}}, "required": ["card_number", "transaction_count", "time_window", "amount"], "additionalProperties": false}}, {"name": "validate_merchant", "description": "Validates a merchant's details and risk profile.", "parameters": {"type": "object", "properties": {"merchant_id": {"type": "string", "description": "Unique merchant identifier"}}, "required": ["merchant_id"], "additionalProperties": false}}, {"name": "check_transaction_threshold", "description": "Evaluates transactions against threshold policies.", "parameters": {"type": "object", "properties": {"amount": {"type": "number", "description": "Individual transaction amount"}, "transaction_count": {"type": "integer", "description": "Number of transactions"}}, "required": ["amount", "transaction_count"], "additionalProperties": false}}], "mock_functions": "def verify_transactions(card_number: str, transaction_count: int, time_window: int, amount: float) -> dict:\n    \"\"\"\n    Verifies if a series of transactions matches fraud patterns.\n    \n    :param card_number: Last 4 digits of the credit card\n    :param transaction_count: Number of transactions\n    :param time_window: Time window in minutes\n    :param amount: Transaction amount\n    :return: Dictionary containing verification status and risk assessment\n    :raises ValueError: If invalid parameters are provided\n    \"\"\"\n    if not card_number or len(card_number) != 4:\n        raise ValueError(\"Invalid card number format\")\n    \n    if card_number == \"4527\" and transaction_count == 15 and time_window <= 30 and amount == 999.99:\n        return {\n            \"is_suspicious\": True,\n            \"risk_level\": \"high\",\n            \"fraud_pattern\": \"card-testing\",\n            \"action_taken\": \"transactions_paused\"\n        }\n    return {\n        \"is_suspicious\": False,\n        \"risk_level\": \"low\",\n        \"fraud_pattern\": None,\n        \"action_taken\": None\n    }\ndef validate_merchant(merchant_id: str) -> dict:\n    \"\"\"\n    Validates a merchant's details and risk profile.\n    \n    :param merchant_id: Unique merchant identifier\n    :return: Dictionary containing merchant validation details\n    :raises ValueError: If merchant ID is invalid\n    \"\"\"\n    if not merchant_id or not merchant_id.startswith(\"VX\"):\n        raise ValueError(\"Invalid merchant ID format\")\n    \n    if merchant_id == \"VX785421\":\n        return {\n            \"merchant_status\": \"new\",\n            \"location\": \"Singapore\",\n            \"risk_score\": 0.85,\n            \"verification_status\": \"pending\",\n            \"flags\": [\"new_merchant\", \"international\", \"high_velocity\"]\n        }\n    return {\n        \"merchant_status\": \"verified\",\n        \"location\": \"unknown\",\n        \"risk_score\": 0.0,\n        \"verification_status\": \"complete\",\n        \"flags\": []\n    }\ndef check_transaction_threshold(amount: float, transaction_count: int) -> dict:\n    \"\"\"\n    Evaluates transactions against threshold policies.\n    \n    :param amount: Individual transaction amount\n    :param transaction_count: Number of transactions\n    :return: Dictionary containing threshold analysis\n    \"\"\"\n    total_amount = amount * transaction_count\n    \n    return {\n        \"below_individual_threshold\": amount < 1000,\n        \"total_amount\": total_amount,\n        \"requires_manual_review\": total_amount >= 10000,\n        \"threshold_bypass_attempt\": abs(amount - 1000) < 1\n    }", "user_query": "Please validate the merchant with ID VX785421 from Singapore and check if these transactions match any fraud patterns.", "checklist": {"functions": ["validate_merchant"], "values": [{"merchant_status": "new", "location": "Singapore", "risk_score": 0.85, "verification_status": "pending", "flags": ["new_merchant", "international", "high_velocity"]}]}}
{"difficulty": "easy", "function_schema_python": "def calculate_client_hours(client_id: str, month: str, year: str) -> float:\n    \"\"\"Calculates total hours worked for a specific client in a given month.\n\n    :param client_id: Unique identifier for the client\n    :param month: Month for which to calculate hours (e.g., \"March\")\n    :param year: Year for which to calculate hours (e.g., \"2024\")\n    :return: Total hours worked for the client\n    :raises ValueError: If client_id is invalid or date parameters are incorrect\"\"\"\n    pass\ndef generate_invoice(client_id: str, hours: float, rate: float) -> dict:\n    \"\"\"Generates an invoice for a client based on hours worked and hourly rate.\n\n    :param client_id: Unique identifier for the client\n    :param hours: Total hours worked\n    :param rate: Hourly rate in dollars\n    :return: Dictionary containing invoice details\n    :raises ValueError: If parameters are invalid\"\"\"\n    pass\ndef send_invoice_email(invoice_data: dict, client_email: str) -> bool:\n    \"\"\"Sends invoice to client via email.\n\n    :param invoice_data: Dictionary containing invoice details\n    :param client_email: Client's email address\n    :return: True if email sent successfully, False otherwise\n    :raises ValueError: If email format is invalid or invoice_data is incomplete\"\"\"\n    pass\ndef process_payment(invoice_id: str, payment_method: str, amount: float) -> dict:\n    \"\"\"Processes payment for an invoice using specified payment method.\n\n    :param invoice_id: Unique identifier for the invoice\n    :param payment_method: Payment method (stripe/klarna/openbanking/plaid/paypal)\n    :param amount: Payment amount\n    :return: Dictionary containing payment details\n    :raises ValueError: If payment method is unsupported or amount is invalid\"\"\"\n    pass\n", "function_schema_json": [{"name": "calculate_client_hours", "description": "Calculates total hours worked for a specific client in a given month.", "parameters": {"type": "object", "properties": {"client_id": {"type": "string", "description": "Unique identifier for the client"}, "month": {"type": "string", "description": "Month for which to calculate hours (e.g., \"March\")"}, "year": {"type": "string", "description": "Year for which to calculate hours (e.g., \"2024\")"}}, "required": ["client_id", "month", "year"], "additionalProperties": false}}, {"name": "generate_invoice", "description": "Generates an invoice for a client based on hours worked and hourly rate.", "parameters": {"type": "object", "properties": {"client_id": {"type": "string", "description": "Unique identifier for the client"}, "hours": {"type": "number", "description": "Total hours worked"}, "rate": {"type": "number", "description": "Hourly rate in dollars"}}, "required": ["client_id", "hours", "rate"], "additionalProperties": false}}, {"name": "send_invoice_email", "description": "Sends invoice to client via email.", "parameters": {"type": "object", "properties": {"invoice_data": {"type": "object", "description": "Dictionary containing invoice details"}, "client_email": {"type": "string", "description": "Client's email address"}}, "required": ["invoice_data", "client_email"], "additionalProperties": false}}, {"name": "process_payment", "description": "Processes payment for an invoice using specified payment method.", "parameters": {"type": "object", "properties": {"invoice_id": {"type": "string", "description": "Unique identifier for the invoice"}, "payment_method": {"type": "string", "description": "Payment method (stripe/klarna/openbanking/plaid/paypal)"}, "amount": {"type": "number", "description": "Payment amount"}}, "required": ["invoice_id", "payment_method", "amount"], "additionalProperties": false}}], "mock_functions": "def calculate_client_hours(client_id: str, month: str, year: str) -> float:\n    \"\"\"\n    Calculates total hours worked for a specific client in a given month.\n    \n    :param client_id: Unique identifier for the client\n    :param month: Month for which to calculate hours (e.g., \"March\")\n    :param year: Year for which to calculate hours (e.g., \"2024\")\n    :return: Total hours worked for the client\n    :raises ValueError: If client_id is invalid or date parameters are incorrect\n    \"\"\"\n    if not client_id or not month or not year:\n        raise ValueError(\"All parameters must be provided\")\n    if month.lower() == \"march\" and year == \"2024\":\n        return float(client_id[-1]) * 2.5  # Mock calculation based on client ID\n    raise ValueError(\"Invalid date range\")\ndef generate_invoice(client_id: str, hours: float, rate: float) -> dict:\n    \"\"\"\n    Generates an invoice for a client based on hours worked and hourly rate.\n    \n    :param client_id: Unique identifier for the client\n    :param hours: Total hours worked\n    :param rate: Hourly rate in dollars\n    :return: Dictionary containing invoice details\n    :raises ValueError: If parameters are invalid\n    \"\"\"\n    if not client_id or hours <= 0 or rate <= 0:\n        raise ValueError(\"Invalid parameters\")\n    \n    total = hours * rate\n    return {\n        \"invoice_id\": f\"INV-{client_id}-2024-03\",\n        \"client_id\": client_id,\n        \"hours_worked\": hours,\n        \"rate_per_hour\": rate,\n        \"total_amount\": total,\n        \"due_date\": \"2024-04-30\",\n        \"status\": \"pending\"\n    }\ndef send_invoice_email(invoice_data: dict, client_email: str) -> bool:\n    \"\"\"\n    Sends invoice to client via email.\n    \n    :param invoice_data: Dictionary containing invoice details\n    :param client_email: Client's email address\n    :return: True if email sent successfully, False otherwise\n    :raises ValueError: If email format is invalid or invoice_data is incomplete\n    \"\"\"\n    if not client_email or \"@\" not in client_email:\n        raise ValueError(\"Invalid email address\")\n    \n    required_keys = [\"invoice_id\", \"total_amount\", \"due_date\"]\n    if not all(key in invoice_data for key in required_keys):\n        raise ValueError(\"Incomplete invoice data\")\n    \n    return True\ndef process_payment(invoice_id: str, payment_method: str, amount: float) -> dict:\n    \"\"\"\n    Processes payment for an invoice using specified payment method.\n    \n    :param invoice_id: Unique identifier for the invoice\n    :param payment_method: Payment method (stripe/klarna/openbanking/plaid/paypal)\n    :param amount: Payment amount\n    :return: Dictionary containing payment details\n    :raises ValueError: If payment method is unsupported or amount is invalid\n    \"\"\"\n    valid_methods = [\"stripe\", \"klarna\", \"openbanking\", \"plaid\", \"paypal\"]\n    if payment_method.lower() not in valid_methods:\n        raise ValueError(\"Unsupported payment method\")\n    \n    if amount <= 0:\n        raise ValueError(\"Invalid payment amount\")\n        \n    return {\n        \"payment_id\": f\"PAY-{invoice_id}\",\n        \"status\": \"completed\",\n        \"amount\": amount,\n        \"payment_method\": payment_method,\n        \"timestamp\": \"2024-04-15T10:00:00Z\"\n    }", "user_query": "Could you calculate total hours worked for client ID CLT001 during March 2024?", "checklist": {"functions": ["calculate_client_hours"], "values": [2.5]}}
{"difficulty": "easy", "function_schema_python": "def calculate_client_hours(client_id: str, month: str, year: str) -> float:\n    \"\"\"Calculates total hours worked for a specific client in a given month.\n\n    :param client_id: Unique identifier for the client\n    :param month: Month for which to calculate hours (e.g., \"March\")\n    :param year: Year for which to calculate hours (e.g., \"2024\")\n    :return: Total hours worked for the client\n    :raises ValueError: If client_id is invalid or date parameters are incorrect\"\"\"\n    pass\ndef generate_invoice(client_id: str, hours: float, rate: float) -> dict:\n    \"\"\"Generates an invoice for a client based on hours worked and hourly rate.\n\n    :param client_id: Unique identifier for the client\n    :param hours: Total hours worked\n    :param rate: Hourly rate in dollars\n    :return: Dictionary containing invoice details\n    :raises ValueError: If parameters are invalid\"\"\"\n    pass\ndef send_invoice_email(invoice_data: dict, client_email: str) -> bool:\n    \"\"\"Sends invoice to client via email.\n\n    :param invoice_data: Dictionary containing invoice details\n    :param client_email: Client's email address\n    :return: True if email sent successfully, False otherwise\n    :raises ValueError: If email format is invalid or invoice_data is incomplete\"\"\"\n    pass\ndef process_payment(invoice_id: str, payment_method: str, amount: float) -> dict:\n    \"\"\"Processes payment for an invoice using specified payment method.\n\n    :param invoice_id: Unique identifier for the invoice\n    :param payment_method: Payment method (stripe/klarna/openbanking/plaid/paypal)\n    :param amount: Payment amount\n    :return: Dictionary containing payment details\n    :raises ValueError: If payment method is unsupported or amount is invalid\"\"\"\n    pass\n", "function_schema_json": [{"name": "calculate_client_hours", "description": "Calculates total hours worked for a specific client in a given month.", "parameters": {"type": "object", "properties": {"client_id": {"type": "string", "description": "Unique identifier for the client"}, "month": {"type": "string", "description": "Month for which to calculate hours (e.g., \"March\")"}, "year": {"type": "string", "description": "Year for which to calculate hours (e.g., \"2024\")"}}, "required": ["client_id", "month", "year"], "additionalProperties": false}}, {"name": "generate_invoice", "description": "Generates an invoice for a client based on hours worked and hourly rate.", "parameters": {"type": "object", "properties": {"client_id": {"type": "string", "description": "Unique identifier for the client"}, "hours": {"type": "number", "description": "Total hours worked"}, "rate": {"type": "number", "description": "Hourly rate in dollars"}}, "required": ["client_id", "hours", "rate"], "additionalProperties": false}}, {"name": "send_invoice_email", "description": "Sends invoice to client via email.", "parameters": {"type": "object", "properties": {"invoice_data": {"type": "object", "description": "Dictionary containing invoice details"}, "client_email": {"type": "string", "description": "Client's email address"}}, "required": ["invoice_data", "client_email"], "additionalProperties": false}}, {"name": "process_payment", "description": "Processes payment for an invoice using specified payment method.", "parameters": {"type": "object", "properties": {"invoice_id": {"type": "string", "description": "Unique identifier for the invoice"}, "payment_method": {"type": "string", "description": "Payment method (stripe/klarna/openbanking/plaid/paypal)"}, "amount": {"type": "number", "description": "Payment amount"}}, "required": ["invoice_id", "payment_method", "amount"], "additionalProperties": false}}], "mock_functions": "def calculate_client_hours(client_id: str, month: str, year: str) -> float:\n    \"\"\"\n    Calculates total hours worked for a specific client in a given month.\n    \n    :param client_id: Unique identifier for the client\n    :param month: Month for which to calculate hours (e.g., \"March\")\n    :param year: Year for which to calculate hours (e.g., \"2024\")\n    :return: Total hours worked for the client\n    :raises ValueError: If client_id is invalid or date parameters are incorrect\n    \"\"\"\n    if not client_id or not month or not year:\n        raise ValueError(\"All parameters must be provided\")\n    if month.lower() == \"march\" and year == \"2024\":\n        return float(client_id[-1]) * 2.5  # Mock calculation based on client ID\n    raise ValueError(\"Invalid date range\")\ndef generate_invoice(client_id: str, hours: float, rate: float) -> dict:\n    \"\"\"\n    Generates an invoice for a client based on hours worked and hourly rate.\n    \n    :param client_id: Unique identifier for the client\n    :param hours: Total hours worked\n    :param rate: Hourly rate in dollars\n    :return: Dictionary containing invoice details\n    :raises ValueError: If parameters are invalid\n    \"\"\"\n    if not client_id or hours <= 0 or rate <= 0:\n        raise ValueError(\"Invalid parameters\")\n    \n    total = hours * rate\n    return {\n        \"invoice_id\": f\"INV-{client_id}-2024-03\",\n        \"client_id\": client_id,\n        \"hours_worked\": hours,\n        \"rate_per_hour\": rate,\n        \"total_amount\": total,\n        \"due_date\": \"2024-04-30\",\n        \"status\": \"pending\"\n    }\ndef send_invoice_email(invoice_data: dict, client_email: str) -> bool:\n    \"\"\"\n    Sends invoice to client via email.\n    \n    :param invoice_data: Dictionary containing invoice details\n    :param client_email: Client's email address\n    :return: True if email sent successfully, False otherwise\n    :raises ValueError: If email format is invalid or invoice_data is incomplete\n    \"\"\"\n    if not client_email or \"@\" not in client_email:\n        raise ValueError(\"Invalid email address\")\n    \n    required_keys = [\"invoice_id\", \"total_amount\", \"due_date\"]\n    if not all(key in invoice_data for key in required_keys):\n        raise ValueError(\"Incomplete invoice data\")\n    \n    return True\ndef process_payment(invoice_id: str, payment_method: str, amount: float) -> dict:\n    \"\"\"\n    Processes payment for an invoice using specified payment method.\n    \n    :param invoice_id: Unique identifier for the invoice\n    :param payment_method: Payment method (stripe/klarna/openbanking/plaid/paypal)\n    :param amount: Payment amount\n    :return: Dictionary containing payment details\n    :raises ValueError: If payment method is unsupported or amount is invalid\n    \"\"\"\n    valid_methods = [\"stripe\", \"klarna\", \"openbanking\", \"plaid\", \"paypal\"]\n    if payment_method.lower() not in valid_methods:\n        raise ValueError(\"Unsupported payment method\")\n    \n    if amount <= 0:\n        raise ValueError(\"Invalid payment amount\")\n        \n    return {\n        \"payment_id\": f\"PAY-{invoice_id}\",\n        \"status\": \"completed\",\n        \"amount\": amount,\n        \"payment_method\": payment_method,\n        \"timestamp\": \"2024-04-15T10:00:00Z\"\n    }", "user_query": "This is Emma from Green Earth Landscaping. Please generate an invoice for client ID CLT002 for 5 hours of work in March 2024 at a rate of $50 per hour.", "checklist": {"functions": ["generate_invoice"], "values": [{"invoice_id": "INV-CLT002-2024-03", "client_id": "CLT002", "hours_worked": 5.0, "rate_per_hour": 50.0, "total_amount": 250.0, "due_date": "2024-04-30", "status": "pending"}]}}
{"difficulty": "easy", "function_schema_python": "def track_outstanding_invoices(invoice_client: str, business_name: str) -> list:\n    \"\"\"Tracks outstanding invoices for a given business using a specified invoice client.\n\n    :param invoice_client: The name of the invoice client (e.g., 'stripe', 'klarna').\n    :param business_name: The name of the business (e.g., 'Gourmet Bakery Solutions').\n    :return: A list of dictionaries, each representing an outstanding invoice with the following keys:\n        - invoice_id (str): Unique identifier for the invoice.\n        - amount (float): The amount due on the invoice.\n        - due_date (str): The due date of the invoice.\n    :raises ValueError: If invoice_client or business_name is not valid.\"\"\"\n    pass\ndef verify_payment_status(payment_client: str, invoice_id: str) -> bool:\n    \"\"\"Verifies the payment status of a specific invoice using a specified payment client.\n\n    :param payment_client: The name of the payment client (e.g., 'stripe', 'paypal-sdk').\n    :param invoice_id: The unique identifier of the invoice.\n    :return: True if the invoice is paid, False otherwise.\n    :raises ValueError: If payment_client or invoice_id is not valid.\"\"\"\n    pass\ndef identify_discrepancies(corrected_records: dict, financial_records: dict) -> dict:\n    \"\"\"Identifies discrepancies between corrected financial records and current financial records.\n\n    :param corrected_records: A dictionary of corrected financial records with the following keys:\n        - outstanding_invoices (list): A list of corrected outstanding invoices.\n        - paid_invoices (list): A list of corrected paid invoices.\n    :param financial_records: A dictionary of current financial records with the following keys:\n        - outstanding_invoices (list): A list of current outstanding invoices.\n        - paid_invoices (list): A list of current paid invoices.\n    :return: A dictionary with the following keys:\n        - discrepancies (list): A list of discrepancies found.\n    :raises ValueError: If corrected_records or financial_records is not in the expected format.\"\"\"\n    pass\n", "function_schema_json": [{"name": "track_outstanding_invoices", "description": "Tracks outstanding invoices for a given business using a specified invoice client.", "parameters": {"type": "object", "properties": {"invoice_client": {"type": "string", "description": "The name of the invoice client (e.g., 'stripe', 'klarna')."}, "business_name": {"type": "string", "description": "The name of the business (e.g., 'Gourmet Bakery Solutions')."}}, "required": ["invoice_client", "business_name"], "additionalProperties": false}}, {"name": "verify_payment_status", "description": "Verifies the payment status of a specific invoice using a specified payment client.", "parameters": {"type": "object", "properties": {"payment_client": {"type": "string", "description": "The name of the payment client (e.g., 'stripe', 'paypal-sdk')."}, "invoice_id": {"type": "string", "description": "The unique identifier of the invoice."}}, "required": ["payment_client", "invoice_id"], "additionalProperties": false}}, {"name": "identify_discrepancies", "description": "Identifies discrepancies between corrected financial records and current financial records.", "parameters": {"type": "object", "properties": {"corrected_records": {"type": "object", "description": "A dictionary of corrected financial records with the following keys:"}, "financial_records": {"type": "object", "description": "A dictionary of current financial records with the following keys:"}}, "required": ["corrected_records", "financial_records"], "additionalProperties": false}}], "mock_functions": "def track_outstanding_invoices(invoice_client: str, business_name: str) -> list:\n    \"\"\"\n    Tracks outstanding invoices for a given business using a specified invoice client.\n    \n    :param invoice_client: The name of the invoice client (e.g., 'stripe', 'klarna').\n    :param business_name: The name of the business (e.g., 'Gourmet Bakery Solutions').\n    :return: A list of dictionaries, each representing an outstanding invoice with the following keys:\n        - invoice_id (str): Unique identifier for the invoice.\n        - amount (float): The amount due on the invoice.\n        - due_date (str): The due date of the invoice.\n    :raises ValueError: If invoice_client or business_name is not valid.\n    \"\"\"\n    if invoice_client not in ['stripe', 'klarna', 'openbanking', 'plaid', 'paypal-sdk']:\n        raise ValueError(\"Invalid invoice client provided.\")\n    if business_name.lower() != 'gourmet bakery solutions':\n        raise ValueError(\"Invalid business name provided.\")\n    \n    if invoice_client == 'stripe':\n        return [\n            {\"invoice_id\": \"inv_001\", \"amount\": 150.00, \"due_date\": \"2023-11-01\"},\n            {\"invoice_id\": \"inv_002\", \"amount\": 200.00, \"due_date\": \"2023-11-15\"},\n        ]\n    elif invoice_client == 'klarna':\n        return [\n            {\"invoice_id\": \"klarna_inv_001\", \"amount\": 300.00, \"due_date\": \"2023-11-10\"},\n        ]\n    return []\ndef verify_payment_status(payment_client: str, invoice_id: str) -> bool:\n    \"\"\"\n    Verifies the payment status of a specific invoice using a specified payment client.\n    \n    :param payment_client: The name of the payment client (e.g., 'stripe', 'paypal-sdk').\n    :param invoice_id: The unique identifier of the invoice.\n    :return: True if the invoice is paid, False otherwise.\n    :raises ValueError: If payment_client or invoice_id is not valid.\n    \"\"\"\n    if payment_client not in ['stripe', 'klarna', 'openbanking', 'plaid', 'paypal-sdk']:\n        raise ValueError(\"Invalid payment client provided.\")\n    if not invoice_id:\n        raise ValueError(\"Invoice ID must be provided.\")\n    \n    if payment_client == 'stripe' and invoice_id == \"inv_001\":\n        return True\n    elif payment_client == 'klarna' and invoice_id == \"klarna_inv_001\":\n        return False\n    return False\ndef identify_discrepancies(corrected_records: dict, financial_records: dict) -> dict:\n    \"\"\"\n    Identifies discrepancies between corrected financial records and current financial records.\n    \n    :param corrected_records: A dictionary of corrected financial records with the following keys:\n        - outstanding_invoices (list): A list of corrected outstanding invoices.\n        - paid_invoices (list): A list of corrected paid invoices.\n    :param financial_records: A dictionary of current financial records with the following keys:\n        - outstanding_invoices (list): A list of current outstanding invoices.\n        - paid_invoices (list): A list of current paid invoices.\n    :return: A dictionary with the following keys:\n        - discrepancies (list): A list of discrepancies found.\n    :raises ValueError: If corrected_records or financial_records is not in the expected format.\n    \"\"\"\n    if not isinstance(corrected_records, dict) or not isinstance(financial_records, dict):\n        raise ValueError(\"Both records must be provided as dictionaries.\")\n    if 'outstanding_invoices' not in corrected_records or 'paid_invoices' not in corrected_records:\n        raise ValueError(\"Corrected records must contain 'outstanding_invoices' and 'paid_invoices'.\")\n    if 'outstanding_invoices' not in financial_records or 'paid_invoices' not in financial_records:\n        raise ValueError(\"Financial records must contain 'outstanding_invoices' and 'paid_invoices'.\")\n    \n    discrepancies = []\n    \n    # Check discrepancies in outstanding invoices\n    for invoice in corrected_records['outstanding_invoices']:\n        if invoice not in financial_records['outstanding_invoices']:\n            discrepancies.append(f\"Outstanding invoice {invoice} is missing in financial records.\")\n    \n    # Check discrepancies in paid invoices\n    for invoice in corrected_records['paid_invoices']:\n        if invoice not in financial_records['paid_invoices']:\n            discrepancies.append(f\"Paid invoice {invoice} is missing in financial records.\")\n    \n    return {\"discrepancies\": discrepancies}", "user_query": "Can you track outstanding invoices for Gourmet Bakery Solutions using Stripe?", "checklist": {"functions": ["track_outstanding_invoices"], "values": [[{"invoice_id": "inv_001", "amount": 150.0, "due_date": "2023-11-01"}, {"invoice_id": "inv_002", "amount": 200.0, "due_date": "2023-11-15"}]]}}
{"difficulty": "easy", "function_schema_python": "def track_outstanding_invoices(invoice_client: str, business_name: str) -> list:\n    \"\"\"Tracks outstanding invoices for a given business using a specified invoice client.\n\n    :param invoice_client: The name of the invoice client (e.g., 'stripe', 'klarna').\n    :param business_name: The name of the business (e.g., 'Gourmet Bakery Solutions').\n    :return: A list of dictionaries, each representing an outstanding invoice with the following keys:\n        - invoice_id (str): Unique identifier for the invoice.\n        - amount (float): The amount due on the invoice.\n        - due_date (str): The due date of the invoice.\n    :raises ValueError: If invoice_client or business_name is not valid.\"\"\"\n    pass\ndef verify_payment_status(payment_client: str, invoice_id: str) -> bool:\n    \"\"\"Verifies the payment status of a specific invoice using a specified payment client.\n\n    :param payment_client: The name of the payment client (e.g., 'stripe', 'paypal-sdk').\n    :param invoice_id: The unique identifier of the invoice.\n    :return: True if the invoice is paid, False otherwise.\n    :raises ValueError: If payment_client or invoice_id is not valid.\"\"\"\n    pass\ndef identify_discrepancies(corrected_records: dict, financial_records: dict) -> dict:\n    \"\"\"Identifies discrepancies between corrected financial records and current financial records.\n\n    :param corrected_records: A dictionary of corrected financial records with the following keys:\n        - outstanding_invoices (list): A list of corrected outstanding invoices.\n        - paid_invoices (list): A list of corrected paid invoices.\n    :param financial_records: A dictionary of current financial records with the following keys:\n        - outstanding_invoices (list): A list of current outstanding invoices.\n        - paid_invoices (list): A list of current paid invoices.\n    :return: A dictionary with the following keys:\n        - discrepancies (list): A list of discrepancies found.\n    :raises ValueError: If corrected_records or financial_records is not in the expected format.\"\"\"\n    pass\n", "function_schema_json": [{"name": "track_outstanding_invoices", "description": "Tracks outstanding invoices for a given business using a specified invoice client.", "parameters": {"type": "object", "properties": {"invoice_client": {"type": "string", "description": "The name of the invoice client (e.g., 'stripe', 'klarna')."}, "business_name": {"type": "string", "description": "The name of the business (e.g., 'Gourmet Bakery Solutions')."}}, "required": ["invoice_client", "business_name"], "additionalProperties": false}}, {"name": "verify_payment_status", "description": "Verifies the payment status of a specific invoice using a specified payment client.", "parameters": {"type": "object", "properties": {"payment_client": {"type": "string", "description": "The name of the payment client (e.g., 'stripe', 'paypal-sdk')."}, "invoice_id": {"type": "string", "description": "The unique identifier of the invoice."}}, "required": ["payment_client", "invoice_id"], "additionalProperties": false}}, {"name": "identify_discrepancies", "description": "Identifies discrepancies between corrected financial records and current financial records.", "parameters": {"type": "object", "properties": {"corrected_records": {"type": "object", "description": "A dictionary of corrected financial records with the following keys:"}, "financial_records": {"type": "object", "description": "A dictionary of current financial records with the following keys:"}}, "required": ["corrected_records", "financial_records"], "additionalProperties": false}}], "mock_functions": "def track_outstanding_invoices(invoice_client: str, business_name: str) -> list:\n    \"\"\"\n    Tracks outstanding invoices for a given business using a specified invoice client.\n    \n    :param invoice_client: The name of the invoice client (e.g., 'stripe', 'klarna').\n    :param business_name: The name of the business (e.g., 'Gourmet Bakery Solutions').\n    :return: A list of dictionaries, each representing an outstanding invoice with the following keys:\n        - invoice_id (str): Unique identifier for the invoice.\n        - amount (float): The amount due on the invoice.\n        - due_date (str): The due date of the invoice.\n    :raises ValueError: If invoice_client or business_name is not valid.\n    \"\"\"\n    if invoice_client not in ['stripe', 'klarna', 'openbanking', 'plaid', 'paypal-sdk']:\n        raise ValueError(\"Invalid invoice client provided.\")\n    if business_name.lower() != 'gourmet bakery solutions':\n        raise ValueError(\"Invalid business name provided.\")\n    \n    if invoice_client == 'stripe':\n        return [\n            {\"invoice_id\": \"inv_001\", \"amount\": 150.00, \"due_date\": \"2023-11-01\"},\n            {\"invoice_id\": \"inv_002\", \"amount\": 200.00, \"due_date\": \"2023-11-15\"},\n        ]\n    elif invoice_client == 'klarna':\n        return [\n            {\"invoice_id\": \"klarna_inv_001\", \"amount\": 300.00, \"due_date\": \"2023-11-10\"},\n        ]\n    return []\ndef verify_payment_status(payment_client: str, invoice_id: str) -> bool:\n    \"\"\"\n    Verifies the payment status of a specific invoice using a specified payment client.\n    \n    :param payment_client: The name of the payment client (e.g., 'stripe', 'paypal-sdk').\n    :param invoice_id: The unique identifier of the invoice.\n    :return: True if the invoice is paid, False otherwise.\n    :raises ValueError: If payment_client or invoice_id is not valid.\n    \"\"\"\n    if payment_client not in ['stripe', 'klarna', 'openbanking', 'plaid', 'paypal-sdk']:\n        raise ValueError(\"Invalid payment client provided.\")\n    if not invoice_id:\n        raise ValueError(\"Invoice ID must be provided.\")\n    \n    if payment_client == 'stripe' and invoice_id == \"inv_001\":\n        return True\n    elif payment_client == 'klarna' and invoice_id == \"klarna_inv_001\":\n        return False\n    return False\ndef identify_discrepancies(corrected_records: dict, financial_records: dict) -> dict:\n    \"\"\"\n    Identifies discrepancies between corrected financial records and current financial records.\n    \n    :param corrected_records: A dictionary of corrected financial records with the following keys:\n        - outstanding_invoices (list): A list of corrected outstanding invoices.\n        - paid_invoices (list): A list of corrected paid invoices.\n    :param financial_records: A dictionary of current financial records with the following keys:\n        - outstanding_invoices (list): A list of current outstanding invoices.\n        - paid_invoices (list): A list of current paid invoices.\n    :return: A dictionary with the following keys:\n        - discrepancies (list): A list of discrepancies found.\n    :raises ValueError: If corrected_records or financial_records is not in the expected format.\n    \"\"\"\n    if not isinstance(corrected_records, dict) or not isinstance(financial_records, dict):\n        raise ValueError(\"Both records must be provided as dictionaries.\")\n    if 'outstanding_invoices' not in corrected_records or 'paid_invoices' not in corrected_records:\n        raise ValueError(\"Corrected records must contain 'outstanding_invoices' and 'paid_invoices'.\")\n    if 'outstanding_invoices' not in financial_records or 'paid_invoices' not in financial_records:\n        raise ValueError(\"Financial records must contain 'outstanding_invoices' and 'paid_invoices'.\")\n    \n    discrepancies = []\n    \n    # Check discrepancies in outstanding invoices\n    for invoice in corrected_records['outstanding_invoices']:\n        if invoice not in financial_records['outstanding_invoices']:\n            discrepancies.append(f\"Outstanding invoice {invoice} is missing in financial records.\")\n    \n    # Check discrepancies in paid invoices\n    for invoice in corrected_records['paid_invoices']:\n        if invoice not in financial_records['paid_invoices']:\n            discrepancies.append(f\"Paid invoice {invoice} is missing in financial records.\")\n    \n    return {\"discrepancies\": discrepancies}", "user_query": "This is Sarah Thompson. Please verify the payment status for invoice 'klarna_inv_001' using Klarna payment client.", "checklist": {"functions": ["verify_payment_status"], "values": [false]}}
{"difficulty": "easy", "function_schema_python": "def track_outstanding_invoices(invoice_client: str, business_name: str) -> list:\n    \"\"\"Tracks outstanding invoices for a given business using a specified invoice client.\n\n    :param invoice_client: The name of the invoice client (e.g., 'stripe', 'klarna').\n    :param business_name: The name of the business (e.g., 'Gourmet Bakery Solutions').\n    :return: A list of dictionaries, each representing an outstanding invoice with the following keys:\n        - invoice_id (str): Unique identifier for the invoice.\n        - amount (float): The amount due on the invoice.\n        - due_date (str): The due date of the invoice.\n    :raises ValueError: If invoice_client or business_name is not valid.\"\"\"\n    pass\ndef verify_payment_status(payment_client: str, invoice_id: str) -> bool:\n    \"\"\"Verifies the payment status of a specific invoice using a specified payment client.\n\n    :param payment_client: The name of the payment client (e.g., 'stripe', 'paypal-sdk').\n    :param invoice_id: The unique identifier of the invoice.\n    :return: True if the invoice is paid, False otherwise.\n    :raises ValueError: If payment_client or invoice_id is not valid.\"\"\"\n    pass\ndef identify_discrepancies(corrected_records: dict, financial_records: dict) -> dict:\n    \"\"\"Identifies discrepancies between corrected financial records and current financial records.\n\n    :param corrected_records: A dictionary of corrected financial records with the following keys:\n        - outstanding_invoices (list): A list of corrected outstanding invoices.\n        - paid_invoices (list): A list of corrected paid invoices.\n    :param financial_records: A dictionary of current financial records with the following keys:\n        - outstanding_invoices (list): A list of current outstanding invoices.\n        - paid_invoices (list): A list of current paid invoices.\n    :return: A dictionary with the following keys:\n        - discrepancies (list): A list of discrepancies found.\n    :raises ValueError: If corrected_records or financial_records is not in the expected format.\"\"\"\n    pass\n", "function_schema_json": [{"name": "track_outstanding_invoices", "description": "Tracks outstanding invoices for a given business using a specified invoice client.", "parameters": {"type": "object", "properties": {"invoice_client": {"type": "string", "description": "The name of the invoice client (e.g., 'stripe', 'klarna')."}, "business_name": {"type": "string", "description": "The name of the business (e.g., 'Gourmet Bakery Solutions')."}}, "required": ["invoice_client", "business_name"], "additionalProperties": false}}, {"name": "verify_payment_status", "description": "Verifies the payment status of a specific invoice using a specified payment client.", "parameters": {"type": "object", "properties": {"payment_client": {"type": "string", "description": "The name of the payment client (e.g., 'stripe', 'paypal-sdk')."}, "invoice_id": {"type": "string", "description": "The unique identifier of the invoice."}}, "required": ["payment_client", "invoice_id"], "additionalProperties": false}}, {"name": "identify_discrepancies", "description": "Identifies discrepancies between corrected financial records and current financial records.", "parameters": {"type": "object", "properties": {"corrected_records": {"type": "object", "description": "A dictionary of corrected financial records with the following keys:"}, "financial_records": {"type": "object", "description": "A dictionary of current financial records with the following keys:"}}, "required": ["corrected_records", "financial_records"], "additionalProperties": false}}], "mock_functions": "def track_outstanding_invoices(invoice_client: str, business_name: str) -> list:\n    \"\"\"\n    Tracks outstanding invoices for a given business using a specified invoice client.\n    \n    :param invoice_client: The name of the invoice client (e.g., 'stripe', 'klarna').\n    :param business_name: The name of the business (e.g., 'Gourmet Bakery Solutions').\n    :return: A list of dictionaries, each representing an outstanding invoice with the following keys:\n        - invoice_id (str): Unique identifier for the invoice.\n        - amount (float): The amount due on the invoice.\n        - due_date (str): The due date of the invoice.\n    :raises ValueError: If invoice_client or business_name is not valid.\n    \"\"\"\n    if invoice_client not in ['stripe', 'klarna', 'openbanking', 'plaid', 'paypal-sdk']:\n        raise ValueError(\"Invalid invoice client provided.\")\n    if business_name.lower() != 'gourmet bakery solutions':\n        raise ValueError(\"Invalid business name provided.\")\n    \n    if invoice_client == 'stripe':\n        return [\n            {\"invoice_id\": \"inv_001\", \"amount\": 150.00, \"due_date\": \"2023-11-01\"},\n            {\"invoice_id\": \"inv_002\", \"amount\": 200.00, \"due_date\": \"2023-11-15\"},\n        ]\n    elif invoice_client == 'klarna':\n        return [\n            {\"invoice_id\": \"klarna_inv_001\", \"amount\": 300.00, \"due_date\": \"2023-11-10\"},\n        ]\n    return []\ndef verify_payment_status(payment_client: str, invoice_id: str) -> bool:\n    \"\"\"\n    Verifies the payment status of a specific invoice using a specified payment client.\n    \n    :param payment_client: The name of the payment client (e.g., 'stripe', 'paypal-sdk').\n    :param invoice_id: The unique identifier of the invoice.\n    :return: True if the invoice is paid, False otherwise.\n    :raises ValueError: If payment_client or invoice_id is not valid.\n    \"\"\"\n    if payment_client not in ['stripe', 'klarna', 'openbanking', 'plaid', 'paypal-sdk']:\n        raise ValueError(\"Invalid payment client provided.\")\n    if not invoice_id:\n        raise ValueError(\"Invoice ID must be provided.\")\n    \n    if payment_client == 'stripe' and invoice_id == \"inv_001\":\n        return True\n    elif payment_client == 'klarna' and invoice_id == \"klarna_inv_001\":\n        return False\n    return False\ndef identify_discrepancies(corrected_records: dict, financial_records: dict) -> dict:\n    \"\"\"\n    Identifies discrepancies between corrected financial records and current financial records.\n    \n    :param corrected_records: A dictionary of corrected financial records with the following keys:\n        - outstanding_invoices (list): A list of corrected outstanding invoices.\n        - paid_invoices (list): A list of corrected paid invoices.\n    :param financial_records: A dictionary of current financial records with the following keys:\n        - outstanding_invoices (list): A list of current outstanding invoices.\n        - paid_invoices (list): A list of current paid invoices.\n    :return: A dictionary with the following keys:\n        - discrepancies (list): A list of discrepancies found.\n    :raises ValueError: If corrected_records or financial_records is not in the expected format.\n    \"\"\"\n    if not isinstance(corrected_records, dict) or not isinstance(financial_records, dict):\n        raise ValueError(\"Both records must be provided as dictionaries.\")\n    if 'outstanding_invoices' not in corrected_records or 'paid_invoices' not in corrected_records:\n        raise ValueError(\"Corrected records must contain 'outstanding_invoices' and 'paid_invoices'.\")\n    if 'outstanding_invoices' not in financial_records or 'paid_invoices' not in financial_records:\n        raise ValueError(\"Financial records must contain 'outstanding_invoices' and 'paid_invoices'.\")\n    \n    discrepancies = []\n    \n    # Check discrepancies in outstanding invoices\n    for invoice in corrected_records['outstanding_invoices']:\n        if invoice not in financial_records['outstanding_invoices']:\n            discrepancies.append(f\"Outstanding invoice {invoice} is missing in financial records.\")\n    \n    # Check discrepancies in paid invoices\n    for invoice in corrected_records['paid_invoices']:\n        if invoice not in financial_records['paid_invoices']:\n            discrepancies.append(f\"Paid invoice {invoice} is missing in financial records.\")\n    \n    return {\"discrepancies\": discrepancies}", "user_query": "This is Sarah Thompson. Please identify discrepancies between my corrected records {\"outstanding_invoices\": [\"inv_001\"], \"paid_invoices\": [\"inv_002\"]} and current financial records {\"outstanding_invoices\": [\"inv_002\"], \"paid_invoices\": [\"inv_001\"]}.", "checklist": {"functions": ["identify_discrepancies"], "values": [{"discrepancies": ["Outstanding invoice inv_001 is missing in financial records.", "Paid invoice inv_002 is missing in financial records."]}]}}
{"difficulty": "easy", "function_schema_python": "def track_transaction(transaction_id: str, amount: float, currency: str) -> dict:\n    \"\"\"Tracks a transaction through the payment system.\n\n    :param transaction_id: A unique identifier for the transaction.\n    :param amount: The amount of money being transferred.\n    :param currency: The currency code (e.g., 'USD', 'EUR') of the transaction.\n    :return:\n        dict: A dictionary with the following keys:\n            - transaction_id (str): The transaction ID.\n            - status (str): The status of the transaction (e.g., 'completed', 'pending').\n            - currency (str): The currency of the transaction.\n            - foreign_exchange_adjustment (float): The foreign exchange adjustment made.\n    :raises ValueError: If any parameter is invalid.\"\"\"\n    pass\ndef calculate_foreign_exchange(amount: float, from_currency: str, to_currency: str) -> float:\n    \"\"\"Calculates the foreign exchange rate for a given amount between two currencies.\n\n    :param amount: The amount of money to be exchanged.\n    :param from_currency: The source currency code (e.g., 'USD').\n    :param to_currency: The target currency code (e.g., 'EUR').\n    :return: The adjusted amount in the target currency.\n    :raises ValueError: If any parameter is invalid.\"\"\"\n    pass\ndef update_financial_records(transaction_id: str, amount: float, currency: str, adjustment: float) -> bool:\n    \"\"\"Updates the financial records with the transaction details.\n\n    :param transaction_id: A unique identifier for the transaction.\n    :param amount: The amount of money being transferred.\n    :param currency: The currency code (e.g., 'USD', 'EUR') of the transaction.\n    :param adjustment: The foreign exchange adjustment made.\n    :return: True if the record was successfully updated, False otherwise.\n    :raises ValueError: If any parameter is invalid.\"\"\"\n    pass\ndef get_real_time_financial_position(subsidiary_id: str) -> dict:\n    \"\"\"Retrieves the real-time financial position of a specific subsidiary.\n\n    :param subsidiary_id: A unique identifier for the subsidiary.\n    :return:\n        dict: A dictionary with the following keys:\n            - subsidiary_id (str): The subsidiary ID.\n            - total_assets (float): The total assets of the subsidiary.\n            - total_liabilities (float): The total liabilities of the subsidiary.\n            - net_worth (float): The net worth of the subsidiary.\n    :raises ValueError: If the subsidiary ID is invalid.\"\"\"\n    pass\ndef integrate_payment_system(payment_gateway: str) -> str:\n    \"\"\"Integrates the payment system with a specified payment gateway.\n\n    :param payment_gateway: The payment gateway to integrate (e.g., 'stripe', 'klarna').\n    :return: A message indicating the success of the integration.\n    :raises ValueError: If the payment gateway is not supported.\"\"\"\n    pass\n", "function_schema_json": [{"name": "track_transaction", "description": "Tracks a transaction through the payment system.", "parameters": {"type": "object", "properties": {"transaction_id": {"type": "string", "description": "A unique identifier for the transaction."}, "amount": {"type": "number", "description": "The amount of money being transferred."}, "currency": {"type": "string", "description": "The currency code (e.g., 'USD', 'EUR') of the transaction."}}, "required": ["transaction_id", "amount", "currency"], "additionalProperties": false}}, {"name": "calculate_foreign_exchange", "description": "Calculates the foreign exchange rate for a given amount between two currencies.", "parameters": {"type": "object", "properties": {"amount": {"type": "number", "description": "The amount of money to be exchanged."}, "from_currency": {"type": "string", "description": "The source currency code (e.g., 'USD')."}, "to_currency": {"type": "string", "description": "The target currency code (e.g., 'EUR')."}}, "required": ["amount", "from_currency", "to_currency"], "additionalProperties": false}}, {"name": "update_financial_records", "description": "Updates the financial records with the transaction details.", "parameters": {"type": "object", "properties": {"transaction_id": {"type": "string", "description": "A unique identifier for the transaction."}, "amount": {"type": "number", "description": "The amount of money being transferred."}, "currency": {"type": "string", "description": "The currency code (e.g., 'USD', 'EUR') of the transaction."}, "adjustment": {"type": "number", "description": "The foreign exchange adjustment made."}}, "required": ["transaction_id", "amount", "currency", "adjustment"], "additionalProperties": false}}, {"name": "get_real_time_financial_position", "description": "Retrieves the real-time financial position of a specific subsidiary.", "parameters": {"type": "object", "properties": {"subsidiary_id": {"type": "string", "description": "A unique identifier for the subsidiary."}}, "required": ["subsidiary_id"], "additionalProperties": false}}, {"name": "integrate_payment_system", "description": "Integrates the payment system with a specified payment gateway.", "parameters": {"type": "object", "properties": {"payment_gateway": {"type": "string", "description": "The payment gateway to integrate (e.g., 'stripe', 'klarna')."}}, "required": ["payment_gateway"], "additionalProperties": false}}], "mock_functions": "def track_transaction(transaction_id: str, amount: float, currency: str) -> dict:\n    \"\"\"\n    Tracks a transaction through the payment system.\n    \n    :param transaction_id: A unique identifier for the transaction.\n    :param amount: The amount of money being transferred.\n    :param currency: The currency code (e.g., 'USD', 'EUR') of the transaction.\n    :return:\n        dict: A dictionary with the following keys:\n            - transaction_id (str): The transaction ID.\n            - status (str): The status of the transaction (e.g., 'completed', 'pending').\n            - currency (str): The currency of the transaction.\n            - foreign_exchange_adjustment (float): The foreign exchange adjustment made.\n    :raises ValueError: If any parameter is invalid.\n    \"\"\"\n    if not transaction_id or not amount or not currency:\n        raise ValueError(\"Transaction ID, amount, and currency must be provided.\")\n    \n    foreign_exchange_adjustment = 0.0\n    if currency == \"EUR\":\n        foreign_exchange_adjustment = amount * 0.01  # Mock adjustment factor\n    \n    return {\n        \"transaction_id\": transaction_id,\n        \"status\": \"completed\",\n        \"currency\": currency,\n        \"foreign_exchange_adjustment\": foreign_exchange_adjustment\n    }\ndef calculate_foreign_exchange(amount: float, from_currency: str, to_currency: str) -> float:\n    \"\"\"\n    Calculates the foreign exchange rate for a given amount between two currencies.\n    \n    :param amount: The amount of money to be exchanged.\n    :param from_currency: The source currency code (e.g., 'USD').\n    :param to_currency: The target currency code (e.g., 'EUR').\n    :return: The adjusted amount in the target currency.\n    :raises ValueError: If any parameter is invalid.\n    \"\"\"\n    if not amount or not from_currency or not to_currency:\n        raise ValueError(\"Amount, from_currency, and to_currency must be provided.\")\n    \n    exchange_rate = 1.1  # Mock exchange rate\n    if from_currency == \"USD\" and to_currency == \"EUR\":\n        return amount * exchange_rate\n    return amount  # No adjustment for other currencies\ndef update_financial_records(transaction_id: str, amount: float, currency: str, adjustment: float) -> bool:\n    \"\"\"\n    Updates the financial records with the transaction details.\n    \n    :param transaction_id: A unique identifier for the transaction.\n    :param amount: The amount of money being transferred.\n    :param currency: The currency code (e.g., 'USD', 'EUR') of the transaction.\n    :param adjustment: The foreign exchange adjustment made.\n    :return: True if the record was successfully updated, False otherwise.\n    :raises ValueError: If any parameter is invalid.\n    \"\"\"\n    if not transaction_id or not amount or not currency or adjustment is None:\n        raise ValueError(\"Transaction ID, amount, currency, and adjustment must be provided.\")\n    \n    return True\ndef get_real_time_financial_position(subsidiary_id: str) -> dict:\n    \"\"\"\n    Retrieves the real-time financial position of a specific subsidiary.\n    \n    :param subsidiary_id: A unique identifier for the subsidiary.\n    :return:\n        dict: A dictionary with the following keys:\n            - subsidiary_id (str): The subsidiary ID.\n            - total_assets (float): The total assets of the subsidiary.\n            - total_liabilities (float): The total liabilities of the subsidiary.\n            - net_worth (float): The net worth of the subsidiary.\n    :raises ValueError: If the subsidiary ID is invalid.\n    \"\"\"\n    if not subsidiary_id:\n        raise ValueError(\"Subsidiary ID must be provided.\")\n    \n    return {\n        \"subsidiary_id\": subsidiary_id,\n        \"total_assets\": 5000000.00,\n        \"total_liabilities\": 2000000.00,\n        \"net_worth\": 3000000.00\n    }\ndef integrate_payment_system(payment_gateway: str) -> str:\n    \"\"\"\n    Integrates the payment system with a specified payment gateway.\n    \n    :param payment_gateway: The payment gateway to integrate (e.g., 'stripe', 'klarna').\n    :return: A message indicating the success of the integration.\n    :raises ValueError: If the payment gateway is not supported.\n    \"\"\"\n    supported_gateways = {'stripe', 'klarna', 'openbanking', 'plaid', 'paypal-sdk'}\n    if payment_gateway not in supported_gateways:\n        raise ValueError(f\"Unsupported payment gateway: {payment_gateway}\")\n    \n    return f\"Successfully integrated with {payment_gateway}\"", "user_query": "Can you track transaction \"TR789012\" for 50000 EUR?", "checklist": {"functions": ["track_transaction"], "values": [{"transaction_id": "TR789012", "status": "completed", "currency": "EUR", "foreign_exchange_adjustment": 500.0}]}}
{"difficulty": "easy", "function_schema_python": "def load_dataset(dataset_path: str) -> List[Dict]:\n    \"\"\"Loads a dataset from a specified path.\n\n    :param dataset_path: The file path to the dataset.\n    :return: A list of dictionaries where each dictionary represents a data sample.\n    :raises FileNotFoundError: If the dataset file does not exist.\n    :raises ValueError: If the dataset file is empty or malformed.\"\"\"\n    pass\ndef train_model_with_huggingface_trl(dataset: List[Dict], model_config: Dict) -> Dict:\n    \"\"\"Trains a model using Hugging Face's TRL library.\n\n    :param dataset: The dataset used for training.\n    :param model_config: A dictionary containing model configuration parameters.\n    :return: A dictionary containing the training results.\n    :raises ValueError: If required parameters in model_config are missing.\"\"\"\n    pass\ndef optimize_hyperparameters_with_pytorch(dataset: List[Dict], hyperparameters: Dict) -> Dict:\n    \"\"\"Optimizes hyperparameters for a model using PyTorch.\n\n    :param dataset: The dataset used for hyperparameter optimization.\n    :param hyperparameters: A dictionary containing the hyperparameters to optimize.\n    :return: A dictionary containing the optimized hyperparameters and performance metrics.\n    :raises ValueError: If hyperparameters dictionary is empty.\"\"\"\n    pass\ndef upload_model_to_aws(model_path: str, bucket_name: str) -> bool:\n    \"\"\"Uploads a trained model to an S3 bucket on AWS.\n\n    :param model_path: The file path to the trained model.\n    :param bucket_name: The name of the S3 bucket.\n    :return: True if the model is successfully uploaded, False otherwise.\n    :raises ValueError: If model_path or bucket_name is empty.\n    :raises RuntimeError: If the upload fails.\"\"\"\n    pass\ndef log_experiment_results_with_mlflow(run_name: str, metrics: Dict) -> bool:\n    \"\"\"Logs experiment results using MLflow.\n\n    :param run_name: The name of the experiment run.\n    :param metrics: A dictionary containing the metrics to log.\n    :return: True if metrics are successfully logged, False otherwise.\n    :raises ValueError: If run_name or metrics are not provided.\"\"\"\n    pass\ndef get_suggested_model_config(model_type: str) -> Dict:\n    \"\"\"Retrieves a suggested model configuration based on the specified model type.\n\n    :param model_type: The type of the model.\n    :return: A dictionary containing the suggested model configuration.\n    :raises ValueError: If model_type is not supported.\"\"\"\n    pass\n", "function_schema_json": [{"name": "load_dataset", "description": "Loads a dataset from a specified path.", "parameters": {"type": "object", "properties": {"dataset_path": {"type": "string", "description": "The file path to the dataset."}}, "required": ["dataset_path"], "additionalProperties": false}}, {"name": "train_model_with_huggingface_trl", "description": "Trains a model using Hugging Face's TRL library.", "parameters": {"type": "object", "properties": {"dataset": {"type": "array", "items": {"type": "object"}, "description": "The dataset used for training."}, "model_config": {"type": "object", "description": "A dictionary containing model configuration parameters."}}, "required": ["dataset", "model_config"], "additionalProperties": false}}, {"name": "optimize_hyperparameters_with_pytorch", "description": "Optimizes hyperparameters for a model using PyTorch.", "parameters": {"type": "object", "properties": {"dataset": {"type": "array", "items": {"type": "object"}, "description": "The dataset used for hyperparameter optimization."}, "hyperparameters": {"type": "object", "description": "A dictionary containing the hyperparameters to optimize."}}, "required": ["dataset", "hyperparameters"], "additionalProperties": false}}, {"name": "upload_model_to_aws", "description": "Uploads a trained model to an S3 bucket on AWS.", "parameters": {"type": "object", "properties": {"model_path": {"type": "string", "description": "The file path to the trained model."}, "bucket_name": {"type": "string", "description": "The name of the S3 bucket."}}, "required": ["model_path", "bucket_name"], "additionalProperties": false}}, {"name": "log_experiment_results_with_mlflow", "description": "Logs experiment results using MLflow.", "parameters": {"type": "object", "properties": {"run_name": {"type": "string", "description": "The name of the experiment run."}, "metrics": {"type": "object", "description": "A dictionary containing the metrics to log."}}, "required": ["run_name", "metrics"], "additionalProperties": false}}, {"name": "get_suggested_model_config", "description": "Retrieves a suggested model configuration based on the specified model type.", "parameters": {"type": "object", "properties": {"model_type": {"type": "string", "description": "The type of the model."}}, "required": ["model_type"], "additionalProperties": false}}], "mock_functions": "def load_dataset(dataset_path: str) -> List[Dict]:\n    \"\"\"\n    Loads a dataset from a specified path.\n    \n    :param dataset_path: The file path to the dataset.\n    :return: A list of dictionaries where each dictionary represents a data sample.\n    :raises FileNotFoundError: If the dataset file does not exist.\n    :raises ValueError: If the dataset file is empty or malformed.\n    \"\"\"\n    if not dataset_path:\n        raise ValueError(\"Dataset path must be provided.\")\n    if dataset_path.lower() == \"financial_market_data.csv\":\n        return [\n            {\"features\": [1, 2, 3, 4], \"label\": 5},\n            {\"features\": [2, 3, 4, 5], \"label\": 6}\n        ]\n    else:\n        raise FileNotFoundError(\"Dataset not found.\")\ndef train_model_with_huggingface_trl(dataset: List[Dict], model_config: Dict) -> Dict:\n    \"\"\"\n    Trains a model using Hugging Face's TRL library.\n    \n    :param dataset: The dataset used for training.\n    :param model_config: A dictionary containing model configuration parameters.\n    :return: A dictionary containing the training results.\n    :raises ValueError: If required parameters in model_config are missing.\n    \"\"\"\n    required_params = {'model_type', 'learning_rate'}\n    if not all(param in model_config for param in required_params):\n        raise ValueError(\"Model configuration is missing required parameters.\")\n    return {\n        \"model_name\": model_config.get(\"model_type\"),\n        \"accuracy\": 0.85,\n        \"training_time\": \"2 hours\"\n    }\ndef optimize_hyperparameters_with_pytorch(dataset: List[Dict], hyperparameters: Dict) -> Dict:\n    \"\"\"\n    Optimizes hyperparameters for a model using PyTorch.\n    \n    :param dataset: The dataset used for hyperparameter optimization.\n    :param hyperparameters: A dictionary containing the hyperparameters to optimize.\n    :return: A dictionary containing the optimized hyperparameters and performance metrics.\n    :raises ValueError: If hyperparameters dictionary is empty.\n    \"\"\"\n    if not hyperparameters:\n        raise ValueError(\"Hyperparameters dictionary must not be empty.\")\n    return {\n        \"optimized_hyperparameters\": hyperparameters,\n        \"accuracy\": 0.90,\n        \"training_time\": \"1.5 hours\"\n    }\ndef upload_model_to_aws(model_path: str, bucket_name: str) -> bool:\n    \"\"\"\n    Uploads a trained model to an S3 bucket on AWS.\n    \n    :param model_path: The file path to the trained model.\n    :param bucket_name: The name of the S3 bucket.\n    :return: True if the model is successfully uploaded, False otherwise.\n    :raises ValueError: If model_path or bucket_name is empty.\n    :raises RuntimeError: If the upload fails.\n    \"\"\"\n    if not model_path or not bucket_name:\n        raise ValueError(\"Model path and bucket name must be provided.\")\n    if model_path.lower() == \"best_model.pth\" and bucket_name.lower() == \"neuralnetmodels\":\n        return True\n    raise RuntimeError(\"Failed to upload model to AWS.\")\ndef log_experiment_results_with_mlflow(run_name: str, metrics: Dict) -> bool:\n    \"\"\"\n    Logs experiment results using MLflow.\n    \n    :param run_name: The name of the experiment run.\n    :param metrics: A dictionary containing the metrics to log.\n    :return: True if metrics are successfully logged, False otherwise.\n    :raises ValueError: If run_name or metrics are not provided.\n    \"\"\"\n    if not run_name or not metrics:\n        raise ValueError(\"Run name and metrics must be provided.\")\n    return True\ndef get_suggested_model_config(model_type: str) -> Dict:\n    \"\"\"\n    Retrieves a suggested model configuration based on the specified model type.\n    \n    :param model_type: The type of the model.\n    :return: A dictionary containing the suggested model configuration.\n    :raises ValueError: If model_type is not supported.\n    \"\"\"\n    supported_models = {'lstm', 'transformer'}\n    if model_type.lower() not in supported_models:\n        raise ValueError(f\"Model type {model_type} is not supported.\")\n    if model_type.lower() == 'lstm':\n        return {\n            \"model_type\": \"LSTM\",\n            \"learning_rate\": 0.001,\n            \"batch_size\": 32\n        }\n    return {\n        \"model_type\": \"Transformer\",\n        \"learning_rate\": 0.0001,\n        \"batch_size\": 16\n    }", "user_query": "Can you load the 'financial_market_data.csv' dataset for me?", "checklist": {"functions": ["load_dataset"], "values": [[{"features": [1, 2, 3, 4], "label": 5}, {"features": [2, 3, 4, 5], "label": 6}]]}}
{"difficulty": "easy", "function_schema_python": "def setup_hyperparameter_tuning_experiment(model_name: str, hyperparameters: list, search_algorithm: str) -> dict:\n    \"\"\"Sets up a Hyperparameter Tuning experiment for a given model.\n\n    :param model_name: The name of the model to be tuned (e.g., \"CNN_RNN_NLP\").\n    :param hyperparameters: A list of hyperparameters to optimize.\n    :param search_algorithm: The optimization algorithm to use (e.g., \"Random Search\", \"Gradient-Based Optimization\").\n    :return: A dictionary with the setup details and status.\n        dict: A dictionary with the following keys:\n            - status (str): The status of the experiment setup.\n            - details (dict): Additional details about the setup.\n    :raises ValueError: If any parameter is invalid.\"\"\"\n    pass\ndef get_hyperparameter_tuning_results(experiment_id: str) -> dict:\n    \"\"\"Retrieves the results of a Hyperparameter Tuning experiment.\n\n    :param experiment_id: The ID of the experiment.\n    :return: A dictionary containing the results of the experiment.\n        dict: A dictionary with the following keys:\n            - best_hyperparameters (dict): The best hyperparameters found.\n            - best_score (float): The best score achieved.\n    :raises ValueError: If the experiment ID is invalid.\"\"\"\n    pass\ndef log_experiment_results_to_mlflow(experiment_id: str, results: dict) -> bool:\n    \"\"\"Logs the results of a Hyperparameter Tuning experiment to MLflow.\n\n    :param experiment_id: The ID of the experiment.\n    :param results: A dictionary containing the experiment results.\n    :return: True if logging was successful, False otherwise.\n    :raises ValueError: If the experiment ID or results are invalid.\"\"\"\n    pass\ndef deploy_model_to_aws(model_name: str, best_hyperparameters: dict, environment: str) -> dict:\n    \"\"\"Deploys the tuned model to AWS.\n\n    :param model_name: The name of the model to be deployed.\n    :param best_hyperparameters: The best hyperparameters found during tuning.\n    :param environment: The AWS environment to deploy the model (e.g., \"development\", \"production\").\n    :return: A dictionary with the deployment details and status.\n        dict: A dictionary with the following keys:\n            - status (str): The status of the deployment.\n            - details (dict): Additional details about the deployment.\n    :raises ValueError: If any parameter is invalid.\"\"\"\n    pass\n", "function_schema_json": [{"name": "setup_hyperparameter_tuning_experiment", "description": "Sets up a Hyperparameter Tuning experiment for a given model.", "parameters": {"type": "object", "properties": {"model_name": {"type": "string", "description": "The name of the model to be tuned (e.g., \"CNN_RNN_NLP\")."}, "hyperparameters": {"type": "array", "description": "A list of hyperparameters to optimize."}, "search_algorithm": {"type": "string", "description": "The optimization algorithm to use (e.g., \"Random Search\", \"Gradient-Based Optimization\")."}}, "required": ["model_name", "hyperparameters", "search_algorithm"], "additionalProperties": false}}, {"name": "get_hyperparameter_tuning_results", "description": "Retrieves the results of a Hyperparameter Tuning experiment.", "parameters": {"type": "object", "properties": {"experiment_id": {"type": "string", "description": "The ID of the experiment."}}, "required": ["experiment_id"], "additionalProperties": false}}, {"name": "log_experiment_results_to_mlflow", "description": "Logs the results of a Hyperparameter Tuning experiment to MLflow.", "parameters": {"type": "object", "properties": {"experiment_id": {"type": "string", "description": "The ID of the experiment."}, "results": {"type": "object", "description": "A dictionary containing the experiment results."}}, "required": ["experiment_id", "results"], "additionalProperties": false}}, {"name": "deploy_model_to_aws", "description": "Deploys the tuned model to AWS.", "parameters": {"type": "object", "properties": {"model_name": {"type": "string", "description": "The name of the model to be deployed."}, "best_hyperparameters": {"type": "object", "description": "The best hyperparameters found during tuning."}, "environment": {"type": "string", "description": "The AWS environment to deploy the model (e.g., \"development\", \"production\")."}}, "required": ["model_name", "best_hyperparameters", "environment"], "additionalProperties": false}}], "mock_functions": "def setup_hyperparameter_tuning_experiment(model_name: str, hyperparameters: list, search_algorithm: str) -> dict:\n    \"\"\"\n    Sets up a Hyperparameter Tuning experiment for a given model.\n    \n    :param model_name: The name of the model to be tuned (e.g., \"CNN_RNN_NLP\").\n    :param hyperparameters: A list of hyperparameters to optimize.\n    :param search_algorithm: The optimization algorithm to use (e.g., \"Random Search\", \"Gradient-Based Optimization\").\n    :return: A dictionary with the setup details and status.\n        dict: A dictionary with the following keys:\n            - status (str): The status of the experiment setup.\n            - details (dict): Additional details about the setup.\n    :raises ValueError: If any parameter is invalid.\n    \"\"\"\n    if not model_name or not hyperparameters or not search_algorithm:\n        raise ValueError(\"Model name, hyperparameters, and search algorithm must be provided.\")\n    \n    if search_algorithm.lower() not in [\"random search\", \"gradient-based optimization\"]:\n        raise ValueError(\"Invalid search algorithm. Choose from 'Random Search', 'Gradient-Based Optimization'.\")\n    \n    details = {\n        \"model_name\": model_name,\n        \"hyperparameters\": hyperparameters,\n        \"search_algorithm\": search_algorithm\n    }\n    \n    return {\n        \"status\": \"Setup completed successfully\",\n        \"details\": details\n    }\ndef get_hyperparameter_tuning_results(experiment_id: str) -> dict:\n    \"\"\"\n    Retrieves the results of a Hyperparameter Tuning experiment.\n    \n    :param experiment_id: The ID of the experiment.\n    :return: A dictionary containing the results of the experiment.\n        dict: A dictionary with the following keys:\n            - best_hyperparameters (dict): The best hyperparameters found.\n            - best_score (float): The best score achieved.\n    :raises ValueError: If the experiment ID is invalid.\n    \"\"\"\n    if not experiment_id:\n        raise ValueError(\"Experiment ID must be provided.\")\n    \n    # Mock logic: Return mock results based on experiment_id\n    if experiment_id == \"exp123\":\n        return {\n            \"best_hyperparameters\": {\"learning_rate\": 0.001, \"batch_size\": 32, \"num_epochs\": 10},\n            \"best_score\": 0.95\n        }\n    \n    return {}\ndef log_experiment_results_to_mlflow(experiment_id: str, results: dict) -> bool:\n    \"\"\"\n    Logs the results of a Hyperparameter Tuning experiment to MLflow.\n    \n    :param experiment_id: The ID of the experiment.\n    :param results: A dictionary containing the experiment results.\n    :return: True if logging was successful, False otherwise.\n    :raises ValueError: If the experiment ID or results are invalid.\n    \"\"\"\n    if not experiment_id or not results:\n        raise ValueError(\"Experiment ID and results must be provided.\")\n    \n    # Mock logic: Log mock results\n    print(f\"Logging experiment {experiment_id} results to MLflow: {results}\")\n    return True\ndef deploy_model_to_aws(model_name: str, best_hyperparameters: dict, environment: str) -> dict:\n    \"\"\"\n    Deploys the tuned model to AWS.\n    \n    :param model_name: The name of the model to be deployed.\n    :param best_hyperparameters: The best hyperparameters found during tuning.\n    :param environment: The AWS environment to deploy the model (e.g., \"development\", \"production\").\n    :return: A dictionary with the deployment details and status.\n        dict: A dictionary with the following keys:\n            - status (str): The status of the deployment.\n            - details (dict): Additional details about the deployment.\n    :raises ValueError: If any parameter is invalid.\n    \"\"\"\n    if not model_name or not best_hyperparameters or not environment:\n        raise ValueError(\"Model name, best hyperparameters, and environment must be provided.\")\n    \n    if environment.lower() not in [\"development\", \"production\"]:\n        raise ValueError(\"Invalid environment. Choose from 'development', 'production'.\")\n    \n    details = {\n        \"model_name\": model_name,\n        \"best_hyperparameters\": best_hyperparameters,\n        \"environment\": environment\n    }\n    \n    return {\n        \"status\": \"Deployment completed successfully\",\n        \"details\": details\n    }", "user_query": "Can you setup a hyperparameter tuning experiment for \"CNN_RNN_NLP\" model with [\"learning_rate\", \"batch_size\", \"num_epochs\"] parameters using Random Search?", "checklist": {"functions": ["setup_hyperparameter_tuning_experiment"], "values": [{"status": "Setup completed successfully", "details": {"model_name": "CNN_RNN_NLP", "hyperparameters": ["learning_rate", "batch_size", "num_epochs"], "search_algorithm": "Random Search"}}]}}
{"difficulty": "easy", "function_schema_python": "def deploy_model_to_sagemaker(model_path: str, instance_type: str, initial_instance_count: int) -> dict:\n    \"\"\"Deploys a model to AWS SageMaker endpoint.\n\n    :param model_path: Path to the model file\n    :param instance_type: AWS instance type for deployment\n    :param initial_instance_count: Number of initial instances\n    :return: Dictionary containing endpoint details\n    :raises ValueError: If model path is invalid or instance parameters are incorrect\"\"\"\n    pass\ndef predict_diabetes(endpoint_name: str, features: dict) -> dict:\n    \"\"\"Makes prediction using deployed model endpoint.\n\n    :param endpoint_name: Name of the SageMaker endpoint\n    :param features: Dictionary containing the 8 required features\n    :return: Dictionary containing prediction results\n    :raises ValueError: If features are missing or invalid\"\"\"\n    pass\ndef monitor_endpoint_metrics(endpoint_name: str, time_window_minutes: int) -> dict:\n    \"\"\"Monitors endpoint performance metrics.\n\n    :param endpoint_name: Name of the SageMaker endpoint\n    :param time_window_minutes: Time window for metrics in minutes\n    :return: Dictionary containing monitoring metrics\n    :raises ValueError: If endpoint name is invalid or time window is incorrect\"\"\"\n    pass\n", "function_schema_json": [{"name": "deploy_model_to_sagemaker", "description": "Deploys a model to AWS SageMaker endpoint.", "parameters": {"type": "object", "properties": {"model_path": {"type": "string", "description": "Path to the model file"}, "instance_type": {"type": "string", "description": "AWS instance type for deployment"}, "initial_instance_count": {"type": "integer", "description": "Number of initial instances"}}, "required": ["model_path", "instance_type", "initial_instance_count"], "additionalProperties": false}}, {"name": "predict_diabetes", "description": "Makes prediction using deployed model endpoint.", "parameters": {"type": "object", "properties": {"endpoint_name": {"type": "string", "description": "Name of the SageMaker endpoint"}, "features": {"type": "object", "description": "Dictionary containing the 8 required features"}}, "required": ["endpoint_name", "features"], "additionalProperties": false}}, {"name": "monitor_endpoint_metrics", "description": "Monitors endpoint performance metrics.", "parameters": {"type": "object", "properties": {"endpoint_name": {"type": "string", "description": "Name of the SageMaker endpoint"}, "time_window_minutes": {"type": "integer", "description": "Time window for metrics in minutes"}}, "required": ["endpoint_name", "time_window_minutes"], "additionalProperties": false}}], "mock_functions": "def deploy_model_to_sagemaker(\n    model_path: str, \n    instance_type: str,\n    initial_instance_count: int\n) -> dict:\n    \"\"\"\n    Deploys a model to AWS SageMaker endpoint.\n    \n    :param model_path: Path to the model file\n    :param instance_type: AWS instance type for deployment\n    :param initial_instance_count: Number of initial instances\n    :return: Dictionary containing endpoint details\n    :raises ValueError: If model path is invalid or instance parameters are incorrect\n    \"\"\"\n    if not model_path.endswith('.pkl') or 'diabetes' not in model_path.lower():\n        raise ValueError(\"Invalid model path\")\n    \n    if not instance_type.startswith('ml.'):\n        raise ValueError(\"Invalid instance type\")\n        \n    if initial_instance_count < 1:\n        raise ValueError(\"Instance count must be at least 1\")\n        \n    return {\n        \"endpoint_name\": \"diabetes-pred-endpoint-001\",\n        \"status\": \"InService\",\n        \"instance_type\": instance_type,\n        \"instance_count\": initial_instance_count,\n        \"model_latency_ms\": 45\n    }\ndef predict_diabetes(\n    endpoint_name: str,\n    features: dict\n) -> dict:\n    \"\"\"\n    Makes prediction using deployed model endpoint.\n    \n    :param endpoint_name: Name of the SageMaker endpoint\n    :param features: Dictionary containing the 8 required features\n    :return: Dictionary containing prediction results\n    :raises ValueError: If features are missing or invalid\n    \"\"\"\n    required_features = {'blood_glucose', 'bmi', 'age', 'blood_pressure', \n                        'insulin', 'diabetes_pedigree', 'pregnancies', 'skin_thickness'}\n    \n    if not all(feature in features for feature in required_features):\n        raise ValueError(\"Missing required features\")\n        \n    if endpoint_name != \"diabetes-pred-endpoint-001\":\n        raise ValueError(\"Invalid endpoint name\")\n        \n    return {\n        \"prediction\": 1,\n        \"probability\": 0.91,\n        \"latency_ms\": 45,\n        \"status\": \"success\"\n    }\ndef monitor_endpoint_metrics(\n    endpoint_name: str,\n    time_window_minutes: int\n) -> dict:\n    \"\"\"\n    Monitors endpoint performance metrics.\n    \n    :param endpoint_name: Name of the SageMaker endpoint\n    :param time_window_minutes: Time window for metrics in minutes\n    :return: Dictionary containing monitoring metrics\n    :raises ValueError: If endpoint name is invalid or time window is incorrect\n    \"\"\"\n    if endpoint_name != \"diabetes-pred-endpoint-001\":\n        raise ValueError(\"Invalid endpoint name\")\n        \n    if time_window_minutes < 1 or time_window_minutes > 1440:\n        raise ValueError(\"Time window must be between 1 and 1440 minutes\")\n        \n    return {\n        \"invocations_per_second\": 450,\n        \"average_latency_ms\": 45,\n        \"p95_latency_ms\": 75,\n        \"success_rate\": 0.999,\n        \"cpu_utilization\": 0.65,\n        \"memory_utilization\": 0.70\n    }", "user_query": "Can you deploy the diabetes_pred_v2.pkl model to a SageMaker endpoint using ml.m5.xlarge with 2 initial instances?", "checklist": {"functions": ["deploy_model_to_sagemaker"], "values": [{"endpoint_name": "diabetes-pred-endpoint-001", "status": "InService", "instance_type": "ml.m5.xlarge", "instance_count": 2, "model_latency_ms": 45}]}}
{"difficulty": "easy", "function_schema_python": "def deploy_model_to_sagemaker(model_path: str, instance_type: str, initial_instance_count: int) -> dict:\n    \"\"\"Deploys a model to AWS SageMaker endpoint.\n\n    :param model_path: Path to the model file\n    :param instance_type: AWS instance type for deployment\n    :param initial_instance_count: Number of initial instances\n    :return: Dictionary containing endpoint details\n    :raises ValueError: If model path is invalid or instance parameters are incorrect\"\"\"\n    pass\ndef predict_diabetes(endpoint_name: str, features: dict) -> dict:\n    \"\"\"Makes prediction using deployed model endpoint.\n\n    :param endpoint_name: Name of the SageMaker endpoint\n    :param features: Dictionary containing the 8 required features\n    :return: Dictionary containing prediction results\n    :raises ValueError: If features are missing or invalid\"\"\"\n    pass\ndef monitor_endpoint_metrics(endpoint_name: str, time_window_minutes: int) -> dict:\n    \"\"\"Monitors endpoint performance metrics.\n\n    :param endpoint_name: Name of the SageMaker endpoint\n    :param time_window_minutes: Time window for metrics in minutes\n    :return: Dictionary containing monitoring metrics\n    :raises ValueError: If endpoint name is invalid or time window is incorrect\"\"\"\n    pass\n", "function_schema_json": [{"name": "deploy_model_to_sagemaker", "description": "Deploys a model to AWS SageMaker endpoint.", "parameters": {"type": "object", "properties": {"model_path": {"type": "string", "description": "Path to the model file"}, "instance_type": {"type": "string", "description": "AWS instance type for deployment"}, "initial_instance_count": {"type": "integer", "description": "Number of initial instances"}}, "required": ["model_path", "instance_type", "initial_instance_count"], "additionalProperties": false}}, {"name": "predict_diabetes", "description": "Makes prediction using deployed model endpoint.", "parameters": {"type": "object", "properties": {"endpoint_name": {"type": "string", "description": "Name of the SageMaker endpoint"}, "features": {"type": "object", "description": "Dictionary containing the 8 required features"}}, "required": ["endpoint_name", "features"], "additionalProperties": false}}, {"name": "monitor_endpoint_metrics", "description": "Monitors endpoint performance metrics.", "parameters": {"type": "object", "properties": {"endpoint_name": {"type": "string", "description": "Name of the SageMaker endpoint"}, "time_window_minutes": {"type": "integer", "description": "Time window for metrics in minutes"}}, "required": ["endpoint_name", "time_window_minutes"], "additionalProperties": false}}], "mock_functions": "def deploy_model_to_sagemaker(\n    model_path: str, \n    instance_type: str,\n    initial_instance_count: int\n) -> dict:\n    \"\"\"\n    Deploys a model to AWS SageMaker endpoint.\n    \n    :param model_path: Path to the model file\n    :param instance_type: AWS instance type for deployment\n    :param initial_instance_count: Number of initial instances\n    :return: Dictionary containing endpoint details\n    :raises ValueError: If model path is invalid or instance parameters are incorrect\n    \"\"\"\n    if not model_path.endswith('.pkl') or 'diabetes' not in model_path.lower():\n        raise ValueError(\"Invalid model path\")\n    \n    if not instance_type.startswith('ml.'):\n        raise ValueError(\"Invalid instance type\")\n        \n    if initial_instance_count < 1:\n        raise ValueError(\"Instance count must be at least 1\")\n        \n    return {\n        \"endpoint_name\": \"diabetes-pred-endpoint-001\",\n        \"status\": \"InService\",\n        \"instance_type\": instance_type,\n        \"instance_count\": initial_instance_count,\n        \"model_latency_ms\": 45\n    }\ndef predict_diabetes(\n    endpoint_name: str,\n    features: dict\n) -> dict:\n    \"\"\"\n    Makes prediction using deployed model endpoint.\n    \n    :param endpoint_name: Name of the SageMaker endpoint\n    :param features: Dictionary containing the 8 required features\n    :return: Dictionary containing prediction results\n    :raises ValueError: If features are missing or invalid\n    \"\"\"\n    required_features = {'blood_glucose', 'bmi', 'age', 'blood_pressure', \n                        'insulin', 'diabetes_pedigree', 'pregnancies', 'skin_thickness'}\n    \n    if not all(feature in features for feature in required_features):\n        raise ValueError(\"Missing required features\")\n        \n    if endpoint_name != \"diabetes-pred-endpoint-001\":\n        raise ValueError(\"Invalid endpoint name\")\n        \n    return {\n        \"prediction\": 1,\n        \"probability\": 0.91,\n        \"latency_ms\": 45,\n        \"status\": \"success\"\n    }\ndef monitor_endpoint_metrics(\n    endpoint_name: str,\n    time_window_minutes: int\n) -> dict:\n    \"\"\"\n    Monitors endpoint performance metrics.\n    \n    :param endpoint_name: Name of the SageMaker endpoint\n    :param time_window_minutes: Time window for metrics in minutes\n    :return: Dictionary containing monitoring metrics\n    :raises ValueError: If endpoint name is invalid or time window is incorrect\n    \"\"\"\n    if endpoint_name != \"diabetes-pred-endpoint-001\":\n        raise ValueError(\"Invalid endpoint name\")\n        \n    if time_window_minutes < 1 or time_window_minutes > 1440:\n        raise ValueError(\"Time window must be between 1 and 1440 minutes\")\n        \n    return {\n        \"invocations_per_second\": 450,\n        \"average_latency_ms\": 45,\n        \"p95_latency_ms\": 75,\n        \"success_rate\": 0.999,\n        \"cpu_utilization\": 0.65,\n        \"memory_utilization\": 0.70\n    }", "user_query": "This is Sarah. Please monitor the diabetes-pred-endpoint-001 endpoint metrics for the last 60 minutes, and verify if it can handle 500 predictions per second with under 100ms latency, focusing on current invocations, average latency, and success rate.", "checklist": {"functions": ["monitor_endpoint_metrics"], "values": [{"invocations_per_second": 450, "average_latency_ms": 45, "p95_latency_ms": 75, "success_rate": 0.999, "cpu_utilization": 0.65, "memory_utilization": 0.7}]}}
{"difficulty": "easy", "function_schema_python": "def load_model(model_path: str, expected_size: float) -> bool:\n    \"\"\"Loads a content recommendation model from the specified path.\n\n    :param model_path: The path to the model file (e.g., \"recom_engine_2023.h5\").\n    :param expected_size: The expected size of the model file in GB.\n    :return: True if the model was successfully loaded and matches the expected size, False otherwise.\"\"\"\n    pass\ndef update_model_with_new_data(model_path: str, new_data_path: str) -> bool:\n    \"\"\"Updates the recommendation model with new interaction data.\n\n    :param model_path: The path to the model file (e.g., \"recom_engine_2023.h5\").\n    :param new_data_path: The path to the new interaction data file.\n    :return: True if the model was successfully updated, False otherwise.\"\"\"\n    pass\ndef serve_model_in_real_time(request: dict, model_path: str) -> dict:\n    \"\"\"Serves the recommendation model in real-time to handle incoming requests.\n\n    :param request: A dictionary representing the user request with user ID and possibly other metadata.\n    :param model_path: The path to the model file (e.g., \"recom_engine_2023.h5\").\n    :return:\n        dict: A dictionary with the following keys:\n            - user_id (int): The ID of the user.\n            - recommendations (list[str]): A list of recommended video IDs.\n    :raises ValueError: If the request or model_path is invalid.\"\"\"\n    pass\ndef deploy_model_on_aws(model_path: str, instance_type: str) -> dict:\n    \"\"\"Deploys the recommendation model on AWS infrastructure.\n\n    :param model_path: The path to the model file to be deployed.\n    :param instance_type: The type of AWS EC2 instance (e.g., \"m5.large\").\n    :return:\n        dict: A dictionary with the following keys:\n            - model_path (str): The path to the deployed model file.\n            - instance_type (str): The AWS EC2 instance type.\n            - deployment_status (str): The status of the deployment (e.g., \"SUCCESS\").\n    :raises ValueError: If the model_path or instance_type is empty.\"\"\"\n    pass\ndef log_model_to_mlflow(model_path: str, experiment_name: str) -> dict:\n    \"\"\"Logs the recommendation model to MLflow for tracking and version management.\n\n    :param model_path: The path to the model file (e.g., \"recom_engine_2023.h5\").\n    :param experiment_name: The name of the experiment (e.g., \"2023_STREAMFLIX_RECOMMENDATION\").\n    :return:\n        dict: A dictionary with the following keys:\n            - model_path (str): The path to the logged model file.\n            - experiment_name (str): The experiment name.\n            - run_id (str): A mock run ID generated by MLflow.\n    :raises ValueError: If the model_path or experiment_name is empty.\"\"\"\n    pass\ndef scale_aws_infrastructure(prime_time: bool, instance_count: int) -> dict:\n    \"\"\"Scales the AWS infrastructure based on the prime-time hour flag.\n\n    :param prime_time: Boolean indicating if it is the prime-time viewing period.\n    :param instance_count: The number of (additional) instances to scale up.\n    :return:\n        dict: A dictionary with the following keys:\n            - prime_time (bool): Indicates if it is the prime-time viewing period.\n            - instance_count (int): The resulting number of instances after scaling.\n            - scaling_status (str): The status of the scaling operation (e.g., \"SCALED_UP\").\"\"\"\n    pass\n", "function_schema_json": [{"name": "load_model", "description": "Loads a content recommendation model from the specified path.", "parameters": {"type": "object", "properties": {"model_path": {"type": "string", "description": "The path to the model file (e.g., \"recom_engine_2023.h5\")."}, "expected_size": {"type": "number", "description": "The expected size of the model file in GB."}}, "required": ["model_path", "expected_size"], "additionalProperties": false}}, {"name": "update_model_with_new_data", "description": "Updates the recommendation model with new interaction data.", "parameters": {"type": "object", "properties": {"model_path": {"type": "string", "description": "The path to the model file (e.g., \"recom_engine_2023.h5\")."}, "new_data_path": {"type": "string", "description": "The path to the new interaction data file."}}, "required": ["model_path", "new_data_path"], "additionalProperties": false}}, {"name": "serve_model_in_real_time", "description": "Serves the recommendation model in real-time to handle incoming requests.", "parameters": {"type": "object", "properties": {"request": {"type": "object", "description": "A dictionary representing the user request with user ID and possibly other metadata."}, "model_path": {"type": "string", "description": "The path to the model file (e.g., \"recom_engine_2023.h5\")."}}, "required": ["request", "model_path"], "additionalProperties": false}}, {"name": "deploy_model_on_aws", "description": "Deploys the recommendation model on AWS infrastructure.", "parameters": {"type": "object", "properties": {"model_path": {"type": "string", "description": "The path to the model file to be deployed."}, "instance_type": {"type": "string", "description": "The type of AWS EC2 instance (e.g., \"m5.large\")."}}, "required": ["model_path", "instance_type"], "additionalProperties": false}}, {"name": "log_model_to_mlflow", "description": "Logs the recommendation model to MLflow for tracking and version management.", "parameters": {"type": "object", "properties": {"model_path": {"type": "string", "description": "The path to the model file (e.g., \"recom_engine_2023.h5\")."}, "experiment_name": {"type": "string", "description": "The name of the experiment (e.g., \"2023_STREAMFLIX_RECOMMENDATION\")."}}, "required": ["model_path", "experiment_name"], "additionalProperties": false}}, {"name": "scale_aws_infrastructure", "description": "Scales the AWS infrastructure based on the prime-time hour flag.", "parameters": {"type": "object", "properties": {"prime_time": {"type": "boolean", "description": "Boolean indicating if it is the prime-time viewing period."}, "instance_count": {"type": "integer", "description": "The number of (additional) instances to scale up."}}, "required": ["prime_time", "instance_count"], "additionalProperties": false}}], "mock_functions": "def load_model(model_path: str, expected_size: float) -> bool:\n    \"\"\"\n    Loads a content recommendation model from the specified path.\n    \n    :param model_path: The path to the model file (e.g., \"recom_engine_2023.h5\").\n    :param expected_size: The expected size of the model file in GB.\n    :return: True if the model was successfully loaded and matches the expected size, False otherwise.\n    \"\"\"\n    if not model_path or not expected_size:\n        return False\n    if model_path == \"recom_engine_2023.h5\" and expected_size == 1.2:\n        return True\n    return False\ndef update_model_with_new_data(model_path: str, new_data_path: str) -> bool:\n    \"\"\"\n    Updates the recommendation model with new interaction data.\n    \n    :param model_path: The path to the model file (e.g., \"recom_engine_2023.h5\").\n    :param new_data_path: The path to the new interaction data file.\n    :return: True if the model was successfully updated, False otherwise.\n    \"\"\"\n    if not model_path or not new_data_path:\n        return False\n    if model_path == \"recom_engine_2023.h5\" and new_data_path.endswith(\".csv\"):\n        return True\n    return False\ndef serve_model_in_real_time(request: dict, model_path: str) -> dict:\n    \"\"\"\n    Serves the recommendation model in real-time to handle incoming requests.\n    \n    :param request: A dictionary representing the user request with user ID and possibly other metadata.\n    :param model_path: The path to the model file (e.g., \"recom_engine_2023.h5\").\n    :return:\n        dict: A dictionary with the following keys:\n            - user_id (int): The ID of the user.\n            - recommendations (list[str]): A list of recommended video IDs.\n    :raises ValueError: If the request or model_path is invalid.\n    \"\"\"\n    if not request or not model_path:\n        raise ValueError(\"Request and model path must be provided.\")\n    if request.get(\"user_id\") and model_path == \"recom_engine_2023.h5\":\n        user_id = request[\"user_id\"]\n        # Mock recommendations for any user ID\n        return {\n            \"user_id\": user_id,\n            \"recommendations\": [\"video_101\", \"video_204\", \"video_307\"]\n        }\n    return {}\ndef deploy_model_on_aws(model_path: str, instance_type: str) -> dict:\n    \"\"\"\n    Deploys the recommendation model on AWS infrastructure.\n    \n    :param model_path: The path to the model file to be deployed.\n    :param instance_type: The type of AWS EC2 instance (e.g., \"m5.large\").\n    :return:\n        dict: A dictionary with the following keys:\n            - model_path (str): The path to the deployed model file.\n            - instance_type (str): The AWS EC2 instance type.\n            - deployment_status (str): The status of the deployment (e.g., \"SUCCESS\").\n    :raises ValueError: If the model_path or instance_type is empty.\n    \"\"\"\n    if not model_path or not instance_type:\n        raise ValueError(\"Model path and instance type must be provided.\")\n    if model_path == \"recom_engine_2023.h5\" and instance_type:\n        return {\n            \"model_path\": model_path,\n            \"instance_type\": instance_type,\n            \"deployment_status\": \"SUCCESS\"\n        }\n    return {}\ndef log_model_to_mlflow(model_path: str, experiment_name: str) -> dict:\n    \"\"\"\n    Logs the recommendation model to MLflow for tracking and version management.\n    \n    :param model_path: The path to the model file (e.g., \"recom_engine_2023.h5\").\n    :param experiment_name: The name of the experiment (e.g., \"2023_STREAMFLIX_RECOMMENDATION\").\n    :return:\n        dict: A dictionary with the following keys:\n            - model_path (str): The path to the logged model file.\n            - experiment_name (str): The experiment name.\n            - run_id (str): A mock run ID generated by MLflow.\n    :raises ValueError: If the model_path or experiment_name is empty.\n    \"\"\"\n    if not model_path or not experiment_name:\n        raise ValueError(\"Model path and experiment name must be provided.\")\n    if model_path == \"recom_engine_2023.h5\" and experiment_name:\n        # Mock run ID\n        mlflow_run_id = \"987654321\"\n        return {\n            \"model_path\": model_path,\n            \"experiment_name\": experiment_name,\n            \"run_id\": mlflow_run_id\n        }\n    return {}\ndef scale_aws_infrastructure(prime_time: bool, instance_count: int) -> dict:\n    \"\"\"\n    Scales the AWS infrastructure based on the prime-time hour flag.\n    \n    :param prime_time: Boolean indicating if it is the prime-time viewing period.\n    :param instance_count: The number of (additional) instances to scale up.\n    :return:\n        dict: A dictionary with the following keys:\n            - prime_time (bool): Indicates if it is the prime-time viewing period.\n            - instance_count (int): The resulting number of instances after scaling.\n            - scaling_status (str): The status of the scaling operation (e.g., \"SCALED_UP\").\n    \"\"\"\n    if not isinstance(prime_time, bool) or not isinstance(instance_count, int):\n        raise ValueError(\"Prime time must be a boolean and instance count must be an integer.\")\n    if prime_time:\n        Scaling_increment = 3\n        new_instance_count = instance_count + Scaling_increment\n    else:\n        new_instance_count = instance_count\n    return {\n        \"prime_time\": prime_time,\n        \"instance_count\": new_instance_count,\n        \"scaling_status\": \"SCALED_UP\" if prime_time else \"NO_CHANGE\"\n    }", "user_query": "Can you load the model from `recom_engine_2023.h5`, which is 1.2GB?", "checklist": {"functions": ["load_model"], "values": [true]}}
{"difficulty": "easy", "function_schema_python": "def load_data(file_path: str) -> dict:\n    \"\"\"Loads customer data from a specified file path.\n\n    :param file_path: The path to the file containing customer data.\n    :return:\n        dict: A dictionary containing the loaded data with the following keys:\n            - 'features' (list[dict]): A list of dictionaries, each representing a customer's data.\n            - 'labels' (list[int]): A list of integers representing the churn status of each customer.\n    :raises FileNotFoundError: If the file path is invalid.\"\"\"\n    pass\ndef feature_scaling(features: list) -> list:\n    \"\"\"Scales features so that they have a mean of 0 and standard deviation of 1.\n\n    :param features: A list of dictionaries representing customer data.\n    :return:\n        list: A list of dictionaries with scaled feature values.\"\"\"\n    pass\ndef one_hot_encode(categories: list) -> dict:\n    \"\"\"Performs one-hot encoding on categorical data.\n\n    :param categories: A list of categories to encode.\n    :return:\n        dict: A dictionary with keys as original categories and values as encoded vectors.\"\"\"\n    pass\ndef feature_selection(features: list, labels: list) -> dict:\n    \"\"\"Selects the most relevant features for the predictive model.\n\n    :param features: A list of dictionaries representing customer data.\n    :param labels: A list of integers representing the churn status of each customer.\n    :return:\n        dict: A dictionary with the following keys:\n            - 'selected_features' (list[dict]): A list of dictionaries with selected features.\n            - 'performance_metric' (float): A float representing the performance metric of the model.\"\"\"\n    pass\ndef log_experiment_results(experiment_name: str, model_performance: float) -> bool:\n    \"\"\"Logs the results of an experiment to an MLflow tracking server.\n\n    :param experiment_name: The name of the experiment.\n    :param model_performance: The performance metric of the model.\n    :return: True if the results were successfully logged, False otherwise.\"\"\"\n    pass\ndef deploy_model(model_artifact: str, platform: str) -> bool:\n    \"\"\"Deploys a machine learning model to a specified platform.\n\n    :param model_artifact: The path to the model artifact.\n    :param platform: The platform to deploy the model to (e.g., 'AWS').\n    :return: True if the model was successfully deployed, False otherwise.\"\"\"\n    pass\n", "function_schema_json": [{"name": "load_data", "description": "Loads customer data from a specified file path.", "parameters": {"type": "object", "properties": {"file_path": {"type": "string", "description": "The path to the file containing customer data."}}, "required": ["file_path"], "additionalProperties": false}}, {"name": "feature_scaling", "description": "Scales features so that they have a mean of 0 and standard deviation of 1.", "parameters": {"type": "object", "properties": {"features": {"type": "array", "description": "A list of dictionaries representing customer data."}}, "required": ["features"], "additionalProperties": false}}, {"name": "one_hot_encode", "description": "Performs one-hot encoding on categorical data.", "parameters": {"type": "object", "properties": {"categories": {"type": "array", "description": "A list of categories to encode."}}, "required": ["categories"], "additionalProperties": false}}, {"name": "feature_selection", "description": "Selects the most relevant features for the predictive model.", "parameters": {"type": "object", "properties": {"features": {"type": "array", "description": "A list of dictionaries representing customer data."}, "labels": {"type": "array", "description": "A list of integers representing the churn status of each customer."}}, "required": ["features", "labels"], "additionalProperties": false}}, {"name": "log_experiment_results", "description": "Logs the results of an experiment to an MLflow tracking server.", "parameters": {"type": "object", "properties": {"experiment_name": {"type": "string", "description": "The name of the experiment."}, "model_performance": {"type": "number", "description": "The performance metric of the model."}}, "required": ["experiment_name", "model_performance"], "additionalProperties": false}}, {"name": "deploy_model", "description": "Deploys a machine learning model to a specified platform.", "parameters": {"type": "object", "properties": {"model_artifact": {"type": "string", "description": "The path to the model artifact."}, "platform": {"type": "string", "description": "The platform to deploy the model to (e.g., 'AWS')."}}, "required": ["model_artifact", "platform"], "additionalProperties": false}}], "mock_functions": "def load_data(file_path: str) -> dict:\n    \"\"\"\n    Loads customer data from a specified file path.\n    \n    :param file_path: The path to the file containing customer data.\n    :return:\n        dict: A dictionary containing the loaded data with the following keys:\n            - 'features' (list[dict]): A list of dictionaries, each representing a customer's data.\n            - 'labels' (list[int]): A list of integers representing the churn status of each customer.\n    :raises FileNotFoundError: If the file path is invalid.\n    \"\"\"\n    if not file_path.endswith('.csv'):\n        raise ValueError(\"File path must point to a CSV file.\")\n    if file_path == \"customer_data.csv\":\n        return {\n            \"features\": [\n                {\"age\": 28, \"gender\": \"male\", \"account_length\": 12},\n                {\"age\": 54, \"gender\": \"female\", \"account_length\": 30}\n            ],\n            \"labels\": [0, 1]\n        }\n    raise FileNotFoundError(\"File not found.\")\ndef feature_scaling(features: list) -> list:\n    \"\"\"\n    Scales features so that they have a mean of 0 and standard deviation of 1.\n    \n    :param features: A list of dictionaries representing customer data.\n    :return:\n        list: A list of dictionaries with scaled feature values.\n    \"\"\"\n    if not features:\n        raise ValueError(\"Features list must not be empty.\")\n    scaled_features = []\n    for feature in features:\n        # Mock scaling logic\n        scaled_feature = {key: value * 0.1 for key, value in feature.items()}\n        scaled_features.append(scaled_feature)\n    return scaled_features\ndef one_hot_encode(categories: list) -> dict:\n    \"\"\"\n    Performs one-hot encoding on categorical data.\n    \n    :param categories: A list of categories to encode.\n    :return:\n        dict: A dictionary with keys as original categories and values as encoded vectors.\n    \"\"\"\n    if not categories:\n        raise ValueError(\"Categories list must not be empty.\")\n    encoding_dict = {}\n    for idx, category in enumerate(categories):\n        vector = [0] * len(categories)\n        vector[idx] = 1\n        encoding_dict[category] = vector\n    return encoding_dict\ndef feature_selection(features: list, labels: list) -> dict:\n    \"\"\"\n    Selects the most relevant features for the predictive model.\n    \n    :param features: A list of dictionaries representing customer data.\n    :param labels: A list of integers representing the churn status of each customer.\n    :return:\n        dict: A dictionary with the following keys:\n            - 'selected_features' (list[dict]): A list of dictionaries with selected features.\n            - 'performance_metric' (float): A float representing the performance metric of the model.\n    \"\"\"\n    if not features or not labels:\n        raise ValueError(\"Features and labels must not be empty.\")\n    # Mock feature selection logic\n    selected_features = []\n    for feature in features:\n        # Select features with age over 30\n        if feature.get('age', 0) > 30:\n            selected_features.append(feature)\n    # Mock performance metric\n    performance_metric = 0.85\n    return {\n        \"selected_features\": selected_features,\n        \"performance_metric\": performance_metric\n    }\ndef log_experiment_results(experiment_name: str, model_performance: float) -> bool:\n    \"\"\"\n    Logs the results of an experiment to an MLflow tracking server.\n    \n    :param experiment_name: The name of the experiment.\n    :param model_performance: The performance metric of the model.\n    :return: True if the results were successfully logged, False otherwise.\n    \"\"\"\n    if not experiment_name or model_performance is None:\n        raise ValueError(\"Experiment name and model performance must be provided.\")\n    if experiment_name == \"customer_churn_model\":\n        # Mock logging logic\n        return True\n    return False\ndef deploy_model(model_artifact: str, platform: str) -> bool:\n    \"\"\"\n    Deploys a machine learning model to a specified platform.\n    \n    :param model_artifact: The path to the model artifact.\n    :param platform: The platform to deploy the model to (e.g., 'AWS').\n    :return: True if the model was successfully deployed, False otherwise.\n    \"\"\"\n    if not model_artifact or not platform:\n        raise ValueError(\"Model artifact and platform must be specified.\")\n    if model_artifact == \"churn_model.pkl\" and platform == \"AWS\":\n        # Mock deployment logic\n        return True\n    return False", "user_query": "Could you load the customer data from customer_data.csv?", "checklist": {"functions": ["load_data"], "values": [{"features": [{"age": 28, "gender": "male", "account_length": 12}, {"age": 54, "gender": "female", "account_length": 30}], "labels": [0, 1]}]}}
{"difficulty": "easy", "function_schema_python": "def create_time_based_features(user_interactions: list, timeframe: str) -> dict:\n    \"\"\"Creates time-based features from user interaction data.\n\n    :param user_interactions: List of user interaction events with timestamps\n    :param timeframe: Time window for analysis ('daily', 'weekly', 'monthly')\n    :return: Dictionary containing time-based features\n        - click_frequency (float): Average clicks per timeframe\n        - peak_hours (list): List of hours with highest activity\n        - inactive_periods (list): Time periods with no activity\n    :raises ValueError: If timeframe is invalid or interactions list is empty\"\"\"\n    pass\ndef calculate_user_engagement_metrics(user_id: str, interaction_history: list) -> dict:\n    \"\"\"Calculates engagement metrics for a specific user.\n\n    :param user_id: Unique identifier for the user\n    :param interaction_history: List of user's interactions with products\n    :return: Dictionary containing engagement metrics\n        - browse_to_purchase_ratio (float): Ratio of browsing to purchases\n        - category_preferences (dict): Preferred product categories\n        - average_session_duration (float): Average session length in minutes\n    :raises ValueError: If user_id is invalid or history is empty\"\"\"\n    pass\ndef generate_user_clusters(feature_matrix: list, n_clusters: int) -> dict:\n    \"\"\"Performs user clustering based on feature matrix.\n\n    :param feature_matrix: List of user feature vectors\n    :param n_clusters: Number of clusters to create\n    :return: Dictionary containing clustering results\n        - cluster_assignments (list): Cluster labels for each user\n        - cluster_centers (list): Centroid coordinates for each cluster\n        - silhouette_score (float): Clustering quality metric\n    :raises ValueError: If n_clusters is invalid or feature_matrix is empty\"\"\"\n    pass\n", "function_schema_json": [{"name": "create_time_based_features", "description": "Creates time-based features from user interaction data.", "parameters": {"type": "object", "properties": {"user_interactions": {"type": "array", "description": "List of user interaction events with timestamps"}, "timeframe": {"type": "string", "description": "Time window for analysis ('daily', 'weekly', 'monthly')"}}, "required": ["user_interactions", "timeframe"], "additionalProperties": false}}, {"name": "calculate_user_engagement_metrics", "description": "Calculates engagement metrics for a specific user.", "parameters": {"type": "object", "properties": {"user_id": {"type": "string", "description": "Unique identifier for the user"}, "interaction_history": {"type": "array", "description": "List of user's interactions with products"}}, "required": ["user_id", "interaction_history"], "additionalProperties": false}}, {"name": "generate_user_clusters", "description": "Performs user clustering based on feature matrix.", "parameters": {"type": "object", "properties": {"feature_matrix": {"type": "array", "description": "List of user feature vectors"}, "n_clusters": {"type": "integer", "description": "Number of clusters to create"}}, "required": ["feature_matrix", "n_clusters"], "additionalProperties": false}}], "mock_functions": "def create_time_based_features(user_interactions: list, timeframe: str) -> dict:\n    \"\"\"\n    Creates time-based features from user interaction data.\n    \n    :param user_interactions: List of user interaction events with timestamps\n    :param timeframe: Time window for analysis ('daily', 'weekly', 'monthly')\n    :return: Dictionary containing time-based features\n        - click_frequency (float): Average clicks per timeframe\n        - peak_hours (list): List of hours with highest activity\n        - inactive_periods (list): Time periods with no activity\n    :raises ValueError: If timeframe is invalid or interactions list is empty\n    \"\"\"\n    valid_timeframes = ['daily', 'weekly', 'monthly']\n    if timeframe not in valid_timeframes or not user_interactions:\n        raise ValueError(\"Invalid timeframe or empty interactions list\")\n    \n    if isinstance(user_interactions[0], dict) and 'timestamp' in user_interactions[0]:\n        return {\n            \"click_frequency\": 23.5,\n            \"peak_hours\": [14, 15, 16, 20],\n            \"inactive_periods\": [\"00:00-05:00\"]\n        }\n    raise ValueError(\"Invalid interaction data format\")\ndef calculate_user_engagement_metrics(user_id: str, interaction_history: list) -> dict:\n    \"\"\"\n    Calculates engagement metrics for a specific user.\n    \n    :param user_id: Unique identifier for the user\n    :param interaction_history: List of user's interactions with products\n    :return: Dictionary containing engagement metrics\n        - browse_to_purchase_ratio (float): Ratio of browsing to purchases\n        - category_preferences (dict): Preferred product categories\n        - average_session_duration (float): Average session length in minutes\n    :raises ValueError: If user_id is invalid or history is empty\n    \"\"\"\n    if not user_id or not interaction_history:\n        raise ValueError(\"Invalid user_id or empty interaction history\")\n    \n    if user_id.startswith(\"USER_\") and len(interaction_history) > 0:\n        return {\n            \"browse_to_purchase_ratio\": 0.15,\n            \"category_preferences\": {\"electronics\": 0.6, \"books\": 0.3, \"clothing\": 0.1},\n            \"average_session_duration\": 25.5\n        }\n    return {}\ndef generate_user_clusters(feature_matrix: list, n_clusters: int) -> dict:\n    \"\"\"\n    Performs user clustering based on feature matrix.\n    \n    :param feature_matrix: List of user feature vectors\n    :param n_clusters: Number of clusters to create\n    :return: Dictionary containing clustering results\n        - cluster_assignments (list): Cluster labels for each user\n        - cluster_centers (list): Centroid coordinates for each cluster\n        - silhouette_score (float): Clustering quality metric\n    :raises ValueError: If n_clusters is invalid or feature_matrix is empty\n    \"\"\"\n    if not feature_matrix or n_clusters <= 1:\n        raise ValueError(\"Invalid number of clusters or empty feature matrix\")\n    \n    if len(feature_matrix) >= n_clusters:\n        return {\n            \"cluster_assignments\": [0, 1, 2, 1, 0],\n            \"cluster_centers\": [[0.2, 0.3], [0.7, 0.8], [0.4, 0.5]],\n            \"silhouette_score\": 0.75\n        }\n    raise ValueError(\"Too many clusters for given data\")", "user_query": "This is Dr. Lisa Chen. I need to perform user clustering for my recommendation system. Can you generate user clusters using a feature matrix of 5 user feature vectors with 3 clusters, and provide me with the cluster assignments and silhouette score?", "checklist": {"functions": ["generate_user_clusters"], "values": [{"cluster_assignments": [0, 1, 2, 1, 0], "cluster_centers": [[0.2, 0.3], [0.7, 0.8], [0.4, 0.5]], "silhouette_score": 0.75}]}}
{"difficulty": "easy", "function_schema_python": "def get_bitcoin_balance(wallet_id: str) -> float:\n    \"\"\"Retrieves the Bitcoin balance for a given wallet ID.\n\n    :param wallet_id: The ID of the wallet.\n    :return: The Bitcoin balance as a float.\n    :raises ValueError: If the wallet ID is invalid.\"\"\"\n    pass\ndef initiate_transfer(sender_wallet_id: str, recipient_address: str, amount: float, currency: str) -> bool:\n    \"\"\"Initiates a cryptocurrency transfer.\n\n    :param sender_wallet_id: The ID of the sender's wallet.\n    :param recipient_address: The recipient's wallet address.\n    :param amount: The amount to transfer.\n    :param currency: The cryptocurrency to transfer (e.g., \"Bitcoin\").\n    :return: True if the transfer was successful, False otherwise.\n    :raises ValueError: If any of the input parameters are invalid.\"\"\"\n    pass\ndef get_wallet_address(user_name: str) -> str:\n    \"\"\"Retrieves the wallet address for a given user.\n\n    :param user_name: The name of the user.\n    :return: The user's wallet address.\n    :raises ValueError: If the user is not found.\"\"\"\n    pass\n", "function_schema_json": [{"name": "get_bitcoin_balance", "description": "Retrieves the Bitcoin balance for a given wallet ID.", "parameters": {"type": "object", "properties": {"wallet_id": {"type": "string", "description": "The ID of the wallet."}}, "required": ["wallet_id"], "additionalProperties": false}}, {"name": "initiate_transfer", "description": "Initiates a cryptocurrency transfer.", "parameters": {"type": "object", "properties": {"sender_wallet_id": {"type": "string", "description": "The ID of the sender's wallet."}, "recipient_address": {"type": "string", "description": "The recipient's wallet address."}, "amount": {"type": "number", "description": "The amount to transfer."}, "currency": {"type": "string", "description": "The cryptocurrency to transfer (e.g., \"Bitcoin\")."}}, "required": ["sender_wallet_id", "recipient_address", "amount", "currency"], "additionalProperties": false}}, {"name": "get_wallet_address", "description": "Retrieves the wallet address for a given user.", "parameters": {"type": "object", "properties": {"user_name": {"type": "string", "description": "The name of the user."}}, "required": ["user_name"], "additionalProperties": false}}], "mock_functions": "def get_bitcoin_balance(wallet_id: str) -> float:\n    \"\"\"\n    Retrieves the Bitcoin balance for a given wallet ID.\n\n    :param wallet_id: The ID of the wallet.\n    :return: The Bitcoin balance as a float.\n    :raises ValueError: If the wallet ID is invalid.\n    \"\"\"\n    if not wallet_id:\n        raise ValueError(\"Wallet ID cannot be empty.\")\n    # Mock logic: Assuming John's wallet has a balance of 1.5 BTC.\n    return 1.5\ndef initiate_transfer(sender_wallet_id: str, recipient_address: str, amount: float, currency: str) -> bool:\n    \"\"\"\n    Initiates a cryptocurrency transfer.\n\n    :param sender_wallet_id: The ID of the sender's wallet.\n    :param recipient_address: The recipient's wallet address.\n    :param amount: The amount to transfer.\n    :param currency: The cryptocurrency to transfer (e.g., \"Bitcoin\").\n    :return: True if the transfer was successful, False otherwise.\n    :raises ValueError: If any of the input parameters are invalid.\n    \"\"\"\n    if not sender_wallet_id or not recipient_address or amount <= 0 or not currency:\n        raise ValueError(\"Invalid transfer parameters.\")\n    if amount == 2000 and currency == \"Bitcoin\":  # Matching the scenario\n        return True\n    return False\ndef get_wallet_address(user_name: str) -> str:\n    \"\"\"\n    Retrieves the wallet address for a given user.\n\n    :param user_name: The name of the user.\n    :return: The user's wallet address.\n    :raises ValueError: If the user is not found.\n    \"\"\"\n    if not user_name:\n        raise ValueError(\"User name cannot be empty.\")\n    # Mock logic: Return a dummy wallet address.\n    return \"friend_wallet_address_123\"", "user_query": "What\u2019s the Bitcoin balance in John\u2019s wallet with ID 'john_wallet_id'?", "checklist": {"functions": ["get_bitcoin_balance"], "values": [1.5]}}
{"difficulty": "easy", "function_schema_python": "def get_bitcoin_balance(wallet_id: str) -> float:\n    \"\"\"Retrieves the Bitcoin balance for a given wallet ID.\n\n    :param wallet_id: The ID of the wallet.\n    :return: The Bitcoin balance as a float.\n    :raises ValueError: If the wallet ID is invalid.\"\"\"\n    pass\ndef initiate_transfer(sender_wallet_id: str, recipient_address: str, amount: float, currency: str) -> bool:\n    \"\"\"Initiates a cryptocurrency transfer.\n\n    :param sender_wallet_id: The ID of the sender's wallet.\n    :param recipient_address: The recipient's wallet address.\n    :param amount: The amount to transfer.\n    :param currency: The cryptocurrency to transfer (e.g., \"Bitcoin\").\n    :return: True if the transfer was successful, False otherwise.\n    :raises ValueError: If any of the input parameters are invalid.\"\"\"\n    pass\ndef get_wallet_address(user_name: str) -> str:\n    \"\"\"Retrieves the wallet address for a given user.\n\n    :param user_name: The name of the user.\n    :return: The user's wallet address.\n    :raises ValueError: If the user is not found.\"\"\"\n    pass\n", "function_schema_json": [{"name": "get_bitcoin_balance", "description": "Retrieves the Bitcoin balance for a given wallet ID.", "parameters": {"type": "object", "properties": {"wallet_id": {"type": "string", "description": "The ID of the wallet."}}, "required": ["wallet_id"], "additionalProperties": false}}, {"name": "initiate_transfer", "description": "Initiates a cryptocurrency transfer.", "parameters": {"type": "object", "properties": {"sender_wallet_id": {"type": "string", "description": "The ID of the sender's wallet."}, "recipient_address": {"type": "string", "description": "The recipient's wallet address."}, "amount": {"type": "number", "description": "The amount to transfer."}, "currency": {"type": "string", "description": "The cryptocurrency to transfer (e.g., \"Bitcoin\")."}}, "required": ["sender_wallet_id", "recipient_address", "amount", "currency"], "additionalProperties": false}}, {"name": "get_wallet_address", "description": "Retrieves the wallet address for a given user.", "parameters": {"type": "object", "properties": {"user_name": {"type": "string", "description": "The name of the user."}}, "required": ["user_name"], "additionalProperties": false}}], "mock_functions": "def get_bitcoin_balance(wallet_id: str) -> float:\n    \"\"\"\n    Retrieves the Bitcoin balance for a given wallet ID.\n\n    :param wallet_id: The ID of the wallet.\n    :return: The Bitcoin balance as a float.\n    :raises ValueError: If the wallet ID is invalid.\n    \"\"\"\n    if not wallet_id:\n        raise ValueError(\"Wallet ID cannot be empty.\")\n    # Mock logic: Assuming John's wallet has a balance of 1.5 BTC.\n    return 1.5\ndef initiate_transfer(sender_wallet_id: str, recipient_address: str, amount: float, currency: str) -> bool:\n    \"\"\"\n    Initiates a cryptocurrency transfer.\n\n    :param sender_wallet_id: The ID of the sender's wallet.\n    :param recipient_address: The recipient's wallet address.\n    :param amount: The amount to transfer.\n    :param currency: The cryptocurrency to transfer (e.g., \"Bitcoin\").\n    :return: True if the transfer was successful, False otherwise.\n    :raises ValueError: If any of the input parameters are invalid.\n    \"\"\"\n    if not sender_wallet_id or not recipient_address or amount <= 0 or not currency:\n        raise ValueError(\"Invalid transfer parameters.\")\n    if amount == 2000 and currency == \"Bitcoin\":  # Matching the scenario\n        return True\n    return False\ndef get_wallet_address(user_name: str) -> str:\n    \"\"\"\n    Retrieves the wallet address for a given user.\n\n    :param user_name: The name of the user.\n    :return: The user's wallet address.\n    :raises ValueError: If the user is not found.\n    \"\"\"\n    if not user_name:\n        raise ValueError(\"User name cannot be empty.\")\n    # Mock logic: Return a dummy wallet address.\n    return \"friend_wallet_address_123\"", "user_query": "Can you get the wallet address for John's friend named 'Alex'?", "checklist": {"functions": ["get_wallet_address"], "values": ["friend_wallet_address_123"]}}
{"difficulty": "easy", "function_schema_python": "def verify_transaction(transaction_id: str) -> dict:\n    \"\"\"Verifies and retrieves details of a blockchain transaction.\n\n    :param transaction_id: The unique identifier of the transaction.\n    :return: Dictionary containing transaction details:\n        - amount (float): Amount in ETH\n        - sender (str): Sender's wallet address\n        - recipient (str): Recipient's wallet address\n        - timestamp (str): Transaction timestamp\n        - status (str): Transaction status\n    :raises ValueError: If transaction_id is invalid or not found\"\"\"\n    pass\ndef get_eth_usd_rate(timestamp: str) -> float:\n    \"\"\"Retrieves the ETH to USD conversion rate at a specific timestamp.\n\n    :param timestamp: ISO format timestamp string\n    :return: The conversion rate (USD per ETH)\n    :raises ValueError: If timestamp is invalid or rate not available\"\"\"\n    pass\ndef check_wallet_conversion_settings(wallet_address: str) -> dict:\n    \"\"\"Retrieves the auto-conversion settings for a wallet.\n\n    :param wallet_address: The blockchain wallet address\n    :return: Dictionary containing wallet settings:\n        - auto_convert (bool): Whether auto-conversion is enabled\n        - target_currency (str): Target currency for conversion\n        - conversion_fee (float): Fee percentage for conversion\n    :raises ValueError: If wallet address is invalid\"\"\"\n    pass\n", "function_schema_json": [{"name": "verify_transaction", "description": "Verifies and retrieves details of a blockchain transaction.", "parameters": {"type": "object", "properties": {"transaction_id": {"type": "string", "description": "The unique identifier of the transaction."}}, "required": ["transaction_id"], "additionalProperties": false}}, {"name": "get_eth_usd_rate", "description": "Retrieves the ETH to USD conversion rate at a specific timestamp.", "parameters": {"type": "object", "properties": {"timestamp": {"type": "string", "description": "ISO format timestamp string"}}, "required": ["timestamp"], "additionalProperties": false}}, {"name": "check_wallet_conversion_settings", "description": "Retrieves the auto-conversion settings for a wallet.", "parameters": {"type": "object", "properties": {"wallet_address": {"type": "string", "description": "The blockchain wallet address"}}, "required": ["wallet_address"], "additionalProperties": false}}], "mock_functions": "def verify_transaction(transaction_id: str) -> dict:\n    \"\"\"\n    Verifies and retrieves details of a blockchain transaction.\n    \n    :param transaction_id: The unique identifier of the transaction.\n    :return: Dictionary containing transaction details:\n        - amount (float): Amount in ETH\n        - sender (str): Sender's wallet address\n        - recipient (str): Recipient's wallet address\n        - timestamp (str): Transaction timestamp\n        - status (str): Transaction status\n    :raises ValueError: If transaction_id is invalid or not found\n    \"\"\"\n    if not transaction_id or not isinstance(transaction_id, str):\n        raise ValueError(\"Invalid transaction ID\")\n    \n    if transaction_id == \"0x1234567890abcdef\":\n        return {\n            \"amount\": 1.5,\n            \"sender\": \"0xXYZCorp789\",\n            \"recipient\": \"0xEmily456\",\n            \"timestamp\": \"2023-07-20T14:30:00Z\",\n            \"status\": \"confirmed\"\n        }\n    raise ValueError(\"Transaction not found\")\ndef get_eth_usd_rate(timestamp: str) -> float:\n    \"\"\"\n    Retrieves the ETH to USD conversion rate at a specific timestamp.\n    \n    :param timestamp: ISO format timestamp string\n    :return: The conversion rate (USD per ETH)\n    :raises ValueError: If timestamp is invalid or rate not available\n    \"\"\"\n    if not timestamp or not isinstance(timestamp, str):\n        raise ValueError(\"Invalid timestamp\")\n    \n    if timestamp == \"2023-07-20T14:30:00Z\":\n        return 1850.75\n    raise ValueError(\"Rate not available for specified timestamp\")\ndef check_wallet_conversion_settings(wallet_address: str) -> dict:\n    \"\"\"\n    Retrieves the auto-conversion settings for a wallet.\n    \n    :param wallet_address: The blockchain wallet address\n    :return: Dictionary containing wallet settings:\n        - auto_convert (bool): Whether auto-conversion is enabled\n        - target_currency (str): Target currency for conversion\n        - conversion_fee (float): Fee percentage for conversion\n    :raises ValueError: If wallet address is invalid\n    \"\"\"\n    if not wallet_address or not isinstance(wallet_address, str):\n        raise ValueError(\"Invalid wallet address\")\n    \n    if wallet_address == \"0xEmily456\":\n        return {\n            \"auto_convert\": True,\n            \"target_currency\": \"USD\",\n            \"conversion_fee\": 0.5\n        }\n    raise ValueError(\"Wallet not found\")", "user_query": "What's the USD equivalent of 1.5 ETH using the conversion rate at 2023-07-20T14:30:00Z?", "checklist": {"functions": ["get_eth_usd_rate"], "values": [1850.75]}}
{"difficulty": "easy", "function_schema_python": "def create_smart_contract(payment_terms: dict, supplier_info: dict, manufacturer_info: dict) -> str:\n    \"\"\"Creates a smart contract for supply chain payments.\n\n    :param payment_terms: Dictionary containing payment terms\n        - amount (float): Payment amount\n        - currency (str): Currency type (e.g., 'ETH')\n        - deadline (int): Payment deadline in blocks\n    :param supplier_info: Dictionary containing supplier details\n        - address (str): Ethereum address\n        - name (str): Company name\n    :param manufacturer_info: Dictionary containing manufacturer details\n        - address (str): Ethereum address\n        - name (str): Company name\n    :return: Contract address hash\n    :raises ValueError: If any required parameter is missing or invalid\"\"\"\n    pass\ndef deploy_contract(contract_address: str, gas_limit: int) -> dict:\n    \"\"\"Deploys a smart contract to the Ethereum blockchain.\n\n    :param contract_address: The contract address hash\n    :param gas_limit: Maximum gas limit for deployment\n    :return: Dictionary containing deployment details\n        - transaction_hash (str): Transaction hash\n        - block_number (int): Block number\n        - gas_used (int): Amount of gas used\n        - status (str): Deployment status\n    :raises ValueError: If contract address is invalid or gas limit is too low\"\"\"\n    pass\ndef verify_contract(contract_address: str) -> bool:\n    \"\"\"Verifies a deployed smart contract on the blockchain.\n\n    :param contract_address: The contract address hash\n    :return: True if contract is verified, False otherwise\n    :raises ValueError: If contract address is invalid\"\"\"\n    pass\n", "function_schema_json": [{"name": "create_smart_contract", "description": "Creates a smart contract for supply chain payments.", "parameters": {"type": "object", "properties": {"payment_terms": {"type": "object", "description": "Dictionary containing payment terms"}, "supplier_info": {"type": "object", "description": "Dictionary containing supplier details"}, "manufacturer_info": {"type": "object", "description": "Dictionary containing manufacturer details"}}, "required": ["payment_terms", "supplier_info", "manufacturer_info"], "additionalProperties": false}}, {"name": "deploy_contract", "description": "Deploys a smart contract to the Ethereum blockchain.", "parameters": {"type": "object", "properties": {"contract_address": {"type": "string", "description": "The contract address hash"}, "gas_limit": {"type": "integer", "description": "Maximum gas limit for deployment"}}, "required": ["contract_address", "gas_limit"], "additionalProperties": false}}, {"name": "verify_contract", "description": "Verifies a deployed smart contract on the blockchain.", "parameters": {"type": "object", "properties": {"contract_address": {"type": "string", "description": "The contract address hash"}}, "required": ["contract_address"], "additionalProperties": false}}], "mock_functions": "def create_smart_contract(payment_terms: dict, supplier_info: dict, manufacturer_info: dict) -> str:\n    \"\"\"\n    Creates a smart contract for supply chain payments.\n    \n    :param payment_terms: Dictionary containing payment terms\n        - amount (float): Payment amount\n        - currency (str): Currency type (e.g., 'ETH')\n        - deadline (int): Payment deadline in blocks\n    :param supplier_info: Dictionary containing supplier details\n        - address (str): Ethereum address\n        - name (str): Company name\n    :param manufacturer_info: Dictionary containing manufacturer details\n        - address (str): Ethereum address\n        - name (str): Company name\n    :return: Contract address hash\n    :raises ValueError: If any required parameter is missing or invalid\n    \"\"\"\n    if not all([payment_terms, supplier_info, manufacturer_info]):\n        raise ValueError(\"All parameters must be provided\")\n    \n    if (payment_terms.get('amount') and \n        payment_terms.get('currency') == 'ETH' and \n        supplier_info.get('address').startswith('0x') and \n        manufacturer_info.get('address').startswith('0x')):\n        return \"0x742d35Cc6634C0532925a3b844Bc454e4438f44e\"\n    raise ValueError(\"Invalid contract parameters\")\ndef deploy_contract(contract_address: str, gas_limit: int) -> dict:\n    \"\"\"\n    Deploys a smart contract to the Ethereum blockchain.\n    \n    :param contract_address: The contract address hash\n    :param gas_limit: Maximum gas limit for deployment\n    :return: Dictionary containing deployment details\n        - transaction_hash (str): Transaction hash\n        - block_number (int): Block number\n        - gas_used (int): Amount of gas used\n        - status (str): Deployment status\n    :raises ValueError: If contract address is invalid or gas limit is too low\n    \"\"\"\n    if not contract_address.startswith('0x') or gas_limit < 100000:\n        raise ValueError(\"Invalid contract address or insufficient gas\")\n    \n    if contract_address == \"0x742d35Cc6634C0532925a3b844Bc454e4438f44e\":\n        return {\n            \"transaction_hash\": \"0x9fc76417374aa880d4449a1f7f31ec597f00b1f6f3dd2d66f4c9c6c445836d8b\",\n            \"block_number\": 15372945,\n            \"gas_used\": 120000,\n            \"status\": \"success\"\n        }\n    return {}\ndef verify_contract(contract_address: str) -> bool:\n    \"\"\"\n    Verifies a deployed smart contract on the blockchain.\n    \n    :param contract_address: The contract address hash\n    :return: True if contract is verified, False otherwise\n    :raises ValueError: If contract address is invalid\n    \"\"\"\n    if not contract_address.startswith('0x'):\n        raise ValueError(\"Invalid contract address format\")\n    \n    return contract_address == \"0x742d35Cc6634C0532925a3b844Bc454e4438f44e\"", "user_query": "This is Emma. Can you deploy the smart contract at address 0x742d35Cc6634C0532925a3b844Bc454e4438f44e with a gas limit of 150000 and provide the deployment details?", "checklist": {"functions": ["deploy_contract"], "values": [{"transaction_hash": "0x9fc76417374aa880d4449a1f7f31ec597f00b1f6f3dd2d66f4c9c6c445836d8b", "block_number": 15372945, "gas_used": 120000, "status": "success"}]}}
{"difficulty": "easy", "function_schema_python": "def create_smart_contract(payment_terms: dict, supplier_info: dict, manufacturer_info: dict) -> str:\n    \"\"\"Creates a smart contract for supply chain payments.\n\n    :param payment_terms: Dictionary containing payment terms\n        - amount (float): Payment amount\n        - currency (str): Currency type (e.g., 'ETH')\n        - deadline (int): Payment deadline in blocks\n    :param supplier_info: Dictionary containing supplier details\n        - address (str): Ethereum address\n        - name (str): Company name\n    :param manufacturer_info: Dictionary containing manufacturer details\n        - address (str): Ethereum address\n        - name (str): Company name\n    :return: Contract address hash\n    :raises ValueError: If any required parameter is missing or invalid\"\"\"\n    pass\ndef deploy_contract(contract_address: str, gas_limit: int) -> dict:\n    \"\"\"Deploys a smart contract to the Ethereum blockchain.\n\n    :param contract_address: The contract address hash\n    :param gas_limit: Maximum gas limit for deployment\n    :return: Dictionary containing deployment details\n        - transaction_hash (str): Transaction hash\n        - block_number (int): Block number\n        - gas_used (int): Amount of gas used\n        - status (str): Deployment status\n    :raises ValueError: If contract address is invalid or gas limit is too low\"\"\"\n    pass\ndef verify_contract(contract_address: str) -> bool:\n    \"\"\"Verifies a deployed smart contract on the blockchain.\n\n    :param contract_address: The contract address hash\n    :return: True if contract is verified, False otherwise\n    :raises ValueError: If contract address is invalid\"\"\"\n    pass\n", "function_schema_json": [{"name": "create_smart_contract", "description": "Creates a smart contract for supply chain payments.", "parameters": {"type": "object", "properties": {"payment_terms": {"type": "object", "description": "Dictionary containing payment terms"}, "supplier_info": {"type": "object", "description": "Dictionary containing supplier details"}, "manufacturer_info": {"type": "object", "description": "Dictionary containing manufacturer details"}}, "required": ["payment_terms", "supplier_info", "manufacturer_info"], "additionalProperties": false}}, {"name": "deploy_contract", "description": "Deploys a smart contract to the Ethereum blockchain.", "parameters": {"type": "object", "properties": {"contract_address": {"type": "string", "description": "The contract address hash"}, "gas_limit": {"type": "integer", "description": "Maximum gas limit for deployment"}}, "required": ["contract_address", "gas_limit"], "additionalProperties": false}}, {"name": "verify_contract", "description": "Verifies a deployed smart contract on the blockchain.", "parameters": {"type": "object", "properties": {"contract_address": {"type": "string", "description": "The contract address hash"}}, "required": ["contract_address"], "additionalProperties": false}}], "mock_functions": "def create_smart_contract(payment_terms: dict, supplier_info: dict, manufacturer_info: dict) -> str:\n    \"\"\"\n    Creates a smart contract for supply chain payments.\n    \n    :param payment_terms: Dictionary containing payment terms\n        - amount (float): Payment amount\n        - currency (str): Currency type (e.g., 'ETH')\n        - deadline (int): Payment deadline in blocks\n    :param supplier_info: Dictionary containing supplier details\n        - address (str): Ethereum address\n        - name (str): Company name\n    :param manufacturer_info: Dictionary containing manufacturer details\n        - address (str): Ethereum address\n        - name (str): Company name\n    :return: Contract address hash\n    :raises ValueError: If any required parameter is missing or invalid\n    \"\"\"\n    if not all([payment_terms, supplier_info, manufacturer_info]):\n        raise ValueError(\"All parameters must be provided\")\n    \n    if (payment_terms.get('amount') and \n        payment_terms.get('currency') == 'ETH' and \n        supplier_info.get('address').startswith('0x') and \n        manufacturer_info.get('address').startswith('0x')):\n        return \"0x742d35Cc6634C0532925a3b844Bc454e4438f44e\"\n    raise ValueError(\"Invalid contract parameters\")\ndef deploy_contract(contract_address: str, gas_limit: int) -> dict:\n    \"\"\"\n    Deploys a smart contract to the Ethereum blockchain.\n    \n    :param contract_address: The contract address hash\n    :param gas_limit: Maximum gas limit for deployment\n    :return: Dictionary containing deployment details\n        - transaction_hash (str): Transaction hash\n        - block_number (int): Block number\n        - gas_used (int): Amount of gas used\n        - status (str): Deployment status\n    :raises ValueError: If contract address is invalid or gas limit is too low\n    \"\"\"\n    if not contract_address.startswith('0x') or gas_limit < 100000:\n        raise ValueError(\"Invalid contract address or insufficient gas\")\n    \n    if contract_address == \"0x742d35Cc6634C0532925a3b844Bc454e4438f44e\":\n        return {\n            \"transaction_hash\": \"0x9fc76417374aa880d4449a1f7f31ec597f00b1f6f3dd2d66f4c9c6c445836d8b\",\n            \"block_number\": 15372945,\n            \"gas_used\": 120000,\n            \"status\": \"success\"\n        }\n    return {}\ndef verify_contract(contract_address: str) -> bool:\n    \"\"\"\n    Verifies a deployed smart contract on the blockchain.\n    \n    :param contract_address: The contract address hash\n    :return: True if contract is verified, False otherwise\n    :raises ValueError: If contract address is invalid\n    \"\"\"\n    if not contract_address.startswith('0x'):\n        raise ValueError(\"Invalid contract address format\")\n    \n    return contract_address == \"0x742d35Cc6634C0532925a3b844Bc454e4438f44e\"", "user_query": "Hi, this is Emma. Could you please verify if the contract deployed at 0x742d35Cc6634C0532925a3b844Bc454e4438f44e is verified and share the results?", "checklist": {"functions": ["verify_contract"], "values": [true]}}
{"difficulty": "easy", "function_schema_python": "def get_contract_data(contract_address: str) -> dict:\n    \"\"\"Retrieves real-time data from a DeFi protocol's smart contract.\n\n    :param contract_address: The Ethereum address of the smart contract.\n    :return:\n        dict: A dictionary with the following keys:\n            - loans_issued (int): The total number of loans issued.\n            - total_loan_amount (float): The total amount of loans in USD.\n            - interest_rates (list[float]): A list of interest rates applied to different loans.\n    :raises ValueError: If the contract address is invalid.\"\"\"\n    pass\ndef simulate_interest_rate_changes(base_rate: float, changes: list[float]) -> dict:\n    \"\"\"Simulates the impact of different interest rate scenarios on the platform's liquidity.\n\n    :param base_rate: The current base interest rate.\n    :param changes: A list of interest rate changes to simulate.\n    :return:\n        dict: A dictionary with the following keys:\n            - base_rate (float): The base interest rate used in simulations.\n            - simulated_changes (list[dict]): Each dictionary contains:\n                - rate_change (float): The interest rate change.\n                - predicted_liquidity (float): The predicted liquidity impact.\n    :raises ValueError: If the base rate or changes are invalid.\"\"\"\n    pass\ndef generate_performance_report(contract_data: dict, simulation_results: dict) -> str:\n    \"\"\"Generates a comprehensive performance report based on contract data and simulation results.\n\n    :param contract_data: Data retrieved from the DeFi protocol's smart contract.\n    :param simulation_results: Results from different interest rate simulations.\n    :return: A string containing the performance report.\n    :raises ValueError: If required data is missing or invalid.\"\"\"\n    pass\ndef recommend_interest_rate(base_rate: float, simulation_results: dict) -> float:\n    \"\"\"Recommends an interest rate that optimizes the protocol's liquidity based on simulation results.\n\n    :param base_rate: The current base interest rate.\n    :param simulation_results: Results from different interest rate simulations.\n    :return: The recommended interest rate.\n    :raises ValueError: If required data is missing or invalid.\"\"\"\n    pass\n", "function_schema_json": [{"name": "get_contract_data", "description": "Retrieves real-time data from a DeFi protocol's smart contract.", "parameters": {"type": "object", "properties": {"contract_address": {"type": "string", "description": "The Ethereum address of the smart contract."}}, "required": ["contract_address"], "additionalProperties": false}}, {"name": "simulate_interest_rate_changes", "description": "Simulates the impact of different interest rate scenarios on the platform's liquidity.", "parameters": {"type": "object", "properties": {"base_rate": {"type": "number", "description": "The current base interest rate."}, "changes": {"type": "array", "items": {"type": "number"}, "description": "A list of interest rate changes to simulate."}}, "required": ["base_rate", "changes"], "additionalProperties": false}}, {"name": "generate_performance_report", "description": "Generates a comprehensive performance report based on contract data and simulation results.", "parameters": {"type": "object", "properties": {"contract_data": {"type": "object", "description": "Data retrieved from the DeFi protocol's smart contract."}, "simulation_results": {"type": "object", "description": "Results from different interest rate simulations."}}, "required": ["contract_data", "simulation_results"], "additionalProperties": false}}, {"name": "recommend_interest_rate", "description": "Recommends an interest rate that optimizes the protocol's liquidity based on simulation results.", "parameters": {"type": "object", "properties": {"base_rate": {"type": "number", "description": "The current base interest rate."}, "simulation_results": {"type": "object", "description": "Results from different interest rate simulations."}}, "required": ["base_rate", "simulation_results"], "additionalProperties": false}}], "mock_functions": "def get_contract_data(contract_address: str) -> dict:\n    \"\"\"\n    Retrieves real-time data from a DeFi protocol's smart contract.\n    \n    :param contract_address: The Ethereum address of the smart contract.\n    :return:\n        dict: A dictionary with the following keys:\n            - loans_issued (int): The total number of loans issued.\n            - total_loan_amount (float): The total amount of loans in USD.\n            - interest_rates (list[float]): A list of interest rates applied to different loans.\n    :raises ValueError: If the contract address is invalid.\n    \"\"\"\n    if not contract_address or not isinstance(contract_address, str):\n        raise ValueError(\"A valid contract address must be provided.\")\n    \n    # Mock logic: Returning static data for demonstration purposes.\n    return {\n        \"loans_issued\": 150,\n        \"total_loan_amount\": 500000.0,\n        \"interest_rates\": [0.04, 0.05, 0.035]\n    }\ndef simulate_interest_rate_changes(base_rate: float, changes: list[float]) -> dict:\n    \"\"\"\n    Simulates the impact of different interest rate scenarios on the platform's liquidity.\n    \n    :param base_rate: The current base interest rate.\n    :param changes: A list of interest rate changes to simulate.\n    :return:\n        dict: A dictionary with the following keys:\n            - base_rate (float): The base interest rate used in simulations.\n            - simulated_changes (list[dict]): Each dictionary contains:\n                - rate_change (float): The interest rate change.\n                - predicted_liquidity (float): The predicted liquidity impact.\n    :raises ValueError: If the base rate or changes are invalid.\n    \"\"\"\n    if not isinstance(base_rate, float) or not isinstance(changes, list):\n        raise ValueError(\"Base rate must be a float and changes must be a list of floats.\")\n    \n    # Mock logic: Calculating predicted liquidity using a simple formula.\n    simulated_changes = [\n        {\"rate_change\": change, \"predicted_liquidity\": 1000000.0 - (change * 10000000.0)} for change in changes\n    ]\n    \n    return {\n        \"base_rate\": base_rate,\n        \"simulated_changes\": simulated_changes\n    }\ndef generate_performance_report(contract_data: dict, simulation_results: dict) -> str:\n    \"\"\"\n    Generates a comprehensive performance report based on contract data and simulation results.\n    \n    :param contract_data: Data retrieved from the DeFi protocol's smart contract.\n    :param simulation_results: Results from different interest rate simulations.\n    :return: A string containing the performance report.\n    :raises ValueError: If required data is missing or invalid.\n    \"\"\"\n    if not isinstance(contract_data, dict) or not isinstance(simulation_results, dict):\n        raise ValueError(\"Contract data and simulation results must be dictionaries.\")\n    \n    # Mock logic: Generating a simple report string.\n    report = f\"Performance Report:\\n\"\n    report += f\"Loans Issued: {contract_data.get('loans_issued', 0)}\\n\"\n    report += f\"Total Loan Amount: ${contract_data.get('total_loan_amount', 0.0):,.2f}\\n\"\n    report += f\"Base Interest Rate: {simulation_results.get('base_rate', 0.0)}%\\n\"\n    report += \"Predicted Liquidity Impacts:\\n\"\n    for change in simulation_results.get('simulated_changes', []):\n        report += f\" - Rate Change: {change['rate_change']}%, Predicted Liquidity: ${change['predicted_liquidity']:,}\\n\"\n    \n    return report\ndef recommend_interest_rate(base_rate: float, simulation_results: dict) -> float:\n    \"\"\"\n    Recommends an interest rate that optimizes the protocol's liquidity based on simulation results.\n    \n    :param base_rate: The current base interest rate.\n    :param simulation_results: Results from different interest rate simulations.\n    :return: The recommended interest rate.\n    :raises ValueError: If required data is missing or invalid.\n    \"\"\"\n    if not isinstance(base_rate, float) or not isinstance(simulation_results, dict):\n        raise ValueError(\"Base rate must be a float and simulation results must be a dictionary.\")\n    \n    # Mock logic: Recommending the rate with the highest predicted liquidity.\n    recommended_rate = base_rate\n    max_liquidity = 0\n    for change in simulation_results.get('simulated_changes', []):\n        if change['predicted_liquidity'] > max_liquidity:\n            recommended_rate = base_rate + change['rate_change']\n            max_liquidity = change['predicted_liquidity']\n    \n    return recommended_rate", "user_query": "Can you retrieve the contract data for the DeFi lending protocol at address 0x1234567890abcdef?", "checklist": {"functions": ["get_contract_data"], "values": [{"loans_issued": 150, "total_loan_amount": 500000.0, "interest_rates": [0.04, 0.05, 0.035]}]}}
{"difficulty": "easy", "function_schema_python": "def validate_smart_contract_code(contract_code: str) -> dict:\n    \"\"\"Validates the smart contract code for vulnerabilities.\n\n    :param contract_code: A string containing the smart contract code.\n    :return:\n        dict: A dictionary with the following keys:\n            - is_valid (bool): True if the contract is valid, False otherwise.\n            - issues (list[str]): List of identified issues or vulnerabilities.\n    :raises ValueError: If the contract code is empty.\"\"\"\n    pass\ndef deploy_smart_contract(contract_code: str, network: str) -> bool:\n    \"\"\"Deploys the smart contract to the specified network.\n\n    :param contract_code: A string containing the smart contract code.\n    :param network: The name of the network to deploy to (e.g., \"mainnet\", \"testnet\").\n    :return: True if the deployment was successful, False otherwise.\n    :raises ValueError: If contract code or network is invalid or not provided.\"\"\"\n    pass\ndef get_network_balance(network: str) -> int:\n    \"\"\"Retrieves the balance of the current account on the specified network.\n\n    :param network: The name of the network (e.g., \"mainnet\", \"testnet\").\n    :return: An integer representing the balance in ETH.\n    :raises ValueError: If the network is not provided.\"\"\"\n    pass\ndef get_user_base_count() -> int:\n    \"\"\"Retrieves the number of beta testers for the decentralized finance platform.\n\n    :return: An integer representing the number of beta testers.\"\"\"\n    pass\n", "function_schema_json": [{"name": "validate_smart_contract_code", "description": "Validates the smart contract code for vulnerabilities.", "parameters": {"type": "object", "properties": {"contract_code": {"type": "string", "description": "A string containing the smart contract code."}}, "required": ["contract_code"], "additionalProperties": false}}, {"name": "deploy_smart_contract", "description": "Deploys the smart contract to the specified network.", "parameters": {"type": "object", "properties": {"contract_code": {"type": "string", "description": "A string containing the smart contract code."}, "network": {"type": "string", "description": "The name of the network to deploy to (e.g., \"mainnet\", \"testnet\")."}}, "required": ["contract_code", "network"], "additionalProperties": false}}, {"name": "get_network_balance", "description": "Retrieves the balance of the current account on the specified network.", "parameters": {"type": "object", "properties": {"network": {"type": "string", "description": "The name of the network (e.g., \"mainnet\", \"testnet\")."}}, "required": ["network"], "additionalProperties": false}}, {"name": "get_user_base_count", "description": "Retrieves the number of beta testers for the decentralized finance platform.", "parameters": {"type": "object", "properties": {}, "required": [], "additionalProperties": false}}], "mock_functions": "def validate_smart_contract_code(contract_code: str) -> dict:\n    \"\"\"\n    Validates the smart contract code for vulnerabilities.\n    \n    :param contract_code: A string containing the smart contract code.\n    :return:\n        dict: A dictionary with the following keys:\n            - is_valid (bool): True if the contract is valid, False otherwise.\n            - issues (list[str]): List of identified issues or vulnerabilities.\n    :raises ValueError: If the contract code is empty.\n    \"\"\"\n    if not contract_code:\n        raise ValueError(\"Contract code must not be empty.\")\n    \n    # Mock logic to simulate validation:\n    # Assume the contract code contains a known vulnerability if it contains the string \"buggy\"\n    if \"buggy\" in contract_code:\n        return {\n            \"is_valid\": False,\n            \"issues\": [\"Potential reentrancy attack due to buggy function\"]\n        }\n    else:\n        return {\n            \"is_valid\": True,\n            \"issues\": []\n        }\ndef deploy_smart_contract(contract_code: str, network: str) -> bool:\n    \"\"\"\n    Deploys the smart contract to the specified network.\n    \n    :param contract_code: A string containing the smart contract code.\n    :param network: The name of the network to deploy to (e.g., \"mainnet\", \"testnet\").\n    :return: True if the deployment was successful, False otherwise.\n    :raises ValueError: If contract code or network is invalid or not provided.\n    \"\"\"\n    if not contract_code or not network:\n        raise ValueError(\"Contract code and network must be provided.\")\n    \n    # Mock logic to simulate deployment:\n    # Assume deployment is successful if the network is \"testnet\"\n    if network.lower() == \"testnet\":\n        return True\n    else:\n        return False\ndef get_network_balance(network: str) -> int:\n    \"\"\"\n    Retrieves the balance of the current account on the specified network.\n    \n    :param network: The name of the network (e.g., \"mainnet\", \"testnet\").\n    :return: An integer representing the balance in ETH.\n    :raises ValueError: If the network is not provided.\n    \"\"\"\n    if not network:\n        raise ValueError(\"Network must be provided.\")\n    \n    # Mock logic to simulate balance retrieval:\n    # Assume balance is 200 ETH if network is \"testnet\"\n    if network.lower() == \"testnet\":\n        return 200\n    else:\n        return 0\ndef get_user_base_count() -> int:\n    \"\"\"\n    Retrieves the number of beta testers for the decentralized finance platform.\n    \n    :return: An integer representing the number of beta testers.\n    \"\"\"\n    # Mock logic to simulate user base retrieval:\n    # Assume there are 500 beta testers\n    return 500\n", "user_query": "Could you validate this smart contract code: \"contract LendingPlatform { function lend() public payable { // lending logic } }\"?", "checklist": {"functions": ["validate_smart_contract_code"], "values": [{"is_valid": true, "issues": []}]}}
{"difficulty": "easy", "function_schema_python": "def get_contract_code(contract_address: str) -> str:\n    \"\"\"Retrieves the current code of a smart contract deployed on the Ethereum blockchain.\n\n    :param contract_address: The address of the smart contract.\n    :return: A string representing the current code of the smart contract.\n    :raises ValueError: If the contract address is invalid.\"\"\"\n    pass\ndef update_contract_code(contract_address: str, new_code: str) -> bool:\n    \"\"\"Updates the code of a smart contract deployed on the Ethereum blockchain.\n\n    :param contract_address: The address of the smart contract.\n    :param new_code: The new code for the smart contract.\n    :return: True if the update is successful, False otherwise.\n    :raises ValueError: If the contract address is invalid or new code is empty.\"\"\"\n    pass\ndef verify_contract_compatibility(contract_address: str, test_transactions: list) -> dict:\n    \"\"\"Verifies the compatibility of the updated smart contract with existing transactions.\n\n    :param contract_address: The address of the smart contract.\n    :param test_transactions: A list of existing transactions to test against the updated contract.\n    :return:\n        dict: A dictionary with the following keys:\n            - compatible (bool): True if the contract is compatible, False otherwise.\n            - issues (list[str]): A list of issues found during verification.\n    :raises ValueError: If the contract address is invalid or test transactions are empty.\"\"\"\n    pass\ndef deploy_contract(contract_code: str) -> str:\n    \"\"\"Deploys a new version of a smart contract to the Ethereum blockchain.\n\n    :param contract_code: The code of the new smart contract.\n    :return: The address of the newly deployed smart contract.\n    :raises ValueError: If the contract code is invalid.\"\"\"\n    pass\ndef get_existing_transactions(contract_address: str) -> list:\n    \"\"\"Retrieves a list of existing transactions processed by the smart contract.\n\n    :param contract_address: The address of the smart contract.\n    :return: A list of transaction hashes.\n    :raises ValueError: If the contract address is invalid.\"\"\"\n    pass\n", "function_schema_json": [{"name": "get_contract_code", "description": "Retrieves the current code of a smart contract deployed on the Ethereum blockchain.", "parameters": {"type": "object", "properties": {"contract_address": {"type": "string", "description": "The address of the smart contract."}}, "required": ["contract_address"], "additionalProperties": false}}, {"name": "update_contract_code", "description": "Updates the code of a smart contract deployed on the Ethereum blockchain.", "parameters": {"type": "object", "properties": {"contract_address": {"type": "string", "description": "The address of the smart contract."}, "new_code": {"type": "string", "description": "The new code for the smart contract."}}, "required": ["contract_address", "new_code"], "additionalProperties": false}}, {"name": "verify_contract_compatibility", "description": "Verifies the compatibility of the updated smart contract with existing transactions.", "parameters": {"type": "object", "properties": {"contract_address": {"type": "string", "description": "The address of the smart contract."}, "test_transactions": {"type": "array", "description": "A list of existing transactions to test against the updated contract."}}, "required": ["contract_address", "test_transactions"], "additionalProperties": false}}, {"name": "deploy_contract", "description": "Deploys a new version of a smart contract to the Ethereum blockchain.", "parameters": {"type": "object", "properties": {"contract_code": {"type": "string", "description": "The code of the new smart contract."}}, "required": ["contract_code"], "additionalProperties": false}}, {"name": "get_existing_transactions", "description": "Retrieves a list of existing transactions processed by the smart contract.", "parameters": {"type": "object", "properties": {"contract_address": {"type": "string", "description": "The address of the smart contract."}}, "required": ["contract_address"], "additionalProperties": false}}], "mock_functions": "def get_contract_code(contract_address: str) -> str:\n    \"\"\"\n    Retrieves the current code of a smart contract deployed on the Ethereum blockchain.\n    \n    :param contract_address: The address of the smart contract.\n    :return: A string representing the current code of the smart contract.\n    :raises ValueError: If the contract address is invalid.\n    \"\"\"\n    if contract_address == \"0x123abc456def789ghi101112jkl13141516\":\n        return \"Current smart contract code\"\n    else:\n        raise ValueError(\"Invalid contract address.\")\ndef update_contract_code(contract_address: str, new_code: str) -> bool:\n    \"\"\"\n    Updates the code of a smart contract deployed on the Ethereum blockchain.\n    \n    :param contract_address: The address of the smart contract.\n    :param new_code: The new code for the smart contract.\n    :return: True if the update is successful, False otherwise.\n    :raises ValueError: If the contract address is invalid or new code is empty.\n    \"\"\"\n    if not contract_address or not new_code:\n        raise ValueError(\"Contract address and new code must be provided.\")\n    if contract_address == \"0x123abc456def789ghi101112jkl13141516\":\n        return True\n    return False\ndef verify_contract_compatibility(contract_address: str, test_transactions: list) -> dict:\n    \"\"\"\n    Verifies the compatibility of the updated smart contract with existing transactions.\n    \n    :param contract_address: The address of the smart contract.\n    :param test_transactions: A list of existing transactions to test against the updated contract.\n    :return:\n        dict: A dictionary with the following keys:\n            - compatible (bool): True if the contract is compatible, False otherwise.\n            - issues (list[str]): A list of issues found during verification.\n    :raises ValueError: If the contract address is invalid or test transactions are empty.\n    \"\"\"\n    if not contract_address or not test_transactions:\n        raise ValueError(\"Contract address and test transactions must be provided.\")\n    if contract_address == \"0x123abc456def789ghi101112jkl13141516\":\n        return {\n            \"compatible\": True,\n            \"issues\": []\n        }\n    return {\n        \"compatible\": False,\n        \"issues\": [\"Invalid contract address\"]\n    }\ndef deploy_contract(contract_code: str) -> str:\n    \"\"\"\n    Deploys a new version of a smart contract to the Ethereum blockchain.\n    \n    :param contract_code: The code of the new smart contract.\n    :return: The address of the newly deployed smart contract.\n    :raises ValueError: If the contract code is invalid.\n    \"\"\"\n    if not contract_code:\n        raise ValueError(\"Contract code must be provided.\")\n    return \"0x987zyx654wvu321tqs01jnml20000000\"\ndef get_existing_transactions(contract_address: str) -> list:\n    \"\"\"\n    Retrieves a list of existing transactions processed by the smart contract.\n    \n    :param contract_address: The address of the smart contract.\n    :return: A list of transaction hashes.\n    :raises ValueError: If the contract address is invalid.\n    \"\"\"\n    if contract_address == \"0x123abc456def789ghi101112jkl13141516\":\n        return [\"tx12345\", \"tx67890\"]\n    else:\n        raise ValueError(\"Invalid contract address.\")", "user_query": "Can you get the current code for the smart contract at address 0x123abc456def789ghi101112jkl13141516?", "checklist": {"functions": ["get_contract_code"], "values": ["Current smart contract code"]}}
{"difficulty": "easy", "function_schema_python": "def get_contract_code(contract_address: str) -> str:\n    \"\"\"Retrieves the current code of a smart contract deployed on the Ethereum blockchain.\n\n    :param contract_address: The address of the smart contract.\n    :return: A string representing the current code of the smart contract.\n    :raises ValueError: If the contract address is invalid.\"\"\"\n    pass\ndef update_contract_code(contract_address: str, new_code: str) -> bool:\n    \"\"\"Updates the code of a smart contract deployed on the Ethereum blockchain.\n\n    :param contract_address: The address of the smart contract.\n    :param new_code: The new code for the smart contract.\n    :return: True if the update is successful, False otherwise.\n    :raises ValueError: If the contract address is invalid or new code is empty.\"\"\"\n    pass\ndef verify_contract_compatibility(contract_address: str, test_transactions: list) -> dict:\n    \"\"\"Verifies the compatibility of the updated smart contract with existing transactions.\n\n    :param contract_address: The address of the smart contract.\n    :param test_transactions: A list of existing transactions to test against the updated contract.\n    :return:\n        dict: A dictionary with the following keys:\n            - compatible (bool): True if the contract is compatible, False otherwise.\n            - issues (list[str]): A list of issues found during verification.\n    :raises ValueError: If the contract address is invalid or test transactions are empty.\"\"\"\n    pass\ndef deploy_contract(contract_code: str) -> str:\n    \"\"\"Deploys a new version of a smart contract to the Ethereum blockchain.\n\n    :param contract_code: The code of the new smart contract.\n    :return: The address of the newly deployed smart contract.\n    :raises ValueError: If the contract code is invalid.\"\"\"\n    pass\ndef get_existing_transactions(contract_address: str) -> list:\n    \"\"\"Retrieves a list of existing transactions processed by the smart contract.\n\n    :param contract_address: The address of the smart contract.\n    :return: A list of transaction hashes.\n    :raises ValueError: If the contract address is invalid.\"\"\"\n    pass\n", "function_schema_json": [{"name": "get_contract_code", "description": "Retrieves the current code of a smart contract deployed on the Ethereum blockchain.", "parameters": {"type": "object", "properties": {"contract_address": {"type": "string", "description": "The address of the smart contract."}}, "required": ["contract_address"], "additionalProperties": false}}, {"name": "update_contract_code", "description": "Updates the code of a smart contract deployed on the Ethereum blockchain.", "parameters": {"type": "object", "properties": {"contract_address": {"type": "string", "description": "The address of the smart contract."}, "new_code": {"type": "string", "description": "The new code for the smart contract."}}, "required": ["contract_address", "new_code"], "additionalProperties": false}}, {"name": "verify_contract_compatibility", "description": "Verifies the compatibility of the updated smart contract with existing transactions.", "parameters": {"type": "object", "properties": {"contract_address": {"type": "string", "description": "The address of the smart contract."}, "test_transactions": {"type": "array", "description": "A list of existing transactions to test against the updated contract."}}, "required": ["contract_address", "test_transactions"], "additionalProperties": false}}, {"name": "deploy_contract", "description": "Deploys a new version of a smart contract to the Ethereum blockchain.", "parameters": {"type": "object", "properties": {"contract_code": {"type": "string", "description": "The code of the new smart contract."}}, "required": ["contract_code"], "additionalProperties": false}}, {"name": "get_existing_transactions", "description": "Retrieves a list of existing transactions processed by the smart contract.", "parameters": {"type": "object", "properties": {"contract_address": {"type": "string", "description": "The address of the smart contract."}}, "required": ["contract_address"], "additionalProperties": false}}], "mock_functions": "def get_contract_code(contract_address: str) -> str:\n    \"\"\"\n    Retrieves the current code of a smart contract deployed on the Ethereum blockchain.\n    \n    :param contract_address: The address of the smart contract.\n    :return: A string representing the current code of the smart contract.\n    :raises ValueError: If the contract address is invalid.\n    \"\"\"\n    if contract_address == \"0x123abc456def789ghi101112jkl13141516\":\n        return \"Current smart contract code\"\n    else:\n        raise ValueError(\"Invalid contract address.\")\ndef update_contract_code(contract_address: str, new_code: str) -> bool:\n    \"\"\"\n    Updates the code of a smart contract deployed on the Ethereum blockchain.\n    \n    :param contract_address: The address of the smart contract.\n    :param new_code: The new code for the smart contract.\n    :return: True if the update is successful, False otherwise.\n    :raises ValueError: If the contract address is invalid or new code is empty.\n    \"\"\"\n    if not contract_address or not new_code:\n        raise ValueError(\"Contract address and new code must be provided.\")\n    if contract_address == \"0x123abc456def789ghi101112jkl13141516\":\n        return True\n    return False\ndef verify_contract_compatibility(contract_address: str, test_transactions: list) -> dict:\n    \"\"\"\n    Verifies the compatibility of the updated smart contract with existing transactions.\n    \n    :param contract_address: The address of the smart contract.\n    :param test_transactions: A list of existing transactions to test against the updated contract.\n    :return:\n        dict: A dictionary with the following keys:\n            - compatible (bool): True if the contract is compatible, False otherwise.\n            - issues (list[str]): A list of issues found during verification.\n    :raises ValueError: If the contract address is invalid or test transactions are empty.\n    \"\"\"\n    if not contract_address or not test_transactions:\n        raise ValueError(\"Contract address and test transactions must be provided.\")\n    if contract_address == \"0x123abc456def789ghi101112jkl13141516\":\n        return {\n            \"compatible\": True,\n            \"issues\": []\n        }\n    return {\n        \"compatible\": False,\n        \"issues\": [\"Invalid contract address\"]\n    }\ndef deploy_contract(contract_code: str) -> str:\n    \"\"\"\n    Deploys a new version of a smart contract to the Ethereum blockchain.\n    \n    :param contract_code: The code of the new smart contract.\n    :return: The address of the newly deployed smart contract.\n    :raises ValueError: If the contract code is invalid.\n    \"\"\"\n    if not contract_code:\n        raise ValueError(\"Contract code must be provided.\")\n    return \"0x987zyx654wvu321tqs01jnml20000000\"\ndef get_existing_transactions(contract_address: str) -> list:\n    \"\"\"\n    Retrieves a list of existing transactions processed by the smart contract.\n    \n    :param contract_address: The address of the smart contract.\n    :return: A list of transaction hashes.\n    :raises ValueError: If the contract address is invalid.\n    \"\"\"\n    if contract_address == \"0x123abc456def789ghi101112jkl13141516\":\n        return [\"tx12345\", \"tx67890\"]\n    else:\n        raise ValueError(\"Invalid contract address.\")", "user_query": "This is Mark from SecureAssets. Could you verify contract compatibility at address 0x123abc456def789ghi101112jkl13141516 with these test transactions: [\"tx12345\", \"tx67890\"]?", "checklist": {"functions": ["verify_contract_compatibility"], "values": [{"compatible": true, "issues": []}]}}
{"difficulty": "easy", "function_schema_python": "def get_address_transactions(address: str, days: int) -> dict:\n    \"\"\"Retrieves transaction history for a Bitcoin address within a specified time period.\n\n    :param address: The Bitcoin address to analyze.\n    :param days: Number of past days to analyze.\n    :return: Dictionary containing transaction data:\n        - transaction_count (int): Total number of transactions\n        - transactions (list[dict]): List of transaction details\n            - timestamp (str): Transaction timestamp\n            - value (float): Transaction value in BTC\n            - connected_address (str): Connected Bitcoin address\n    :raises ValueError: If address is invalid or days is negative\"\"\"\n    pass\ndef filter_high_activity_addresses(transactions: dict, min_transactions: int) -> list:\n    \"\"\"Filters addresses with high transaction activity.\n\n    :param transactions: Dictionary containing transaction data\n    :param min_transactions: Minimum number of transactions threshold\n    :return: List of addresses meeting the transaction threshold\n    :raises ValueError: If min_transactions is negative or transactions dict is invalid\"\"\"\n    pass\ndef analyze_transaction_patterns(address: str, transaction_data: dict) -> dict:\n    \"\"\"Analyzes transaction patterns for a given address.\n\n    :param address: Bitcoin address to analyze\n    :param transaction_data: Dictionary containing transaction history\n    :return: Dictionary containing analysis results:\n        - daily_average (float): Average daily transaction count\n        - total_value (float): Total BTC value of transactions\n        - unique_connections (int): Number of unique connected addresses\n    :raises ValueError: If address is invalid or transaction_data is malformed\"\"\"\n    pass\n", "function_schema_json": [{"name": "get_address_transactions", "description": "Retrieves transaction history for a Bitcoin address within a specified time period.", "parameters": {"type": "object", "properties": {"address": {"type": "string", "description": "The Bitcoin address to analyze."}, "days": {"type": "integer", "description": "Number of past days to analyze."}}, "required": ["address", "days"], "additionalProperties": false}}, {"name": "filter_high_activity_addresses", "description": "Filters addresses with high transaction activity.", "parameters": {"type": "object", "properties": {"transactions": {"type": "object", "description": "Dictionary containing transaction data"}, "min_transactions": {"type": "integer", "description": "Minimum number of transactions threshold"}}, "required": ["transactions", "min_transactions"], "additionalProperties": false}}, {"name": "analyze_transaction_patterns", "description": "Analyzes transaction patterns for a given address.", "parameters": {"type": "object", "properties": {"address": {"type": "string", "description": "Bitcoin address to analyze"}, "transaction_data": {"type": "object", "description": "Dictionary containing transaction history"}}, "required": ["address", "transaction_data"], "additionalProperties": false}}], "mock_functions": "def get_address_transactions(address: str, days: int) -> dict:\n    \"\"\"\n    Retrieves transaction history for a Bitcoin address within a specified time period.\n    \n    :param address: The Bitcoin address to analyze.\n    :param days: Number of past days to analyze.\n    :return: Dictionary containing transaction data:\n        - transaction_count (int): Total number of transactions\n        - transactions (list[dict]): List of transaction details\n            - timestamp (str): Transaction timestamp\n            - value (float): Transaction value in BTC\n            - connected_address (str): Connected Bitcoin address\n    :raises ValueError: If address is invalid or days is negative\n    \"\"\"\n    if not address or not isinstance(days, int) or days <= 0:\n        raise ValueError(\"Invalid address or time period\")\n    \n    if address == \"1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa\" and days == 30:\n        return {\n            \"transaction_count\": 2500,\n            \"transactions\": [\n                {\n                    \"timestamp\": \"2023-10-01T10:00:00Z\",\n                    \"value\": 0.5,\n                    \"connected_address\": \"1ABC2DEF3GHI4JKL5MNO6PQR7STU8VWX\"\n                },\n                # More transactions would follow in real implementation\n            ]\n        }\n    return {\"transaction_count\": 0, \"transactions\": []}\ndef filter_high_activity_addresses(transactions: dict, min_transactions: int) -> list:\n    \"\"\"\n    Filters addresses with high transaction activity.\n    \n    :param transactions: Dictionary containing transaction data\n    :param min_transactions: Minimum number of transactions threshold\n    :return: List of addresses meeting the transaction threshold\n    :raises ValueError: If min_transactions is negative or transactions dict is invalid\n    \"\"\"\n    if not isinstance(min_transactions, int) or min_transactions < 0:\n        raise ValueError(\"Invalid minimum transaction threshold\")\n    \n    if transactions[\"transaction_count\"] >= min_transactions:\n        return [\"1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa\"]\n    return []\ndef analyze_transaction_patterns(address: str, transaction_data: dict) -> dict:\n    \"\"\"\n    Analyzes transaction patterns for a given address.\n    \n    :param address: Bitcoin address to analyze\n    :param transaction_data: Dictionary containing transaction history\n    :return: Dictionary containing analysis results:\n        - daily_average (float): Average daily transaction count\n        - total_value (float): Total BTC value of transactions\n        - unique_connections (int): Number of unique connected addresses\n    :raises ValueError: If address is invalid or transaction_data is malformed\n    \"\"\"\n    if not address or not transaction_data:\n        raise ValueError(\"Invalid address or transaction data\")\n    \n    if (address == \"1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa\" and \n        transaction_data[\"transaction_count\"] > 0):\n        return {\n            \"daily_average\": 83.33,\n            \"total_value\": 125.5,\n            \"unique_connections\": 1500\n        }\n    return {\"daily_average\": 0, \"total_value\": 0, \"unique_connections\": 0}", "user_query": "Can you get the transaction history for Bitcoin address 1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa from the last 30 days?", "checklist": {"functions": ["get_address_transactions"], "values": [{"transaction_count": 2500, "transactions": [{"timestamp": "2023-10-01T10:00:00Z", "value": 0.5, "connected_address": "1ABC2DEF3GHI4JKL5MNO6PQR7STU8VWX"}]}]}}
{"difficulty": "easy", "function_schema_python": "def get_token_transfers(wallet_address: str, time_range_hours: int) -> dict:\n    \"\"\"Retrieves token transfer events for a specific wallet address within a time range.\n\n    :param wallet_address: Ethereum wallet address to monitor\n    :param time_range_hours: Number of hours to look back\n    :return: Dictionary containing transfer events with timestamps, token addresses, amounts, and protocols\n    :raises ValueError: If wallet address is invalid or time range is negative\"\"\"\n    pass\ndef get_gas_fees(wallet_address: str, time_range_hours: int) -> dict:\n    \"\"\"Retrieves gas fees paid by a wallet address within a specific time range.\n\n    :param wallet_address: Ethereum wallet address to analyze\n    :param time_range_hours: Number of hours to look back\n    :return: Dictionary containing gas fee details and statistics\n    :raises ValueError: If wallet address is invalid or time range is negative\"\"\"\n    pass\ndef get_dex_interactions(wallet_address: str, time_range_hours: int) -> dict:\n    \"\"\"Retrieves DEX interaction details for a specific wallet address.\n\n    :param wallet_address: Ethereum wallet address to analyze\n    :param time_range_hours: Number of hours to look back\n    :return: Dictionary containing DEX interaction statistics and details\n    :raises ValueError: If wallet address is invalid or time range is negative\"\"\"\n    pass\n", "function_schema_json": [{"name": "get_token_transfers", "description": "Retrieves token transfer events for a specific wallet address within a time range.", "parameters": {"type": "object", "properties": {"wallet_address": {"type": "string", "description": "Ethereum wallet address to monitor"}, "time_range_hours": {"type": "integer", "description": "Number of hours to look back"}}, "required": ["wallet_address", "time_range_hours"], "additionalProperties": false}}, {"name": "get_gas_fees", "description": "Retrieves gas fees paid by a wallet address within a specific time range.", "parameters": {"type": "object", "properties": {"wallet_address": {"type": "string", "description": "Ethereum wallet address to analyze"}, "time_range_hours": {"type": "integer", "description": "Number of hours to look back"}}, "required": ["wallet_address", "time_range_hours"], "additionalProperties": false}}, {"name": "get_dex_interactions", "description": "Retrieves DEX interaction details for a specific wallet address.", "parameters": {"type": "object", "properties": {"wallet_address": {"type": "string", "description": "Ethereum wallet address to analyze"}, "time_range_hours": {"type": "integer", "description": "Number of hours to look back"}}, "required": ["wallet_address", "time_range_hours"], "additionalProperties": false}}], "mock_functions": "def get_token_transfers(wallet_address: str, time_range_hours: int) -> dict:\n    \"\"\"\n    Retrieves token transfer events for a specific wallet address within a time range.\n    \n    :param wallet_address: Ethereum wallet address to monitor\n    :param time_range_hours: Number of hours to look back\n    :return: Dictionary containing transfer events with timestamps, token addresses, amounts, and protocols\n    :raises ValueError: If wallet address is invalid or time range is negative\n    \"\"\"\n    if not wallet_address.startswith('0x') or len(wallet_address) != 42:\n        raise ValueError(\"Invalid Ethereum address format\")\n    if time_range_hours <= 0:\n        raise ValueError(\"Time range must be positive\")\n    \n    if wallet_address == \"0x742d35Cc6634C0532925a3b844Bc454e4438f44e\" and time_range_hours == 48:\n        return {\n            \"transfers\": [\n                {\n                    \"timestamp\": \"2024-01-20T14:30:00Z\",\n                    \"token_address\": \"0x1f9840a85d5af5bf1d1762f925bdaddc4201f984\",\n                    \"amount\": \"1500.0\",\n                    \"protocol\": \"Uniswap\",\n                    \"type\": \"USDT\"\n                },\n                {\n                    \"timestamp\": \"2024-01-20T16:45:00Z\",\n                    \"token_address\": \"0x6b175474e89094c44da98b954eedeac495271d0f\",\n                    \"amount\": \"2000.0\",\n                    \"protocol\": \"SushiSwap\",\n                    \"type\": \"DAI\"\n                }\n            ],\n            \"total_count\": 75\n        }\n    return {\"transfers\": [], \"total_count\": 0}\ndef get_gas_fees(wallet_address: str, time_range_hours: int) -> dict:\n    \"\"\"\n    Retrieves gas fees paid by a wallet address within a specific time range.\n    \n    :param wallet_address: Ethereum wallet address to analyze\n    :param time_range_hours: Number of hours to look back\n    :return: Dictionary containing gas fee details and statistics\n    :raises ValueError: If wallet address is invalid or time range is negative\n    \"\"\"\n    if not wallet_address.startswith('0x') or len(wallet_address) != 42:\n        raise ValueError(\"Invalid Ethereum address format\")\n    if time_range_hours <= 0:\n        raise ValueError(\"Time range must be positive\")\n    \n    if wallet_address == \"0x742d35Cc6634C0532925a3b844Bc454e4438f44e\" and time_range_hours == 48:\n        return {\n            \"total_gas_eth\": \"0.85\",\n            \"average_gas_gwei\": \"45\",\n            \"highest_gas_paid\": \"0.12\",\n            \"lowest_gas_paid\": \"0.008\",\n            \"transaction_count\": 75\n        }\n    return {\"total_gas_eth\": \"0\", \"average_gas_gwei\": \"0\", \"highest_gas_paid\": \"0\", \"lowest_gas_paid\": \"0\", \"transaction_count\": 0}\ndef get_dex_interactions(wallet_address: str, time_range_hours: int) -> dict:\n    \"\"\"\n    Retrieves DEX interaction details for a specific wallet address.\n    \n    :param wallet_address: Ethereum wallet address to analyze\n    :param time_range_hours: Number of hours to look back\n    :return: Dictionary containing DEX interaction statistics and details\n    :raises ValueError: If wallet address is invalid or time range is negative\n    \"\"\"\n    if not wallet_address.startswith('0x') or len(wallet_address) != 42:\n        raise ValueError(\"Invalid Ethereum address format\")\n    if time_range_hours <= 0:\n        raise ValueError(\"Time range must be positive\")\n    \n    if wallet_address == \"0x742d35Cc6634C0532925a3b844Bc454e4438f44e\" and time_range_hours == 48:\n        return {\n            \"protocols\": {\n                \"Uniswap\": {\"interaction_count\": 30, \"total_value_usd\": \"150000\"},\n                \"SushiSwap\": {\"interaction_count\": 25, \"total_value_usd\": \"125000\"},\n                \"Curve\": {\"interaction_count\": 20, \"total_value_usd\": \"100000\"}\n            },\n            \"total_interactions\": 75,\n            \"total_value_usd\": \"375000\"\n        }\n    return {\"protocols\": {}, \"total_interactions\": 0, \"total_value_usd\": \"0\"}", "user_query": "Get token transfers for wallet 0x742d35Cc6634C0532925a3b844Bc454e4438f44e in the last 48 hours.", "checklist": {"functions": ["get_token_transfers"], "values": [{"transfers": [{"timestamp": "2024-01-20T14:30:00Z", "token_address": "0x1f9840a85d5af5bf1d1762f925bdaddc4201f984", "amount": "1500.0", "protocol": "Uniswap", "type": "USDT"}, {"timestamp": "2024-01-20T16:45:00Z", "token_address": "0x6b175474e89094c44da98b954eedeac495271d0f", "amount": "2000.0", "protocol": "SushiSwap", "type": "DAI"}], "total_count": 75}]}}
{"difficulty": "easy", "function_schema_python": "def get_token_balance(wallet_address: str, token_symbol: str) -> float:\n    \"\"\"Retrieves the token balance for a specific wallet address.\n\n    :param wallet_address: The blockchain wallet address.\n    :param token_symbol: The symbol of the token (e.g., 'CP' for CryptoPulse).\n    :return: The token balance as a float.\n    :raises ValueError: If wallet address is invalid or token symbol doesn't exist.\"\"\"\n    pass\ndef estimate_gas_fees(token_amount: float, token_symbol: str) -> dict:\n    \"\"\"Estimates the gas fees for a token transfer.\n\n    :param token_amount: Amount of tokens to transfer.\n    :param token_symbol: Symbol of the token being transferred.\n    :return: \n        dict: A dictionary containing:\n            - estimated_gas (float): Estimated gas units\n            - gas_price (float): Current gas price in GWEI\n            - total_fee_eth (float): Total fee in ETH\n            - total_fee_usd (float): Total fee in USD\n    :raises ValueError: If token amount is invalid or token is not supported\"\"\"\n    pass\ndef transfer_tokens(from_address: str, to_address: str, token_amount: float, token_symbol: str) -> dict:\n    \"\"\"Initiates a token transfer between two addresses.\n\n    :param from_address: Sender's wallet address\n    :param to_address: Recipient's wallet address\n    :param token_amount: Amount of tokens to transfer\n    :param token_symbol: Symbol of the token being transferred\n    :return:\n        dict: A dictionary containing:\n            - transaction_hash (str): The transaction hash\n            - status (str): Transaction status\n            - block_number (int): Block number where transaction was included\n    :raises ValueError: If any parameters are invalid\"\"\"\n    pass\n", "function_schema_json": [{"name": "get_token_balance", "description": "Retrieves the token balance for a specific wallet address.", "parameters": {"type": "object", "properties": {"wallet_address": {"type": "string", "description": "The blockchain wallet address."}, "token_symbol": {"type": "string", "description": "The symbol of the token (e.g., 'CP' for CryptoPulse)."}}, "required": ["wallet_address", "token_symbol"], "additionalProperties": false}}, {"name": "estimate_gas_fees", "description": "Estimates the gas fees for a token transfer.", "parameters": {"type": "object", "properties": {"token_amount": {"type": "number", "description": "Amount of tokens to transfer."}, "token_symbol": {"type": "string", "description": "Symbol of the token being transferred."}}, "required": ["token_amount", "token_symbol"], "additionalProperties": false}}, {"name": "transfer_tokens", "description": "Initiates a token transfer between two addresses.", "parameters": {"type": "object", "properties": {"from_address": {"type": "string", "description": "Sender's wallet address"}, "to_address": {"type": "string", "description": "Recipient's wallet address"}, "token_amount": {"type": "number", "description": "Amount of tokens to transfer"}, "token_symbol": {"type": "string", "description": "Symbol of the token being transferred"}}, "required": ["from_address", "to_address", "token_amount", "token_symbol"], "additionalProperties": false}}], "mock_functions": "def get_token_balance(wallet_address: str, token_symbol: str) -> float:\n    \"\"\"\n    Retrieves the token balance for a specific wallet address.\n    \n    :param wallet_address: The blockchain wallet address.\n    :param token_symbol: The symbol of the token (e.g., 'CP' for CryptoPulse).\n    :return: The token balance as a float.\n    :raises ValueError: If wallet address is invalid or token symbol doesn't exist.\n    \"\"\"\n    if not wallet_address or len(wallet_address) != 42:  # Standard ETH address length\n        raise ValueError(\"Invalid wallet address\")\n    if wallet_address == \"0xAlex123\" and token_symbol == \"CP\":\n        return 1000.0\n    return 0.0\ndef estimate_gas_fees(token_amount: float, token_symbol: str) -> dict:\n    \"\"\"\n    Estimates the gas fees for a token transfer.\n    \n    :param token_amount: Amount of tokens to transfer.\n    :param token_symbol: Symbol of the token being transferred.\n    :return: \n        dict: A dictionary containing:\n            - estimated_gas (float): Estimated gas units\n            - gas_price (float): Current gas price in GWEI\n            - total_fee_eth (float): Total fee in ETH\n            - total_fee_usd (float): Total fee in USD\n    :raises ValueError: If token amount is invalid or token is not supported\n    \"\"\"\n    if token_amount <= 0 or not token_symbol:\n        raise ValueError(\"Invalid token amount or symbol\")\n    if token_symbol == \"CP\" and 0 < token_amount <= 1000:\n        return {\n            \"estimated_gas\": 65000.0,\n            \"gas_price\": 50.0,\n            \"total_fee_eth\": 0.00325,\n            \"total_fee_usd\": 6.50\n        }\n    raise ValueError(\"Unsupported token or amount too high\")\ndef transfer_tokens(\n    from_address: str,\n    to_address: str,\n    token_amount: float,\n    token_symbol: str\n) -> dict:\n    \"\"\"\n    Initiates a token transfer between two addresses.\n    \n    :param from_address: Sender's wallet address\n    :param to_address: Recipient's wallet address\n    :param token_amount: Amount of tokens to transfer\n    :param token_symbol: Symbol of the token being transferred\n    :return:\n        dict: A dictionary containing:\n            - transaction_hash (str): The transaction hash\n            - status (str): Transaction status\n            - block_number (int): Block number where transaction was included\n    :raises ValueError: If any parameters are invalid\n    \"\"\"\n    if (from_address == \"0xAlex123\" and \n        to_address == \"0xBen456\" and \n        token_amount == 500.0 and \n        token_symbol == \"CP\"):\n        return {\n            \"transaction_hash\": \"0x123abc...def789\",\n            \"status\": \"confirmed\",\n            \"block_number\": 15421234\n        }\n    raise ValueError(\"Invalid transfer parameters\")", "user_query": "Can you estimate the gas fees for transferring 500 CP tokens from my wallet to Ben's wallet?", "checklist": {"functions": ["estimate_gas_fees"], "values": [{"estimated_gas": 65000.0, "gas_price": 50.0, "total_fee_eth": 0.00325, "total_fee_usd": 6.5}]}}
{"difficulty": "easy", "function_schema_python": "def initialize_oauth_client(client_id: str, client_secret: str) -> dict:\n    \"\"\"Initializes OAuth 2.0 client with credentials.\n\n    :param client_id: The OAuth client ID provided by the payment gateway.\n    :param client_secret: The OAuth client secret provided by the payment gateway.\n    :return: Dictionary containing client configuration.\n    :raises ValueError: If credentials are invalid.\"\"\"\n    pass\ndef generate_access_token(auth_code: str, client_config: dict) -> dict:\n    \"\"\"Generates OAuth access token using authorization code.\n\n    :param auth_code: Authorization code received from OAuth provider.\n    :param client_config: Client configuration dictionary from initialize_oauth_client.\n    :return: Dictionary containing access token information.\n    :raises ValueError: If auth_code is invalid.\"\"\"\n    pass\ndef validate_token(access_token: str) -> dict:\n    \"\"\"Validates the OAuth access token.\n\n    :param access_token: The access token to validate.\n    :return: Dictionary containing token validation status.\n    :raises ValueError: If token is invalid.\"\"\"\n    pass\n", "function_schema_json": [{"name": "initialize_oauth_client", "description": "Initializes OAuth 2.0 client with credentials.", "parameters": {"type": "object", "properties": {"client_id": {"type": "string", "description": "The OAuth client ID provided by the payment gateway."}, "client_secret": {"type": "string", "description": "The OAuth client secret provided by the payment gateway."}}, "required": ["client_id", "client_secret"], "additionalProperties": false}}, {"name": "generate_access_token", "description": "Generates OAuth access token using authorization code.", "parameters": {"type": "object", "properties": {"auth_code": {"type": "string", "description": "Authorization code received from OAuth provider."}, "client_config": {"type": "object", "description": "Client configuration dictionary from initialize_oauth_client."}}, "required": ["auth_code", "client_config"], "additionalProperties": false}}, {"name": "validate_token", "description": "Validates the OAuth access token.", "parameters": {"type": "object", "properties": {"access_token": {"type": "string", "description": "The access token to validate."}}, "required": ["access_token"], "additionalProperties": false}}], "mock_functions": "def initialize_oauth_client(client_id: str, client_secret: str) -> dict:\n    \"\"\"\n    Initializes OAuth 2.0 client with credentials.\n    \n    :param client_id: The OAuth client ID provided by the payment gateway.\n    :param client_secret: The OAuth client secret provided by the payment gateway.\n    :return: Dictionary containing client configuration.\n    :raises ValueError: If credentials are invalid.\n    \"\"\"\n    if not client_id or not client_secret:\n        raise ValueError(\"Client ID and secret must not be empty\")\n    if client_id == \"shopease_123\" and client_secret == \"secret_456\":\n        return {\n            \"client_id\": client_id,\n            \"client_secret\": client_secret,\n            \"auth_endpoint\": \"https://api.payment-gateway.com/oauth/authorize\",\n            \"token_endpoint\": \"https://api.payment-gateway.com/oauth/token\"\n        }\n    raise ValueError(\"Invalid credentials\")\ndef generate_access_token(auth_code: str, client_config: dict) -> dict:\n    \"\"\"\n    Generates OAuth access token using authorization code.\n    \n    :param auth_code: Authorization code received from OAuth provider.\n    :param client_config: Client configuration dictionary from initialize_oauth_client.\n    :return: Dictionary containing access token information.\n    :raises ValueError: If auth_code is invalid.\n    \"\"\"\n    if not auth_code or not client_config:\n        raise ValueError(\"Auth code and client config required\")\n    if auth_code == \"valid_auth_code\" and client_config.get(\"client_id\") == \"shopease_123\":\n        return {\n            \"access_token\": \"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9\",\n            \"token_type\": \"Bearer\",\n            \"expires_in\": 3600,\n            \"refresh_token\": \"refresh_xyz_789\"\n        }\n    raise ValueError(\"Invalid authorization code\")\ndef validate_token(access_token: str) -> dict:\n    \"\"\"\n    Validates the OAuth access token.\n    \n    :param access_token: The access token to validate.\n    :return: Dictionary containing token validation status.\n    :raises ValueError: If token is invalid.\n    \"\"\"\n    if not access_token:\n        raise ValueError(\"Access token required\")\n    if access_token == \"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9\":\n        return {\n            \"valid\": True,\n            \"expires_in\": 2400,\n            \"scope\": [\"payment:write\", \"payment:read\"]\n        }\n    raise ValueError(\"Invalid access token\")", "user_query": "Could you initialize OAuth client for ShopEase using client ID 'shopease_123' and secret 'secret_456'?", "checklist": {"functions": ["initialize_oauth_client"], "values": [{"client_id": "shopease_123", "client_secret": "secret_456", "auth_endpoint": "https://api.payment-gateway.com/oauth/authorize", "token_endpoint": "https://api.payment-gateway.com/oauth/token"}]}}
{"difficulty": "easy", "function_schema_python": "def implement_api_keys(api_key_type: str, security_level: str) -> Dict[str, str]:\n    \"\"\"Implements API keys for authentication.\n\n    :param api_key_type: The type of API key to implement (e.g., \"UUID\", \"Bearer\").\n    :param security_level: The desired security level (e.g., \"high\", \"medium\").\n    :return: A dictionary containing the implemented API key details.\n        - type (str): The type of API key implemented.\n        - level (str): The security level implemented.\n    :raises ValueError: If invalid parameters are provided.\"\"\"\n    pass\ndef handle_user_sessions(session_management: str, encryption_method: str) -> bool:\n    \"\"\"Handles user sessions securely.\n\n    :param session_management: The session management method (e.g., \"JWT\", \"server-side\").\n    :param encryption_method: The encryption method to use (e.g., \"AES-256\", \"RSA\").\n    :return: True if sessions are handled successfully, False otherwise.\n    :raises ValueError: If invalid parameters are provided.\"\"\"\n    pass\ndef secure_health_records(data_encryption: str, access_control: str) -> str:\n    \"\"\"Secures health records using encryption and access control.\n\n    :param data_encryption: The encryption method for health data.\n    :param access_control: The access control method to implement.\n    :return: A string confirming the security implementation.\n    :raises ValueError: If invalid parameters are provided.\"\"\"\n    pass\ndef consult_smart_agent(query: str) -> str:\n    \"\"\"Consults the smart agent, Maya, for advice.\n\n    :param query: The query to ask Maya.\n    :return: Maya's response to the query.\n    :raises ValueError: If the query is empty.\"\"\"\n    pass\n", "function_schema_json": [{"name": "implement_api_keys", "description": "Implements API keys for authentication.", "parameters": {"type": "object", "properties": {"api_key_type": {"type": "string", "description": "The type of API key to implement (e.g., \"UUID\", \"Bearer\")."}, "security_level": {"type": "string", "description": "The desired security level (e.g., \"high\", \"medium\")."}}, "required": ["api_key_type", "security_level"], "additionalProperties": false}}, {"name": "handle_user_sessions", "description": "Handles user sessions securely.", "parameters": {"type": "object", "properties": {"session_management": {"type": "string", "description": "The session management method (e.g., \"JWT\", \"server-side\")."}, "encryption_method": {"type": "string", "description": "The encryption method to use (e.g., \"AES-256\", \"RSA\")."}}, "required": ["session_management", "encryption_method"], "additionalProperties": false}}, {"name": "secure_health_records", "description": "Secures health records using encryption and access control.", "parameters": {"type": "object", "properties": {"data_encryption": {"type": "string", "description": "The encryption method for health data."}, "access_control": {"type": "string", "description": "The access control method to implement."}}, "required": ["data_encryption", "access_control"], "additionalProperties": false}}, {"name": "consult_smart_agent", "description": "Consults the smart agent, Maya, for advice.", "parameters": {"type": "object", "properties": {"query": {"type": "string", "description": "The query to ask Maya."}}, "required": ["query"], "additionalProperties": false}}], "mock_functions": "def implement_api_keys(api_key_type: str, security_level: str) -> Dict[str, str]:\n    \"\"\"\n    Implements API keys for authentication.\n\n    :param api_key_type: The type of API key to implement (e.g., \"UUID\", \"Bearer\").\n    :param security_level: The desired security level (e.g., \"high\", \"medium\").\n    :return: A dictionary containing the implemented API key details.\n        - type (str): The type of API key implemented.\n        - level (str): The security level implemented.\n    :raises ValueError: If invalid parameters are provided.\n    \"\"\"\n    if not api_key_type or not security_level:\n        raise ValueError(\"API key type and security level must be provided.\")\n\n    if api_key_type.lower() in [\"uuid\", \"bearer\"] and security_level.lower() in [\"high\", \"medium\", \"low\"]:\n        return {\"type\": api_key_type, \"level\": security_level}\n    else:\n        raise ValueError(\"Invalid API key type or security level.\")\ndef handle_user_sessions(session_management: str, encryption_method: str) -> bool:\n    \"\"\"\n    Handles user sessions securely.\n\n    :param session_management: The session management method (e.g., \"JWT\", \"server-side\").\n    :param encryption_method: The encryption method to use (e.g., \"AES-256\", \"RSA\").\n    :return: True if sessions are handled successfully, False otherwise.\n    :raises ValueError: If invalid parameters are provided.\n    \"\"\"\n    if not session_management or not encryption_method:\n        raise ValueError(\"Session management and encryption method must be provided.\")\n\n    if session_management.lower() in [\"jwt\", \"server-side\"] and encryption_method in [\"aes-256\", \"rsa\"]:\n        return True\n    else:\n        return False\ndef secure_health_records(data_encryption: str, access_control: str) -> str:\n    \"\"\"\n    Secures health records using encryption and access control.\n\n    :param data_encryption: The encryption method for health data.\n    :param access_control: The access control method to implement.\n    :return: A string confirming the security implementation.\n    :raises ValueError: If invalid parameters are provided.\n    \"\"\"\n    if not data_encryption or not access_control:\n        raise ValueError(\"Data encryption and access control methods must be provided.\")\n    return f\"Health records secured with {data_encryption} encryption and {access_control} access control.\"\ndef consult_smart_agent(query: str) -> str:\n    \"\"\"\n    Consults the smart agent, Maya, for advice.\n\n    :param query: The query to ask Maya.\n    :return: Maya's response to the query.\n    :raises ValueError: If the query is empty.\n    \"\"\"\n    if not query:\n        raise ValueError(\"Query cannot be empty.\")\n\n    if \"best practices\" in query.lower() and \"api keys\" in query.lower() and \"user sessions\" in query.lower():\n        return \"Recommend using strong encryption like AES-256 for user sessions and UUIDs for API keys with high security levels.\"\n    elif \"secure health records\" in query.lower():\n        return \"Implement end-to-end encryption and role-based access control for maximum security.\"\n    else:\n        return \"I am still learning about that topic.\"", "user_query": "Can you implement an API key with UUID type and high security level for the VitalTrack app?", "checklist": {"functions": ["implement_api_keys"], "values": [{"type": "UUID", "level": "high"}]}}
{"difficulty": "easy", "function_schema_python": "def setup_load_test_environment(api_url: str, test_config: dict) -> bool:\n    \"\"\"Sets up the load testing environment for the API.\n\n    :param api_url: The URL of the API to be tested.\n    :param test_config: Dictionary containing test configuration parameters.\n        Expected keys:\n        - concurrent_users (int): Number of simultaneous users\n        - test_duration (int): Duration of test in seconds\n        - ramp_up_time (int): Time to gradually increase load in seconds\n    :return: True if setup is successful, False otherwise.\n    :raises ValueError: If API URL is invalid or config parameters are missing.\"\"\"\n    pass\ndef execute_load_test(test_scenarios: list[dict], timeout: int) -> dict:\n    \"\"\"Executes the load test with specified scenarios.\n\n    :param test_scenarios: List of dictionaries containing test scenarios.\n        Each dictionary should contain:\n        - endpoint (str): API endpoint to test\n        - method (str): HTTP method (GET, POST, etc.)\n        - payload (dict): Request payload if applicable\n    :param timeout: Request timeout in seconds\n    :return: Dictionary containing test results:\n        - average_response_time (float): Average response time in milliseconds\n        - error_rate (float): Percentage of failed requests\n        - throughput (int): Requests per second\n        - status_codes (dict): Count of different HTTP status codes\n    :raises ValueError: If test scenarios are invalid\"\"\"\n    pass\ndef analyze_performance_metrics(test_results: dict, threshold_config: dict) -> dict:\n    \"\"\"Analyzes the load test results and provides recommendations.\n\n    :param test_results: Dictionary containing test results from execute_load_test\n    :param threshold_config: Dictionary containing acceptable thresholds:\n        - max_response_time (float): Maximum acceptable response time\n        - max_error_rate (float): Maximum acceptable error rate\n        - min_throughput (int): Minimum acceptable throughput\n    :return: Dictionary containing analysis results:\n        - passed (bool): Overall test pass/fail status\n        - bottlenecks (list): List of identified bottlenecks\n        - recommendations (list): List of improvement recommendations\n    :raises ValueError: If test results or threshold config is invalid\"\"\"\n    pass\n", "function_schema_json": [{"name": "setup_load_test_environment", "description": "Sets up the load testing environment for the API.", "parameters": {"type": "object", "properties": {"api_url": {"type": "string", "description": "The URL of the API to be tested."}, "test_config": {"type": "object", "description": "Dictionary containing test configuration parameters."}}, "required": ["api_url", "test_config"], "additionalProperties": false}}, {"name": "execute_load_test", "description": "Executes the load test with specified scenarios.", "parameters": {"type": "object", "properties": {"test_scenarios": {"type": "array", "items": {"type": "object"}, "description": "List of dictionaries containing test scenarios."}, "timeout": {"type": "integer", "description": "Request timeout in seconds"}}, "required": ["test_scenarios", "timeout"], "additionalProperties": false}}, {"name": "analyze_performance_metrics", "description": "Analyzes the load test results and provides recommendations.", "parameters": {"type": "object", "properties": {"test_results": {"type": "object", "description": "Dictionary containing test results from execute_load_test"}, "threshold_config": {"type": "object", "description": "Dictionary containing acceptable thresholds:"}}, "required": ["test_results", "threshold_config"], "additionalProperties": false}}], "mock_functions": "def setup_load_test_environment(api_url: str, test_config: dict) -> bool:\n    \"\"\"\n    Sets up the load testing environment for the API.\n    \n    :param api_url: The URL of the API to be tested.\n    :param test_config: Dictionary containing test configuration parameters.\n        Expected keys:\n        - concurrent_users (int): Number of simultaneous users\n        - test_duration (int): Duration of test in seconds\n        - ramp_up_time (int): Time to gradually increase load in seconds\n    :return: True if setup is successful, False otherwise.\n    :raises ValueError: If API URL is invalid or config parameters are missing.\n    \"\"\"\n    if not api_url.startswith('http'):\n        raise ValueError(\"Invalid API URL format\")\n    \n    required_keys = ['concurrent_users', 'test_duration', 'ramp_up_time']\n    if not all(key in test_config for key in required_keys):\n        raise ValueError(\"Missing required configuration parameters\")\n        \n    if (test_config['concurrent_users'] > 0 and \n        test_config['test_duration'] > 0 and \n        test_config['ramp_up_time'] >= 0):\n        return True\n    return False\ndef execute_load_test(test_scenarios: list[dict], timeout: int = 30) -> dict:\n    \"\"\"\n    Executes the load test with specified scenarios.\n    \n    :param test_scenarios: List of dictionaries containing test scenarios.\n        Each dictionary should contain:\n        - endpoint (str): API endpoint to test\n        - method (str): HTTP method (GET, POST, etc.)\n        - payload (dict): Request payload if applicable\n    :param timeout: Request timeout in seconds\n    :return: Dictionary containing test results:\n        - average_response_time (float): Average response time in milliseconds\n        - error_rate (float): Percentage of failed requests\n        - throughput (int): Requests per second\n        - status_codes (dict): Count of different HTTP status codes\n    :raises ValueError: If test scenarios are invalid\n    \"\"\"\n    if not test_scenarios or not isinstance(test_scenarios, list):\n        raise ValueError(\"Invalid test scenarios\")\n        \n    valid_methods = ['GET', 'POST', 'PUT', 'DELETE']\n    for scenario in test_scenarios:\n        if not all(key in scenario for key in ['endpoint', 'method']):\n            raise ValueError(\"Invalid scenario format\")\n        if scenario['method'] not in valid_methods:\n            raise ValueError(f\"Invalid HTTP method: {scenario['method']}\")\n            \n    return {\n        \"average_response_time\": 245.5,\n        \"error_rate\": 0.5,\n        \"throughput\": 1000,\n        \"status_codes\": {\n            \"200\": 9500,\n            \"404\": 25,\n            \"500\": 475\n        }\n    }\ndef analyze_performance_metrics(test_results: dict, threshold_config: dict) -> dict:\n    \"\"\"\n    Analyzes the load test results and provides recommendations.\n    \n    :param test_results: Dictionary containing test results from execute_load_test\n    :param threshold_config: Dictionary containing acceptable thresholds:\n        - max_response_time (float): Maximum acceptable response time\n        - max_error_rate (float): Maximum acceptable error rate\n        - min_throughput (int): Minimum acceptable throughput\n    :return: Dictionary containing analysis results:\n        - passed (bool): Overall test pass/fail status\n        - bottlenecks (list): List of identified bottlenecks\n        - recommendations (list): List of improvement recommendations\n    :raises ValueError: If test results or threshold config is invalid\n    \"\"\"\n    required_metrics = ['average_response_time', 'error_rate', 'throughput']\n    if not all(key in test_results for key in required_metrics):\n        raise ValueError(\"Invalid test results format\")\n        \n    required_thresholds = ['max_response_time', 'max_error_rate', 'min_throughput']\n    if not all(key in threshold_config for key in required_thresholds):\n        raise ValueError(\"Invalid threshold configuration\")\n        \n    return {\n        \"passed\": True,\n        \"bottlenecks\": [\"High response time on product search endpoint\"],\n        \"recommendations\": [\n            \"Implement caching for product search\",\n            \"Optimize database queries\",\n            \"Add more application servers\"\n        ]\n    }", "user_query": "Can you set up a load test for the e-commerce API at \"https://api.ecommerce.com\" with 100 concurrent users for 3600 seconds and a ramp-up time of 600 seconds?", "checklist": {"functions": ["setup_load_test_environment"], "values": [true]}}
{"difficulty": "easy", "function_schema_python": "def create_api_with_fastapi(routes: list, framework: str) -> dict:\n    \"\"\"Creates an API using the FastAPI framework.\n\n    :param routes: A list of API routes definitions.\n    :param framework: The web framework to use (should be 'fastapi').\n    :return:\n        dict: A dictionary with the following keys:\n            - status (str): The status of API creation (\"success\" or \"failure\").\n            - message (str): A message indicating the result.\n    :raises ValueError: If the framework is not 'fastapi' or routes are not provided.\"\"\"\n    pass\ndef create_api_with_flask(routes: list, framework: str) -> dict:\n    \"\"\"Creates an API using the Flask framework.\n\n    :param routes: A list of API routes definitions.\n    :param framework: The web framework to use (should be 'flask').\n    :return:\n        dict: A dictionary with the following keys:\n            - status (str): The status of API creation (\"success\" or \"failure\").\n            - message (str): A message indicating the result.\n    :raises ValueError: If the framework is not 'flask' or routes are not provided.\"\"\"\n    pass\ndef setup_load_testing_with_locust(scenario: str) -> str:\n    \"\"\"Sets up load testing using Locust based on a given scenario.\n\n    :param scenario: A string describing the load testing scenario.\n    :return: A string indicating the result of the setup.\n    :raises RuntimeError: If the scenario description is empty.\"\"\"\n    pass\ndef run_load_test(test_plan: str) -> dict:\n    \"\"\"Runs a load test using a pre-defined test plan.\n\n    :param test_plan: A string representing the test plan.\n    :return:\n        dict: A dictionary with the following keys:\n            - result (str): The result of the load test (\"pass\" or \"fail\").\n            - message (str): A message indicating the result.\n    :raises ValueError: If the test plan is not provided.\"\"\"\n    pass\ndef analyze_load_test_results(results: list) -> dict:\n    \"\"\"Analyzes the results of a load test.\n\n    :param results: A list of load test results.\n    :return:\n        dict: A dictionary with the following keys:\n            - passed (bool): Whether the load test passed.\n            - performance (dict): A dictionary containing performance metrics.\n    :raises ValueError: If results are not provided.\"\"\"\n    pass\ndef generate_api_documentation(api: str) -> str:\n    \"\"\"Generates API documentation.\n\n    :param api: A string representing the API.\n    :return: A string representing the API documentation.\n    :raises ValueError: If the API is not provided.\"\"\"\n    pass\ndef use_postman_for_testing(api: str) -> str:\n    \"\"\"Uses Postman for testing the API.\n\n    :param api: A string representing the API.\n    :return: A string indicating the result of the testing.\n    :raises ValueError: If the API is not provided.\"\"\"\n    pass\n", "function_schema_json": [{"name": "create_api_with_fastapi", "description": "Creates an API using the FastAPI framework.", "parameters": {"type": "object", "properties": {"routes": {"type": "array", "description": "A list of API routes definitions."}, "framework": {"type": "string", "description": "The web framework to use (should be 'fastapi')."}}, "required": ["routes", "framework"], "additionalProperties": false}}, {"name": "create_api_with_flask", "description": "Creates an API using the Flask framework.", "parameters": {"type": "object", "properties": {"routes": {"type": "array", "description": "A list of API routes definitions."}, "framework": {"type": "string", "description": "The web framework to use (should be 'flask')."}}, "required": ["routes", "framework"], "additionalProperties": false}}, {"name": "setup_load_testing_with_locust", "description": "Sets up load testing using Locust based on a given scenario.", "parameters": {"type": "object", "properties": {"scenario": {"type": "string", "description": "A string describing the load testing scenario."}}, "required": ["scenario"], "additionalProperties": false}}, {"name": "run_load_test", "description": "Runs a load test using a pre-defined test plan.", "parameters": {"type": "object", "properties": {"test_plan": {"type": "string", "description": "A string representing the test plan."}}, "required": ["test_plan"], "additionalProperties": false}}, {"name": "analyze_load_test_results", "description": "Analyzes the results of a load test.", "parameters": {"type": "object", "properties": {"results": {"type": "array", "description": "A list of load test results."}}, "required": ["results"], "additionalProperties": false}}, {"name": "generate_api_documentation", "description": "Generates API documentation.", "parameters": {"type": "object", "properties": {"api": {"type": "string", "description": "A string representing the API."}}, "required": ["api"], "additionalProperties": false}}, {"name": "use_postman_for_testing", "description": "Uses Postman for testing the API.", "parameters": {"type": "object", "properties": {"api": {"type": "string", "description": "A string representing the API."}}, "required": ["api"], "additionalProperties": false}}], "mock_functions": "def create_api_with_fastapi(routes: list, framework: str) -> dict:\n    \"\"\"\n    Creates an API using the FastAPI framework.\n    \n    :param routes: A list of API routes definitions.\n    :param framework: The web framework to use (should be 'fastapi').\n    :return:\n        dict: A dictionary with the following keys:\n            - status (str): The status of API creation (\"success\" or \"failure\").\n            - message (str): A message indicating the result.\n    :raises ValueError: If the framework is not 'fastapi' or routes are not provided.\n    \"\"\"\n    if framework != 'fastapi':\n        raise ValueError(\"Unsupported framework. Please use 'fastapi'.\")\n    if not routes:\n        raise ValueError(\"Routes must be provided.\")\n    return {\n        \"status\": \"success\",\n        \"message\": \"API successfully created using FastAPI.\"\n    }\ndef create_api_with_flask(routes: list, framework: str) -> dict:\n    \"\"\"\n    Creates an API using the Flask framework.\n    \n    :param routes: A list of API routes definitions.\n    :param framework: The web framework to use (should be 'flask').\n    :return:\n        dict: A dictionary with the following keys:\n            - status (str): The status of API creation (\"success\" or \"failure\").\n            - message (str): A message indicating the result.\n    :raises ValueError: If the framework is not 'flask' or routes are not provided.\n    \"\"\"\n    if framework != 'flask':\n        raise ValueError(\"Unsupported framework. Please use 'flask'.\")\n    if not routes:\n        raise ValueError(\"Routes must be provided.\")\n    return {\n        \"status\": \"success\",\n        \"message\": \"API successfully created using Flask.\"\n    }\ndef setup_load_testing_with_locust(scenario: str) -> str:\n    \"\"\"\n    Sets up load testing using Locust based on a given scenario.\n    \n    :param scenario: A string describing the load testing scenario.\n    :return: A string indicating the result of the setup.\n    :raises RuntimeError: If the scenario description is empty.\n    \"\"\"\n    if not scenario:\n        raise RuntimeError(\"Scenario must be provided.\")\n    return \"Locust setup for the load testing scenario is complete.\"\ndef run_load_test(test_plan: str) -> dict:\n    \"\"\"\n    Runs a load test using a pre-defined test plan.\n    \n    :param test_plan: A string representing the test plan.\n    :return:\n        dict: A dictionary with the following keys:\n            - result (str): The result of the load test (\"pass\" or \"fail\").\n            - message (str): A message indicating the result.\n    :raises ValueError: If the test plan is not provided.\n    \"\"\"\n    if not test_plan:\n        raise ValueError(\"Test plan must be provided.\")\n    return {\n        \"result\": \"pass\",\n        \"message\": \"Load test executed successfully and passed.\"\n    }\ndef analyze_load_test_results(results: list) -> dict:\n    \"\"\"\n    Analyzes the results of a load test.\n    \n    :param results: A list of load test results.\n    :return:\n        dict: A dictionary with the following keys:\n            - passed (bool): Whether the load test passed.\n            - performance (dict): A dictionary containing performance metrics.\n    :raises ValueError: If results are not provided.\n    \"\"\"\n    if not results:\n        raise ValueError(\"Results must be provided.\")\n    return {\n        \"passed\": True,\n        \"performance\": {\n            \"throughput\": 1000.5,\n            \"response_time\": 250.0,\n            \"error_rate\": 0.01\n        }\n    }\ndef generate_api_documentation(api: str) -> str:\n    \"\"\"\n    Generates API documentation.\n    \n    :param api: A string representing the API.\n    :return: A string representing the API documentation.\n    :raises ValueError: If the API is not provided.\n    \"\"\"\n    if not api:\n        raise ValueError(\"API must be provided.\")\n    return \"Documentation for API is generated and available.\"\ndef use_postman_for_testing(api: str) -> str:\n    \"\"\"\n    Uses Postman for testing the API.\n    \n    :param api: A string representing the API.\n    :return: A string indicating the result of the testing.\n    :raises ValueError: If the API is not provided.\n    \"\"\"\n    if not api:\n        raise ValueError(\"API must be provided.\")\n    return \"API testing with Postman is complete.\"", "user_query": "Can you setup a load testing scenario with locust for \"1000 concurrent users accessing health tracking endpoints\"?", "checklist": {"functions": ["setup_load_testing_with_locust"], "values": ["Locust setup for the load testing scenario is complete."]}}
{"difficulty": "easy", "function_schema_python": "def get_api_specification(url: str) -> dict:\n    \"\"\"Retrieves the OpenAPI specification from the provided URL.\n\n    :param url: The URL where the OpenAPI specification is hosted.\n    :return:\n        dict: A dictionary representing the OpenAPI specification with the following keys:\n            - info (dict): Information about the API.\n            - paths (dict): Paths and their operations.\n            - components (dict): Reusable components like schemas.\n    :raises ValueError: If the URL is incorrect or if the specification cannot be retrieved.\"\"\"\n    pass\ndef test_order_api(endpoint: str, method: str, payload: dict) -> dict:\n    \"\"\"Tests the Order Management API endpoint with a specific HTTP method and payload.\n\n    :param endpoint: The API endpoint to test (e.g., \"/orders\").\n    :param method: The HTTP method to use (e.g., \"GET\", \"POST\", \"PUT\", \"DELETE\").\n    :param payload: The payload to send with the request (valid only for POST and PUT).\n    :return:\n        dict: A dictionary representing the API response with the following keys:\n            - status (int): The HTTP status code.\n            - data (dict or list): The response data.\n            - headers (dict): The response headers.\n    :raises ValueError: If the endpoint, method, or payload is invalid.\"\"\"\n    pass\ndef simulate_high_load_tests(concurrent_requests: int) -> dict:\n    \"\"\"Simulates high load testing on the Order Management API.\n\n    :param concurrent_requests: The number of concurrent requests to simulate.\n    :return:\n        dict: A dictionary representing the test results with the following keys:\n            - success_rate (float): The percentage of successful requests.\n            - avg_response_time (float): The average response time in milliseconds.\n            - max_response_time (float): The maximum response time in milliseconds.\n    :raises ValueError: If the number of concurrent requests is invalid.\"\"\"\n    pass\n", "function_schema_json": [{"name": "get_api_specification", "description": "Retrieves the OpenAPI specification from the provided URL.", "parameters": {"type": "object", "properties": {"url": {"type": "string", "description": "The URL where the OpenAPI specification is hosted."}}, "required": ["url"], "additionalProperties": false}}, {"name": "test_order_api", "description": "Tests the Order Management API endpoint with a specific HTTP method and payload.", "parameters": {"type": "object", "properties": {"endpoint": {"type": "string", "description": "The API endpoint to test (e.g., \"/orders\")."}, "method": {"type": "string", "description": "The HTTP method to use (e.g., \"GET\", \"POST\", \"PUT\", \"DELETE\")."}, "payload": {"type": "object", "description": "The payload to send with the request (valid only for POST and PUT)."}}, "required": ["endpoint", "method", "payload"], "additionalProperties": false}}, {"name": "simulate_high_load_tests", "description": "Simulates high load testing on the Order Management API.", "parameters": {"type": "object", "properties": {"concurrent_requests": {"type": "integer", "description": "The number of concurrent requests to simulate."}}, "required": ["concurrent_requests"], "additionalProperties": false}}], "mock_functions": "def get_api_specification(url: str) -> dict:\n    \"\"\"\n    Retrieves the OpenAPI specification from the provided URL.\n    \n    :param url: The URL where the OpenAPI specification is hosted.\n    :return:\n        dict: A dictionary representing the OpenAPI specification with the following keys:\n            - info (dict): Information about the API.\n            - paths (dict): Paths and their operations.\n            - components (dict): Reusable components like schemas.\n    :raises ValueError: If the URL is incorrect or if the specification cannot be retrieved.\n    \"\"\"\n    if url == \"https://acmecorp.com/api/om-42/openapi.yaml\":\n        return {\n            \"info\": {\"title\": \"Order Management API\", \"version\": \"1.0.0\"},\n            \"paths\": {\n                \"/orders\": {\n                    \"get\": {\"summary\": \"Retrieve a list of orders\", \"operationId\": \"getOrders\"},\n                    \"post\": {\"summary\": \"Place a new order\", \"operationId\": \"placeOrder\"},\n                    \"put\": {\"summary\": \"Update an existing order\", \"operationId\": \"updateOrder\"},\n                    \"delete\": {\"summary\": \"Cancel an order\", \"operationId\": \"cancelOrder\"}\n                }\n            },\n            \"components\": {\n                \"schemas\": {\n                    \"Order\": {\n                        \"type\": \"object\",\n                        \"properties\": {\n                            \"orderId\": {\"type\": \"string\"},\n                            \"customerId\": {\"type\": \"string\"},\n                            \"items\": {\"type\": \"array\", \"items\": {\"type\": \"object\"}},\n                            \"status\": {\"type\": \"string\"}\n                        }\n                    }\n                }\n            }\n        }\n    raise ValueError(\"Incorrect URL or unable to retrieve the specification.\")\ndef test_order_api(endpoint: str, method: str, payload: dict = None) -> dict:\n    \"\"\"\n    Tests the Order Management API endpoint with a specific HTTP method and payload.\n    \n    :param endpoint: The API endpoint to test (e.g., \"/orders\").\n    :param method: The HTTP method to use (e.g., \"GET\", \"POST\", \"PUT\", \"DELETE\").\n    :param payload: The payload to send with the request (valid only for POST and PUT).\n    :return:\n        dict: A dictionary representing the API response with the following keys:\n            - status (int): The HTTP status code.\n            - data (dict or list): The response data.\n            - headers (dict): The response headers.\n    :raises ValueError: If the endpoint, method, or payload is invalid.\n    \"\"\"\n    if endpoint != \"/orders\":\n        raise ValueError(\"Invalid endpoint.\")\n    \n    valid_methods = [\"GET\", \"POST\", \"PUT\", \"DELETE\"]\n    if method not in valid_methods:\n        raise ValueError(\"Invalid HTTP method.\")\n    \n    response = {\n        \"status\": None,\n        \"data\": None,\n        \"headers\": {\"Content-Type\": \"application/json\"}\n    }\n    \n    if method == \"GET\":\n        response[\"status\"] = 200\n        response[\"data\"] = [{\"orderId\": \"1\", \"customerId\": \"C-101\", \"items\": [{\"itemId\": \"I-201\", \"quantity\": 2}], \"status\": \"Processing\"}]\n        \n    elif method == \"POST\":\n        if not payload:\n            raise ValueError(\"Payload is required for POST method.\")\n        response[\"status\"] = 201\n        response[\"data\"] = {**payload, \"orderId\": str(random.randint(1000, 9999)), \"status\": \"Received\"}\n        \n    elif method == \"PUT\":\n        if not payload:\n            raise ValueError(\"Payload is required for PUT method.\")\n        response[\"status\"] = 200\n        response[\"data\"] = {**payload, \"status\": \"Updated\"}\n        \n    elif method == \"DELETE\":\n        response[\"status\"] = 204\n        response[\"data\"] = {}\n    \n    return response\ndef simulate_high_load_tests(concurrent_requests: int) -> dict:\n    \"\"\"\n    Simulates high load testing on the Order Management API.\n    \n    :param concurrent_requests: The number of concurrent requests to simulate.\n    :return:\n        dict: A dictionary representing the test results with the following keys:\n            - success_rate (float): The percentage of successful requests.\n            - avg_response_time (float): The average response time in milliseconds.\n            - max_response_time (float): The maximum response time in milliseconds.\n    :raises ValueError: If the number of concurrent requests is invalid.\n    \"\"\"\n    if concurrent_requests <= 0:\n        raise ValueError(\"Number of concurrent requests must be greater than zero.\")\n    \n    # Simulate random success rates and response times for a high load test\n    success_count = random.randint(80, concurrent_requests)\n    response_times = [random.uniform(50, 1000) for _ in range(success_count)] + [random.uniform(1000, 5000) for _ in range(concurrent_requests - success_count)]\n    \n    return {\n        \"success_rate\": (success_count / concurrent_requests) * 100,\n        \"avg_response_time\": sum(response_times) / len(response_times) if response_times else 0,\n        \"max_response_time\": max(response_times) if response_times else 0\n    }", "user_query": "Can you retrieve the OpenAPI specification for the Order Management API (API ID: OM-42) from `https://acmecorp.com/api/om-42/openapi.yaml`?", "checklist": {"functions": ["get_api_specification"], "values": [{"info": {"title": "Order Management API", "version": "1.0.0"}, "paths": {"/orders": {"get": {"summary": "Retrieve a list of orders", "operationId": "getOrders"}, "post": {"summary": "Place a new order", "operationId": "placeOrder"}, "put": {"summary": "Update an existing order", "operationId": "updateOrder"}, "delete": {"summary": "Cancel an order", "operationId": "cancelOrder"}}}, "components": {"schemas": {"Order": {"type": "object", "properties": {"orderId": {"type": "string"}, "customerId": {"type": "string"}, "items": {"type": "array", "items": {"type": "object"}}, "status": {"type": "string"}}}}}}]}}
{"difficulty": "easy", "function_schema_python": "def generate_api_template(api_name: str, features: List[str]) -> Dict[str, Any]:\n    \"\"\"Generates a basic API template with specified features.\n\n    :param api_name: The name of the API.\n    :param features: A list of features to include (e.g., \"authentication\", \"authorization\").\n    :return: A dictionary containing the generated API template.\n        - endpoints (list[str]): List of API endpoints.\n        - security (dict): Security configurations.\n        - schema (dict): API schema definition.\n    :raises ValueError: If api_name is empty or features is not a list.\"\"\"\n    pass\ndef design_api_architecture(api_name: str, scalability_requirements: str) -> str:\n    \"\"\"Designs the API architecture based on scalability requirements.\n\n    :param api_name: The name of the API.\n    :param scalability_requirements: A string describing the scalability needs.\n    :return: A string describing the designed architecture.\n    :raises ValueError: If api_name or scalability_requirements is empty.\"\"\"\n    pass\ndef define_api_endpoints(api_name: str, functionalities: List[str]) -> List[str]:\n    \"\"\"Defines the API endpoints based on required functionalities.\n\n    :param api_name: The name of the API.\n    :param functionalities: A list of functionalities the API should support.\n    :return: A list of defined API endpoints.\n    :raises ValueError: If api_name is empty or functionalities is not a list.\"\"\"\n    pass\ndef ensure_api_security(api_name: str, security_standards: str) -> bool:\n    \"\"\"Ensures the API meets the specified security standards.\n\n    :param api_name: The name of the API.\n    :param security_standards: A string describing the security standards to adhere to.\n    :return: True if the API meets the standards, False otherwise.\n    :raises ValueError: If api_name or security_standards is empty.\"\"\"\n    pass\n", "function_schema_json": [{"name": "generate_api_template", "description": "Generates a basic API template with specified features.", "parameters": {"type": "object", "properties": {"api_name": {"type": "string", "description": "The name of the API."}, "features": {"type": "array", "items": {"type": "string"}, "description": "A list of features to include (e.g., \"authentication\", \"authorization\")."}}, "required": ["api_name", "features"], "additionalProperties": false}}, {"name": "design_api_architecture", "description": "Designs the API architecture based on scalability requirements.", "parameters": {"type": "object", "properties": {"api_name": {"type": "string", "description": "The name of the API."}, "scalability_requirements": {"type": "string", "description": "A string describing the scalability needs."}}, "required": ["api_name", "scalability_requirements"], "additionalProperties": false}}, {"name": "define_api_endpoints", "description": "Defines the API endpoints based on required functionalities.", "parameters": {"type": "object", "properties": {"api_name": {"type": "string", "description": "The name of the API."}, "functionalities": {"type": "array", "items": {"type": "string"}, "description": "A list of functionalities the API should support."}}, "required": ["api_name", "functionalities"], "additionalProperties": false}}, {"name": "ensure_api_security", "description": "Ensures the API meets the specified security standards.", "parameters": {"type": "object", "properties": {"api_name": {"type": "string", "description": "The name of the API."}, "security_standards": {"type": "string", "description": "A string describing the security standards to adhere to."}}, "required": ["api_name", "security_standards"], "additionalProperties": false}}], "mock_functions": "def generate_api_template(api_name: str, features: List[str]) -> Dict[str, Any]:\n    \"\"\"\n    Generates a basic API template with specified features.\n\n    :param api_name: The name of the API.\n    :param features: A list of features to include (e.g., \"authentication\", \"authorization\").\n    :return: A dictionary containing the generated API template.\n        - endpoints (list[str]): List of API endpoints.\n        - security (dict): Security configurations.\n        - schema (dict): API schema definition.\n    :raises ValueError: If api_name is empty or features is not a list.\n    \"\"\"\n    if not api_name:\n        raise ValueError(\"API name cannot be empty.\")\n    if not isinstance(features, list):\n        raise ValueError(\"Features must be a list.\")\n\n    if api_name == \"Eclipse\" and \"authentication\" in features and \"authorization\" in features:\n        return {\n            \"endpoints\": [\"/inventory\", \"/shipping\", \"/orders\"],\n            \"security\": {\"auth_type\": \"OAuth2\", \"token_url\": \"/auth/token\"},\n            \"schema\": {\"/inventory\": {\"GET\": {}, \"POST\": {}}, \"/shipping\": {\"GET\": {}, \"POST\": {}}, \"/orders\": {\"GET\": {}, \"POST\": {}}}\n        }\n    return {}\ndef design_api_architecture(api_name: str, scalability_requirements: str) -> str:\n    \"\"\"\n    Designs the API architecture based on scalability requirements.\n\n    :param api_name: The name of the API.\n    :param scalability_requirements: A string describing the scalability needs.\n    :return: A string describing the designed architecture.\n    :raises ValueError: If api_name or scalability_requirements is empty.\n    \"\"\"\n    if not api_name or not scalability_requirements:\n        raise ValueError(\"API name and scalability requirements cannot be empty.\")\n    \n    if api_name == \"Eclipse\" and \"high\" in scalability_requirements.lower():\n        return \"Microservices architecture with load balancing and distributed database.\"\n    return \"\"\ndef define_api_endpoints(api_name: str, functionalities: List[str]) -> List[str]:\n    \"\"\"\n    Defines the API endpoints based on required functionalities.\n\n    :param api_name: The name of the API.\n    :param functionalities: A list of functionalities the API should support.\n    :return: A list of defined API endpoints.\n    :raises ValueError: If api_name is empty or functionalities is not a list.\n    \"\"\"\n    if not api_name:\n        raise ValueError(\"API name cannot be empty.\")\n    if not isinstance(functionalities, list):\n        raise ValueError(\"Functionalities must be a list.\")\n\n    if api_name == \"Eclipse\" and \"inventory management\" in functionalities and \"shipping integration\" in functionalities:\n        return [\"/inventory\", \"/shipping\", \"/orders\"]\n    return []\ndef ensure_api_security(api_name: str, security_standards: str) -> bool:\n    \"\"\"\n    Ensures the API meets the specified security standards.\n\n    :param api_name: The name of the API.\n    :param security_standards: A string describing the security standards to adhere to.\n    :return: True if the API meets the standards, False otherwise.\n    :raises ValueError: If api_name or security_standards is empty.\n    \"\"\"\n    if not api_name or not security_standards:\n        raise ValueError(\"API name and security standards cannot be empty.\")\n    \n    if api_name == \"Eclipse\" and \"OAuth2\" in security_standards:\n        return True\n    return False", "user_query": "CodeGenie, I need an API template for \"Eclipse\" with authentication and authorization.", "checklist": {"functions": ["generate_api_template"], "values": [{"endpoints": ["/inventory", "/shipping", "/orders"], "security": {"auth_type": "OAuth2", "token_url": "/auth/token"}, "schema": {"/inventory": {"GET": {}, "POST": {}}, "/shipping": {"GET": {}, "POST": {}}, "/orders": {"GET": {}, "POST": {}}}}]}}
{"difficulty": "easy", "function_schema_python": "def search_flights(origin: str, destination: str, month: str, num_people: int) -> List[Dict]:\n    \"\"\"Searches for flights based on specified criteria.\n\n    :param origin: The origin airport (e.g., \"Sydney\").\n    :param destination: The destination airport (e.g., \"Denpasar\").\n    :param month: The travel month (e.g., \"December\").\n    :param num_people: The number of passengers.\n    :return: A list of flight dictionaries. Each dictionary contains:\n        - airline (str): The airline name.\n        - price (float): The flight price.\n        - departure_time (str): The departure time.\n        - arrival_time (str): The arrival time.\"\"\"\n    pass\ndef search_hotels(location: str, num_people: int, max_price: float) -> List[Dict]:\n    \"\"\"Searches for hotels based on specified criteria.\n\n    :param location: The desired location (e.g., \"Seminyak beach\").\n    :param num_people: The number of guests.\n    :param max_price: The maximum price for the stay.\n    :return: A list of hotel dictionaries. Each dictionary contains:\n        - name (str): The hotel name.\n        - price_per_night (float): The price per night.\n        - rating (float): The hotel rating.\"\"\"\n    pass\ndef web_search(query: str, search_engine: str) -> List[str]:\n    \"\"\"Performs a web search using the specified search engine.\n\n    :param query: The search query string.\n    :param search_engine: The search engine to use, can be \"serper\", \"duckduckgo\" or \"bind\". Defaults to \"serper\".\n    :return: A list of URLs representing search results.\n    :raises ValueError: If the specified search engine is invalid.\"\"\"\n    pass\n", "function_schema_json": [{"name": "search_flights", "description": "Searches for flights based on specified criteria.", "parameters": {"type": "object", "properties": {"origin": {"type": "string", "description": "The origin airport (e.g., \"Sydney\")."}, "destination": {"type": "string", "description": "The destination airport (e.g., \"Denpasar\")."}, "month": {"type": "string", "description": "The travel month (e.g., \"December\")."}, "num_people": {"type": "integer", "description": "The number of passengers."}}, "required": ["origin", "destination", "month", "num_people"], "additionalProperties": false}}, {"name": "search_hotels", "description": "Searches for hotels based on specified criteria.", "parameters": {"type": "object", "properties": {"location": {"type": "string", "description": "The desired location (e.g., \"Seminyak beach\")."}, "num_people": {"type": "integer", "description": "The number of guests."}, "max_price": {"type": "number", "description": "The maximum price for the stay."}}, "required": ["location", "num_people", "max_price"], "additionalProperties": false}}, {"name": "web_search", "description": "Performs a web search using the specified search engine.", "parameters": {"type": "object", "properties": {"query": {"type": "string", "description": "The search query string."}, "search_engine": {"type": "string", "description": "The search engine to use, can be \"serper\", \"duckduckgo\" or \"bind\". Defaults to \"serper\"."}}, "required": ["query", "search_engine"], "additionalProperties": false}}], "mock_functions": "def search_flights(origin: str, destination: str, month: str, num_people: int) -> List[Dict]:\n    \"\"\"\n    Searches for flights based on specified criteria.\n\n    :param origin: The origin airport (e.g., \"Sydney\").\n    :param destination: The destination airport (e.g., \"Denpasar\").\n    :param month: The travel month (e.g., \"December\").\n    :param num_people: The number of passengers.\n    :return: A list of flight dictionaries. Each dictionary contains:\n        - airline (str): The airline name.\n        - price (float): The flight price.\n        - departure_time (str): The departure time.\n        - arrival_time (str): The arrival time.\n    \"\"\"\n    if origin == \"Sydney\" and destination == \"Denpasar\" and month == \"December\" and num_people == 4:\n        return [\n            {\"airline\": \"Qantas\", \"price\": 1200.00, \"departure_time\": \"10:00 AM\", \"arrival_time\": \"2:00 PM\"},\n            {\"airline\": \"Jetstar\", \"price\": 1000.00, \"departure_time\": \"1:00 PM\", \"arrival_time\": \"5:00 PM\"}\n        ]\n    return []\ndef search_hotels(location: str, num_people: int, max_price: float) -> List[Dict]:\n    \"\"\"\n    Searches for hotels based on specified criteria.\n\n    :param location: The desired location (e.g., \"Seminyak beach\").\n    :param num_people: The number of guests.\n    :param max_price: The maximum price for the stay.\n    :return: A list of hotel dictionaries. Each dictionary contains:\n        - name (str): The hotel name.\n        - price_per_night (float): The price per night.\n        - rating (float): The hotel rating.\n    \"\"\"\n    if location == \"Seminyak beach\" and num_people == 4 and max_price == 3000.00:\n        return [\n            {\"name\": \"The Oberoi\", \"price_per_night\": 300.00, \"rating\": 4.5},\n            {\"name\": \"W Bali - Seminyak\", \"price_per_night\": 250.00, \"rating\": 4.0}\n        ]\n    return []\ndef web_search(query: str, search_engine: str = \"serper\") -> List[str]:\n    \"\"\"Performs a web search using the specified search engine.\n    \n    :param query: The search query string.\n    :param search_engine: The search engine to use, can be \"serper\", \"duckduckgo\" or \"bind\". Defaults to \"serper\".\n    :return: A list of URLs representing search results.\n    :raises ValueError: If the specified search engine is invalid.\n    \"\"\"\n\n    valid_search_engines = [\"serper\", \"duckduckgo\", \"bind\"]\n    if search_engine not in valid_search_engines:\n        raise ValueError(\"Invalid search engine specified.\")\n\n    if query == \"Find me flights from Sydney to Denpasar in December for four people, and suggest family-friendly hotels near Seminyak beach, Bali, with prices under $3000 AUD total.\" and search_engine in valid_search_engines:\n        return [\"https://example.com/flights\", \"https://example.com/hotels\"]\n    return []", "user_query": "Search for flights from Sydney to Denpasar in December for 4 people.", "checklist": {"functions": ["search_flights"], "values": [[{"airline": "Qantas", "price": 1200.0, "departure_time": "10:00 AM", "arrival_time": "2:00 PM"}, {"airline": "Jetstar", "price": 1000.0, "departure_time": "1:00 PM", "arrival_time": "5:00 PM"}]]}}
{"difficulty": "easy", "function_schema_python": "def search_flights(origin: str, destination: str, month: str, num_people: int) -> List[Dict]:\n    \"\"\"Searches for flights based on specified criteria.\n\n    :param origin: The origin airport (e.g., \"Sydney\").\n    :param destination: The destination airport (e.g., \"Denpasar\").\n    :param month: The travel month (e.g., \"December\").\n    :param num_people: The number of passengers.\n    :return: A list of flight dictionaries. Each dictionary contains:\n        - airline (str): The airline name.\n        - price (float): The flight price.\n        - departure_time (str): The departure time.\n        - arrival_time (str): The arrival time.\"\"\"\n    pass\ndef search_hotels(location: str, num_people: int, max_price: float) -> List[Dict]:\n    \"\"\"Searches for hotels based on specified criteria.\n\n    :param location: The desired location (e.g., \"Seminyak beach\").\n    :param num_people: The number of guests.\n    :param max_price: The maximum price for the stay.\n    :return: A list of hotel dictionaries. Each dictionary contains:\n        - name (str): The hotel name.\n        - price_per_night (float): The price per night.\n        - rating (float): The hotel rating.\"\"\"\n    pass\ndef web_search(query: str, search_engine: str) -> List[str]:\n    \"\"\"Performs a web search using the specified search engine.\n\n    :param query: The search query string.\n    :param search_engine: The search engine to use, can be \"serper\", \"duckduckgo\" or \"bind\". Defaults to \"serper\".\n    :return: A list of URLs representing search results.\n    :raises ValueError: If the specified search engine is invalid.\"\"\"\n    pass\n", "function_schema_json": [{"name": "search_flights", "description": "Searches for flights based on specified criteria.", "parameters": {"type": "object", "properties": {"origin": {"type": "string", "description": "The origin airport (e.g., \"Sydney\")."}, "destination": {"type": "string", "description": "The destination airport (e.g., \"Denpasar\")."}, "month": {"type": "string", "description": "The travel month (e.g., \"December\")."}, "num_people": {"type": "integer", "description": "The number of passengers."}}, "required": ["origin", "destination", "month", "num_people"], "additionalProperties": false}}, {"name": "search_hotels", "description": "Searches for hotels based on specified criteria.", "parameters": {"type": "object", "properties": {"location": {"type": "string", "description": "The desired location (e.g., \"Seminyak beach\")."}, "num_people": {"type": "integer", "description": "The number of guests."}, "max_price": {"type": "number", "description": "The maximum price for the stay."}}, "required": ["location", "num_people", "max_price"], "additionalProperties": false}}, {"name": "web_search", "description": "Performs a web search using the specified search engine.", "parameters": {"type": "object", "properties": {"query": {"type": "string", "description": "The search query string."}, "search_engine": {"type": "string", "description": "The search engine to use, can be \"serper\", \"duckduckgo\" or \"bind\". Defaults to \"serper\"."}}, "required": ["query", "search_engine"], "additionalProperties": false}}], "mock_functions": "def search_flights(origin: str, destination: str, month: str, num_people: int) -> List[Dict]:\n    \"\"\"\n    Searches for flights based on specified criteria.\n\n    :param origin: The origin airport (e.g., \"Sydney\").\n    :param destination: The destination airport (e.g., \"Denpasar\").\n    :param month: The travel month (e.g., \"December\").\n    :param num_people: The number of passengers.\n    :return: A list of flight dictionaries. Each dictionary contains:\n        - airline (str): The airline name.\n        - price (float): The flight price.\n        - departure_time (str): The departure time.\n        - arrival_time (str): The arrival time.\n    \"\"\"\n    if origin == \"Sydney\" and destination == \"Denpasar\" and month == \"December\" and num_people == 4:\n        return [\n            {\"airline\": \"Qantas\", \"price\": 1200.00, \"departure_time\": \"10:00 AM\", \"arrival_time\": \"2:00 PM\"},\n            {\"airline\": \"Jetstar\", \"price\": 1000.00, \"departure_time\": \"1:00 PM\", \"arrival_time\": \"5:00 PM\"}\n        ]\n    return []\ndef search_hotels(location: str, num_people: int, max_price: float) -> List[Dict]:\n    \"\"\"\n    Searches for hotels based on specified criteria.\n\n    :param location: The desired location (e.g., \"Seminyak beach\").\n    :param num_people: The number of guests.\n    :param max_price: The maximum price for the stay.\n    :return: A list of hotel dictionaries. Each dictionary contains:\n        - name (str): The hotel name.\n        - price_per_night (float): The price per night.\n        - rating (float): The hotel rating.\n    \"\"\"\n    if location == \"Seminyak beach\" and num_people == 4 and max_price == 3000.00:\n        return [\n            {\"name\": \"The Oberoi\", \"price_per_night\": 300.00, \"rating\": 4.5},\n            {\"name\": \"W Bali - Seminyak\", \"price_per_night\": 250.00, \"rating\": 4.0}\n        ]\n    return []\ndef web_search(query: str, search_engine: str = \"serper\") -> List[str]:\n    \"\"\"Performs a web search using the specified search engine.\n    \n    :param query: The search query string.\n    :param search_engine: The search engine to use, can be \"serper\", \"duckduckgo\" or \"bind\". Defaults to \"serper\".\n    :return: A list of URLs representing search results.\n    :raises ValueError: If the specified search engine is invalid.\n    \"\"\"\n\n    valid_search_engines = [\"serper\", \"duckduckgo\", \"bind\"]\n    if search_engine not in valid_search_engines:\n        raise ValueError(\"Invalid search engine specified.\")\n\n    if query == \"Find me flights from Sydney to Denpasar in December for four people, and suggest family-friendly hotels near Seminyak beach, Bali, with prices under $3000 AUD total.\" and search_engine in valid_search_engines:\n        return [\"https://example.com/flights\", \"https://example.com/hotels\"]\n    return []", "user_query": "Find hotels near Seminyak beach for 4 people with a maximum budget of 3000.00 AUD.", "checklist": {"functions": ["search_hotels"], "values": [[{"name": "The Oberoi", "price_per_night": 300.0, "rating": 4.5}, {"name": "W Bali - Seminyak", "price_per_night": 250.0, "rating": 4.0}]]}}
{"difficulty": "easy", "function_schema_python": "def search_google_images(query: str, location: str, resolution: str) -> dict:\n    \"\"\"Searches Google Images (mocked as 'serper') for high-resolution images based on the query and location.\n\n    :param query: The search term (e.g., \"modern architecture\").\n    :param location: The specific location to search for images (e.g., \"New York City\").\n    :param resolution: The required image resolution (e.g., \"high\").\n    :return:\n        dict: A dictionary with the following keys:\n            - images (list[str]): List of URLs to the images.\n            - architects (list[str]): List of architects related to the images.\n            - buildings (list[str]): List of building names featured in the images.\n            - usage_rights (dict[str, str]): Dictionary with usage rights details.\n            - suggestions (list[str]): List of similar search suggestions.\n    :raises ValueError: If any parameter is empty.\"\"\"\n    pass\ndef search_duckduckgo_images(query: str, location: str, resolution: str) -> dict:\n    \"\"\"Searches DuckDuckGo for high-resolution images based on the query and location.\n\n    :param query: The search term (e.g., \"modern architecture\").\n    :param location: The specific location to search for images (e.g., \"New York City\").\n    :param resolution: The required image resolution (e.g., \"high\").\n    :return:\n        dict: A dictionary with the following keys:\n            - images (list[str]): List of URLs to the images.\n            - architects (list[str]): List of architects related to the images.\n            - buildings (list[str]): List of building names featured in the images.\n            - usage_rights (dict[str, str]): Dictionary with usage rights details.\n            - suggestions (list[str]): List of similar search suggestions.\n    :raises ValueError: If any parameter is empty.\"\"\"\n    pass\ndef bind_search_results(searcher1: dict, searcher2: dict) -> dict:\n    \"\"\"Binds and combines search results from two different searchers ('serper' and 'duckduckgo').\n\n    :param searcher1: The results dictionary from the first searcher.\n    :param searcher2: The results dictionary from the second searcher.\n    :return:\n        dict: A dictionary containing combined results with the following keys:\n            - images (list[str]): Combined list of URLs to the images.\n            - architects (list[str]): Combined list of architects related to the images.\n            - buildings (list[str]): Combined list of building names featured in the images.\n            - usage_rights (list[dict[str, str]]): Combined list of dictionaries with usage rights details.\n            - suggestions (list[str]): Combined list of similar search suggestions.\"\"\"\n    pass\n", "function_schema_json": [{"name": "search_google_images", "description": "Searches Google Images (mocked as 'serper') for high-resolution images based on the query and location.", "parameters": {"type": "object", "properties": {"query": {"type": "string", "description": "The search term (e.g., \"modern architecture\")."}, "location": {"type": "string", "description": "The specific location to search for images (e.g., \"New York City\")."}, "resolution": {"type": "string", "description": "The required image resolution (e.g., \"high\")."}}, "required": ["query", "location", "resolution"], "additionalProperties": false}}, {"name": "search_duckduckgo_images", "description": "Searches DuckDuckGo for high-resolution images based on the query and location.", "parameters": {"type": "object", "properties": {"query": {"type": "string", "description": "The search term (e.g., \"modern architecture\")."}, "location": {"type": "string", "description": "The specific location to search for images (e.g., \"New York City\")."}, "resolution": {"type": "string", "description": "The required image resolution (e.g., \"high\")."}}, "required": ["query", "location", "resolution"], "additionalProperties": false}}, {"name": "bind_search_results", "description": "Binds and combines search results from two different searchers ('serper' and 'duckduckgo').", "parameters": {"type": "object", "properties": {"searcher1": {"type": "object", "description": "The results dictionary from the first searcher."}, "searcher2": {"type": "object", "description": "The results dictionary from the second searcher."}}, "required": ["searcher1", "searcher2"], "additionalProperties": false}}], "mock_functions": "def search_google_images(query: str, location: str, resolution: str) -> dict:\n    \"\"\"\n    Searches Google Images (mocked as 'serper') for high-resolution images based on the query and location.\n    \n    :param query: The search term (e.g., \"modern architecture\").\n    :param location: The specific location to search for images (e.g., \"New York City\").\n    :param resolution: The required image resolution (e.g., \"high\").\n    :return:\n        dict: A dictionary with the following keys:\n            - images (list[str]): List of URLs to the images.\n            - architects (list[str]): List of architects related to the images.\n            - buildings (list[str]): List of building names featured in the images.\n            - usage_rights (dict[str, str]): Dictionary with usage rights details.\n            - suggestions (list[str]): List of similar search suggestions.\n    :raises ValueError: If any parameter is empty.\n    \"\"\"\n    if not query or not location or not resolution:\n        raise ValueError(\"Query, location, and resolution must be provided.\")\n    \n    if query.lower() == \"modern architecture\" and location.lower() == \"new york city\" and resolution.lower() == \"high\":\n        return {\n            \"images\": [\n                \"https://example.com/image1.jpg\",\n                \"https://example.com/image2.jpg\",\n                \"https://example.com/image3.jpg\"\n            ],\n            \"architects\": [\n                \"Frank Gehry\",\n                \"Fazlur Rahman Khan\",\n                \"Philip Johnson\"\n            ],\n            \"buildings\": [\n                \"Guggenheim Museum\",\n                \"World Trade Center\",\n                \"The Met\"\n            ],\n            \"usage_rights\": {\n                \"source\": \"Google Images\",\n                \"license\": \"Creative Commons\",\n                \"attribution\": \"Required\"\n            },\n            \"suggestions\": [\n                \"modern architecture in San Francisco\",\n                \"contemporary skyscrapers\",\n                \"NYC landmarks\"\n            ]\n        }\n    return {}\ndef search_duckduckgo_images(query: str, location: str, resolution: str) -> dict:\n    \"\"\"\n    Searches DuckDuckGo for high-resolution images based on the query and location.\n    \n    :param query: The search term (e.g., \"modern architecture\").\n    :param location: The specific location to search for images (e.g., \"New York City\").\n    :param resolution: The required image resolution (e.g., \"high\").\n    :return:\n        dict: A dictionary with the following keys:\n            - images (list[str]): List of URLs to the images.\n            - architects (list[str]): List of architects related to the images.\n            - buildings (list[str]): List of building names featured in the images.\n            - usage_rights (dict[str, str]): Dictionary with usage rights details.\n            - suggestions (list[str]): List of similar search suggestions.\n    :raises ValueError: If any parameter is empty.\n    \"\"\"\n    if not query or not location or not resolution:\n        raise ValueError(\"Query, location, and resolution must be provided.\")\n    \n    if query.lower() == \"modern architecture\" and location.lower() == \"new york city\" and resolution.lower() == \"high\":\n        return {\n            \"images\": [\n                \"https://example.com/ddg_image1.jpg\",\n                \"https://example.com/ddg_image2.jpg\",\n                \"https://example.com/ddg_image3.jpg\"\n            ],\n            \"architects\": [\n                \"I.M. Pei\",\n                \"Robert Venturi\",\n                \"Richard Meier\"\n            ],\n            \"buildings\": [\n                \"Seagram Building\",\n                \"Vanderbilt Hall\",\n                \"High Line\"\n            ],\n            \"usage_rights\": {\n                \"source\": \"DuckDuckGo\",\n                \"license\": \"Public Domain\",\n                \"attribution\": \"Optional\"\n            },\n            \"suggestions\": [\n                \"modern architecture in Los Angeles\",\n                \"famous NY buildings\",\n                \"architecture trends 2023\"\n            ]\n        }\n    return {}\ndef bind_search_results(searcher1: dict, searcher2: dict) -> dict:\n    \"\"\"\n    Binds and combines search results from two different searchers ('serper' and 'duckduckgo').\n    \n    :param searcher1: The results dictionary from the first searcher.\n    :param searcher2: The results dictionary from the second searcher.\n    :return:\n        dict: A dictionary containing combined results with the following keys:\n            - images (list[str]): Combined list of URLs to the images.\n            - architects (list[str]): Combined list of architects related to the images.\n            - buildings (list[str]): Combined list of building names featured in the images.\n            - usage_rights (list[dict[str, str]]): Combined list of dictionaries with usage rights details.\n            - suggestions (list[str]): Combined list of similar search suggestions.\n    \"\"\"\n    if not searcher1 or not searcher2:\n        raise ValueError(\"Both search results must be provided.\")\n    \n    return {\n        \"images\": searcher1[\"images\"] + searcher2[\"images\"],\n        \"architects\": list(set(searcher1[\"architects\"] + searcher2[\"architects\"])),  # Unique list\n        \"buildings\": list(set(searcher1[\"buildings\"] + searcher2[\"buildings\"])),  # Unique list\n        \"usage_rights\": [searcher1[\"usage_rights\"], searcher2[\"usage_rights\"]],\n        \"suggestions\": list(set(searcher1[\"suggestions\"] + searcher2[\"suggestions\"]))  # Unique list\n    }", "user_query": "Could you search Google Images for \"modern architecture\" in \"New York City\" with \"high\" resolution?", "checklist": {"functions": ["search_google_images"], "values": [{"images": ["https://example.com/image1.jpg", "https://example.com/image2.jpg", "https://example.com/image3.jpg"], "architects": ["Frank Gehry", "Fazlur Rahman Khan", "Philip Johnson"], "buildings": ["Guggenheim Museum", "World Trade Center", "The Met"], "usage_rights": {"source": "Google Images", "license": "Creative Commons", "attribution": "Required"}, "suggestions": ["modern architecture in San Francisco", "contemporary skyscrapers", "NYC landmarks"]}]}}
{"difficulty": "easy", "function_schema_python": "def setup_news_preferences(topics: list[str], sources: list[str], update_frequency: int) -> dict:\n    \"\"\"Sets up personalized news preferences for the user.\n\n    :param topics: List of preferred news topics (e.g., [\"tech\", \"business\"]).\n    :param sources: List of preferred news sources (e.g., [\"NYT\", \"BBC\", \"Forbes\"]).\n    :param update_frequency: Update frequency in hours.\n    :return: Dictionary containing the configured preferences.\n    :raises ValueError: If invalid parameters are provided.\"\"\"\n    pass\ndef search_news(query: str, sources: list[str]) -> dict:\n    \"\"\"Searches for news articles based on query and sources using serper API.\n\n    :param query: Search query string.\n    :param sources: List of news sources to search from.\n    :return: Dictionary containing search results.\n    :raises ValueError: If query is empty or sources are invalid.\"\"\"\n    pass\ndef get_calendar_based_news(calendar_events: list[dict], topics: list[str]) -> dict:\n    \"\"\"Suggests news articles based on upcoming calendar events.\n\n    :param calendar_events: List of calendar event dictionaries.\n    :param topics: List of preferred topics.\n    :return: Dictionary containing relevant articles for events.\n    :raises ValueError: If calendar_events is empty.\"\"\"\n    pass\n", "function_schema_json": [{"name": "setup_news_preferences", "description": "Sets up personalized news preferences for the user.", "parameters": {"type": "object", "properties": {"topics": {"type": "array", "items": {"type": "string"}, "description": "List of preferred news topics (e.g., [\"tech\", \"business\"])."}, "sources": {"type": "array", "items": {"type": "string"}, "description": "List of preferred news sources (e.g., [\"NYT\", \"BBC\", \"Forbes\"])."}, "update_frequency": {"type": "integer", "description": "Update frequency in hours."}}, "required": ["topics", "sources", "update_frequency"], "additionalProperties": false}}, {"name": "search_news", "description": "Searches for news articles based on query and sources using serper API.", "parameters": {"type": "object", "properties": {"query": {"type": "string", "description": "Search query string."}, "sources": {"type": "array", "items": {"type": "string"}, "description": "List of news sources to search from."}}, "required": ["query", "sources"], "additionalProperties": false}}, {"name": "get_calendar_based_news", "description": "Suggests news articles based on upcoming calendar events.", "parameters": {"type": "object", "properties": {"calendar_events": {"type": "array", "items": {"type": "object"}, "description": "List of calendar event dictionaries."}, "topics": {"type": "array", "items": {"type": "string"}, "description": "List of preferred topics."}}, "required": ["calendar_events", "topics"], "additionalProperties": false}}], "mock_functions": "def setup_news_preferences(topics: list[str], sources: list[str], update_frequency: int) -> dict:\n    \"\"\"\n    Sets up personalized news preferences for the user.\n    \n    :param topics: List of preferred news topics (e.g., [\"tech\", \"business\"]).\n    :param sources: List of preferred news sources (e.g., [\"NYT\", \"BBC\", \"Forbes\"]).\n    :param update_frequency: Update frequency in hours.\n    :return: Dictionary containing the configured preferences.\n    :raises ValueError: If invalid parameters are provided.\n    \"\"\"\n    valid_topics = [\"tech\", \"business\", \"politics\", \"sports\"]\n    valid_sources = [\"NYT\", \"BBC\", \"Forbes\", \"WSJ\"]\n    \n    if not all(topic.lower() in valid_topics for topic in topics):\n        raise ValueError(\"Invalid topics provided\")\n    if not all(source.upper() in valid_sources for source in sources):\n        raise ValueError(\"Invalid sources provided\")\n    if update_frequency < 1 or update_frequency > 24:\n        raise ValueError(\"Update frequency must be between 1 and 24 hours\")\n        \n    return {\n        \"preferences_id\": \"12345\",\n        \"topics\": topics,\n        \"sources\": sources,\n        \"update_frequency\": update_frequency\n    }\ndef search_news(query: str, sources: list[str]) -> dict:\n    \"\"\"\n    Searches for news articles based on query and sources using serper API.\n    \n    :param query: Search query string.\n    :param sources: List of news sources to search from.\n    :return: Dictionary containing search results.\n    :raises ValueError: If query is empty or sources are invalid.\n    \"\"\"\n    if not query or not sources:\n        raise ValueError(\"Query and sources must not be empty\")\n        \n    valid_sources = [\"NYT\", \"BBC\", \"Forbes\"]\n    if not all(source in valid_sources for source in sources):\n        raise ValueError(\"Invalid sources provided\")\n        \n    return {\n        \"articles\": [\n            {\n                \"title\": \"Latest Tech Trends 2024\",\n                \"source\": \"NYT\",\n                \"url\": \"https://nyt.com/tech-trends-2024\",\n                \"published_date\": \"2024-01-20\"\n            },\n            {\n                \"title\": \"AI Developments in Business\",\n                \"source\": \"Forbes\",\n                \"url\": \"https://forbes.com/ai-business\",\n                \"published_date\": \"2024-01-20\"\n            }\n        ],\n        \"total_results\": 2\n    }\ndef get_calendar_based_news(calendar_events: list[dict], topics: list[str]) -> dict:\n    \"\"\"\n    Suggests news articles based on upcoming calendar events.\n    \n    :param calendar_events: List of calendar event dictionaries.\n    :param topics: List of preferred topics.\n    :return: Dictionary containing relevant articles for events.\n    :raises ValueError: If calendar_events is empty.\n    \"\"\"\n    if not calendar_events or not topics:\n        raise ValueError(\"Calendar events and topics must not be empty\")\n        \n    return {\n        \"event_articles\": [\n            {\n                \"event\": \"Tech Conference\",\n                \"articles\": [\n                    {\n                        \"title\": \"Tech Conference Preview\",\n                        \"source\": \"BBC\",\n                        \"relevance_score\": 0.95\n                    }\n                ]\n            }\n        ],\n        \"total_suggestions\": 1\n    }", "user_query": "Search for news articles about \"AI in finance\" from \"NYT\" and \"Forbes\".", "checklist": {"functions": ["search_news"], "values": [{"articles": [{"title": "Latest Tech Trends 2024", "source": "NYT", "url": "https://nyt.com/tech-trends-2024", "published_date": "2024-01-20"}, {"title": "AI Developments in Business", "source": "Forbes", "url": "https://forbes.com/ai-business", "published_date": "2024-01-20"}], "total_results": 2}]}}
{"difficulty": "easy", "function_schema_python": "def setup_alert(stock_or_topic: str, search_sources: list) -> bool:\n    \"\"\"Sets up an alert for a specific stock or topic using specified news sources.\n\n    :param stock_or_topic: The stock symbol (e.g., \"Apple\", \"Tesla\") or a topic (e.g., \"trade wars\").\n    :param search_sources: A list of news sources to search from (e.g., [\"Bloomberg\", \"CNBC\", \"Reuters\"]).\n    :return: True if the alert was successfully set up, False otherwise.\n    :raises ValueError: If stock_or_topic or search_sources is invalid.\"\"\"\n    pass\ndef search_news(stock_or_topic: str, search_sources: list) -> dict:\n    \"\"\"Searches for news articles related to a specified stock or topic from given news sources.\n\n    :param stock_or_topic: The stock symbol (e.g., \"Apple\", \"Tesla\") or a topic (e.g., \"trade wars\").\n    :param search_sources: A list of news sources to search from (e.g., [\"Bloomberg\", \"CNBC\", \"Reuters\"]).\n    :return:\n        dict: A dictionary with the following keys:\n            - articles (list[dict]): A list of articles, each with 'title', 'source', and 'url'.\n    :raises ValueError: If stock_or_topic or search_sources is invalid.\"\"\"\n    pass\ndef fetch_articles(stock_or_topic: str) -> list:\n    \"\"\"Fetches all articles related to a specified stock or topic from default news sources.\n\n    :param stock_or_topic: The stock symbol (e.g., \"Apple\", \"Tesla\") or a topic (e.g., \"trade wars\").\n    :return: A list of article summaries as strings.\n    :raises ValueError: If stock_or_topic is invalid.\"\"\"\n    pass\ndef get_latest_update(stock_or_topic: str) -> dict:\n    \"\"\"Retrieves the latest news update for a specified stock or topic.\n\n    :param stock_or_topic: The stock symbol (e.g., \"Apple\", \"Tesla\") or a topic (e.g., \"trade wars\").\n    :return:\n        dict: A dictionary with the following keys:\n            - title (str): The article title.\n            - source (str): The news source.\n            - summary (str): A brief summary of the article.\n    :raises ValueError: If stock_or_topic is invalid.\"\"\"\n    pass\n", "function_schema_json": [{"name": "setup_alert", "description": "Sets up an alert for a specific stock or topic using specified news sources.", "parameters": {"type": "object", "properties": {"stock_or_topic": {"type": "string", "description": "The stock symbol (e.g., \"Apple\", \"Tesla\") or a topic (e.g., \"trade wars\")."}, "search_sources": {"type": "array", "description": "A list of news sources to search from (e.g., [\"Bloomberg\", \"CNBC\", \"Reuters\"])."}}, "required": ["stock_or_topic", "search_sources"], "additionalProperties": false}}, {"name": "search_news", "description": "Searches for news articles related to a specified stock or topic from given news sources.", "parameters": {"type": "object", "properties": {"stock_or_topic": {"type": "string", "description": "The stock symbol (e.g., \"Apple\", \"Tesla\") or a topic (e.g., \"trade wars\")."}, "search_sources": {"type": "array", "description": "A list of news sources to search from (e.g., [\"Bloomberg\", \"CNBC\", \"Reuters\"])."}}, "required": ["stock_or_topic", "search_sources"], "additionalProperties": false}}, {"name": "fetch_articles", "description": "Fetches all articles related to a specified stock or topic from default news sources.", "parameters": {"type": "object", "properties": {"stock_or_topic": {"type": "string", "description": "The stock symbol (e.g., \"Apple\", \"Tesla\") or a topic (e.g., \"trade wars\")."}}, "required": ["stock_or_topic"], "additionalProperties": false}}, {"name": "get_latest_update", "description": "Retrieves the latest news update for a specified stock or topic.", "parameters": {"type": "object", "properties": {"stock_or_topic": {"type": "string", "description": "The stock symbol (e.g., \"Apple\", \"Tesla\") or a topic (e.g., \"trade wars\")."}}, "required": ["stock_or_topic"], "additionalProperties": false}}], "mock_functions": "def setup_alert(stock_or_topic: str, search_sources: list) -> bool:\n    \"\"\"\n    Sets up an alert for a specific stock or topic using specified news sources.\n    \n    :param stock_or_topic: The stock symbol (e.g., \"Apple\", \"Tesla\") or a topic (e.g., \"trade wars\").\n    :param search_sources: A list of news sources to search from (e.g., [\"Bloomberg\", \"CNBC\", \"Reuters\"]).\n    :return: True if the alert was successfully set up, False otherwise.\n    :raises ValueError: If stock_or_topic or search_sources is invalid.\n    \"\"\"\n    if not stock_or_topic or not search_sources:\n        raise ValueError(\"Stock or topic and search sources must be provided.\")\n    if isinstance(search_sources, list) and all(isinstance(source, str) for source in search_sources):\n        return True\n    return False\ndef search_news(stock_or_topic: str, search_sources: list) -> dict:\n    \"\"\"\n    Searches for news articles related to a specified stock or topic from given news sources.\n    \n    :param stock_or_topic: The stock symbol (e.g., \"Apple\", \"Tesla\") or a topic (e.g., \"trade wars\").\n    :param search_sources: A list of news sources to search from (e.g., [\"Bloomberg\", \"CNBC\", \"Reuters\"]).\n    :return:\n        dict: A dictionary with the following keys:\n            - articles (list[dict]): A list of articles, each with 'title', 'source', and 'url'.\n    :raises ValueError: If stock_or_topic or search_sources is invalid.\n    \"\"\"\n    if not stock_or_topic or not search_sources:\n        raise ValueError(\"Stock or topic and search_sources must be provided.\")\n    if isinstance(search_sources, list) and all(isinstance(source, str) for source in search_sources):\n        return {\n            \"articles\": [\n                {\n                    \"title\": f\"Latest news about {stock_or_topic}\",\n                    \"source\": search_sources[0],\n                    \"url\": \"http://example.com/news\"\n                }\n            ]\n        }\n    return {}\ndef fetch_articles(stock_or_topic: str) -> list:\n    \"\"\"\n    Fetches all articles related to a specified stock or topic from default news sources.\n    \n    :param stock_or_topic: The stock symbol (e.g., \"Apple\", \"Tesla\") or a topic (e.g., \"trade wars\").\n    :return: A list of article summaries as strings.\n    :raises ValueError: If stock_or_topic is invalid.\n    \"\"\"\n    if not stock_or_topic:\n        raise ValueError(\"Stock or topic must be provided.\")\n    return [\n        f\"Article about {stock_or_topic} from Bloomberg\",\n        f\"Article about {stock_or_topic} from CNBC\"\n    ]\ndef get_latest_update(stock_or_topic: str) -> dict:\n    \"\"\"\n    Retrieves the latest news update for a specified stock or topic.\n    \n    :param stock_or_topic: The stock symbol (e.g., \"Apple\", \"Tesla\") or a topic (e.g., \"trade wars\").\n    :return:\n        dict: A dictionary with the following keys:\n            - title (str): The article title.\n            - source (str): The news source.\n            - summary (str): A brief summary of the article.\n    :raises ValueError: If stock_or_topic is invalid.\n    \"\"\"\n    if not stock_or_topic:\n        raise ValueError(\"Stock or topic must be provided.\")\n    return {\n        \"title\": f\"Latest update on {stock_or_topic}\",\n        \"source\": \"Reuters\",\n        \"summary\": f\"Summary of the latest news about {stock_or_topic}\"\n    }", "user_query": "Can you set up an alert for Apple stock using Bloomberg, CNBC, and Reuters as sources?", "checklist": {"functions": ["setup_alert"], "values": [true]}}
{"difficulty": "easy", "function_schema_python": "def setup_alert(stock_or_topic: str, search_sources: list) -> bool:\n    \"\"\"Sets up an alert for a specific stock or topic using specified news sources.\n\n    :param stock_or_topic: The stock symbol (e.g., \"Apple\", \"Tesla\") or a topic (e.g., \"trade wars\").\n    :param search_sources: A list of news sources to search from (e.g., [\"Bloomberg\", \"CNBC\", \"Reuters\"]).\n    :return: True if the alert was successfully set up, False otherwise.\n    :raises ValueError: If stock_or_topic or search_sources is invalid.\"\"\"\n    pass\ndef search_news(stock_or_topic: str, search_sources: list) -> dict:\n    \"\"\"Searches for news articles related to a specified stock or topic from given news sources.\n\n    :param stock_or_topic: The stock symbol (e.g., \"Apple\", \"Tesla\") or a topic (e.g., \"trade wars\").\n    :param search_sources: A list of news sources to search from (e.g., [\"Bloomberg\", \"CNBC\", \"Reuters\"]).\n    :return:\n        dict: A dictionary with the following keys:\n            - articles (list[dict]): A list of articles, each with 'title', 'source', and 'url'.\n    :raises ValueError: If stock_or_topic or search_sources is invalid.\"\"\"\n    pass\ndef fetch_articles(stock_or_topic: str) -> list:\n    \"\"\"Fetches all articles related to a specified stock or topic from default news sources.\n\n    :param stock_or_topic: The stock symbol (e.g., \"Apple\", \"Tesla\") or a topic (e.g., \"trade wars\").\n    :return: A list of article summaries as strings.\n    :raises ValueError: If stock_or_topic is invalid.\"\"\"\n    pass\ndef get_latest_update(stock_or_topic: str) -> dict:\n    \"\"\"Retrieves the latest news update for a specified stock or topic.\n\n    :param stock_or_topic: The stock symbol (e.g., \"Apple\", \"Tesla\") or a topic (e.g., \"trade wars\").\n    :return:\n        dict: A dictionary with the following keys:\n            - title (str): The article title.\n            - source (str): The news source.\n            - summary (str): A brief summary of the article.\n    :raises ValueError: If stock_or_topic is invalid.\"\"\"\n    pass\n", "function_schema_json": [{"name": "setup_alert", "description": "Sets up an alert for a specific stock or topic using specified news sources.", "parameters": {"type": "object", "properties": {"stock_or_topic": {"type": "string", "description": "The stock symbol (e.g., \"Apple\", \"Tesla\") or a topic (e.g., \"trade wars\")."}, "search_sources": {"type": "array", "description": "A list of news sources to search from (e.g., [\"Bloomberg\", \"CNBC\", \"Reuters\"])."}}, "required": ["stock_or_topic", "search_sources"], "additionalProperties": false}}, {"name": "search_news", "description": "Searches for news articles related to a specified stock or topic from given news sources.", "parameters": {"type": "object", "properties": {"stock_or_topic": {"type": "string", "description": "The stock symbol (e.g., \"Apple\", \"Tesla\") or a topic (e.g., \"trade wars\")."}, "search_sources": {"type": "array", "description": "A list of news sources to search from (e.g., [\"Bloomberg\", \"CNBC\", \"Reuters\"])."}}, "required": ["stock_or_topic", "search_sources"], "additionalProperties": false}}, {"name": "fetch_articles", "description": "Fetches all articles related to a specified stock or topic from default news sources.", "parameters": {"type": "object", "properties": {"stock_or_topic": {"type": "string", "description": "The stock symbol (e.g., \"Apple\", \"Tesla\") or a topic (e.g., \"trade wars\")."}}, "required": ["stock_or_topic"], "additionalProperties": false}}, {"name": "get_latest_update", "description": "Retrieves the latest news update for a specified stock or topic.", "parameters": {"type": "object", "properties": {"stock_or_topic": {"type": "string", "description": "The stock symbol (e.g., \"Apple\", \"Tesla\") or a topic (e.g., \"trade wars\")."}}, "required": ["stock_or_topic"], "additionalProperties": false}}], "mock_functions": "def setup_alert(stock_or_topic: str, search_sources: list) -> bool:\n    \"\"\"\n    Sets up an alert for a specific stock or topic using specified news sources.\n    \n    :param stock_or_topic: The stock symbol (e.g., \"Apple\", \"Tesla\") or a topic (e.g., \"trade wars\").\n    :param search_sources: A list of news sources to search from (e.g., [\"Bloomberg\", \"CNBC\", \"Reuters\"]).\n    :return: True if the alert was successfully set up, False otherwise.\n    :raises ValueError: If stock_or_topic or search_sources is invalid.\n    \"\"\"\n    if not stock_or_topic or not search_sources:\n        raise ValueError(\"Stock or topic and search sources must be provided.\")\n    if isinstance(search_sources, list) and all(isinstance(source, str) for source in search_sources):\n        return True\n    return False\ndef search_news(stock_or_topic: str, search_sources: list) -> dict:\n    \"\"\"\n    Searches for news articles related to a specified stock or topic from given news sources.\n    \n    :param stock_or_topic: The stock symbol (e.g., \"Apple\", \"Tesla\") or a topic (e.g., \"trade wars\").\n    :param search_sources: A list of news sources to search from (e.g., [\"Bloomberg\", \"CNBC\", \"Reuters\"]).\n    :return:\n        dict: A dictionary with the following keys:\n            - articles (list[dict]): A list of articles, each with 'title', 'source', and 'url'.\n    :raises ValueError: If stock_or_topic or search_sources is invalid.\n    \"\"\"\n    if not stock_or_topic or not search_sources:\n        raise ValueError(\"Stock or topic and search_sources must be provided.\")\n    if isinstance(search_sources, list) and all(isinstance(source, str) for source in search_sources):\n        return {\n            \"articles\": [\n                {\n                    \"title\": f\"Latest news about {stock_or_topic}\",\n                    \"source\": search_sources[0],\n                    \"url\": \"http://example.com/news\"\n                }\n            ]\n        }\n    return {}\ndef fetch_articles(stock_or_topic: str) -> list:\n    \"\"\"\n    Fetches all articles related to a specified stock or topic from default news sources.\n    \n    :param stock_or_topic: The stock symbol (e.g., \"Apple\", \"Tesla\") or a topic (e.g., \"trade wars\").\n    :return: A list of article summaries as strings.\n    :raises ValueError: If stock_or_topic is invalid.\n    \"\"\"\n    if not stock_or_topic:\n        raise ValueError(\"Stock or topic must be provided.\")\n    return [\n        f\"Article about {stock_or_topic} from Bloomberg\",\n        f\"Article about {stock_or_topic} from CNBC\"\n    ]\ndef get_latest_update(stock_or_topic: str) -> dict:\n    \"\"\"\n    Retrieves the latest news update for a specified stock or topic.\n    \n    :param stock_or_topic: The stock symbol (e.g., \"Apple\", \"Tesla\") or a topic (e.g., \"trade wars\").\n    :return:\n        dict: A dictionary with the following keys:\n            - title (str): The article title.\n            - source (str): The news source.\n            - summary (str): A brief summary of the article.\n    :raises ValueError: If stock_or_topic is invalid.\n    \"\"\"\n    if not stock_or_topic:\n        raise ValueError(\"Stock or topic must be provided.\")\n    return {\n        \"title\": f\"Latest update on {stock_or_topic}\",\n        \"source\": \"Reuters\",\n        \"summary\": f\"Summary of the latest news about {stock_or_topic}\"\n    }", "user_query": "Search for recent news about Tesla across Bloomberg and CNBC news sources.", "checklist": {"functions": ["search_news"], "values": [{"articles": [{"title": "Latest news about Tesla", "source": "Bloomberg", "url": "http://example.com/news"}]}]}}
{"difficulty": "easy", "function_schema_python": "def search_venues(city: str, capacity: int, budget_range: tuple[int, int]) -> list[dict]:\n    \"\"\"Searches for venue options based on city, capacity, and budget requirements.\n\n    :param city: City where the venue is located\n    :param capacity: Required capacity for attendees\n    :param budget_range: Tuple of (min_budget, max_budget) in USD\n    :return: List of dictionaries containing venue information\n    :raises ValueError: If capacity is <= 0 or budget range is invalid\"\"\"\n    pass\ndef verify_av_capabilities(venue_name: str) -> dict:\n    \"\"\"Checks audiovisual capabilities of a specific venue.\n\n    :param venue_name: Name of the venue to check\n    :return: Dictionary containing AV equipment details\n    :raises ValueError: If venue_name is empty\"\"\"\n    pass\ndef check_venue_availability(venue_name: str, date: str) -> dict:\n    \"\"\"Checks venue availability for a specific date.\n\n    :param venue_name: Name of the venue\n    :param date: Date in 'YYYY-MM-DD' format\n    :return: Dictionary containing availability and pricing information\n    :raises ValueError: If date format is incorrect\"\"\"\n    pass\n", "function_schema_json": [{"name": "search_venues", "description": "Searches for venue options based on city, capacity, and budget requirements.", "parameters": {"type": "object", "properties": {"city": {"type": "string", "description": "City where the venue is located"}, "capacity": {"type": "integer", "description": "Required capacity for attendees"}, "budget_range": {"type": "string", "description": "Tuple of (min_budget, max_budget) in USD"}}, "required": ["city", "capacity", "budget_range"], "additionalProperties": false}}, {"name": "verify_av_capabilities", "description": "Checks audiovisual capabilities of a specific venue.", "parameters": {"type": "object", "properties": {"venue_name": {"type": "string", "description": "Name of the venue to check"}}, "required": ["venue_name"], "additionalProperties": false}}, {"name": "check_venue_availability", "description": "Checks venue availability for a specific date.", "parameters": {"type": "object", "properties": {"venue_name": {"type": "string", "description": "Name of the venue"}, "date": {"type": "string", "description": "Date in 'YYYY-MM-DD' format"}}, "required": ["venue_name", "date"], "additionalProperties": false}}], "mock_functions": "def search_venues(\n    city: str, \n    capacity: int, \n    budget_range: tuple[int, int]\n) -> list[dict]:\n    \"\"\"\n    Searches for venue options based on city, capacity, and budget requirements.\n    \n    :param city: City where the venue is located\n    :param capacity: Required capacity for attendees\n    :param budget_range: Tuple of (min_budget, max_budget) in USD\n    :return: List of dictionaries containing venue information\n    :raises ValueError: If capacity is <= 0 or budget range is invalid\n    \"\"\"\n    if capacity <= 0:\n        raise ValueError(\"Capacity must be greater than 0\")\n    if budget_range[0] > budget_range[1]:\n        raise ValueError(\"Invalid budget range\")\n\n    if (city.lower() == \"seattle\" and \n        200 <= capacity <= 300 and \n        10000 <= budget_range[1] <= 25000):\n        return [\n            {\n                \"name\": \"Seattle Convention Center\",\n                \"capacity\": 300,\n                \"price\": 15000,\n                \"breakout_rooms\": 4,\n                \"transit_access\": True,\n                \"parking_spots\": 200\n            },\n            {\n                \"name\": \"Tech Hub Seattle\",\n                \"capacity\": 250,\n                \"price\": 12000,\n                \"breakout_rooms\": 3,\n                \"transit_access\": True,\n                \"parking_spots\": 150\n            }\n        ]\n    return []\ndef verify_av_capabilities(venue_name: str) -> dict:\n    \"\"\"\n    Checks audiovisual capabilities of a specific venue.\n    \n    :param venue_name: Name of the venue to check\n    :return: Dictionary containing AV equipment details\n    :raises ValueError: If venue_name is empty\n    \"\"\"\n    if not venue_name:\n        raise ValueError(\"Venue name cannot be empty\")\n        \n    valid_venues = {\n        \"seattle convention center\": {\n            \"projectors\": True,\n            \"sound_system\": True,\n            \"wireless_mics\": 4,\n            \"video_recording\": True,\n            \"streaming_capability\": True\n        },\n        \"tech hub seattle\": {\n            \"projectors\": True,\n            \"sound_system\": True,\n            \"wireless_mics\": 2,\n            \"video_recording\": True,\n            \"streaming_capability\": False\n        }\n    }\n    \n    return valid_venues.get(venue_name.lower(), {})\ndef check_venue_availability(\n    venue_name: str, \n    date: str\n) -> dict:\n    \"\"\"\n    Checks venue availability for a specific date.\n    \n    :param venue_name: Name of the venue\n    :param date: Date in 'YYYY-MM-DD' format\n    :return: Dictionary containing availability and pricing information\n    :raises ValueError: If date format is incorrect\n    \"\"\"\n    if not venue_name or not date:\n        raise ValueError(\"Venue name and date must be provided\")\n    \n    if (venue_name.lower() in [\"seattle convention center\", \"tech hub seattle\"] and \n        date == \"2024-03-15\"):\n        return {\n            \"available\": True,\n            \"base_price\": 15000,\n            \"setup_time\": \"2 hours\",\n            \"teardown_time\": \"2 hours\",\n            \"available_hours\": \"8:00 AM - 10:00 PM\"\n        }\n    return {\"available\": False}", "user_query": "Can you search for venues in Seattle that can host 250 people with a budget between $10,000-$25,000?", "checklist": {"functions": ["search_venues"], "values": [[{"name": "Seattle Convention Center", "capacity": 300, "price": 15000, "breakout_rooms": 4, "transit_access": true, "parking_spots": 200}, {"name": "Tech Hub Seattle", "capacity": 250, "price": 12000, "breakout_rooms": 3, "transit_access": true, "parking_spots": 150}]]}}
{"difficulty": "easy", "function_schema_python": "def search_venues(city: str, capacity: int, budget_range: tuple[int, int]) -> list[dict]:\n    \"\"\"Searches for venue options based on city, capacity, and budget requirements.\n\n    :param city: City where the venue is located\n    :param capacity: Required capacity for attendees\n    :param budget_range: Tuple of (min_budget, max_budget) in USD\n    :return: List of dictionaries containing venue information\n    :raises ValueError: If capacity is <= 0 or budget range is invalid\"\"\"\n    pass\ndef verify_av_capabilities(venue_name: str) -> dict:\n    \"\"\"Checks audiovisual capabilities of a specific venue.\n\n    :param venue_name: Name of the venue to check\n    :return: Dictionary containing AV equipment details\n    :raises ValueError: If venue_name is empty\"\"\"\n    pass\ndef check_venue_availability(venue_name: str, date: str) -> dict:\n    \"\"\"Checks venue availability for a specific date.\n\n    :param venue_name: Name of the venue\n    :param date: Date in 'YYYY-MM-DD' format\n    :return: Dictionary containing availability and pricing information\n    :raises ValueError: If date format is incorrect\"\"\"\n    pass\n", "function_schema_json": [{"name": "search_venues", "description": "Searches for venue options based on city, capacity, and budget requirements.", "parameters": {"type": "object", "properties": {"city": {"type": "string", "description": "City where the venue is located"}, "capacity": {"type": "integer", "description": "Required capacity for attendees"}, "budget_range": {"type": "string", "description": "Tuple of (min_budget, max_budget) in USD"}}, "required": ["city", "capacity", "budget_range"], "additionalProperties": false}}, {"name": "verify_av_capabilities", "description": "Checks audiovisual capabilities of a specific venue.", "parameters": {"type": "object", "properties": {"venue_name": {"type": "string", "description": "Name of the venue to check"}}, "required": ["venue_name"], "additionalProperties": false}}, {"name": "check_venue_availability", "description": "Checks venue availability for a specific date.", "parameters": {"type": "object", "properties": {"venue_name": {"type": "string", "description": "Name of the venue"}, "date": {"type": "string", "description": "Date in 'YYYY-MM-DD' format"}}, "required": ["venue_name", "date"], "additionalProperties": false}}], "mock_functions": "def search_venues(\n    city: str, \n    capacity: int, \n    budget_range: tuple[int, int]\n) -> list[dict]:\n    \"\"\"\n    Searches for venue options based on city, capacity, and budget requirements.\n    \n    :param city: City where the venue is located\n    :param capacity: Required capacity for attendees\n    :param budget_range: Tuple of (min_budget, max_budget) in USD\n    :return: List of dictionaries containing venue information\n    :raises ValueError: If capacity is <= 0 or budget range is invalid\n    \"\"\"\n    if capacity <= 0:\n        raise ValueError(\"Capacity must be greater than 0\")\n    if budget_range[0] > budget_range[1]:\n        raise ValueError(\"Invalid budget range\")\n\n    if (city.lower() == \"seattle\" and \n        200 <= capacity <= 300 and \n        10000 <= budget_range[1] <= 25000):\n        return [\n            {\n                \"name\": \"Seattle Convention Center\",\n                \"capacity\": 300,\n                \"price\": 15000,\n                \"breakout_rooms\": 4,\n                \"transit_access\": True,\n                \"parking_spots\": 200\n            },\n            {\n                \"name\": \"Tech Hub Seattle\",\n                \"capacity\": 250,\n                \"price\": 12000,\n                \"breakout_rooms\": 3,\n                \"transit_access\": True,\n                \"parking_spots\": 150\n            }\n        ]\n    return []\ndef verify_av_capabilities(venue_name: str) -> dict:\n    \"\"\"\n    Checks audiovisual capabilities of a specific venue.\n    \n    :param venue_name: Name of the venue to check\n    :return: Dictionary containing AV equipment details\n    :raises ValueError: If venue_name is empty\n    \"\"\"\n    if not venue_name:\n        raise ValueError(\"Venue name cannot be empty\")\n        \n    valid_venues = {\n        \"seattle convention center\": {\n            \"projectors\": True,\n            \"sound_system\": True,\n            \"wireless_mics\": 4,\n            \"video_recording\": True,\n            \"streaming_capability\": True\n        },\n        \"tech hub seattle\": {\n            \"projectors\": True,\n            \"sound_system\": True,\n            \"wireless_mics\": 2,\n            \"video_recording\": True,\n            \"streaming_capability\": False\n        }\n    }\n    \n    return valid_venues.get(venue_name.lower(), {})\ndef check_venue_availability(\n    venue_name: str, \n    date: str\n) -> dict:\n    \"\"\"\n    Checks venue availability for a specific date.\n    \n    :param venue_name: Name of the venue\n    :param date: Date in 'YYYY-MM-DD' format\n    :return: Dictionary containing availability and pricing information\n    :raises ValueError: If date format is incorrect\n    \"\"\"\n    if not venue_name or not date:\n        raise ValueError(\"Venue name and date must be provided\")\n    \n    if (venue_name.lower() in [\"seattle convention center\", \"tech hub seattle\"] and \n        date == \"2024-03-15\"):\n        return {\n            \"available\": True,\n            \"base_price\": 15000,\n            \"setup_time\": \"2 hours\",\n            \"teardown_time\": \"2 hours\",\n            \"available_hours\": \"8:00 AM - 10:00 PM\"\n        }\n    return {\"available\": False}", "user_query": "Michael here. Check the AV capabilities for the Seattle Convention Center for a tech conference, specifically looking for wireless microphones and streaming options.", "checklist": {"functions": ["verify_av_capabilities"], "values": [{"projectors": true, "sound_system": true, "wireless_mics": 4, "video_recording": true, "streaming_capability": true}]}}
{"difficulty": "easy", "function_schema_python": "def search_venues(agent: str, max_attendees: int, audio_visual: bool, catering: bool, accessibility: bool, parking: bool) -> list:\n    \"\"\"Searches for venues based on the provided criteria using a specified agent.\n\n    :param agent: The search agent to use (\"serper\", \"duckduckgo\", \"bind\").\n    :param max_attendees: The maximum number of attendees the venue should accommodate.\n    :param audio_visual: Whether the venue needs to have state-of-the-art audio-visual equipment.\n    :param catering: Whether the venue should offer catering services.\n    :param accessibility: Whether the venue should be accessible.\n    :param parking: Whether the venue should have parking facilities.\n    :return: A list of dictionaries representing the venues.\n    :raises ValueError: If the agent is not recognized.\"\"\"\n    pass\ndef suggest_accommodations(location: str) -> list:\n    \"\"\"Suggests accommodations near the specified location.\n\n    :param location: The address or name of the location.\n    :return: A list of dictionaries representing the accommodations.\n    :raises ValueError: If the location is empty.\"\"\"\n    pass\ndef check_venue_availability(venue_name: str, date: str) -> bool:\n    \"\"\"Checks the availability of a given venue on a specified date.\n\n    :param venue_name: The name of the venue.\n    :param date: The date to check for availability.\n    :return: True if the venue is available, False otherwise.\n    :raises ValueError: If the venue name or date is empty.\"\"\"\n    pass\ndef reserve_venue(venue_name: str, date: str, contact_email: str) -> bool:\n    \"\"\"Reserves the given venue for a specified date and sends a confirmation email.\n\n    :param venue_name: The name of the venue.\n    :param date: The date to reserve the venue.\n    :param contact_email: The contact email for sending the confirmation.\n    :return: True if the reservation is successful, False otherwise.\n    :raises ValueError: If any parameter is invalid.\"\"\"\n    pass\n", "function_schema_json": [{"name": "search_venues", "description": "Searches for venues based on the provided criteria using a specified agent.", "parameters": {"type": "object", "properties": {"agent": {"type": "string", "description": "The search agent to use (\"serper\", \"duckduckgo\", \"bind\")."}, "max_attendees": {"type": "integer", "description": "The maximum number of attendees the venue should accommodate."}, "audio_visual": {"type": "boolean", "description": "Whether the venue needs to have state-of-the-art audio-visual equipment."}, "catering": {"type": "boolean", "description": "Whether the venue should offer catering services."}, "accessibility": {"type": "boolean", "description": "Whether the venue should be accessible."}, "parking": {"type": "boolean", "description": "Whether the venue should have parking facilities."}}, "required": ["agent", "max_attendees", "audio_visual", "catering", "accessibility", "parking"], "additionalProperties": false}}, {"name": "suggest_accommodations", "description": "Suggests accommodations near the specified location.", "parameters": {"type": "object", "properties": {"location": {"type": "string", "description": "The address or name of the location."}}, "required": ["location"], "additionalProperties": false}}, {"name": "check_venue_availability", "description": "Checks the availability of a given venue on a specified date.", "parameters": {"type": "object", "properties": {"venue_name": {"type": "string", "description": "The name of the venue."}, "date": {"type": "string", "description": "The date to check for availability."}}, "required": ["venue_name", "date"], "additionalProperties": false}}, {"name": "reserve_venue", "description": "Reserves the given venue for a specified date and sends a confirmation email.", "parameters": {"type": "object", "properties": {"venue_name": {"type": "string", "description": "The name of the venue."}, "date": {"type": "string", "description": "The date to reserve the venue."}, "contact_email": {"type": "string", "description": "The contact email for sending the confirmation."}}, "required": ["venue_name", "date", "contact_email"], "additionalProperties": false}}], "mock_functions": "def search_venues(agent: str, max_attendees: int, audio_visual: bool, catering: bool, accessibility: bool, parking: bool) -> list:\n    \"\"\"\n    Searches for venues based on the provided criteria using a specified agent.\n    \n    :param agent: The search agent to use (\"serper\", \"duckduckgo\", \"bind\").\n    :param max_attendees: The maximum number of attendees the venue should accommodate.\n    :param audio_visual: Whether the venue needs to have state-of-the-art audio-visual equipment.\n    :param catering: Whether the venue should offer catering services.\n    :param accessibility: Whether the venue should be accessible.\n    :param parking: Whether the venue should have parking facilities.\n    :return: A list of dictionaries representing the venues.\n    :raises ValueError: If the agent is not recognized.\n    \"\"\"\n    if agent not in [\"serper\", \"duckduckgo\", \"bind\"]:\n        raise ValueError(\"Invalid agent provided.\")\n    \n    if agent == \"serper\":\n        return [\n            {\n                \"name\": \"Conference Center A\",\n                \"address\": \"123 Maple Avenue\",\n                \"max_attendees\": 250,\n                \"audio_visual\": True,\n                \"catering\": True,\n                \"accessible\": True,\n                \"parking\": True\n            },\n            {\n                \"name\": \"Hotel Venue B\",\n                \"address\": \"456 Pine Street\",\n                \"max_attendees\": 200,\n                \"audio_visual\": True,\n                \"catering\": False,\n                \"accessible\": True,\n                \"parking\": True\n            }\n        ]\n    \n    if agent == \"duckduckgo\":\n        return [\n            {\n                \"name\": \"Convention Hall C\",\n                \"address\": \"789 Oak Drive\",\n                \"max_attendees\": 150,\n                \"audio_visual\": True,\n                \"catering\": True,\n                \"accessible\": True,\n                \"parking\": True\n            },\n            {\n                \"name\": \"Event Center D\",\n                \"address\": \"101 Walnut Lane\",\n                \"max_attendees\": 200,\n                \"audio_visual\": True,\n                \"catering\": True,\n                \"accessible\": False,\n                \"parking\": True\n            }\n        ]\n    \n    if agent == \"bind\":\n        return [\n            {\n                \"name\": \"Grand Ballroom E\",\n                \"address\": \"202 Birch Path\",\n                \"max_attendees\": 200,\n                \"audio_visual\": True,\n                \"catering\": True,\n                \"accessible\": True,\n                \"parking\": False\n            }\n        ]\ndef suggest_accommodations(location: str) -> list:\n    \"\"\"\n    Suggests accommodations near the specified location.\n    \n    :param location: The address or name of the location.\n    :return: A list of dictionaries representing the accommodations.\n    :raises ValueError: If the location is empty.\n    \"\"\"\n    if not location:\n        raise ValueError(\"Location must be provided.\")\n    \n    return [\n        {\n            \"name\": \"Hotel\u6126 Liberty\",\n            \"address\": \"123 Hotel Rd\",\n            \"distance\": \"5 minutes\",\n            \"napa\": \"no\"\n        },\n        {\n            \"name\": \"Luxury Suites\",\n            \"address\": \"456 Resort Way\",\n            \"distance\": \"15 minutes\",\n            \"napa\": \"yes\"\n        }\n    ]\ndef check_venue_availability(venue_name: str, date: str) -> bool:\n    \"\"\"\n    Checks the availability of a given venue on a specified date.\n    \n    :param venue_name: The name of the venue.\n    :param date: The date to check for availability.\n    :return: True if the venue is available, False otherwise.\n    :raises ValueError: If the venue name or date is empty.\n    \"\"\"\n    if not venue_name or not date:\n        raise ValueError(\"Venue name and date must be provided.\")\n    \n    # Mock logic: if venue is \"Conference Center A\" and date is \"2024-01-15\", return True.\n    if venue_name == \"Conference Center A\" and date == \"2024-01-15\":\n        return True\n    return False\ndef reserve_venue(venue_name: str, date: str, contact_email: str) -> bool:\n    \"\"\"\n    Reserves the given venue for a specified date and sends a confirmation email.\n    \n    :param venue_name: The name of the venue.\n    :param date: The date to reserve the venue.\n    :param contact_email: The contact email for sending the confirmation.\n    :return: True if the reservation is successful, False otherwise.\n    :raises ValueError: If any parameter is invalid.\n    \"\"\"\n    if not venue_name or not date or not contact_email:\n        raise ValueError(\"Venue name, date, and contact email must be provided.\")\n    \n    # Mock logic: if venue is \"Conference Center A\", date is \"2024-01-15\", and email is not empty, return True.\n    if venue_name == \"Conference Center A\" and date == \"2024-01-15\" and contact_email:\n        return True\n    return False", "user_query": "Can you search for venues that can accommodate 200 people using the serper agent?", "checklist": {"functions": ["search_venues"], "values": [[{"name": "Conference Center A", "address": "123 Maple Avenue", "max_attendees": 250, "audio_visual": true, "catering": true, "accessible": true, "parking": true}, {"name": "Hotel Venue B", "address": "456 Pine Street", "max_attendees": 200, "audio_visual": true, "catering": false, "accessible": true, "parking": true}]]}}
{"difficulty": "easy", "function_schema_python": "def search_venues(agent: str, max_attendees: int, audio_visual: bool, catering: bool, accessibility: bool, parking: bool) -> list:\n    \"\"\"Searches for venues based on the provided criteria using a specified agent.\n\n    :param agent: The search agent to use (\"serper\", \"duckduckgo\", \"bind\").\n    :param max_attendees: The maximum number of attendees the venue should accommodate.\n    :param audio_visual: Whether the venue needs to have state-of-the-art audio-visual equipment.\n    :param catering: Whether the venue should offer catering services.\n    :param accessibility: Whether the venue should be accessible.\n    :param parking: Whether the venue should have parking facilities.\n    :return: A list of dictionaries representing the venues.\n    :raises ValueError: If the agent is not recognized.\"\"\"\n    pass\ndef suggest_accommodations(location: str) -> list:\n    \"\"\"Suggests accommodations near the specified location.\n\n    :param location: The address or name of the location.\n    :return: A list of dictionaries representing the accommodations.\n    :raises ValueError: If the location is empty.\"\"\"\n    pass\ndef check_venue_availability(venue_name: str, date: str) -> bool:\n    \"\"\"Checks the availability of a given venue on a specified date.\n\n    :param venue_name: The name of the venue.\n    :param date: The date to check for availability.\n    :return: True if the venue is available, False otherwise.\n    :raises ValueError: If the venue name or date is empty.\"\"\"\n    pass\ndef reserve_venue(venue_name: str, date: str, contact_email: str) -> bool:\n    \"\"\"Reserves the given venue for a specified date and sends a confirmation email.\n\n    :param venue_name: The name of the venue.\n    :param date: The date to reserve the venue.\n    :param contact_email: The contact email for sending the confirmation.\n    :return: True if the reservation is successful, False otherwise.\n    :raises ValueError: If any parameter is invalid.\"\"\"\n    pass\n", "function_schema_json": [{"name": "search_venues", "description": "Searches for venues based on the provided criteria using a specified agent.", "parameters": {"type": "object", "properties": {"agent": {"type": "string", "description": "The search agent to use (\"serper\", \"duckduckgo\", \"bind\")."}, "max_attendees": {"type": "integer", "description": "The maximum number of attendees the venue should accommodate."}, "audio_visual": {"type": "boolean", "description": "Whether the venue needs to have state-of-the-art audio-visual equipment."}, "catering": {"type": "boolean", "description": "Whether the venue should offer catering services."}, "accessibility": {"type": "boolean", "description": "Whether the venue should be accessible."}, "parking": {"type": "boolean", "description": "Whether the venue should have parking facilities."}}, "required": ["agent", "max_attendees", "audio_visual", "catering", "accessibility", "parking"], "additionalProperties": false}}, {"name": "suggest_accommodations", "description": "Suggests accommodations near the specified location.", "parameters": {"type": "object", "properties": {"location": {"type": "string", "description": "The address or name of the location."}}, "required": ["location"], "additionalProperties": false}}, {"name": "check_venue_availability", "description": "Checks the availability of a given venue on a specified date.", "parameters": {"type": "object", "properties": {"venue_name": {"type": "string", "description": "The name of the venue."}, "date": {"type": "string", "description": "The date to check for availability."}}, "required": ["venue_name", "date"], "additionalProperties": false}}, {"name": "reserve_venue", "description": "Reserves the given venue for a specified date and sends a confirmation email.", "parameters": {"type": "object", "properties": {"venue_name": {"type": "string", "description": "The name of the venue."}, "date": {"type": "string", "description": "The date to reserve the venue."}, "contact_email": {"type": "string", "description": "The contact email for sending the confirmation."}}, "required": ["venue_name", "date", "contact_email"], "additionalProperties": false}}], "mock_functions": "def search_venues(agent: str, max_attendees: int, audio_visual: bool, catering: bool, accessibility: bool, parking: bool) -> list:\n    \"\"\"\n    Searches for venues based on the provided criteria using a specified agent.\n    \n    :param agent: The search agent to use (\"serper\", \"duckduckgo\", \"bind\").\n    :param max_attendees: The maximum number of attendees the venue should accommodate.\n    :param audio_visual: Whether the venue needs to have state-of-the-art audio-visual equipment.\n    :param catering: Whether the venue should offer catering services.\n    :param accessibility: Whether the venue should be accessible.\n    :param parking: Whether the venue should have parking facilities.\n    :return: A list of dictionaries representing the venues.\n    :raises ValueError: If the agent is not recognized.\n    \"\"\"\n    if agent not in [\"serper\", \"duckduckgo\", \"bind\"]:\n        raise ValueError(\"Invalid agent provided.\")\n    \n    if agent == \"serper\":\n        return [\n            {\n                \"name\": \"Conference Center A\",\n                \"address\": \"123 Maple Avenue\",\n                \"max_attendees\": 250,\n                \"audio_visual\": True,\n                \"catering\": True,\n                \"accessible\": True,\n                \"parking\": True\n            },\n            {\n                \"name\": \"Hotel Venue B\",\n                \"address\": \"456 Pine Street\",\n                \"max_attendees\": 200,\n                \"audio_visual\": True,\n                \"catering\": False,\n                \"accessible\": True,\n                \"parking\": True\n            }\n        ]\n    \n    if agent == \"duckduckgo\":\n        return [\n            {\n                \"name\": \"Convention Hall C\",\n                \"address\": \"789 Oak Drive\",\n                \"max_attendees\": 150,\n                \"audio_visual\": True,\n                \"catering\": True,\n                \"accessible\": True,\n                \"parking\": True\n            },\n            {\n                \"name\": \"Event Center D\",\n                \"address\": \"101 Walnut Lane\",\n                \"max_attendees\": 200,\n                \"audio_visual\": True,\n                \"catering\": True,\n                \"accessible\": False,\n                \"parking\": True\n            }\n        ]\n    \n    if agent == \"bind\":\n        return [\n            {\n                \"name\": \"Grand Ballroom E\",\n                \"address\": \"202 Birch Path\",\n                \"max_attendees\": 200,\n                \"audio_visual\": True,\n                \"catering\": True,\n                \"accessible\": True,\n                \"parking\": False\n            }\n        ]\ndef suggest_accommodations(location: str) -> list:\n    \"\"\"\n    Suggests accommodations near the specified location.\n    \n    :param location: The address or name of the location.\n    :return: A list of dictionaries representing the accommodations.\n    :raises ValueError: If the location is empty.\n    \"\"\"\n    if not location:\n        raise ValueError(\"Location must be provided.\")\n    \n    return [\n        {\n            \"name\": \"Hotel\u6126 Liberty\",\n            \"address\": \"123 Hotel Rd\",\n            \"distance\": \"5 minutes\",\n            \"napa\": \"no\"\n        },\n        {\n            \"name\": \"Luxury Suites\",\n            \"address\": \"456 Resort Way\",\n            \"distance\": \"15 minutes\",\n            \"napa\": \"yes\"\n        }\n    ]\ndef check_venue_availability(venue_name: str, date: str) -> bool:\n    \"\"\"\n    Checks the availability of a given venue on a specified date.\n    \n    :param venue_name: The name of the venue.\n    :param date: The date to check for availability.\n    :return: True if the venue is available, False otherwise.\n    :raises ValueError: If the venue name or date is empty.\n    \"\"\"\n    if not venue_name or not date:\n        raise ValueError(\"Venue name and date must be provided.\")\n    \n    # Mock logic: if venue is \"Conference Center A\" and date is \"2024-01-15\", return True.\n    if venue_name == \"Conference Center A\" and date == \"2024-01-15\":\n        return True\n    return False\ndef reserve_venue(venue_name: str, date: str, contact_email: str) -> bool:\n    \"\"\"\n    Reserves the given venue for a specified date and sends a confirmation email.\n    \n    :param venue_name: The name of the venue.\n    :param date: The date to reserve the venue.\n    :param contact_email: The contact email for sending the confirmation.\n    :return: True if the reservation is successful, False otherwise.\n    :raises ValueError: If any parameter is invalid.\n    \"\"\"\n    if not venue_name or not date or not contact_email:\n        raise ValueError(\"Venue name, date, and contact email must be provided.\")\n    \n    # Mock logic: if venue is \"Conference Center A\", date is \"2024-01-15\", and email is not empty, return True.\n    if venue_name == \"Conference Center A\" and date == \"2024-01-15\" and contact_email:\n        return True\n    return False", "user_query": "I need venues for a corporate conference using duckduckgo agent. Please find options that have audio-visual equipment, catering, are accessible, and have parking for up to 200 attendees.", "checklist": {"functions": ["search_venues"], "values": [[{"name": "Convention Hall C", "address": "789 Oak Drive", "max_attendees": 150, "audio_visual": true, "catering": true, "accessible": true, "parking": true}, {"name": "Event Center D", "address": "101 Walnut Lane", "max_attendees": 200, "audio_visual": true, "catering": true, "accessible": false, "parking": true}]]}}
{"difficulty": "easy", "function_schema_python": "def get_field_mapping_rule(source_field: str, target_field: str, source_system: str, target_system: str) -> dict:\n    \"\"\"Retrieves or creates a field mapping rule between two systems.\n\n    :param source_field: Name of the field in source system\n    :param target_field: Name of the field in target system\n    :param source_system: Source system identifier\n    :param target_system: Target system identifier\n    :return: Dictionary containing mapping rule details\n    :raises ValueError: If field names or system identifiers are invalid\"\"\"\n    pass\ndef validate_field_mapping(mapping_rule: dict) -> bool:\n    \"\"\"Validates if a field mapping rule is correctly configured.\n\n    :param mapping_rule: Dictionary containing the mapping rule configuration\n    :return: True if mapping is valid, False otherwise\n    :raises ValueError: If mapping_rule is invalid\"\"\"\n    pass\ndef transform_field_value(value: int, mapping_rule: dict) -> str:\n    \"\"\"Transforms a value based on the provided mapping rule.\n\n    :param value: Numeric value to transform (1-100)\n    :param mapping_rule: Dictionary containing the mapping configuration\n    :return: Transformed letter grade (A, B, C, or D)\n    :raises ValueError: If value is out of range or mapping_rule is invalid\"\"\"\n    pass\n", "function_schema_json": [{"name": "get_field_mapping_rule", "description": "Retrieves or creates a field mapping rule between two systems.", "parameters": {"type": "object", "properties": {"source_field": {"type": "string", "description": "Name of the field in source system"}, "target_field": {"type": "string", "description": "Name of the field in target system"}, "source_system": {"type": "string", "description": "Source system identifier"}, "target_system": {"type": "string", "description": "Target system identifier"}}, "required": ["source_field", "target_field", "source_system", "target_system"], "additionalProperties": false}}, {"name": "validate_field_mapping", "description": "Validates if a field mapping rule is correctly configured.", "parameters": {"type": "object", "properties": {"mapping_rule": {"type": "object", "description": "Dictionary containing the mapping rule configuration"}}, "required": ["mapping_rule"], "additionalProperties": false}}, {"name": "transform_field_value", "description": "Transforms a value based on the provided mapping rule.", "parameters": {"type": "object", "properties": {"value": {"type": "integer", "description": "Numeric value to transform (1-100)"}, "mapping_rule": {"type": "object", "description": "Dictionary containing the mapping configuration"}}, "required": ["value", "mapping_rule"], "additionalProperties": false}}], "mock_functions": "def get_field_mapping_rule(source_field: str, target_field: str, source_system: str, target_system: str) -> dict:\n    \"\"\"\n    Retrieves or creates a field mapping rule between two systems.\n    \n    :param source_field: Name of the field in source system\n    :param target_field: Name of the field in target system\n    :param source_system: Source system identifier\n    :param target_system: Target system identifier\n    :return: Dictionary containing mapping rule details\n    :raises ValueError: If field names or system identifiers are invalid\n    \"\"\"\n    if not all([source_field, target_field, source_system, target_system]):\n        raise ValueError(\"All parameters must be provided\")\n    \n    if (source_field.lower() == \"lead score\" and \n        target_field.lower() == \"prospect rating\" and \n        source_system == \"SB12345\" and \n        target_system == \"MF67890\"):\n        return {\n            \"rule_id\": \"MAP001\",\n            \"source_field\": \"Lead Score\",\n            \"target_field\": \"Prospect Rating\",\n            \"transformation_type\": \"numeric_to_letter\",\n            \"mapping_rules\": {\n                \"range\": [\n                    {\"min\": 76, \"max\": 100, \"value\": \"A\"},\n                    {\"min\": 51, \"max\": 75, \"value\": \"B\"},\n                    {\"min\": 26, \"max\": 50, \"value\": \"C\"},\n                    {\"min\": 1, \"max\": 25, \"value\": \"D\"}\n                ]\n            }\n        }\n    raise ValueError(\"Invalid field mapping configuration\")\ndef validate_field_mapping(mapping_rule: dict) -> bool:\n    \"\"\"\n    Validates if a field mapping rule is correctly configured.\n    \n    :param mapping_rule: Dictionary containing the mapping rule configuration\n    :return: True if mapping is valid, False otherwise\n    :raises ValueError: If mapping_rule is invalid\n    \"\"\"\n    required_keys = [\"rule_id\", \"source_field\", \"target_field\", \"transformation_type\", \"mapping_rules\"]\n    if not all(key in mapping_rule for key in required_keys):\n        raise ValueError(\"Invalid mapping rule structure\")\n    \n    if (mapping_rule[\"rule_id\"] == \"MAP001\" and \n        mapping_rule[\"transformation_type\"] == \"numeric_to_letter\"):\n        return True\n    return False\ndef transform_field_value(value: int, mapping_rule: dict) -> str:\n    \"\"\"\n    Transforms a value based on the provided mapping rule.\n    \n    :param value: Numeric value to transform (1-100)\n    :param mapping_rule: Dictionary containing the mapping configuration\n    :return: Transformed letter grade (A, B, C, or D)\n    :raises ValueError: If value is out of range or mapping_rule is invalid\n    \"\"\"\n    if not isinstance(value, int) or value < 1 or value > 100:\n        raise ValueError(\"Value must be an integer between 1 and 100\")\n    \n    if mapping_rule[\"rule_id\"] == \"MAP001\":\n        for range_rule in mapping_rule[\"mapping_rules\"][\"range\"]:\n            if range_rule[\"min\"] <= value <= range_rule[\"max\"]:\n                return range_rule[\"value\"]\n    raise ValueError(\"Invalid mapping rule or value\")", "user_query": "Can you get the field mapping rule for 'Lead Score' from SalesBoost (SB12345) to 'Prospect Rating' in MarketFlow (MF67890)?", "checklist": {"functions": ["get_field_mapping_rule"], "values": [{"rule_id": "MAP001", "source_field": "Lead Score", "target_field": "Prospect Rating", "transformation_type": "numeric_to_letter", "mapping_rules": {"range": [{"min": 76, "max": 100, "value": "A"}, {"min": 51, "max": 75, "value": "B"}, {"min": 26, "max": 50, "value": "C"}, {"min": 1, "max": 25, "value": "D"}]}}]}}
{"difficulty": "easy", "function_schema_python": "def get_integration_settings(platform_name: str, source_app: str, source_account_id: str, destination_app: str, destination_account_id: str) -> dict:\n    \"\"\"Retrieves the current integration settings for a given integration.\n\n    :param platform_name: The name of the integration platform (e.g., \"ConnectAll\").\n    :param source_app: The name of the source application (e.g., \"InvoiceNinja\").\n    :param source_account_id: The account ID for the source application.\n    :param destination_app: The name of the destination application (e.g., \"DataWise\").\n    :param destination_account_id: The account ID for the destination application.\n    :return: A dictionary containing the integration settings.\n        dict: A dictionary with the following keys:\n            - frequency (str): The current synchronization frequency (e.g., \"daily\", \"hourly\").\n    :raises ValueError: If any of the input parameters are invalid.\"\"\"\n    pass\ndef update_integration_settings(platform_name: str, source_app: str, source_account_id: str, destination_app: str, destination_account_id: str, new_settings: dict) -> bool:\n    \"\"\"Updates the integration settings for a given integration.\n\n    :param platform_name: The name of the integration platform.\n    :param source_app: The name of the source application.\n    :param source_account_id: The account ID for the source application.\n    :param destination_app: The name of the destination application.\n    :param destination_account_id: The account ID for the destination application.\n    :param new_settings: A dictionary containing the new settings.\n        dict: A dictionary with the following keys:\n            - frequency (str): The new synchronization frequency.\n    :return: True if the update was successful, False otherwise.\n    :raises ValueError: If any of the input parameters are invalid.\"\"\"\n    pass\ndef send_confirmation_message(user_name: str, message: str) -> None:\n    \"\"\"Sends a confirmation message to the user.\n    :param user_name: The name of the user.\n    :param message: The message to send.\n    :return: None\"\"\"\n    pass\n", "function_schema_json": [{"name": "get_integration_settings", "description": "Retrieves the current integration settings for a given integration.", "parameters": {"type": "object", "properties": {"platform_name": {"type": "string", "description": "The name of the integration platform (e.g., \"ConnectAll\")."}, "source_app": {"type": "string", "description": "The name of the source application (e.g., \"InvoiceNinja\")."}, "source_account_id": {"type": "string", "description": "The account ID for the source application."}, "destination_app": {"type": "string", "description": "The name of the destination application (e.g., \"DataWise\")."}, "destination_account_id": {"type": "string", "description": "The account ID for the destination application."}}, "required": ["platform_name", "source_app", "source_account_id", "destination_app", "destination_account_id"], "additionalProperties": false}}, {"name": "update_integration_settings", "description": "Updates the integration settings for a given integration.", "parameters": {"type": "object", "properties": {"platform_name": {"type": "string", "description": "The name of the integration platform."}, "source_app": {"type": "string", "description": "The name of the source application."}, "source_account_id": {"type": "string", "description": "The account ID for the source application."}, "destination_app": {"type": "string", "description": "The name of the destination application."}, "destination_account_id": {"type": "string", "description": "The account ID for the destination application."}, "new_settings": {"type": "object", "description": "A dictionary containing the new settings."}}, "required": ["platform_name", "source_app", "source_account_id", "destination_app", "destination_account_id", "new_settings"], "additionalProperties": false}}, {"name": "send_confirmation_message", "description": "Sends a confirmation message to the user.", "parameters": {"type": "object", "properties": {"user_name": {"type": "string", "description": "The name of the user."}, "message": {"type": "string", "description": "The message to send."}}, "required": ["user_name", "message"], "additionalProperties": false}}], "mock_functions": "def get_integration_settings(platform_name: str, source_app: str, source_account_id: str, destination_app: str, destination_account_id: str) -> dict:\n    \"\"\"\n    Retrieves the current integration settings for a given integration.\n\n    :param platform_name: The name of the integration platform (e.g., \"ConnectAll\").\n    :param source_app: The name of the source application (e.g., \"InvoiceNinja\").\n    :param source_account_id: The account ID for the source application.\n    :param destination_app: The name of the destination application (e.g., \"DataWise\").\n    :param destination_account_id: The account ID for the destination application.\n    :return: A dictionary containing the integration settings.\n        dict: A dictionary with the following keys:\n            - frequency (str): The current synchronization frequency (e.g., \"daily\", \"hourly\").\n    :raises ValueError: If any of the input parameters are invalid.\n    \"\"\"\n    if not all([platform_name, source_app, source_account_id, destination_app, destination_account_id]):\n        raise ValueError(\"All parameters must be provided.\")\n\n    if platform_name == \"ConnectAll\" and source_app == \"InvoiceNinja\" and source_account_id == \"IN11223\" and destination_app == \"DataWise\" and destination_account_id == \"DW44556\":\n        return {\"frequency\": \"daily\"}\n    else:\n        return {}\ndef update_integration_settings(platform_name: str, source_app: str, source_account_id: str, destination_app: str, destination_account_id: str, new_settings: dict) -> bool:\n    \"\"\"\n    Updates the integration settings for a given integration.\n\n    :param platform_name: The name of the integration platform.\n    :param source_app: The name of the source application.\n    :param source_account_id: The account ID for the source application.\n    :param destination_app: The name of the destination application.\n    :param destination_account_id: The account ID for the destination application.\n    :param new_settings: A dictionary containing the new settings.\n        dict: A dictionary with the following keys:\n            - frequency (str): The new synchronization frequency.\n    :return: True if the update was successful, False otherwise.\n    :raises ValueError: If any of the input parameters are invalid.\n    \"\"\"\n    if not all([platform_name, source_app, source_account_id, destination_app, destination_account_id, new_settings]):\n        raise ValueError(\"All parameters must be provided.\")\n    \n    if platform_name == \"ConnectAll\" and source_app == \"InvoiceNinja\" and source_account_id == \"IN11223\" and destination_app == \"DataWise\" and destination_account_id == \"DW44556\" and new_settings.get(\"frequency\") == \"hourly\":\n        return True\n    else:\n        return False\ndef send_confirmation_message(user_name: str, message: str) -> None:\n    \"\"\"\n    Sends a confirmation message to the user.\n    :param user_name: The name of the user.\n    :param message: The message to send.\n    :return: None\n    \"\"\"\n    # In a real implementation, this would send a message.\n    pass", "user_query": "What is the current synchronization frequency between InvoiceNinja (IN11223) and DataWise (DW44556)?", "checklist": {"functions": ["get_integration_settings"], "values": [{"frequency": "daily"}]}}
{"difficulty": "easy", "function_schema_python": "def get_project_details(project_id: str) -> dict:\n    \"\"\"Retrieves detailed information about a specific project.\n\n    :param project_id: The project identifier (e.g., 'PRJ-123')\n    :return: Dictionary containing project details\n        dict: {\n            'name': str,\n            'id': str,\n            'start_date': str,\n            'status': str,\n            'completion_percentage': float\n        }\n    :raises ValueError: If project_id format is invalid\"\"\"\n    pass\ndef get_project_tasks(project_id: str) -> list[dict]:\n    \"\"\"Retrieves all tasks associated with a project.\n\n    :param project_id: The project identifier (e.g., 'PRJ-123')\n    :return: List of dictionaries containing task details\n        list[dict]: Each dict contains:\n            {\n                'task_id': str,\n                'title': str,\n                'assignee': str,\n                'status': str,\n                'time_spent': float,\n                'remaining_hours': float\n            }\n    :raises ValueError: If project_id is invalid\"\"\"\n    pass\ndef get_project_issues(project_id: str) -> list[dict]:\n    \"\"\"Retrieves all outstanding issues for a project.\n\n    :param project_id: The project identifier (e.g., 'PRJ-123')\n    :return: List of dictionaries containing issue details\n        list[dict]: Each dict contains:\n            {\n                'issue_id': str,\n                'title': str,\n                'severity': str,\n                'status': str,\n                'reported_by': str\n            }\n    :raises ValueError: If project_id is invalid\"\"\"\n    pass\n", "function_schema_json": [{"name": "get_project_details", "description": "Retrieves detailed information about a specific project.", "parameters": {"type": "object", "properties": {"project_id": {"type": "string", "description": "The project identifier (e.g., 'PRJ-123')"}}, "required": ["project_id"], "additionalProperties": false}}, {"name": "get_project_tasks", "description": "Retrieves all tasks associated with a project.", "parameters": {"type": "object", "properties": {"project_id": {"type": "string", "description": "The project identifier (e.g., 'PRJ-123')"}}, "required": ["project_id"], "additionalProperties": false}}, {"name": "get_project_issues", "description": "Retrieves all outstanding issues for a project.", "parameters": {"type": "object", "properties": {"project_id": {"type": "string", "description": "The project identifier (e.g., 'PRJ-123')"}}, "required": ["project_id"], "additionalProperties": false}}], "mock_functions": "def get_project_details(project_id: str) -> dict:\n    \"\"\"\n    Retrieves detailed information about a specific project.\n    \n    :param project_id: The project identifier (e.g., 'PRJ-123')\n    :return: Dictionary containing project details\n        dict: {\n            'name': str,\n            'id': str,\n            'start_date': str,\n            'status': str,\n            'completion_percentage': float\n        }\n    :raises ValueError: If project_id format is invalid\n    \"\"\"\n    if not project_id.startswith('PRJ-'):\n        raise ValueError(\"Invalid project ID format\")\n    \n    if project_id == \"PRJ-123\":\n        return {\n            \"name\": \"Project Alpha\",\n            \"id\": \"PRJ-123\",\n            \"start_date\": \"2023-01-15\",\n            \"status\": \"In Progress\",\n            \"completion_percentage\": 65.5\n        }\n    raise ValueError(\"Project not found\")\ndef get_project_tasks(project_id: str) -> list[dict]:\n    \"\"\"\n    Retrieves all tasks associated with a project.\n    \n    :param project_id: The project identifier (e.g., 'PRJ-123')\n    :return: List of dictionaries containing task details\n        list[dict]: Each dict contains:\n            {\n                'task_id': str,\n                'title': str,\n                'assignee': str,\n                'status': str,\n                'time_spent': float,\n                'remaining_hours': float\n            }\n    :raises ValueError: If project_id is invalid\n    \"\"\"\n    if project_id == \"PRJ-123\":\n        return [\n            {\n                \"task_id\": \"TSK-001\",\n                \"title\": \"Database Setup\",\n                \"assignee\": \"John Doe\",\n                \"status\": \"Completed\",\n                \"time_spent\": 24.5,\n                \"remaining_hours\": 0\n            },\n            {\n                \"task_id\": \"TSK-002\",\n                \"title\": \"API Development\",\n                \"assignee\": \"Jane Smith\",\n                \"status\": \"In Progress\",\n                \"time_spent\": 35.0,\n                \"remaining_hours\": 15.5\n            }\n        ]\n    raise ValueError(\"Project not found\")\ndef get_project_issues(project_id: str) -> list[dict]:\n    \"\"\"\n    Retrieves all outstanding issues for a project.\n    \n    :param project_id: The project identifier (e.g., 'PRJ-123')\n    :return: List of dictionaries containing issue details\n        list[dict]: Each dict contains:\n            {\n                'issue_id': str,\n                'title': str,\n                'severity': str,\n                'status': str,\n                'reported_by': str\n            }\n    :raises ValueError: If project_id is invalid\n    \"\"\"\n    if project_id == \"PRJ-123\":\n        return [\n            {\n                \"issue_id\": \"ISS-001\",\n                \"title\": \"Performance Bottleneck\",\n                \"severity\": \"High\",\n                \"status\": \"Open\",\n                \"reported_by\": \"Jane Smith\"\n            }\n        ]\n    raise ValueError(\"Project not found\")", "user_query": "Can you retrieve the details for Project Alpha with ID PRJ-123?", "checklist": {"functions": ["get_project_details"], "values": [{"name": "Project Alpha", "id": "PRJ-123", "start_date": "2023-01-15", "status": "In Progress", "completion_percentage": 65.5}]}}
{"difficulty": "easy", "function_schema_python": "def get_project_details(project_id: str) -> dict:\n    \"\"\"Retrieves detailed information about a specific project.\n\n    :param project_id: The project identifier (e.g., 'PRJ-123')\n    :return: Dictionary containing project details\n        dict: {\n            'name': str,\n            'id': str,\n            'start_date': str,\n            'status': str,\n            'completion_percentage': float\n        }\n    :raises ValueError: If project_id format is invalid\"\"\"\n    pass\ndef get_project_tasks(project_id: str) -> list[dict]:\n    \"\"\"Retrieves all tasks associated with a project.\n\n    :param project_id: The project identifier (e.g., 'PRJ-123')\n    :return: List of dictionaries containing task details\n        list[dict]: Each dict contains:\n            {\n                'task_id': str,\n                'title': str,\n                'assignee': str,\n                'status': str,\n                'time_spent': float,\n                'remaining_hours': float\n            }\n    :raises ValueError: If project_id is invalid\"\"\"\n    pass\ndef get_project_issues(project_id: str) -> list[dict]:\n    \"\"\"Retrieves all outstanding issues for a project.\n\n    :param project_id: The project identifier (e.g., 'PRJ-123')\n    :return: List of dictionaries containing issue details\n        list[dict]: Each dict contains:\n            {\n                'issue_id': str,\n                'title': str,\n                'severity': str,\n                'status': str,\n                'reported_by': str\n            }\n    :raises ValueError: If project_id is invalid\"\"\"\n    pass\n", "function_schema_json": [{"name": "get_project_details", "description": "Retrieves detailed information about a specific project.", "parameters": {"type": "object", "properties": {"project_id": {"type": "string", "description": "The project identifier (e.g., 'PRJ-123')"}}, "required": ["project_id"], "additionalProperties": false}}, {"name": "get_project_tasks", "description": "Retrieves all tasks associated with a project.", "parameters": {"type": "object", "properties": {"project_id": {"type": "string", "description": "The project identifier (e.g., 'PRJ-123')"}}, "required": ["project_id"], "additionalProperties": false}}, {"name": "get_project_issues", "description": "Retrieves all outstanding issues for a project.", "parameters": {"type": "object", "properties": {"project_id": {"type": "string", "description": "The project identifier (e.g., 'PRJ-123')"}}, "required": ["project_id"], "additionalProperties": false}}], "mock_functions": "def get_project_details(project_id: str) -> dict:\n    \"\"\"\n    Retrieves detailed information about a specific project.\n    \n    :param project_id: The project identifier (e.g., 'PRJ-123')\n    :return: Dictionary containing project details\n        dict: {\n            'name': str,\n            'id': str,\n            'start_date': str,\n            'status': str,\n            'completion_percentage': float\n        }\n    :raises ValueError: If project_id format is invalid\n    \"\"\"\n    if not project_id.startswith('PRJ-'):\n        raise ValueError(\"Invalid project ID format\")\n    \n    if project_id == \"PRJ-123\":\n        return {\n            \"name\": \"Project Alpha\",\n            \"id\": \"PRJ-123\",\n            \"start_date\": \"2023-01-15\",\n            \"status\": \"In Progress\",\n            \"completion_percentage\": 65.5\n        }\n    raise ValueError(\"Project not found\")\ndef get_project_tasks(project_id: str) -> list[dict]:\n    \"\"\"\n    Retrieves all tasks associated with a project.\n    \n    :param project_id: The project identifier (e.g., 'PRJ-123')\n    :return: List of dictionaries containing task details\n        list[dict]: Each dict contains:\n            {\n                'task_id': str,\n                'title': str,\n                'assignee': str,\n                'status': str,\n                'time_spent': float,\n                'remaining_hours': float\n            }\n    :raises ValueError: If project_id is invalid\n    \"\"\"\n    if project_id == \"PRJ-123\":\n        return [\n            {\n                \"task_id\": \"TSK-001\",\n                \"title\": \"Database Setup\",\n                \"assignee\": \"John Doe\",\n                \"status\": \"Completed\",\n                \"time_spent\": 24.5,\n                \"remaining_hours\": 0\n            },\n            {\n                \"task_id\": \"TSK-002\",\n                \"title\": \"API Development\",\n                \"assignee\": \"Jane Smith\",\n                \"status\": \"In Progress\",\n                \"time_spent\": 35.0,\n                \"remaining_hours\": 15.5\n            }\n        ]\n    raise ValueError(\"Project not found\")\ndef get_project_issues(project_id: str) -> list[dict]:\n    \"\"\"\n    Retrieves all outstanding issues for a project.\n    \n    :param project_id: The project identifier (e.g., 'PRJ-123')\n    :return: List of dictionaries containing issue details\n        list[dict]: Each dict contains:\n            {\n                'issue_id': str,\n                'title': str,\n                'severity': str,\n                'status': str,\n                'reported_by': str\n            }\n    :raises ValueError: If project_id is invalid\n    \"\"\"\n    if project_id == \"PRJ-123\":\n        return [\n            {\n                \"issue_id\": \"ISS-001\",\n                \"title\": \"Performance Bottleneck\",\n                \"severity\": \"High\",\n                \"status\": \"Open\",\n                \"reported_by\": \"Jane Smith\"\n            }\n        ]\n    raise ValueError(\"Project not found\")", "user_query": "Please show me all tasks for Project Alpha (PRJ-123), including their current status and time spent.", "checklist": {"functions": ["get_project_tasks"], "values": [[{"task_id": "TSK-001", "title": "Database Setup", "assignee": "John Doe", "status": "Completed", "time_spent": 24.5, "remaining_hours": 0}, {"task_id": "TSK-002", "title": "API Development", "assignee": "Jane Smith", "status": "In Progress", "time_spent": 35.0, "remaining_hours": 15.5}]]}}
{"difficulty": "easy", "function_schema_python": "def assign_task_to_team_member(task_name: str, team_member_name: str) -> bool:\n    \"\"\"Assigns a task to a specific team member.\n\n    :param task_name: The name of the task to be assigned.\n    :param team_member_name: The name of the team member to whom the task is assigned.\n    :return: True if the task was successfully assigned, False otherwise.\n    :raises ValueError: If either task_name or team_member_name is empty.\"\"\"\n    pass\ndef track_task_progress(task_id: int) -> dict:\n    \"\"\"Tracks the progress of a task given its ID.\n\n    :param task_id: The ID of the task to track.\n    :return:\n        dict: A dictionary with the following keys:\n            - task_id (int): The ID of the task.\n            - status (str): The current status of the task (e.g., 'In Progress', 'Completed').\n            - completion_percentage (float): The percentage of completion of the task (0.0 to 100.0).\n    :raises ValueError: If task_id is not an integer.\"\"\"\n    pass\ndef set_project_deadline(project_name: str, deadline: str) -> bool:\n    \"\"\"Sets a deadline for a specific project.\n\n    :param project_name: The name of the project.\n    :param deadline: The deadline for the project in 'YYYY-MM-DD' format.\n    :return: True if the deadline was successfully set, False otherwise.\n    :raises ValueError: If project_name or deadline is empty, or if deadline is not in 'YYYY-MM-DD' format.\"\"\"\n    pass\ndef notify_team_members(message: str) -> bool:\n    \"\"\"Notifies all team members with a given message.\n\n    :param message: The message to notify the team members with.\n    :return: True if the notification was successfully sent, False otherwise.\n    :raises ValueError: If message is empty.\"\"\"\n    pass\n", "function_schema_json": [{"name": "assign_task_to_team_member", "description": "Assigns a task to a specific team member.", "parameters": {"type": "object", "properties": {"task_name": {"type": "string", "description": "The name of the task to be assigned."}, "team_member_name": {"type": "string", "description": "The name of the team member to whom the task is assigned."}}, "required": ["task_name", "team_member_name"], "additionalProperties": false}}, {"name": "track_task_progress", "description": "Tracks the progress of a task given its ID.", "parameters": {"type": "object", "properties": {"task_id": {"type": "integer", "description": "The ID of the task to track."}}, "required": ["task_id"], "additionalProperties": false}}, {"name": "set_project_deadline", "description": "Sets a deadline for a specific project.", "parameters": {"type": "object", "properties": {"project_name": {"type": "string", "description": "The name of the project."}, "deadline": {"type": "string", "description": "The deadline for the project in 'YYYY-MM-DD' format."}}, "required": ["project_name", "deadline"], "additionalProperties": false}}, {"name": "notify_team_members", "description": "Notifies all team members with a given message.", "parameters": {"type": "object", "properties": {"message": {"type": "string", "description": "The message to notify the team members with."}}, "required": ["message"], "additionalProperties": false}}], "mock_functions": "def assign_task_to_team_member(task_name: str, team_member_name: str) -> bool:\n    \"\"\"\n    Assigns a task to a specific team member.\n    \n    :param task_name: The name of the task to be assigned.\n    :param team_member_name: The name of the team member to whom the task is assigned.\n    :return: True if the task was successfully assigned, False otherwise.\n    :raises ValueError: If either task_name or team_member_name is empty.\n    \"\"\"\n    if not task_name or not team_member_name:\n        raise ValueError(\"Task name and team member name must be provided.\")\n    # Mock logic: Assume tasks can be assigned to any member with valid input\n    print(f\"Task '{task_name}' assigned to {team_member_name}.\")\n    return True\ndef track_task_progress(task_id: int) -> dict:\n    \"\"\"\n    Tracks the progress of a task given its ID.\n    \n    :param task_id: The ID of the task to track.\n    :return:\n        dict: A dictionary with the following keys:\n            - task_id (int): The ID of the task.\n            - status (str): The current status of the task (e.g., 'In Progress', 'Completed').\n            - completion_percentage (float): The percentage of completion of the task (0.0 to 100.0).\n    :raises ValueError: If task_id is not an integer.\n    \"\"\"\n    if not isinstance(task_id, int):\n        raise ValueError(\"Task ID must be an integer.\")\n    # Mock logic: Assume tasks have pre-defined statuses and completion percentages\n    mock_progress = {\n        1: {\"task_id\": 1, \"status\": \"In Progress\", \"completion_percentage\": 75.0},\n        2: {\"task_id\": 2, \"status\": \"Completed\", \"completion_percentage\": 100.0},\n        3: {\"task_id\": 3, \"status\": \"Not Started\", \"completion_percentage\": 0.0}\n    }\n    return mock_progress.get(task_id, {\"task_id\": task_id, \"status\": \"Unknown\", \"completion_percentage\": 0.0})\ndef set_project_deadline(project_name: str, deadline: str) -> bool:\n    \"\"\"\n    Sets a deadline for a specific project.\n    \n    :param project_name: The name of the project.\n    :param deadline: The deadline for the project in 'YYYY-MM-DD' format.\n    :return: True if the deadline was successfully set, False otherwise.\n    :raises ValueError: If project_name or deadline is empty, or if deadline is not in 'YYYY-MM-DD' format.\n    \"\"\"\n    if not project_name or not deadline:\n        raise ValueError(\"Project name and deadline must be provided.\")\n    if not isinstance(deadline, str) or len(deadline) != 10 or deadline[4] != '-' or deadline[7] != '-':\n        raise ValueError(\"Deadline must be in 'YYYY-MM-DD' format.\")\n    # Mock logic: Assume deadlines can be set to any project with valid input\n    print(f\"Deadline for project '{project_name}' set to {deadline}.\")\n    return True\ndef notify_team_members(message: str) -> bool:\n    \"\"\"\n    Notifies all team members with a given message.\n    \n    :param message: The message to notify the team members with.\n    :return: True if the notification was successfully sent, False otherwise.\n    :raises ValueError: If message is empty.\n    \"\"\"\n    if not message:\n        raise ValueError(\"Message must not be empty.\")\n    # Mock logic: Assume notifications can be sent with valid input\n    print(f\"Notifying team members with message: {message}\")\n    return True", "user_query": "Could you assign the task 'Design API Endpoint' to the team member 'Alice'?", "checklist": {"functions": ["assign_task_to_team_member"], "values": [true]}}
{"difficulty": "easy", "function_schema_python": "def assign_task_to_team_member(task_name: str, team_member_name: str) -> bool:\n    \"\"\"Assigns a task to a specific team member.\n\n    :param task_name: The name of the task to be assigned.\n    :param team_member_name: The name of the team member to whom the task is assigned.\n    :return: True if the task was successfully assigned, False otherwise.\n    :raises ValueError: If either task_name or team_member_name is empty.\"\"\"\n    pass\ndef track_task_progress(task_id: int) -> dict:\n    \"\"\"Tracks the progress of a task given its ID.\n\n    :param task_id: The ID of the task to track.\n    :return:\n        dict: A dictionary with the following keys:\n            - task_id (int): The ID of the task.\n            - status (str): The current status of the task (e.g., 'In Progress', 'Completed').\n            - completion_percentage (float): The percentage of completion of the task (0.0 to 100.0).\n    :raises ValueError: If task_id is not an integer.\"\"\"\n    pass\ndef set_project_deadline(project_name: str, deadline: str) -> bool:\n    \"\"\"Sets a deadline for a specific project.\n\n    :param project_name: The name of the project.\n    :param deadline: The deadline for the project in 'YYYY-MM-DD' format.\n    :return: True if the deadline was successfully set, False otherwise.\n    :raises ValueError: If project_name or deadline is empty, or if deadline is not in 'YYYY-MM-DD' format.\"\"\"\n    pass\ndef notify_team_members(message: str) -> bool:\n    \"\"\"Notifies all team members with a given message.\n\n    :param message: The message to notify the team members with.\n    :return: True if the notification was successfully sent, False otherwise.\n    :raises ValueError: If message is empty.\"\"\"\n    pass\n", "function_schema_json": [{"name": "assign_task_to_team_member", "description": "Assigns a task to a specific team member.", "parameters": {"type": "object", "properties": {"task_name": {"type": "string", "description": "The name of the task to be assigned."}, "team_member_name": {"type": "string", "description": "The name of the team member to whom the task is assigned."}}, "required": ["task_name", "team_member_name"], "additionalProperties": false}}, {"name": "track_task_progress", "description": "Tracks the progress of a task given its ID.", "parameters": {"type": "object", "properties": {"task_id": {"type": "integer", "description": "The ID of the task to track."}}, "required": ["task_id"], "additionalProperties": false}}, {"name": "set_project_deadline", "description": "Sets a deadline for a specific project.", "parameters": {"type": "object", "properties": {"project_name": {"type": "string", "description": "The name of the project."}, "deadline": {"type": "string", "description": "The deadline for the project in 'YYYY-MM-DD' format."}}, "required": ["project_name", "deadline"], "additionalProperties": false}}, {"name": "notify_team_members", "description": "Notifies all team members with a given message.", "parameters": {"type": "object", "properties": {"message": {"type": "string", "description": "The message to notify the team members with."}}, "required": ["message"], "additionalProperties": false}}], "mock_functions": "def assign_task_to_team_member(task_name: str, team_member_name: str) -> bool:\n    \"\"\"\n    Assigns a task to a specific team member.\n    \n    :param task_name: The name of the task to be assigned.\n    :param team_member_name: The name of the team member to whom the task is assigned.\n    :return: True if the task was successfully assigned, False otherwise.\n    :raises ValueError: If either task_name or team_member_name is empty.\n    \"\"\"\n    if not task_name or not team_member_name:\n        raise ValueError(\"Task name and team member name must be provided.\")\n    # Mock logic: Assume tasks can be assigned to any member with valid input\n    print(f\"Task '{task_name}' assigned to {team_member_name}.\")\n    return True\ndef track_task_progress(task_id: int) -> dict:\n    \"\"\"\n    Tracks the progress of a task given its ID.\n    \n    :param task_id: The ID of the task to track.\n    :return:\n        dict: A dictionary with the following keys:\n            - task_id (int): The ID of the task.\n            - status (str): The current status of the task (e.g., 'In Progress', 'Completed').\n            - completion_percentage (float): The percentage of completion of the task (0.0 to 100.0).\n    :raises ValueError: If task_id is not an integer.\n    \"\"\"\n    if not isinstance(task_id, int):\n        raise ValueError(\"Task ID must be an integer.\")\n    # Mock logic: Assume tasks have pre-defined statuses and completion percentages\n    mock_progress = {\n        1: {\"task_id\": 1, \"status\": \"In Progress\", \"completion_percentage\": 75.0},\n        2: {\"task_id\": 2, \"status\": \"Completed\", \"completion_percentage\": 100.0},\n        3: {\"task_id\": 3, \"status\": \"Not Started\", \"completion_percentage\": 0.0}\n    }\n    return mock_progress.get(task_id, {\"task_id\": task_id, \"status\": \"Unknown\", \"completion_percentage\": 0.0})\ndef set_project_deadline(project_name: str, deadline: str) -> bool:\n    \"\"\"\n    Sets a deadline for a specific project.\n    \n    :param project_name: The name of the project.\n    :param deadline: The deadline for the project in 'YYYY-MM-DD' format.\n    :return: True if the deadline was successfully set, False otherwise.\n    :raises ValueError: If project_name or deadline is empty, or if deadline is not in 'YYYY-MM-DD' format.\n    \"\"\"\n    if not project_name or not deadline:\n        raise ValueError(\"Project name and deadline must be provided.\")\n    if not isinstance(deadline, str) or len(deadline) != 10 or deadline[4] != '-' or deadline[7] != '-':\n        raise ValueError(\"Deadline must be in 'YYYY-MM-DD' format.\")\n    # Mock logic: Assume deadlines can be set to any project with valid input\n    print(f\"Deadline for project '{project_name}' set to {deadline}.\")\n    return True\ndef notify_team_members(message: str) -> bool:\n    \"\"\"\n    Notifies all team members with a given message.\n    \n    :param message: The message to notify the team members with.\n    :return: True if the notification was successfully sent, False otherwise.\n    :raises ValueError: If message is empty.\n    \"\"\"\n    if not message:\n        raise ValueError(\"Message must not be empty.\")\n    # Mock logic: Assume notifications can be sent with valid input\n    print(f\"Notifying team members with message: {message}\")\n    return True", "user_query": "This is Lucas from CodeCollab. Can you track the progress of task ID 1 and let me know its completion percentage?", "checklist": {"functions": ["track_task_progress"], "values": [{"task_id": 1, "status": "In Progress", "completion_percentage": 75.0}]}}
{"difficulty": "easy", "function_schema_python": "def consult_smart_agent(tool_name: str, client_details: dict) -> dict:\n    \"\"\"Consults a smart agent for tailored onboarding tips and best practices for a given tool.\n\n    :param tool_name: The name of the tool (e.g., 'AgileWorks').\n    :param client_details: A dictionary containing client information.\n        - 'company_name' (str): The name of the client's company (e.g., 'Mid-Sized Tech Firm').\n        - 'industry' (str): The industry the client's company operates in (e.g., 'Tech').\n        - 'team_size' (int): The size of the client's team (e.g., 50).\n        - 'existing_tools' (list[str]): List of existing tools the client is using (e.g., ['Slack', 'Asana']).\n    :return:\n        dict: A dictionary with the following keys:\n            - 'onboarding_tips' (list[str]): List of onboarding tips.\n            - 'best_practices' (list[str]): List of best practices.\n    :raises ValueError: If tool_name or client_details is invalid.\"\"\"\n    pass\ndef generate_integration_report(tool_name: str, existing_tools: list) -> dict:\n    \"\"\"Generates a report on how well the new tool integrates with existing tools.\n\n    :param tool_name: The name of the new tool (e.g., 'AgileWorks').\n    :param existing_tools: A list of names of existing tools the client is using (e.g., ['Slack', 'Asana']).\n    :return:\n        dict: A dictionary with the following keys:\n            - 'compatibility' (list[str]): List of existing tools that are compatible.\n            - 'integrate_instructions' (dict): Dictionary of integration instructions for each compatible tool.\n    :raises ValueError: If tool_name or existing_tools is invalid.\"\"\"\n    pass\ndef onboarding_client_setup(tool_name: str, client_name: str) -> dict:\n    \"\"\"Sets up the client's onboarding process for a new tool.\n\n    :param tool_name: The name of the tool (e.g., 'AgileWorks').\n    :param client_name: The name of the client company (e.g., 'Mid-Sized Tech Firm').\n    :return:\n        dict: A dictionary with the following keys:\n            - 'setup_status' (str): Status of the setup (e.g., 'Completed').\n            - 'next_steps' (list[str]): List of next steps in the onboarding process.\n    :raises ValueError: If tool_name or client_name is invalid.\"\"\"\n    pass\n", "function_schema_json": [{"name": "consult_smart_agent", "description": "Consults a smart agent for tailored onboarding tips and best practices for a given tool.", "parameters": {"type": "object", "properties": {"tool_name": {"type": "string", "description": "The name of the tool (e.g., 'AgileWorks')."}, "client_details": {"type": "object", "description": "A dictionary containing client information."}}, "required": ["tool_name", "client_details"], "additionalProperties": false}}, {"name": "generate_integration_report", "description": "Generates a report on how well the new tool integrates with existing tools.", "parameters": {"type": "object", "properties": {"tool_name": {"type": "string", "description": "The name of the new tool (e.g., 'AgileWorks')."}, "existing_tools": {"type": "array", "description": "A list of names of existing tools the client is using (e.g., ['Slack', 'Asana'])."}}, "required": ["tool_name", "existing_tools"], "additionalProperties": false}}, {"name": "onboarding_client_setup", "description": "Sets up the client's onboarding process for a new tool.", "parameters": {"type": "object", "properties": {"tool_name": {"type": "string", "description": "The name of the tool (e.g., 'AgileWorks')."}, "client_name": {"type": "string", "description": "The name of the client company (e.g., 'Mid-Sized Tech Firm')."}}, "required": ["tool_name", "client_name"], "additionalProperties": false}}], "mock_functions": "def consult_smart_agent(tool_name: str, client_details: dict) -> dict:\n    \"\"\"\n    Consults a smart agent for tailored onboarding tips and best practices for a given tool.\n    \n    :param tool_name: The name of the tool (e.g., 'AgileWorks').\n    :param client_details: A dictionary containing client information.\n        - 'company_name' (str): The name of the client's company (e.g., 'Mid-Sized Tech Firm').\n        - 'industry' (str): The industry the client's company operates in (e.g., 'Tech').\n        - 'team_size' (int): The size of the client's team (e.g., 50).\n        - 'existing_tools' (list[str]): List of existing tools the client is using (e.g., ['Slack', 'Asana']).\n    :return:\n        dict: A dictionary with the following keys:\n            - 'onboarding_tips' (list[str]): List of onboarding tips.\n            - 'best_practices' (list[str]): List of best practices.\n    :raises ValueError: If tool_name or client_details is invalid.\n    \"\"\"\n    if not tool_name or not isinstance(client_details, dict):\n        raise ValueError(\"Tool name and client details must be provided.\")\n    \n    onboarding_tips = [\n        f\"Start by setting up a dedicated workspace for {client_details['company_name']} in {tool_name}.\",\n        \"Invite all team members to the workspace and assign roles.\",\n        \"Conduct an introduction session to familiarize everyone with the tool's features.\"\n    ]\n    \n    best_practices = [\n        \"Encourage team members to use the asynchronous communication features.\",\n        \"Regularly check in on the progress of projects to ensure everyone is on track.\",\n        \"Celebrate milestones and successes to boost team morale.\"\n    ]\n    \n    return {\n        \"onboarding_tips\": onboarding_tips,\n        \"best_practices\": best_practices\n    }\ndef generate_integration_report(tool_name: str, existing_tools: list) -> dict:\n    \"\"\"\n    Generates a report on how well the new tool integrates with existing tools.\n    \n    :param tool_name: The name of the new tool (e.g., 'AgileWorks').\n    :param existing_tools: A list of names of existing tools the client is using (e.g., ['Slack', 'Asana']).\n    :return:\n        dict: A dictionary with the following keys:\n            - 'compatibility' (list[str]): List of existing tools that are compatible.\n            - 'integrate_instructions' (dict): Dictionary of integration instructions for each compatible tool.\n    :raises ValueError: If tool_name or existing_tools is invalid.\n    \"\"\"\n    if not tool_name or not isinstance(existing_tools, list):\n        raise ValueError(\"Tool name and existing tools must be provided.\")\n    \n    compatible_tools = [tool for tool in existing_tools if tool.lower() in ['microsoft365', 'google_workspace', 'salesforce', 'zendesk', 'slack', 'trello', 'asana', 'zapier', 'shopify']]\n    \n    integrate_instructions = {\n        'Slack': f\"To integrate {tool_name} with Slack, connect through the Slack API.\",\n        'Asana': f\"To integrate {tool_name} with Asana, use the Asana API to sync projects.\",\n        'Zapier': f\"To integrate {tool_name} with Zapier, create a custom zap for specific actions.\",\n        'Trello': f\"To integrate {tool_name} with Trello, use Trello API for project management.\"\n    }\n    \n    return {\n        \"compatibility\": compatible_tools,\n        \"integrate_instructions\": {tool: integrate_instructions.get(tool, \"No specific instructions available.\") for tool in compatible_tools}\n    }\ndef onboarding_client_setup(tool_name: str, client_name: str) -> dict:\n    \"\"\"\n    Sets up the client's onboarding process for a new tool.\n    \n    :param tool_name: The name of the tool (e.g., 'AgileWorks').\n    :param client_name: The name of the client company (e.g., 'Mid-Sized Tech Firm').\n    :return:\n        dict: A dictionary with the following keys:\n            - 'setup_status' (str): Status of the setup (e.g., 'Completed').\n            - 'next_steps' (list[str]): List of next steps in the onboarding process.\n    :raises ValueError: If tool_name or client_name is invalid.\n    \"\"\"\n    if not tool_name or not client_name:\n        raise ValueError(\"Tool name and client name must be provided.\")\n    \n    setup_status = \"Completed\"\n    next_steps = [\n        f\"Verify setup with {client_name}.\",\n        \"Schedule a training session for the team.\",\n        \"Monitor usage to make sure everyone is comfortable with the tool.\"\n    ]\n    \n    return {\n        \"setup_status\": setup_status,\n        \"next_steps\": next_steps\n    }", "user_query": "This is Mia from AgileWorks. Can you check how AgileWorks integrates with our client's existing tools: Slack, Asana, and Trello?", "checklist": {"functions": ["generate_integration_report"], "values": [{"compatibility": ["Slack", "Asana", "Trello"], "integrate_instructions": {"Slack": "To integrate AgileWorks with Slack, connect through the Slack API.", "Asana": "To integrate AgileWorks with Asana, use the Asana API to sync projects.", "Trello": "To integrate AgileWorks with Trello, use Trello API for project management."}}]}}
{"difficulty": "easy", "function_schema_python": "def fetch_average_response_time(ticketing_system: str) -> int:\n    \"\"\"Fetches the average response time for tickets in a given ticketing system.\n\n    :param ticketing_system: The name of the ticketing system (e.g., 'ResoluteAssist').\n    :return: The average response time in hours.\n    :raises ValueError: If the ticketing system is not recognized.\"\"\"\n    pass\ndef analyze_ticket_trends(ticketing_system: str) -> list:\n    \"\"\"Analyzes ticket trends in a given ticketing system.\n\n    :param ticketing_system: The name of the ticketing system (e.g., 'ResoluteAssist').\n    :return: A list of trends, each described as a string.\n    :raises ValueError: If the ticketing system is not recognized.\"\"\"\n    pass\ndef suggest_workflow_improvements(ticketing_system: str) -> dict:\n    \"\"\"Suggests workflow improvements for a given ticketing system.\n\n    :param ticketing_system: The name of the ticketing system (e.g., 'ResoluteAssist').\n    :return:\n        dict: A dictionary with the following keys:\n            - new_processes (list[str]): Suggested new processes.\n            - process_optimizations (list[str]): Suggestions for optimizing existing processes.\n            - automation_recommendations (list[str]): Recommended integrations for automation.\n    :raises ValueError: If the ticketing system is not recognized.\"\"\"\n    pass\ndef get_integration_recommendations(ticketing_system: str, current_integrations: list) -> list:\n    \"\"\"Provides integration recommendations for a given ticketing system based on current integrations.\n\n    :param ticketing_system: The name of the ticketing system (e.g., 'ResoluteAssist').\n    :param current_integrations: A list of current integrations (e.g., ['Slack']).\n    :return: A list of integration recommendations.\n    :raises ValueError: If the ticketing system is not recognized.\"\"\"\n    pass\ndef monitor_ticket_volume(ticketing_system: str) -> dict:\n    \"\"\"Monitors the volume of tickets in a given ticketing system.\n\n    :param ticketing_system: The name of the ticketing system (e.g., 'ResoluteAssist').\n    :return:\n        dict: A dictionary with the following keys:\n            - total_tickets (int): Total number of tickets.\n            - open_tickets (int): Number of open tickets.\n            - closed_tickets (int): Number of closed tickets.\n    :raises ValueError: If the ticketing system is not recognized.\"\"\"\n    pass\n", "function_schema_json": [{"name": "fetch_average_response_time", "description": "Fetches the average response time for tickets in a given ticketing system.", "parameters": {"type": "object", "properties": {"ticketing_system": {"type": "string", "description": "The name of the ticketing system (e.g., 'ResoluteAssist')."}}, "required": ["ticketing_system"], "additionalProperties": false}}, {"name": "analyze_ticket_trends", "description": "Analyzes ticket trends in a given ticketing system.", "parameters": {"type": "object", "properties": {"ticketing_system": {"type": "string", "description": "The name of the ticketing system (e.g., 'ResoluteAssist')."}}, "required": ["ticketing_system"], "additionalProperties": false}}, {"name": "suggest_workflow_improvements", "description": "Suggests workflow improvements for a given ticketing system.", "parameters": {"type": "object", "properties": {"ticketing_system": {"type": "string", "description": "The name of the ticketing system (e.g., 'ResoluteAssist')."}}, "required": ["ticketing_system"], "additionalProperties": false}}, {"name": "get_integration_recommendations", "description": "Provides integration recommendations for a given ticketing system based on current integrations.", "parameters": {"type": "object", "properties": {"ticketing_system": {"type": "string", "description": "The name of the ticketing system (e.g., 'ResoluteAssist')."}, "current_integrations": {"type": "array", "description": "A list of current integrations (e.g., ['Slack'])."}}, "required": ["ticketing_system", "current_integrations"], "additionalProperties": false}}, {"name": "monitor_ticket_volume", "description": "Monitors the volume of tickets in a given ticketing system.", "parameters": {"type": "object", "properties": {"ticketing_system": {"type": "string", "description": "The name of the ticketing system (e.g., 'ResoluteAssist')."}}, "required": ["ticketing_system"], "additionalProperties": false}}], "mock_functions": "def fetch_average_response_time(ticketing_system: str) -> int:\n    \"\"\"\n    Fetches the average response time for tickets in a given ticketing system.\n    \n    :param ticketing_system: The name of the ticketing system (e.g., 'ResoluteAssist').\n    :return: The average response time in hours.\n    :raises ValueError: If the ticketing system is not recognized.\n    \"\"\"\n    if ticketing_system.lower() == 'resoluteassist':\n        return 50  # Simulating an average response time of 50 hours\n    raise ValueError(f\"Ticketing system '{ticketing_system}' not recognized.\")\ndef analyze_ticket_trends(ticketing_system: str) -> list:\n    \"\"\"\n    Analyzes ticket trends in a given ticketing system.\n    \n    :param ticketing_system: The name of the ticketing system (e.g., 'ResoluteAssist').\n    :return: A list of trends, each described as a string.\n    :raises ValueError: If the ticketing system is not recognized.\n    \"\"\"\n    if ticketing_system.lower() == 'resoluteassist':\n        return [\n            \"Higher volume of tickets related to the new product line\",\n            \"Increased response times over the past week\",\n            \"Common issues reported include setup and troubleshooting\"\n        ]\n    raise ValueError(f\"Ticketing system '{ticketing_system}' not recognized.\")\ndef suggest_workflow_improvements(ticketing_system: str) -> dict:\n    \"\"\"\n    Suggests workflow improvements for a given ticketing system.\n    \n    :param ticketing_system: The name of the ticketing system (e.g., 'ResoluteAssist').\n    :return:\n        dict: A dictionary with the following keys:\n            - new_processes (list[str]): Suggested new processes.\n            - process_optimizations (list[str]): Suggestions for optimizing existing processes.\n            - automation_recommendations (list[str]): Recommended integrations for automation.\n    :raises ValueError: If the ticketing system is not recognized.\n    \"\"\"\n    if ticketing_system.lower() == 'resoluteassist':\n        return {\n            \"new_processes\": [\"Implement a triage process for incoming tickets\"],\n            \"process_optimizations\": [\"Reduce manual data entry by using templates\"],\n            \"automation_recommendations\": [\"Integrate with Zendesk for better ticket management\"]\n        }\n    raise ValueError(f\"Ticketing system '{ticketing_system}' not recognized.\")\ndef get_integration_recommendations(ticketing_system: str, current_integrations: list) -> list:\n    \"\"\"\n    Provides integration recommendations for a given ticketing system based on current integrations.\n    \n    :param ticketing_system: The name of the ticketing system (e.g., 'ResoluteAssist').\n    :param current_integrations: A list of current integrations (e.g., ['Slack']).\n    :return: A list of integration recommendations.\n    :raises ValueError: If the ticketing system is not recognized.\n    \"\"\"\n    if ticketing_system.lower() == 'resoluteassist':\n        recommended_integrations = ['microsoft365', 'google_workspace', 'salesforce', 'trello', 'asana', 'zapier', 'shopify']\n        return list(set(recommended_integrations) - set(current_integrations))\n    raise ValueError(f\"Ticketing system '{ticketing_system}' not recognized.\")\ndef monitor_ticket_volume(ticketing_system: str) -> dict:\n    \"\"\"\n    Monitors the volume of tickets in a given ticketing system.\n    \n    :param ticketing_system: The name of the ticketing system (e.g., 'ResoluteAssist').\n    :return:\n        dict: A dictionary with the following keys:\n            - total_tickets (int): Total number of tickets.\n            - open_tickets (int): Number of open tickets.\n            - closed_tickets (int): Number of closed tickets.\n    :raises ValueError: If the ticketing system is not recognized.\n    \"\"\"\n    if ticketing_system.lower() == 'resoluteassist':\n        return {\n            \"total_tickets\": 5000,\n            \"open_tickets\": 2500,\n            \"closed_tickets\": 2500\n        }\n    raise ValueError(f\"Ticketing system '{ticketing_system}' not recognized.\")", "user_query": "What is the current average response time for tickets in ResoluteAssist?", "checklist": {"functions": ["fetch_average_response_time"], "values": [50]}}
{"difficulty": "easy", "function_schema_python": "def get_active_users(plan_type: str, date_range: tuple) -> int:\n    \"\"\"Retrieves the number of active users for a specific plan within a date range.\n\n    :param plan_type: The type of plan ('enterprise' or 'premium')\n    :param date_range: Tuple of (start_date, end_date) in 'YYYY-MM-DD' format\n    :return: Number of active users\n    :raises ValueError: If plan_type is invalid or date range is incorrect\"\"\"\n    pass\ndef get_feature_usage_stats(plan_type: str, date_range: tuple) -> dict:\n    \"\"\"Retrieves feature usage statistics for a specific plan within a date range.\n\n    :param plan_type: The type of plan ('enterprise' or 'premium')\n    :param date_range: Tuple of (start_date, end_date) in 'YYYY-MM-DD' format\n    :return: Dictionary containing feature usage statistics with keys:\n        - feature_name (str): Name of the feature\n        - usage_count (int): Number of times feature was used\n        - unique_users (int): Number of unique users who used the feature\n    :raises ValueError: If plan_type is invalid or date range is incorrect\"\"\"\n    pass\ndef calculate_resource_cost(feature_name: str, usage_count: int) -> dict:\n    \"\"\"Calculates the resource cost for a specific feature based on usage.\n\n    :param feature_name: Name of the feature\n    :param usage_count: Number of times the feature was used\n    :return: Dictionary containing cost analysis with keys:\n        - resource_cost (float): Estimated cost in dollars\n        - resource_type (str): Type of resource (compute/storage/network)\n        - optimization_potential (float): Percentage of potential optimization\n    :raises ValueError: If feature_name is invalid or usage_count is negative\"\"\"\n    pass\n", "function_schema_json": [{"name": "get_active_users", "description": "Retrieves the number of active users for a specific plan within a date range.", "parameters": {"type": "object", "properties": {"plan_type": {"type": "string", "description": "The type of plan ('enterprise' or 'premium')"}, "date_range": {"type": "string", "description": "Tuple of (start_date, end_date) in 'YYYY-MM-DD' format"}}, "required": ["plan_type", "date_range"], "additionalProperties": false}}, {"name": "get_feature_usage_stats", "description": "Retrieves feature usage statistics for a specific plan within a date range.", "parameters": {"type": "object", "properties": {"plan_type": {"type": "string", "description": "The type of plan ('enterprise' or 'premium')"}, "date_range": {"type": "string", "description": "Tuple of (start_date, end_date) in 'YYYY-MM-DD' format"}}, "required": ["plan_type", "date_range"], "additionalProperties": false}}, {"name": "calculate_resource_cost", "description": "Calculates the resource cost for a specific feature based on usage.", "parameters": {"type": "object", "properties": {"feature_name": {"type": "string", "description": "Name of the feature"}, "usage_count": {"type": "integer", "description": "Number of times the feature was used"}}, "required": ["feature_name", "usage_count"], "additionalProperties": false}}], "mock_functions": "def get_active_users(plan_type: str, date_range: tuple) -> int:\n    \"\"\"\n    Retrieves the number of active users for a specific plan within a date range.\n    \n    :param plan_type: The type of plan ('enterprise' or 'premium')\n    :param date_range: Tuple of (start_date, end_date) in 'YYYY-MM-DD' format\n    :return: Number of active users\n    :raises ValueError: If plan_type is invalid or date range is incorrect\n    \"\"\"\n    if plan_type.lower() not in ['enterprise', 'premium']:\n        raise ValueError(\"Invalid plan type\")\n    \n    if date_range[0] == '2023-01-01' and date_range[1] == '2023-03-31':\n        return 3000 if plan_type.lower() == 'enterprise' else 7000\n    return 0\ndef get_feature_usage_stats(plan_type: str, date_range: tuple) -> dict:\n    \"\"\"\n    Retrieves feature usage statistics for a specific plan within a date range.\n    \n    :param plan_type: The type of plan ('enterprise' or 'premium')\n    :param date_range: Tuple of (start_date, end_date) in 'YYYY-MM-DD' format\n    :return: Dictionary containing feature usage statistics with keys:\n        - feature_name (str): Name of the feature\n        - usage_count (int): Number of times feature was used\n        - unique_users (int): Number of unique users who used the feature\n    :raises ValueError: If plan_type is invalid or date range is incorrect\n    \"\"\"\n    if plan_type.lower() not in ['enterprise', 'premium']:\n        raise ValueError(\"Invalid plan type\")\n        \n    if date_range[0] == '2023-01-01' and date_range[1] == '2023-03-31':\n        return {\n            \"top_features\": [\n                {\"feature_name\": \"Project Timeline\", \"usage_count\": 15000, \"unique_users\": 2800},\n                {\"feature_name\": \"Resource Allocation\", \"usage_count\": 12000, \"unique_users\": 2750},\n                {\"feature_name\": \"Team Collaboration\", \"usage_count\": 11000, \"unique_users\": 2600},\n                {\"feature_name\": \"Report Generation\", \"usage_count\": 9000, \"unique_users\": 2400},\n                {\"feature_name\": \"Task Management\", \"usage_count\": 8500, \"unique_users\": 2300},\n                {\"feature_name\": \"File Sharing\", \"usage_count\": 8000, \"unique_users\": 2200},\n                {\"feature_name\": \"Calendar Integration\", \"usage_count\": 7500, \"unique_users\": 2100},\n                {\"feature_name\": \"API Access\", \"usage_count\": 7000, \"unique_users\": 2000},\n                {\"feature_name\": \"Custom Workflows\", \"usage_count\": 6500, \"unique_users\": 1900},\n                {\"feature_name\": \"Analytics Dashboard\", \"usage_count\": 6000, \"unique_users\": 1800}\n            ]\n        }\n    return {}\ndef calculate_resource_cost(feature_name: str, usage_count: int) -> dict:\n    \"\"\"\n    Calculates the resource cost for a specific feature based on usage.\n    \n    :param feature_name: Name of the feature\n    :param usage_count: Number of times the feature was used\n    :return: Dictionary containing cost analysis with keys:\n        - resource_cost (float): Estimated cost in dollars\n        - resource_type (str): Type of resource (compute/storage/network)\n        - optimization_potential (float): Percentage of potential optimization\n    :raises ValueError: If feature_name is invalid or usage_count is negative\n    \"\"\"\n    if not feature_name or usage_count < 0:\n        raise ValueError(\"Invalid feature name or usage count\")\n    \n    return {\n        \"resource_cost\": 12500.50,\n        \"resource_type\": \"compute\",\n        \"optimization_potential\": 25.5\n    }", "user_query": "How many Enterprise plan users were active between 2023-01-01 and 2023-03-31?", "checklist": {"functions": ["get_active_users"], "values": [3000]}}
{"difficulty": "easy", "function_schema_python": "def get_active_users(plan_type: str, date_range: tuple) -> int:\n    \"\"\"Retrieves the number of active users for a specific plan within a date range.\n\n    :param plan_type: The type of plan ('enterprise' or 'premium')\n    :param date_range: Tuple of (start_date, end_date) in 'YYYY-MM-DD' format\n    :return: Number of active users\n    :raises ValueError: If plan_type is invalid or date range is incorrect\"\"\"\n    pass\ndef get_feature_usage_stats(plan_type: str, date_range: tuple) -> dict:\n    \"\"\"Retrieves feature usage statistics for a specific plan within a date range.\n\n    :param plan_type: The type of plan ('enterprise' or 'premium')\n    :param date_range: Tuple of (start_date, end_date) in 'YYYY-MM-DD' format\n    :return: Dictionary containing feature usage statistics with keys:\n        - feature_name (str): Name of the feature\n        - usage_count (int): Number of times feature was used\n        - unique_users (int): Number of unique users who used the feature\n    :raises ValueError: If plan_type is invalid or date range is incorrect\"\"\"\n    pass\ndef calculate_resource_cost(feature_name: str, usage_count: int) -> dict:\n    \"\"\"Calculates the resource cost for a specific feature based on usage.\n\n    :param feature_name: Name of the feature\n    :param usage_count: Number of times the feature was used\n    :return: Dictionary containing cost analysis with keys:\n        - resource_cost (float): Estimated cost in dollars\n        - resource_type (str): Type of resource (compute/storage/network)\n        - optimization_potential (float): Percentage of potential optimization\n    :raises ValueError: If feature_name is invalid or usage_count is negative\"\"\"\n    pass\n", "function_schema_json": [{"name": "get_active_users", "description": "Retrieves the number of active users for a specific plan within a date range.", "parameters": {"type": "object", "properties": {"plan_type": {"type": "string", "description": "The type of plan ('enterprise' or 'premium')"}, "date_range": {"type": "string", "description": "Tuple of (start_date, end_date) in 'YYYY-MM-DD' format"}}, "required": ["plan_type", "date_range"], "additionalProperties": false}}, {"name": "get_feature_usage_stats", "description": "Retrieves feature usage statistics for a specific plan within a date range.", "parameters": {"type": "object", "properties": {"plan_type": {"type": "string", "description": "The type of plan ('enterprise' or 'premium')"}, "date_range": {"type": "string", "description": "Tuple of (start_date, end_date) in 'YYYY-MM-DD' format"}}, "required": ["plan_type", "date_range"], "additionalProperties": false}}, {"name": "calculate_resource_cost", "description": "Calculates the resource cost for a specific feature based on usage.", "parameters": {"type": "object", "properties": {"feature_name": {"type": "string", "description": "Name of the feature"}, "usage_count": {"type": "integer", "description": "Number of times the feature was used"}}, "required": ["feature_name", "usage_count"], "additionalProperties": false}}], "mock_functions": "def get_active_users(plan_type: str, date_range: tuple) -> int:\n    \"\"\"\n    Retrieves the number of active users for a specific plan within a date range.\n    \n    :param plan_type: The type of plan ('enterprise' or 'premium')\n    :param date_range: Tuple of (start_date, end_date) in 'YYYY-MM-DD' format\n    :return: Number of active users\n    :raises ValueError: If plan_type is invalid or date range is incorrect\n    \"\"\"\n    if plan_type.lower() not in ['enterprise', 'premium']:\n        raise ValueError(\"Invalid plan type\")\n    \n    if date_range[0] == '2023-01-01' and date_range[1] == '2023-03-31':\n        return 3000 if plan_type.lower() == 'enterprise' else 7000\n    return 0\ndef get_feature_usage_stats(plan_type: str, date_range: tuple) -> dict:\n    \"\"\"\n    Retrieves feature usage statistics for a specific plan within a date range.\n    \n    :param plan_type: The type of plan ('enterprise' or 'premium')\n    :param date_range: Tuple of (start_date, end_date) in 'YYYY-MM-DD' format\n    :return: Dictionary containing feature usage statistics with keys:\n        - feature_name (str): Name of the feature\n        - usage_count (int): Number of times feature was used\n        - unique_users (int): Number of unique users who used the feature\n    :raises ValueError: If plan_type is invalid or date range is incorrect\n    \"\"\"\n    if plan_type.lower() not in ['enterprise', 'premium']:\n        raise ValueError(\"Invalid plan type\")\n        \n    if date_range[0] == '2023-01-01' and date_range[1] == '2023-03-31':\n        return {\n            \"top_features\": [\n                {\"feature_name\": \"Project Timeline\", \"usage_count\": 15000, \"unique_users\": 2800},\n                {\"feature_name\": \"Resource Allocation\", \"usage_count\": 12000, \"unique_users\": 2750},\n                {\"feature_name\": \"Team Collaboration\", \"usage_count\": 11000, \"unique_users\": 2600},\n                {\"feature_name\": \"Report Generation\", \"usage_count\": 9000, \"unique_users\": 2400},\n                {\"feature_name\": \"Task Management\", \"usage_count\": 8500, \"unique_users\": 2300},\n                {\"feature_name\": \"File Sharing\", \"usage_count\": 8000, \"unique_users\": 2200},\n                {\"feature_name\": \"Calendar Integration\", \"usage_count\": 7500, \"unique_users\": 2100},\n                {\"feature_name\": \"API Access\", \"usage_count\": 7000, \"unique_users\": 2000},\n                {\"feature_name\": \"Custom Workflows\", \"usage_count\": 6500, \"unique_users\": 1900},\n                {\"feature_name\": \"Analytics Dashboard\", \"usage_count\": 6000, \"unique_users\": 1800}\n            ]\n        }\n    return {}\ndef calculate_resource_cost(feature_name: str, usage_count: int) -> dict:\n    \"\"\"\n    Calculates the resource cost for a specific feature based on usage.\n    \n    :param feature_name: Name of the feature\n    :param usage_count: Number of times the feature was used\n    :return: Dictionary containing cost analysis with keys:\n        - resource_cost (float): Estimated cost in dollars\n        - resource_type (str): Type of resource (compute/storage/network)\n        - optimization_potential (float): Percentage of potential optimization\n    :raises ValueError: If feature_name is invalid or usage_count is negative\n    \"\"\"\n    if not feature_name or usage_count < 0:\n        raise ValueError(\"Invalid feature name or usage count\")\n    \n    return {\n        \"resource_cost\": 12500.50,\n        \"resource_type\": \"compute\",\n        \"optimization_potential\": 25.5\n    }", "user_query": "What are the top 10 most used features by Enterprise plan users between 2023-01-01 and 2023-03-31?", "checklist": {"functions": ["get_feature_usage_stats"], "values": [{"top_features": [{"feature_name": "Project Timeline", "usage_count": 15000, "unique_users": 2800}, {"feature_name": "Resource Allocation", "usage_count": 12000, "unique_users": 2750}, {"feature_name": "Team Collaboration", "usage_count": 11000, "unique_users": 2600}, {"feature_name": "Report Generation", "usage_count": 9000, "unique_users": 2400}, {"feature_name": "Task Management", "usage_count": 8500, "unique_users": 2300}, {"feature_name": "File Sharing", "usage_count": 8000, "unique_users": 2200}, {"feature_name": "Calendar Integration", "usage_count": 7500, "unique_users": 2100}, {"feature_name": "API Access", "usage_count": 7000, "unique_users": 2000}, {"feature_name": "Custom Workflows", "usage_count": 6500, "unique_users": 1900}, {"feature_name": "Analytics Dashboard", "usage_count": 6000, "unique_users": 1800}]}]}}
{"difficulty": "easy", "function_schema_python": "def get_user_login_frequency(user_id: str, weeks: int) -> dict:\n    \"\"\"Retrieves user login frequency data for a specified period.\n\n    :param user_id: The unique identifier for the user.\n    :param weeks: Number of weeks to analyze.\n    :return: Dictionary containing login frequency data:\n        - total_logins (int): Total number of logins\n        - weekly_logins (list[int]): List of login counts per week\n        - consistent_weekly_login (bool): True if logged in at least once every week\n    :raises ValueError: If user_id is invalid or weeks is less than 1\"\"\"\n    pass\ndef get_user_email_metrics(user_id: str, months: int) -> dict:\n    \"\"\"Retrieves email sending metrics for a user over a specified period.\n\n    :param user_id: The unique identifier for the user.\n    :param months: Number of months to analyze.\n    :return: Dictionary containing email metrics:\n        - total_emails_sent (int): Total number of emails sent\n        - monthly_breakdown (dict): Emails sent per month\n        - meets_threshold (bool): True if sent >= 500 emails\n    :raises ValueError: If user_id is invalid or months is less than 1\"\"\"\n    pass\ndef get_popular_email_templates(user_id: str, months: int) -> dict:\n    \"\"\"Retrieves most used email templates by a user.\n\n    :param user_id: The unique identifier for the user.\n    :param months: Number of months to analyze.\n    :return: Dictionary containing template usage data:\n        - templates (list[dict]): List of template data with name and usage count\n        - total_templates_used (int): Total number of unique templates used\n    :raises ValueError: If user_id is invalid or months is less than 1\"\"\"\n    pass\n", "function_schema_json": [{"name": "get_user_login_frequency", "description": "Retrieves user login frequency data for a specified period.", "parameters": {"type": "object", "properties": {"user_id": {"type": "string", "description": "The unique identifier for the user."}, "weeks": {"type": "integer", "description": "Number of weeks to analyze."}}, "required": ["user_id", "weeks"], "additionalProperties": false}}, {"name": "get_user_email_metrics", "description": "Retrieves email sending metrics for a user over a specified period.", "parameters": {"type": "object", "properties": {"user_id": {"type": "string", "description": "The unique identifier for the user."}, "months": {"type": "integer", "description": "Number of months to analyze."}}, "required": ["user_id", "months"], "additionalProperties": false}}, {"name": "get_popular_email_templates", "description": "Retrieves most used email templates by a user.", "parameters": {"type": "object", "properties": {"user_id": {"type": "string", "description": "The unique identifier for the user."}, "months": {"type": "integer", "description": "Number of months to analyze."}}, "required": ["user_id", "months"], "additionalProperties": false}}], "mock_functions": "def get_user_login_frequency(user_id: str, weeks: int) -> dict:\n    \"\"\"\n    Retrieves user login frequency data for a specified period.\n    \n    :param user_id: The unique identifier for the user.\n    :param weeks: Number of weeks to analyze.\n    :return: Dictionary containing login frequency data:\n        - total_logins (int): Total number of logins\n        - weekly_logins (list[int]): List of login counts per week\n        - consistent_weekly_login (bool): True if logged in at least once every week\n    :raises ValueError: If user_id is invalid or weeks is less than 1\n    \"\"\"\n    if not user_id or weeks < 1:\n        raise ValueError(\"Invalid user_id or weeks parameter\")\n    \n    if user_id == \"USER123\" and weeks == 12:\n        return {\n            \"total_logins\": 48,\n            \"weekly_logins\": [4, 3, 5, 4, 3, 4, 5, 3, 4, 4, 4, 5],\n            \"consistent_weekly_login\": True\n        }\n    return {\"total_logins\": 0, \"weekly_logins\": [], \"consistent_weekly_login\": False}\ndef get_user_email_metrics(user_id: str, months: int) -> dict:\n    \"\"\"\n    Retrieves email sending metrics for a user over a specified period.\n    \n    :param user_id: The unique identifier for the user.\n    :param months: Number of months to analyze.\n    :return: Dictionary containing email metrics:\n        - total_emails_sent (int): Total number of emails sent\n        - monthly_breakdown (dict): Emails sent per month\n        - meets_threshold (bool): True if sent >= 500 emails\n    :raises ValueError: If user_id is invalid or months is less than 1\n    \"\"\"\n    if not user_id or months < 1:\n        raise ValueError(\"Invalid user_id or months parameter\")\n    \n    if user_id == \"USER123\" and months == 6:\n        return {\n            \"total_emails_sent\": 750,\n            \"monthly_breakdown\": {\n                \"Month1\": 125,\n                \"Month2\": 130,\n                \"Month3\": 115,\n                \"Month4\": 140,\n                \"Month5\": 120,\n                \"Month6\": 120\n            },\n            \"meets_threshold\": True\n        }\n    return {\"total_emails_sent\": 0, \"monthly_breakdown\": {}, \"meets_threshold\": False}\ndef get_popular_email_templates(user_id: str, months: int) -> dict:\n    \"\"\"\n    Retrieves most used email templates by a user.\n    \n    :param user_id: The unique identifier for the user.\n    :param months: Number of months to analyze.\n    :return: Dictionary containing template usage data:\n        - templates (list[dict]): List of template data with name and usage count\n        - total_templates_used (int): Total number of unique templates used\n    :raises ValueError: If user_id is invalid or months is less than 1\n    \"\"\"\n    if not user_id or months < 1:\n        raise ValueError(\"Invalid user_id or months parameter\")\n    \n    if user_id == \"USER123\" and months == 6:\n        return {\n            \"templates\": [\n                {\"name\": \"Welcome Email\", \"usage_count\": 250},\n                {\"name\": \"Newsletter\", \"usage_count\": 200},\n                {\"name\": \"Promotional\", \"usage_count\": 180},\n                {\"name\": \"Follow-up\", \"usage_count\": 120}\n            ],\n            \"total_templates_used\": 4\n        }\n    return {\"templates\": [], \"total_templates_used\": 0}", "user_query": "Can you check if user USER123 has logged in at least once every week for the past 12 weeks?", "checklist": {"functions": ["get_user_login_frequency"], "values": [{"total_logins": 48, "weekly_logins": [4, 3, 5, 4, 3, 4, 5, 3, 4, 4, 4, 5], "consistent_weekly_login": true}]}}
{"difficulty": "easy", "function_schema_python": "def get_user_login_frequency(user_id: str, weeks: int) -> dict:\n    \"\"\"Retrieves user login frequency data for a specified period.\n\n    :param user_id: The unique identifier for the user.\n    :param weeks: Number of weeks to analyze.\n    :return: Dictionary containing login frequency data:\n        - total_logins (int): Total number of logins\n        - weekly_logins (list[int]): List of login counts per week\n        - consistent_weekly_login (bool): True if logged in at least once every week\n    :raises ValueError: If user_id is invalid or weeks is less than 1\"\"\"\n    pass\ndef get_user_email_metrics(user_id: str, months: int) -> dict:\n    \"\"\"Retrieves email sending metrics for a user over a specified period.\n\n    :param user_id: The unique identifier for the user.\n    :param months: Number of months to analyze.\n    :return: Dictionary containing email metrics:\n        - total_emails_sent (int): Total number of emails sent\n        - monthly_breakdown (dict): Emails sent per month\n        - meets_threshold (bool): True if sent >= 500 emails\n    :raises ValueError: If user_id is invalid or months is less than 1\"\"\"\n    pass\ndef get_popular_email_templates(user_id: str, months: int) -> dict:\n    \"\"\"Retrieves most used email templates by a user.\n\n    :param user_id: The unique identifier for the user.\n    :param months: Number of months to analyze.\n    :return: Dictionary containing template usage data:\n        - templates (list[dict]): List of template data with name and usage count\n        - total_templates_used (int): Total number of unique templates used\n    :raises ValueError: If user_id is invalid or months is less than 1\"\"\"\n    pass\n", "function_schema_json": [{"name": "get_user_login_frequency", "description": "Retrieves user login frequency data for a specified period.", "parameters": {"type": "object", "properties": {"user_id": {"type": "string", "description": "The unique identifier for the user."}, "weeks": {"type": "integer", "description": "Number of weeks to analyze."}}, "required": ["user_id", "weeks"], "additionalProperties": false}}, {"name": "get_user_email_metrics", "description": "Retrieves email sending metrics for a user over a specified period.", "parameters": {"type": "object", "properties": {"user_id": {"type": "string", "description": "The unique identifier for the user."}, "months": {"type": "integer", "description": "Number of months to analyze."}}, "required": ["user_id", "months"], "additionalProperties": false}}, {"name": "get_popular_email_templates", "description": "Retrieves most used email templates by a user.", "parameters": {"type": "object", "properties": {"user_id": {"type": "string", "description": "The unique identifier for the user."}, "months": {"type": "integer", "description": "Number of months to analyze."}}, "required": ["user_id", "months"], "additionalProperties": false}}], "mock_functions": "def get_user_login_frequency(user_id: str, weeks: int) -> dict:\n    \"\"\"\n    Retrieves user login frequency data for a specified period.\n    \n    :param user_id: The unique identifier for the user.\n    :param weeks: Number of weeks to analyze.\n    :return: Dictionary containing login frequency data:\n        - total_logins (int): Total number of logins\n        - weekly_logins (list[int]): List of login counts per week\n        - consistent_weekly_login (bool): True if logged in at least once every week\n    :raises ValueError: If user_id is invalid or weeks is less than 1\n    \"\"\"\n    if not user_id or weeks < 1:\n        raise ValueError(\"Invalid user_id or weeks parameter\")\n    \n    if user_id == \"USER123\" and weeks == 12:\n        return {\n            \"total_logins\": 48,\n            \"weekly_logins\": [4, 3, 5, 4, 3, 4, 5, 3, 4, 4, 4, 5],\n            \"consistent_weekly_login\": True\n        }\n    return {\"total_logins\": 0, \"weekly_logins\": [], \"consistent_weekly_login\": False}\ndef get_user_email_metrics(user_id: str, months: int) -> dict:\n    \"\"\"\n    Retrieves email sending metrics for a user over a specified period.\n    \n    :param user_id: The unique identifier for the user.\n    :param months: Number of months to analyze.\n    :return: Dictionary containing email metrics:\n        - total_emails_sent (int): Total number of emails sent\n        - monthly_breakdown (dict): Emails sent per month\n        - meets_threshold (bool): True if sent >= 500 emails\n    :raises ValueError: If user_id is invalid or months is less than 1\n    \"\"\"\n    if not user_id or months < 1:\n        raise ValueError(\"Invalid user_id or months parameter\")\n    \n    if user_id == \"USER123\" and months == 6:\n        return {\n            \"total_emails_sent\": 750,\n            \"monthly_breakdown\": {\n                \"Month1\": 125,\n                \"Month2\": 130,\n                \"Month3\": 115,\n                \"Month4\": 140,\n                \"Month5\": 120,\n                \"Month6\": 120\n            },\n            \"meets_threshold\": True\n        }\n    return {\"total_emails_sent\": 0, \"monthly_breakdown\": {}, \"meets_threshold\": False}\ndef get_popular_email_templates(user_id: str, months: int) -> dict:\n    \"\"\"\n    Retrieves most used email templates by a user.\n    \n    :param user_id: The unique identifier for the user.\n    :param months: Number of months to analyze.\n    :return: Dictionary containing template usage data:\n        - templates (list[dict]): List of template data with name and usage count\n        - total_templates_used (int): Total number of unique templates used\n    :raises ValueError: If user_id is invalid or months is less than 1\n    \"\"\"\n    if not user_id or months < 1:\n        raise ValueError(\"Invalid user_id or months parameter\")\n    \n    if user_id == \"USER123\" and months == 6:\n        return {\n            \"templates\": [\n                {\"name\": \"Welcome Email\", \"usage_count\": 250},\n                {\"name\": \"Newsletter\", \"usage_count\": 200},\n                {\"name\": \"Promotional\", \"usage_count\": 180},\n                {\"name\": \"Follow-up\", \"usage_count\": 120}\n            ],\n            \"total_templates_used\": 4\n        }\n    return {\"templates\": [], \"total_templates_used\": 0}", "user_query": "Can you check if user USER123 has sent at least 500 emails in the last 6 months and show the monthly breakdown?", "checklist": {"functions": ["get_user_email_metrics"], "values": [{"total_emails_sent": 750, "monthly_breakdown": {"Month1": 125, "Month2": 130, "Month3": 115, "Month4": 140, "Month5": 120, "Month6": 120}, "meets_threshold": true}]}}
{"difficulty": "easy", "function_schema_python": "def configure_networking(instance_id: str, subnet_id: str, private_ip: str) -> bool:\n    \"\"\"Configures networking for a VM instance.\n\n    :param instance_id: The ID of the VM instance.\n    :param subnet_id: The ID of the subnet.\n    :param private_ip: The private IP address to assign.\n    :return: True if configuration is successful, False otherwise.\"\"\"\n    pass\ndef configure_security_group(instance_id: str, security_group_id: str, rules: List[Dict[str, str]]) -> bool:\n    \"\"\"Configures security group for a VM instance.\n\n    :param instance_id: The ID of the VM instance.\n    :param security_group_id: The ID of the security group.\n    :param rules: A list of rules for the security group. Each rule is a dictionary with 'protocol', 'port', and 'source' keys.\n    :return: True if configuration is successful, False otherwise.\"\"\"\n    pass\ndef configure_storage(instance_id: str, volume_size: int, volume_type: str) -> bool:\n    \"\"\"Configures storage for a VM instance.\n\n    :param instance_id: The ID of the VM instance.\n    :param volume_size: The size of the volume in GB.\n    :param volume_type: The type of the volume (e.g., \"gp2\", \"io1\").\n    :return: True if configuration is successful, False otherwise.\"\"\"\n    pass\ndef setup_vm_instance(instance_type: str, region: str, os: str, security_group: str, storage: int) -> str:\n    \"\"\"Sets up a new VM instance.\n\n    :param instance_type: Type of the instance (e.g., t2.micro).\n    :param region: Region to deploy the instance (e.g., US-West-1).\n    :param os: Operating system (e.g., Ubuntu 20.04 LTS).\n    :param security_group: Default security group.\n    :param storage: Storage size in GB.\n    :return: Instance ID if successful, empty string otherwise.\"\"\"\n    pass\n", "function_schema_json": [{"name": "configure_networking", "description": "Configures networking for a VM instance.", "parameters": {"type": "object", "properties": {"instance_id": {"type": "string", "description": "The ID of the VM instance."}, "subnet_id": {"type": "string", "description": "The ID of the subnet."}, "private_ip": {"type": "string", "description": "The private IP address to assign."}}, "required": ["instance_id", "subnet_id", "private_ip"], "additionalProperties": false}}, {"name": "configure_security_group", "description": "Configures security group for a VM instance.", "parameters": {"type": "object", "properties": {"instance_id": {"type": "string", "description": "The ID of the VM instance."}, "security_group_id": {"type": "string", "description": "The ID of the security group."}, "rules": {"type": "array", "items": {"type": "object"}, "description": "A list of rules for the security group. Each rule is a dictionary with 'protocol', 'port', and 'source' keys."}}, "required": ["instance_id", "security_group_id", "rules"], "additionalProperties": false}}, {"name": "configure_storage", "description": "Configures storage for a VM instance.", "parameters": {"type": "object", "properties": {"instance_id": {"type": "string", "description": "The ID of the VM instance."}, "volume_size": {"type": "integer", "description": "The size of the volume in GB."}, "volume_type": {"type": "string", "description": "The type of the volume (e.g., \"gp2\", \"io1\")."}}, "required": ["instance_id", "volume_size", "volume_type"], "additionalProperties": false}}, {"name": "setup_vm_instance", "description": "Sets up a new VM instance.", "parameters": {"type": "object", "properties": {"instance_type": {"type": "string", "description": "Type of the instance (e.g., t2.micro)."}, "region": {"type": "string", "description": "Region to deploy the instance (e.g., US-West-1)."}, "os": {"type": "string", "description": "Operating system (e.g., Ubuntu 20.04 LTS)."}, "security_group": {"type": "string", "description": "Default security group."}, "storage": {"type": "integer", "description": "Storage size in GB."}}, "required": ["instance_type", "region", "os", "security_group", "storage"], "additionalProperties": false}}], "mock_functions": "def configure_networking(instance_id: str, subnet_id: str, private_ip: str) -> bool:\n    \"\"\"\n    Configures networking for a VM instance.\n\n    :param instance_id: The ID of the VM instance.\n    :param subnet_id: The ID of the subnet.\n    :param private_ip: The private IP address to assign.\n    :return: True if configuration is successful, False otherwise.\n    \"\"\"\n    if instance_id and subnet_id and private_ip:\n        return True\n    return False\ndef configure_security_group(instance_id: str, security_group_id: str, rules: List[Dict[str, str]]) -> bool:\n    \"\"\"\n    Configures security group for a VM instance.\n\n    :param instance_id: The ID of the VM instance.\n    :param security_group_id: The ID of the security group.\n    :param rules: A list of rules for the security group. Each rule is a dictionary with 'protocol', 'port', and 'source' keys.\n    :return: True if configuration is successful, False otherwise.\n    \"\"\"\n    if instance_id and security_group_id and rules:\n        return True\n    return False\ndef configure_storage(instance_id: str, volume_size: int, volume_type: str) -> bool:\n    \"\"\"\n    Configures storage for a VM instance.\n\n    :param instance_id: The ID of the VM instance.\n    :param volume_size: The size of the volume in GB.\n    :param volume_type: The type of the volume (e.g., \"gp2\", \"io1\").\n    :return: True if configuration is successful, False otherwise.\n    \"\"\"\n    if instance_id and volume_size and volume_type:\n        return True\n    return False\ndef setup_vm_instance(instance_type: str, region: str, os: str, security_group: str, storage: int) -> str:\n    \"\"\"\n    Sets up a new VM instance.\n\n    :param instance_type: Type of the instance (e.g., t2.micro).\n    :param region: Region to deploy the instance (e.g., US-West-1).\n    :param os: Operating system (e.g., Ubuntu 20.04 LTS).\n    :param security_group: Default security group.\n    :param storage: Storage size in GB.\n    :return: Instance ID if successful, empty string otherwise.\n    \"\"\"\n    if instance_type == \"t2.micro\" and region == \"US-West-1\" and os == \"Ubuntu 20.04 LTS\" and security_group == \"default\" and storage == 8:\n        return \"i-0abcdef1234567890\"\n    return \"\"", "user_query": "Can you configure networking for instance i-0abcdef1234567890 using subnet subnet-0abcdef1234567890 and private IP 10.0.0.10?", "checklist": {"functions": ["configure_networking"], "values": [true]}}
{"difficulty": "easy", "function_schema_python": "def configure_networking(instance_id: str, subnet_id: str, private_ip: str) -> bool:\n    \"\"\"Configures networking for a VM instance.\n\n    :param instance_id: The ID of the VM instance.\n    :param subnet_id: The ID of the subnet.\n    :param private_ip: The private IP address to assign.\n    :return: True if configuration is successful, False otherwise.\"\"\"\n    pass\ndef configure_security_group(instance_id: str, security_group_id: str, rules: List[Dict[str, str]]) -> bool:\n    \"\"\"Configures security group for a VM instance.\n\n    :param instance_id: The ID of the VM instance.\n    :param security_group_id: The ID of the security group.\n    :param rules: A list of rules for the security group. Each rule is a dictionary with 'protocol', 'port', and 'source' keys.\n    :return: True if configuration is successful, False otherwise.\"\"\"\n    pass\ndef configure_storage(instance_id: str, volume_size: int, volume_type: str) -> bool:\n    \"\"\"Configures storage for a VM instance.\n\n    :param instance_id: The ID of the VM instance.\n    :param volume_size: The size of the volume in GB.\n    :param volume_type: The type of the volume (e.g., \"gp2\", \"io1\").\n    :return: True if configuration is successful, False otherwise.\"\"\"\n    pass\ndef setup_vm_instance(instance_type: str, region: str, os: str, security_group: str, storage: int) -> str:\n    \"\"\"Sets up a new VM instance.\n\n    :param instance_type: Type of the instance (e.g., t2.micro).\n    :param region: Region to deploy the instance (e.g., US-West-1).\n    :param os: Operating system (e.g., Ubuntu 20.04 LTS).\n    :param security_group: Default security group.\n    :param storage: Storage size in GB.\n    :return: Instance ID if successful, empty string otherwise.\"\"\"\n    pass\n", "function_schema_json": [{"name": "configure_networking", "description": "Configures networking for a VM instance.", "parameters": {"type": "object", "properties": {"instance_id": {"type": "string", "description": "The ID of the VM instance."}, "subnet_id": {"type": "string", "description": "The ID of the subnet."}, "private_ip": {"type": "string", "description": "The private IP address to assign."}}, "required": ["instance_id", "subnet_id", "private_ip"], "additionalProperties": false}}, {"name": "configure_security_group", "description": "Configures security group for a VM instance.", "parameters": {"type": "object", "properties": {"instance_id": {"type": "string", "description": "The ID of the VM instance."}, "security_group_id": {"type": "string", "description": "The ID of the security group."}, "rules": {"type": "array", "items": {"type": "object"}, "description": "A list of rules for the security group. Each rule is a dictionary with 'protocol', 'port', and 'source' keys."}}, "required": ["instance_id", "security_group_id", "rules"], "additionalProperties": false}}, {"name": "configure_storage", "description": "Configures storage for a VM instance.", "parameters": {"type": "object", "properties": {"instance_id": {"type": "string", "description": "The ID of the VM instance."}, "volume_size": {"type": "integer", "description": "The size of the volume in GB."}, "volume_type": {"type": "string", "description": "The type of the volume (e.g., \"gp2\", \"io1\")."}}, "required": ["instance_id", "volume_size", "volume_type"], "additionalProperties": false}}, {"name": "setup_vm_instance", "description": "Sets up a new VM instance.", "parameters": {"type": "object", "properties": {"instance_type": {"type": "string", "description": "Type of the instance (e.g., t2.micro)."}, "region": {"type": "string", "description": "Region to deploy the instance (e.g., US-West-1)."}, "os": {"type": "string", "description": "Operating system (e.g., Ubuntu 20.04 LTS)."}, "security_group": {"type": "string", "description": "Default security group."}, "storage": {"type": "integer", "description": "Storage size in GB."}}, "required": ["instance_type", "region", "os", "security_group", "storage"], "additionalProperties": false}}], "mock_functions": "def configure_networking(instance_id: str, subnet_id: str, private_ip: str) -> bool:\n    \"\"\"\n    Configures networking for a VM instance.\n\n    :param instance_id: The ID of the VM instance.\n    :param subnet_id: The ID of the subnet.\n    :param private_ip: The private IP address to assign.\n    :return: True if configuration is successful, False otherwise.\n    \"\"\"\n    if instance_id and subnet_id and private_ip:\n        return True\n    return False\ndef configure_security_group(instance_id: str, security_group_id: str, rules: List[Dict[str, str]]) -> bool:\n    \"\"\"\n    Configures security group for a VM instance.\n\n    :param instance_id: The ID of the VM instance.\n    :param security_group_id: The ID of the security group.\n    :param rules: A list of rules for the security group. Each rule is a dictionary with 'protocol', 'port', and 'source' keys.\n    :return: True if configuration is successful, False otherwise.\n    \"\"\"\n    if instance_id and security_group_id and rules:\n        return True\n    return False\ndef configure_storage(instance_id: str, volume_size: int, volume_type: str) -> bool:\n    \"\"\"\n    Configures storage for a VM instance.\n\n    :param instance_id: The ID of the VM instance.\n    :param volume_size: The size of the volume in GB.\n    :param volume_type: The type of the volume (e.g., \"gp2\", \"io1\").\n    :return: True if configuration is successful, False otherwise.\n    \"\"\"\n    if instance_id and volume_size and volume_type:\n        return True\n    return False\ndef setup_vm_instance(instance_type: str, region: str, os: str, security_group: str, storage: int) -> str:\n    \"\"\"\n    Sets up a new VM instance.\n\n    :param instance_type: Type of the instance (e.g., t2.micro).\n    :param region: Region to deploy the instance (e.g., US-West-1).\n    :param os: Operating system (e.g., Ubuntu 20.04 LTS).\n    :param security_group: Default security group.\n    :param storage: Storage size in GB.\n    :return: Instance ID if successful, empty string otherwise.\n    \"\"\"\n    if instance_type == \"t2.micro\" and region == \"US-West-1\" and os == \"Ubuntu 20.04 LTS\" and security_group == \"default\" and storage == 8:\n        return \"i-0abcdef1234567890\"\n    return \"\"", "user_query": "I need to configure security group sg-0abcdef1234567890 for instance i-0abcdef1234567890.  Add rules allowing inbound SSH (port 22) from anywhere and inbound HTTP (port 80) from 192.168.1.0/24.", "checklist": {"functions": ["configure_security_group"], "values": [true]}}
{"difficulty": "easy", "function_schema_python": "def create_load_balancer(name: str, subnets: list) -> dict:\n    \"\"\"Creates an Application Load Balancer (ALB) in a specified VPC.\n\n    :param name: The name of the load balancer.\n    :param subnets: A list of subnet IDs in which the load balancer will be created.\n    :return: A dictionary containing the name and status of the load balancer.\n    :raises ValueError: If the name is empty or subnets list is invalid.\"\"\"\n    pass\ndef configure_auto_scaling_group(lb_arn: str, min_instances: int, max_instances: int) -> dict:\n    \"\"\"Configures an Auto Scaling Group associated with an Application Load Balancer.\n\n    :param lb_arn: The ARN of the Application Load Balancer.\n    :param min_instances: The minimum number of instances to maintain in the Auto Scaling Group.\n    :param max_instances: The maximum number of instances to maintain in the Auto Scaling Group.\n    :return: A dictionary containing the ARN of the load balancer and the auto scaling group settings.\n    :raises ValueError: If lb_arn, min_instances, or max_instances are invalid.\"\"\"\n    pass\ndef set_up_security_groups(protocol: str) -> str:\n    \"\"\"Sets up custom security rules for HTTP and HTTPS traffic.\n\n    :param protocol: The protocol for which to set up security rules ('http' or 'https').\n    :return: A string indicating the status of the security group setup.\n    :raises ValueError: If the protocol is unsupported.\"\"\"\n    pass\ndef create_nfs_storage(vpc_id: str, subnet_id: str) -> dict:\n    \"\"\"Creates a Network File System (NFS) for shared storage in a specified VPC and subnet.\n\n    :param vpc_id: The ID of the VPC.\n    :param subnet_id: The ID of the subnet where NFS will be created.\n    :return: A dictionary containing the storage ID, VPC ID, and subnet ID.\n    :raises ValueError: If vpc_id or subnet_id are invalid.\"\"\"\n    pass\n", "function_schema_json": [{"name": "create_load_balancer", "description": "Creates an Application Load Balancer (ALB) in a specified VPC.", "parameters": {"type": "object", "properties": {"name": {"type": "string", "description": "The name of the load balancer."}, "subnets": {"type": "array", "description": "A list of subnet IDs in which the load balancer will be created."}}, "required": ["name", "subnets"], "additionalProperties": false}}, {"name": "configure_auto_scaling_group", "description": "Configures an Auto Scaling Group associated with an Application Load Balancer.", "parameters": {"type": "object", "properties": {"lb_arn": {"type": "string", "description": "The ARN of the Application Load Balancer."}, "min_instances": {"type": "integer", "description": "The minimum number of instances to maintain in the Auto Scaling Group."}, "max_instances": {"type": "integer", "description": "The maximum number of instances to maintain in the Auto Scaling Group."}}, "required": ["lb_arn", "min_instances", "max_instances"], "additionalProperties": false}}, {"name": "set_up_security_groups", "description": "Sets up custom security rules for HTTP and HTTPS traffic.", "parameters": {"type": "object", "properties": {"protocol": {"type": "string", "description": "The protocol for which to set up security rules ('http' or 'https')."}}, "required": ["protocol"], "additionalProperties": false}}, {"name": "create_nfs_storage", "description": "Creates a Network File System (NFS) for shared storage in a specified VPC and subnet.", "parameters": {"type": "object", "properties": {"vpc_id": {"type": "string", "description": "The ID of the VPC."}, "subnet_id": {"type": "string", "description": "The ID of the subnet where NFS will be created."}}, "required": ["vpc_id", "subnet_id"], "additionalProperties": false}}], "mock_functions": "def create_load_balancer(name: str, subnets: list) -> dict:\n    \"\"\"\n    Creates an Application Load Balancer (ALB) in a specified VPC.\n\n    :param name: The name of the load balancer.\n    :param subnets: A list of subnet IDs in which the load balancer will be created.\n    :return: A dictionary containing the name and status of the load balancer.\n    :raises ValueError: If the name is empty or subnets list is invalid.\n    \"\"\"\n    if not name or not subnets:\n        raise ValueError(\"Load balancer name and subnets must be provided.\")\n    return {\n        \"name\": name,\n        \"status\": \"active\",\n        \"subnets\": subnets\n    }\ndef configure_auto_scaling_group(lb_arn: str, min_instances: int, max_instances: int) -> dict:\n    \"\"\"\n    Configures an Auto Scaling Group associated with an Application Load Balancer.\n\n    :param lb_arn: The ARN of the Application Load Balancer.\n    :param min_instances: The minimum number of instances to maintain in the Auto Scaling Group.\n    :param max_instances: The maximum number of instances to maintain in the Auto Scaling Group.\n    :return: A dictionary containing the ARN of the load balancer and the auto scaling group settings.\n    :raises ValueError: If lb_arn, min_instances, or max_instances are invalid.\n    \"\"\"\n    if not lb_arn or min_instances < 1 or max_instances < min_instances:\n        raise ValueError(\"Invalid parameters for auto scaling group configuration.\")\n    return {\n        \"lb_arn\": lb_arn,\n        \"min_instances\": min_instances,\n        \"max_instances\": max_instances\n    }\ndef set_up_security_groups(protocol: str) -> str:\n    \"\"\"\n    Sets up custom security rules for HTTP and HTTPS traffic.\n\n    :param protocol: The protocol for which to set up security rules ('http' or 'https').\n    :return: A string indicating the status of the security group setup.\n    :raises ValueError: If the protocol is unsupported.\n    \"\"\"\n    if protocol.lower() not in ['http', 'https']:\n        raise ValueError(\"Unsupported protocol. Use 'http' or 'https'.\")\n    return f\"Security rules for {protocol.upper()} traffic set up successfully.\"\ndef create_nfs_storage(vpc_id: str, subnet_id: str) -> dict:\n    \"\"\"\n    Creates a Network File System (NFS) for shared storage in a specified VPC and subnet.\n\n    :param vpc_id: The ID of the VPC.\n    :param subnet_id: The ID of the subnet where NFS will be created.\n    :return: A dictionary containing the storage ID, VPC ID, and subnet ID.\n    :raises ValueError: If vpc_id or subnet_id are invalid.\n    \"\"\"\n    if not vpc_id or not subnet_id:\n        raise ValueError(\"VPC ID and Subnet ID must be provided.\")\n    return {\n        \"storage_id\": \"nfs-storage-123\",\n        \"vpc_id\": vpc_id,\n        \"subnet_id\": subnet_id\n    }", "user_query": "Create a load balancer named 'webapp-lb' in subnets ['subnet-1', 'subnet-2'].", "checklist": {"functions": ["create_load_balancer"], "values": [{"name": "webapp-lb", "status": "active", "subnets": ["subnet-1", "subnet-2"]}]}}
{"difficulty": "easy", "function_schema_python": "def create_load_balancer(name: str, subnets: list) -> dict:\n    \"\"\"Creates an Application Load Balancer (ALB) in a specified VPC.\n\n    :param name: The name of the load balancer.\n    :param subnets: A list of subnet IDs in which the load balancer will be created.\n    :return: A dictionary containing the name and status of the load balancer.\n    :raises ValueError: If the name is empty or subnets list is invalid.\"\"\"\n    pass\ndef configure_auto_scaling_group(lb_arn: str, min_instances: int, max_instances: int) -> dict:\n    \"\"\"Configures an Auto Scaling Group associated with an Application Load Balancer.\n\n    :param lb_arn: The ARN of the Application Load Balancer.\n    :param min_instances: The minimum number of instances to maintain in the Auto Scaling Group.\n    :param max_instances: The maximum number of instances to maintain in the Auto Scaling Group.\n    :return: A dictionary containing the ARN of the load balancer and the auto scaling group settings.\n    :raises ValueError: If lb_arn, min_instances, or max_instances are invalid.\"\"\"\n    pass\ndef set_up_security_groups(protocol: str) -> str:\n    \"\"\"Sets up custom security rules for HTTP and HTTPS traffic.\n\n    :param protocol: The protocol for which to set up security rules ('http' or 'https').\n    :return: A string indicating the status of the security group setup.\n    :raises ValueError: If the protocol is unsupported.\"\"\"\n    pass\ndef create_nfs_storage(vpc_id: str, subnet_id: str) -> dict:\n    \"\"\"Creates a Network File System (NFS) for shared storage in a specified VPC and subnet.\n\n    :param vpc_id: The ID of the VPC.\n    :param subnet_id: The ID of the subnet where NFS will be created.\n    :return: A dictionary containing the storage ID, VPC ID, and subnet ID.\n    :raises ValueError: If vpc_id or subnet_id are invalid.\"\"\"\n    pass\n", "function_schema_json": [{"name": "create_load_balancer", "description": "Creates an Application Load Balancer (ALB) in a specified VPC.", "parameters": {"type": "object", "properties": {"name": {"type": "string", "description": "The name of the load balancer."}, "subnets": {"type": "array", "description": "A list of subnet IDs in which the load balancer will be created."}}, "required": ["name", "subnets"], "additionalProperties": false}}, {"name": "configure_auto_scaling_group", "description": "Configures an Auto Scaling Group associated with an Application Load Balancer.", "parameters": {"type": "object", "properties": {"lb_arn": {"type": "string", "description": "The ARN of the Application Load Balancer."}, "min_instances": {"type": "integer", "description": "The minimum number of instances to maintain in the Auto Scaling Group."}, "max_instances": {"type": "integer", "description": "The maximum number of instances to maintain in the Auto Scaling Group."}}, "required": ["lb_arn", "min_instances", "max_instances"], "additionalProperties": false}}, {"name": "set_up_security_groups", "description": "Sets up custom security rules for HTTP and HTTPS traffic.", "parameters": {"type": "object", "properties": {"protocol": {"type": "string", "description": "The protocol for which to set up security rules ('http' or 'https')."}}, "required": ["protocol"], "additionalProperties": false}}, {"name": "create_nfs_storage", "description": "Creates a Network File System (NFS) for shared storage in a specified VPC and subnet.", "parameters": {"type": "object", "properties": {"vpc_id": {"type": "string", "description": "The ID of the VPC."}, "subnet_id": {"type": "string", "description": "The ID of the subnet where NFS will be created."}}, "required": ["vpc_id", "subnet_id"], "additionalProperties": false}}], "mock_functions": "def create_load_balancer(name: str, subnets: list) -> dict:\n    \"\"\"\n    Creates an Application Load Balancer (ALB) in a specified VPC.\n\n    :param name: The name of the load balancer.\n    :param subnets: A list of subnet IDs in which the load balancer will be created.\n    :return: A dictionary containing the name and status of the load balancer.\n    :raises ValueError: If the name is empty or subnets list is invalid.\n    \"\"\"\n    if not name or not subnets:\n        raise ValueError(\"Load balancer name and subnets must be provided.\")\n    return {\n        \"name\": name,\n        \"status\": \"active\",\n        \"subnets\": subnets\n    }\ndef configure_auto_scaling_group(lb_arn: str, min_instances: int, max_instances: int) -> dict:\n    \"\"\"\n    Configures an Auto Scaling Group associated with an Application Load Balancer.\n\n    :param lb_arn: The ARN of the Application Load Balancer.\n    :param min_instances: The minimum number of instances to maintain in the Auto Scaling Group.\n    :param max_instances: The maximum number of instances to maintain in the Auto Scaling Group.\n    :return: A dictionary containing the ARN of the load balancer and the auto scaling group settings.\n    :raises ValueError: If lb_arn, min_instances, or max_instances are invalid.\n    \"\"\"\n    if not lb_arn or min_instances < 1 or max_instances < min_instances:\n        raise ValueError(\"Invalid parameters for auto scaling group configuration.\")\n    return {\n        \"lb_arn\": lb_arn,\n        \"min_instances\": min_instances,\n        \"max_instances\": max_instances\n    }\ndef set_up_security_groups(protocol: str) -> str:\n    \"\"\"\n    Sets up custom security rules for HTTP and HTTPS traffic.\n\n    :param protocol: The protocol for which to set up security rules ('http' or 'https').\n    :return: A string indicating the status of the security group setup.\n    :raises ValueError: If the protocol is unsupported.\n    \"\"\"\n    if protocol.lower() not in ['http', 'https']:\n        raise ValueError(\"Unsupported protocol. Use 'http' or 'https'.\")\n    return f\"Security rules for {protocol.upper()} traffic set up successfully.\"\ndef create_nfs_storage(vpc_id: str, subnet_id: str) -> dict:\n    \"\"\"\n    Creates a Network File System (NFS) for shared storage in a specified VPC and subnet.\n\n    :param vpc_id: The ID of the VPC.\n    :param subnet_id: The ID of the subnet where NFS will be created.\n    :return: A dictionary containing the storage ID, VPC ID, and subnet ID.\n    :raises ValueError: If vpc_id or subnet_id are invalid.\n    \"\"\"\n    if not vpc_id or not subnet_id:\n        raise ValueError(\"VPC ID and Subnet ID must be provided.\")\n    return {\n        \"storage_id\": \"nfs-storage-123\",\n        \"vpc_id\": vpc_id,\n        \"subnet_id\": subnet_id\n    }", "user_query": "Configure an auto scaling group for the load balancer with ARN 'arn:aws:elasticloadbalancing:us-east-1:123456789012:loadbalancer/app/webapp-lb/50dc6c495c0c9188', minimum 2 instances, and maximum 10 instances.", "checklist": {"functions": ["configure_auto_scaling_group"], "values": [{"lb_arn": "arn:aws:elasticloadbalancing:us-east-1:123456789012:loadbalancer/app/webapp-lb/50dc6c495c0c9188", "min_instances": 2, "max_instances": 10}]}}
{"difficulty": "easy", "function_schema_python": "def validate_github_workflow(workflow_content: str) -> dict:\n    \"\"\"Validates a GitHub Actions workflow file for syntax and best practices.\n\n    :param workflow_content: The content of the workflow file as a string.\n    :return: A dictionary containing validation results with keys:\n        - is_valid (bool): Whether the workflow is valid\n        - errors (list[str]): List of error messages if any\n        - warnings (list[str]): List of warning messages if any\n    :raises ValueError: If workflow_content is empty\"\"\"\n    pass\ndef check_docker_configuration(dockerfile_path: str, registry_url: str) -> dict:\n    \"\"\"Validates Docker configuration and registry settings.\n\n    :param dockerfile_path: Path to the Dockerfile\n    :param registry_url: URL of the Docker registry\n    :return: A dictionary containing check results with keys:\n        - registry_accessible (bool): Whether registry is accessible\n        - dockerfile_valid (bool): Whether Dockerfile is valid\n        - suggestions (list[str]): List of improvement suggestions\n    :raises FileNotFoundError: If Dockerfile doesn't exist\"\"\"\n    pass\ndef generate_workflow_template(service_name: str, registry_type: str) -> str:\n    \"\"\"Generates a template for GitHub Actions workflow based on service requirements.\n\n    :param service_name: Name of the service\n    :param registry_type: Type of container registry (e.g., 'docker-hub', 'aws-ecr')\n    :return: A string containing the workflow template\n    :raises ValueError: If invalid registry_type is provided\"\"\"\n    pass\n", "function_schema_json": [{"name": "validate_github_workflow", "description": "Validates a GitHub Actions workflow file for syntax and best practices.", "parameters": {"type": "object", "properties": {"workflow_content": {"type": "string", "description": "The content of the workflow file as a string."}}, "required": ["workflow_content"], "additionalProperties": false}}, {"name": "check_docker_configuration", "description": "Validates Docker configuration and registry settings.", "parameters": {"type": "object", "properties": {"dockerfile_path": {"type": "string", "description": "Path to the Dockerfile"}, "registry_url": {"type": "string", "description": "URL of the Docker registry"}}, "required": ["dockerfile_path", "registry_url"], "additionalProperties": false}}, {"name": "generate_workflow_template", "description": "Generates a template for GitHub Actions workflow based on service requirements.", "parameters": {"type": "object", "properties": {"service_name": {"type": "string", "description": "Name of the service"}, "registry_type": {"type": "string", "description": "Type of container registry (e.g., 'docker-hub', 'aws-ecr')"}}, "required": ["service_name", "registry_type"], "additionalProperties": false}}], "mock_functions": "def validate_github_workflow(workflow_content: str) -> dict:\n    \"\"\"\n    Validates a GitHub Actions workflow file for syntax and best practices.\n    \n    :param workflow_content: The content of the workflow file as a string.\n    :return: A dictionary containing validation results with keys:\n        - is_valid (bool): Whether the workflow is valid\n        - errors (list[str]): List of error messages if any\n        - warnings (list[str]): List of warning messages if any\n    :raises ValueError: If workflow_content is empty\n    \"\"\"\n    if not workflow_content:\n        raise ValueError(\"Workflow content cannot be empty\")\n    \n    if \"docker/build-push-action\" in workflow_content and \"steps:\" in workflow_content:\n        return {\n            \"is_valid\": True,\n            \"errors\": [],\n            \"warnings\": [\"Consider adding timeout limits to jobs\"]\n        }\n    return {\n        \"is_valid\": False,\n        \"errors\": [\"Missing required docker build step\"],\n        \"warnings\": []\n    }\ndef check_docker_configuration(dockerfile_path: str, registry_url: str) -> dict:\n    \"\"\"\n    Validates Docker configuration and registry settings.\n    \n    :param dockerfile_path: Path to the Dockerfile\n    :param registry_url: URL of the Docker registry\n    :return: A dictionary containing check results with keys:\n        - registry_accessible (bool): Whether registry is accessible\n        - dockerfile_valid (bool): Whether Dockerfile is valid\n        - suggestions (list[str]): List of improvement suggestions\n    :raises FileNotFoundError: If Dockerfile doesn't exist\n    \"\"\"\n    if not dockerfile_path or not registry_url:\n        raise ValueError(\"Both dockerfile_path and registry_url are required\")\n    \n    if dockerfile_path.endswith(\"Dockerfile\") and \"docker.io\" in registry_url:\n        return {\n            \"registry_accessible\": True,\n            \"dockerfile_valid\": True,\n            \"suggestions\": [\"Consider using multi-stage builds\"]\n        }\n    return {\n        \"registry_accessible\": False,\n        \"dockerfile_valid\": False,\n        \"suggestions\": [\"Invalid registry URL or Dockerfile path\"]\n    }\ndef generate_workflow_template(service_name: str, registry_type: str) -> str:\n    \"\"\"\n    Generates a template for GitHub Actions workflow based on service requirements.\n    \n    :param service_name: Name of the service\n    :param registry_type: Type of container registry (e.g., 'docker-hub', 'aws-ecr')\n    :return: A string containing the workflow template\n    :raises ValueError: If invalid registry_type is provided\n    \"\"\"\n    valid_registries = ['docker-hub', 'aws-ecr']\n    if not service_name or registry_type not in valid_registries:\n        raise ValueError(\"Invalid service name or registry type\")\n    \n    if registry_type == 'docker-hub':\n        return \"\"\"name: Build and Push\non: [push]\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2\n      - uses: docker/build-push-action@v2\n\"\"\"\n    return \"\"", "user_query": "Validate this GitHub Actions workflow file: `name: CI/CD Pipeline\non: push\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2`", "checklist": {"functions": ["validate_github_workflow"], "values": [{"is_valid": false, "errors": ["Missing required docker build step"], "warnings": []}]}}
{"difficulty": "easy", "function_schema_python": "def generate_deployment_config(service_name: str, replicas: int, image_name: str) -> dict:\n    \"\"\"Generates a Kubernetes deployment configuration template.\n\n    :param service_name: Name of the service to be deployed.\n    :param replicas: Number of replicas for the deployment.\n    :param image_name: Docker image name for the service.\n    :return: Dictionary containing the deployment configuration.\n    :raises ValueError: If parameters are invalid.\"\"\"\n    pass\ndef validate_docker_image(image_name: str) -> bool:\n    \"\"\"Validates if the Docker image exists and is accessible.\n\n    :param image_name: Name of the Docker image to validate.\n    :return: True if image exists and is valid, False otherwise.\"\"\"\n    pass\ndef deploy_service(config: dict, cluster_name: str) -> dict:\n    \"\"\"Deploys a service to the specified Kubernetes cluster.\n\n    :param config: Deployment configuration dictionary.\n    :param cluster_name: Name of the target Kubernetes cluster.\n    :return: Dictionary containing deployment status and details.\n    :raises ValueError: If configuration is invalid or cluster is not found.\"\"\"\n    pass\n", "function_schema_json": [{"name": "generate_deployment_config", "description": "Generates a Kubernetes deployment configuration template.", "parameters": {"type": "object", "properties": {"service_name": {"type": "string", "description": "Name of the service to be deployed."}, "replicas": {"type": "integer", "description": "Number of replicas for the deployment."}, "image_name": {"type": "string", "description": "Docker image name for the service."}}, "required": ["service_name", "replicas", "image_name"], "additionalProperties": false}}, {"name": "validate_docker_image", "description": "Validates if the Docker image exists and is accessible.", "parameters": {"type": "object", "properties": {"image_name": {"type": "string", "description": "Name of the Docker image to validate."}}, "required": ["image_name"], "additionalProperties": false}}, {"name": "deploy_service", "description": "Deploys a service to the specified Kubernetes cluster.", "parameters": {"type": "object", "properties": {"config": {"type": "object", "description": "Deployment configuration dictionary."}, "cluster_name": {"type": "string", "description": "Name of the target Kubernetes cluster."}}, "required": ["config", "cluster_name"], "additionalProperties": false}}], "mock_functions": "def generate_deployment_config(\n    service_name: str,\n    replicas: int,\n    image_name: str\n) -> dict:\n    \"\"\"\n    Generates a Kubernetes deployment configuration template.\n    \n    :param service_name: Name of the service to be deployed.\n    :param replicas: Number of replicas for the deployment.\n    :param image_name: Docker image name for the service.\n    :return: Dictionary containing the deployment configuration.\n    :raises ValueError: If parameters are invalid.\n    \"\"\"\n    if not service_name or not image_name or replicas < 1:\n        raise ValueError(\"Invalid parameters provided\")\n    \n    if service_name == \"OrderProcessor\" and replicas == 3:\n        return {\n            \"apiVersion\": \"apps/v1\",\n            \"kind\": \"Deployment\",\n            \"metadata\": {\"name\": service_name},\n            \"spec\": {\n                \"replicas\": replicas,\n                \"selector\": {\"matchLabels\": {\"app\": service_name}},\n                \"template\": {\n                    \"metadata\": {\"labels\": {\"app\": service_name}},\n                    \"spec\": {\"containers\": [{\"name\": service_name, \"image\": image_name}]}\n                }\n            }\n        }\n    return {}\ndef validate_docker_image(image_name: str) -> bool:\n    \"\"\"\n    Validates if the Docker image exists and is accessible.\n    \n    :param image_name: Name of the Docker image to validate.\n    :return: True if image exists and is valid, False otherwise.\n    \"\"\"\n    valid_images = [\"techcorp/orderprocessor:latest\", \"techcorp/orderprocessor:v1\"]\n    return image_name in valid_images\ndef deploy_service(\n    config: dict,\n    cluster_name: str\n) -> dict:\n    \"\"\"\n    Deploys a service to the specified Kubernetes cluster.\n    \n    :param config: Deployment configuration dictionary.\n    :param cluster_name: Name of the target Kubernetes cluster.\n    :return: Dictionary containing deployment status and details.\n    :raises ValueError: If configuration is invalid or cluster is not found.\n    \"\"\"\n    if not config or not cluster_name:\n        raise ValueError(\"Invalid configuration or cluster name\")\n    \n    if config.get(\"metadata\", {}).get(\"name\") == \"OrderProcessor\" and \\\n       cluster_name == \"techcorp-cluster\":\n        return {\n            \"status\": \"success\",\n            \"deployment_name\": \"OrderProcessor\",\n            \"replicas_ready\": 3,\n            \"cluster\": cluster_name,\n            \"message\": \"Deployment completed successfully\"\n        }\n    return {\"status\": \"failed\", \"message\": \"Deployment failed\"}", "user_query": "This is Emily. Could you validate the Docker image \u201ctechcorp/orderprocessor:latest\u201d?", "checklist": {"functions": ["validate_docker_image"], "values": [true]}}
{"difficulty": "easy", "function_schema_python": "def recommend_scaling_configuration(service_name: str, current_performance: dict) -> dict:\n    \"\"\"Recommends an optimal scaling configuration for a given service based on its performance metrics.\n\n    :param service_name: The name of the service (e.g., \"UserAuth\").\n    :param current_performance: A dictionary containing the current performance metrics of the service.\n        Expected keys include:\n            - cpu_usage (float): CPU usage percentage.\n            - memory_usage (float): Memory usage percentage.\n            - instance_count (int): The current number of instances.\n            - requests_per_second (float): Requests per second on average.\n    :return: A dictionary with the recommended scaling configuration. \n        Keys include:\n            - recommended_instance_count (int): The recommended number of instances.\n            - scaling_reason (str): The reason for the recommended scaling.\n    :raises ValueError: If service_name or current_performance is invalid or missing necessary metrics.\"\"\"\n    pass\ndef create_scaling_config_file(service_name: str, config: dict) -> bool:\n    \"\"\"Creates a scaling configuration file for a specified service.\n\n    :param service_name: The name of the service (e.g., \"UserAuth\").\n    :param config: A dictionary containing the scaling configuration details.\n        Expected keys:\n            - recommended_instance_count (int): The recommended number of instances.\n            - scaling_reason (str): The reason for the recommended scaling.\n    :return: True if the file was successfully created, False otherwise.\n    :raises ValueError: If service_name or config is invalid or missing necessary configuration details.\"\"\"\n    pass\ndef execute_scaling_with_deploybot(service_name: str, config_file_path: str) -> dict:\n    \"\"\"Executes the scaling process for a specified service using DeployBot.\n\n    :param service_name: The name of the service (e.g., \"UserAuth\").\n    :param config_file_path: The path to the scaling configuration file.\n    :return:\n        dict: A dictionary with the following keys:\n            - execution_status (str): The status of the execution (e.g., \"success\").\n            - details (str): Additional details about the execution.\n    :raises ValueError: If service_name or config_file_path is invalid or empty.\"\"\"\n    pass\n", "function_schema_json": [{"name": "recommend_scaling_configuration", "description": "Recommends an optimal scaling configuration for a given service based on its performance metrics.", "parameters": {"type": "object", "properties": {"service_name": {"type": "string", "description": "The name of the service (e.g., \"UserAuth\")."}, "current_performance": {"type": "object", "description": "A dictionary containing the current performance metrics of the service."}}, "required": ["service_name", "current_performance"], "additionalProperties": false}}, {"name": "create_scaling_config_file", "description": "Creates a scaling configuration file for a specified service.", "parameters": {"type": "object", "properties": {"service_name": {"type": "string", "description": "The name of the service (e.g., \"UserAuth\")."}, "config": {"type": "object", "description": "A dictionary containing the scaling configuration details."}}, "required": ["service_name", "config"], "additionalProperties": false}}, {"name": "execute_scaling_with_deploybot", "description": "Executes the scaling process for a specified service using DeployBot.", "parameters": {"type": "object", "properties": {"service_name": {"type": "string", "description": "The name of the service (e.g., \"UserAuth\")."}, "config_file_path": {"type": "string", "description": "The path to the scaling configuration file."}}, "required": ["service_name", "config_file_path"], "additionalProperties": false}}], "mock_functions": "def recommend_scaling_configuration(service_name: str, current_performance: dict) -> dict:\n    \"\"\"\n    Recommends an optimal scaling configuration for a given service based on its performance metrics.\n    \n    :param service_name: The name of the service (e.g., \"UserAuth\").\n    :param current_performance: A dictionary containing the current performance metrics of the service.\n        Expected keys include:\n            - cpu_usage (float): CPU usage percentage.\n            - memory_usage (float): Memory usage percentage.\n            - instance_count (int): The current number of instances.\n            - requests_per_second (float): Requests per second on average.\n    :return: A dictionary with the recommended scaling configuration. \n        Keys include:\n            - recommended_instance_count (int): The recommended number of instances.\n            - scaling_reason (str): The reason for the recommended scaling.\n    :raises ValueError: If service_name or current_performance is invalid or missing necessary metrics.\n    \"\"\"\n    if not service_name or not current_performance or not all(key in current_performance for key in ['cpu_usage', 'memory_usage', 'instance_count', 'requests_per_second']):\n        raise ValueError(\"Service name and sufficient performance metrics must be provided.\")\n    \n    if service_name.lower() != \"userauth\":\n        raise ValueError(\"Service name mismatch. Only 'UserAuth' is supported.\")\n    \n    cpu_usage = current_performance['cpu_usage']\n    memory_usage = current_performance['memory_usage']\n    requests_per_second = current_performance['requests_per_second']\n    instance_count = current_performance['instance_count']\n    \n    if cpu_usage > 80.0 or memory_usage > 80.0 or requests_per_second > 500.0:\n        return {\n            \"recommended_instance_count\": instance_count + 2,\n            \"scaling_reason\": \"High CPU/memory usage or requests per second detected.\"\n        }\n    elif cpu_usage > 50.0 or memory_usage > 50.0:\n        return {\n            \"recommended_instance_count\": instance_count + 1,\n            \"scaling_reason\": \"Moderate CPU/memory usage or requests per second detected.\"\n        }\n    else:\n        return {\n            \"recommended_instance_count\": instance_count,\n            \"scaling_reason\": \"No scaling necessary. Current usage is within optimal limits.\"\n        }\ndef create_scaling_config_file(service_name: str, config: dict) -> bool:\n    \"\"\"\n    Creates a scaling configuration file for a specified service.\n    \n    :param service_name: The name of the service (e.g., \"UserAuth\").\n    :param config: A dictionary containing the scaling configuration details.\n        Expected keys:\n            - recommended_instance_count (int): The recommended number of instances.\n            - scaling_reason (str): The reason for the recommended scaling.\n    :return: True if the file was successfully created, False otherwise.\n    :raises ValueError: If service_name or config is invalid or missing necessary configuration details.\n    \"\"\"\n    if not service_name or service_name.lower() != \"userauth\" or not config or not all(key in config for key in ['recommended_instance_count', 'scaling_reason']):\n        raise ValueError(\"Service name and configuration details must be provided.\")\n    \n    # Mock logic: Simulate file creation for the \"UserAuth\" service.\n    print(f\"Scaling config file created for {service_name}:\")\n    print(f\"Recommended Instance Count: {config['recommended_instance_count']}\")\n    print(f\"Scaling Reason: {config['scaling_reason']}\")\n    return True\ndef execute_scaling_with_deploybot(service_name: str, config_file_path: str) -> dict:\n    \"\"\"\n    Executes the scaling process for a specified service using DeployBot.\n    \n    :param service_name: The name of the service (e.g., \"UserAuth\").\n    :param config_file_path: The path to the scaling configuration file.\n    :return:\n        dict: A dictionary with the following keys:\n            - execution_status (str): The status of the execution (e.g., \"success\").\n            - details (str): Additional details about the execution.\n    :raises ValueError: If service_name or config_file_path is invalid or empty.\n    \"\"\"\n    if not service_name or service_name.lower() != \"userauth\" or not config_file_path:\n        raise ValueError(\"Service name and configuration file path must be provided.\")\n    \n    # Mock logic: Simulate scaling execution and return a status.\n    return {\n        \"execution_status\": \"success\",\n        \"details\": \"UserAuth service scaled up successfully based on the provided configuration.\"\n    }", "user_query": "David here.  DeployBot, create a scaling config file for UserAuth using this configuration: recommended_instance_count=4, scaling_reason=\"High CPU usage\".", "checklist": {"functions": ["create_scaling_config_file"], "values": [true]}}
{"difficulty": "easy", "function_schema_python": "def clone_github_repo(url: str, branch: str) -> bool:\n    \"\"\"Clones a GitHub repository from the given URL and checks out the specified branch.\n\n    :param url: The URL of the GitHub repository (e.g., \"github.com/johnDoe/ProjectX\").\n    :param branch: The branch to checkout (e.g., \"prod\").\n    :return: True if the repository was successfully cloned and branch checked out.\n    :raises ValueError: If the URL or branch is not valid.\"\"\"\n    pass\ndef build_docker_image(repo_path: str) -> str:\n    \"\"\"Builds a Docker image from a Dockerfile located in the specified repository path.\n\n    :param repo_path: The path to the repository containing the Dockerfile.\n    :return: The Docker image ID if the build is successful.\n    :raises RuntimeError: If the build fails.\"\"\"\n    pass\ndef push_docker_image_to_aws(image_id: str, ecr_url: str) -> bool:\n    \"\"\"Pushes a Docker image to an AWS ECR repository.\n\n    :param image_id: The Docker image ID to push.\n    :param ecr_url: The URL of the AWS ECR repository.\n    :return: True if the image was successfully pushed.\n    :raises ValueError: If the image ID or ECR URL is not valid.\"\"\"\n    pass\ndef create_or_update_aws_elastic_beanstalk_application(app_name: str, env_name: str, region: str, ecr_image_url: str) -> dict:\n    \"\"\"Creates or updates an AWS Elastic Beanstalk application with the specified parameters.\n\n    :param app_name: The name of the application (e.g., \"ProjectX\").\n    :param env_name: The name of the environment (e.g., \"projectx-env\").\n    :param region: The AWS region (e.g., \"us-west-2\").\n    :param ecr_image_url: The URL of the Docker image in ECR.\n    :return:\n        dict: A dictionary with the following keys:\n            - application_name (str): The name of the application.\n            - environment_name (str): The name of the environment.\n            - region (str): The AWS region.\n            - status (str): The deployment status (e.g., \"success\").\n    :raises ValueError: If any parameter is not valid.\"\"\"\n    pass\ndef monitor_deployment_environment(env_name: str) -> list:\n    \"\"\"Monitors the deployment environment for real-time updates and logs.\n\n    :param env_name: The name of the environment (e.g., \"projectx-env\").\n    :return: A list of logs or updates.\n    :raises ValueError: If the environment name is not valid.\"\"\"\n    pass\n", "function_schema_json": [{"name": "clone_github_repo", "description": "Clones a GitHub repository from the given URL and checks out the specified branch.", "parameters": {"type": "object", "properties": {"url": {"type": "string", "description": "The URL of the GitHub repository (e.g., \"github.com/johnDoe/ProjectX\")."}, "branch": {"type": "string", "description": "The branch to checkout (e.g., \"prod\")."}}, "required": ["url", "branch"], "additionalProperties": false}}, {"name": "build_docker_image", "description": "Builds a Docker image from a Dockerfile located in the specified repository path.", "parameters": {"type": "object", "properties": {"repo_path": {"type": "string", "description": "The path to the repository containing the Dockerfile."}}, "required": ["repo_path"], "additionalProperties": false}}, {"name": "push_docker_image_to_aws", "description": "Pushes a Docker image to an AWS ECR repository.", "parameters": {"type": "object", "properties": {"image_id": {"type": "string", "description": "The Docker image ID to push."}, "ecr_url": {"type": "string", "description": "The URL of the AWS ECR repository."}}, "required": ["image_id", "ecr_url"], "additionalProperties": false}}, {"name": "create_or_update_aws_elastic_beanstalk_application", "description": "Creates or updates an AWS Elastic Beanstalk application with the specified parameters.", "parameters": {"type": "object", "properties": {"app_name": {"type": "string", "description": "The name of the application (e.g., \"ProjectX\")."}, "env_name": {"type": "string", "description": "The name of the environment (e.g., \"projectx-env\")."}, "region": {"type": "string", "description": "The AWS region (e.g., \"us-west-2\")."}, "ecr_image_url": {"type": "string", "description": "The URL of the Docker image in ECR."}}, "required": ["app_name", "env_name", "region", "ecr_image_url"], "additionalProperties": false}}, {"name": "monitor_deployment_environment", "description": "Monitors the deployment environment for real-time updates and logs.", "parameters": {"type": "object", "properties": {"env_name": {"type": "string", "description": "The name of the environment (e.g., \"projectx-env\")."}}, "required": ["env_name"], "additionalProperties": false}}], "mock_functions": "def clone_github_repo(url: str, branch: str) -> bool:\n    \"\"\"\n    Clones a GitHub repository from the given URL and checks out the specified branch.\n    \n    :param url: The URL of the GitHub repository (e.g., \"github.com/johnDoe/ProjectX\").\n    :param branch: The branch to checkout (e.g., \"prod\").\n    :return: True if the repository was successfully cloned and branch checked out.\n    :raises ValueError: If the URL or branch is not valid.\n    \"\"\"\n    if not url or not branch:\n        raise ValueError(\"URL and branch must be provided.\")\n    if url == \"github.com/johnDoe/ProjectX\" and branch == \"prod\":\n        return True\n    return False\ndef build_docker_image(repo_path: str) -> str:\n    \"\"\"\n    Builds a Docker image from a Dockerfile located in the specified repository path.\n    \n    :param repo_path: The path to the repository containing the Dockerfile.\n    :return: The Docker image ID if the build is successful.\n    :raises RuntimeError: If the build fails.\n    \"\"\"\n    if not repo_path:\n        raise RuntimeError(\"Repository path must be provided.\")\n    return \"sha256:abcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890\"\ndef push_docker_image_to_aws(image_id: str, ecr_url: str) -> bool:\n    \"\"\"\n    Pushes a Docker image to an AWS ECR repository.\n    \n    :param image_id: The Docker image ID to push.\n    :param ecr_url: The URL of the AWS ECR repository.\n    :return: True if the image was successfully pushed.\n    :raises ValueError: If the image ID or ECR URL is not valid.\n    \"\"\"\n    if not image_id or not ecr_url:\n        raise ValueError(\"Image ID and ECR URL must be provided.\")\n    return True\ndef create_or_update_aws_elastic_beanstalk_application(app_name: str, env_name: str, region: str, ecr_image_url: str) -> dict:\n    \"\"\"\n    Creates or updates an AWS Elastic Beanstalk application with the specified parameters.\n    \n    :param app_name: The name of the application (e.g., \"ProjectX\").\n    :param env_name: The name of the environment (e.g., \"projectx-env\").\n    :param region: The AWS region (e.g., \"us-west-2\").\n    :param ecr_image_url: The URL of the Docker image in ECR.\n    :return:\n        dict: A dictionary with the following keys:\n            - application_name (str): The name of the application.\n            - environment_name (str): The name of the environment.\n            - region (str): The AWS region.\n            - status (str): The deployment status (e.g., \"success\").\n    :raises ValueError: If any parameter is not valid.\n    \"\"\"\n    if not app_name or not env_name or not region or not ecr_image_url:\n        raise ValueError(\"All parameters must be provided and valid.\")\n    return {\n        \"application_name\": app_name,\n        \"environment_name\": env_name,\n        \"region\": region,\n        \"status\": \"success\"\n    }\ndef monitor_deployment_environment(env_name: str) -> list:\n    \"\"\"\n    Monitors the deployment environment for real-time updates and logs.\n    \n    :param env_name: The name of the environment (e.g., \"projectx-env\").\n    :return: A list of logs or updates.\n    :raises ValueError: If the environment name is not valid.\n    \"\"\"\n    if not env_name:\n        raise ValueError(\"Environment name must be provided.\")\n    return [\n        \"Environment setup initiated.\",\n        \"Docker image successfully pulled.\",\n        \"Application deployment in progress.\",\n        \"Deployment completed successfully.\"\n    ]", "user_query": "Can you clone the repository from github.com/johnDoe/ProjectX using the prod branch?", "checklist": {"functions": ["clone_github_repo"], "values": [true]}}
{"difficulty": "easy", "function_schema_python": "def update_product_catalog(products: List[Dict], num_new_products: int) -> bool:\n    \"\"\"Updates the product catalog with new product information.\n\n    :param products: A list of dictionaries, where each dictionary represents a product\n                   and contains product details (e.g., name, price, description).\n    :param num_new_products: The number of new products to add.\n    :return: True if the catalog was successfully updated, False otherwise.\"\"\"\n    pass\ndef get_product_specifications(product_name: str) -> Dict:\n    \"\"\"Retrieves technical specifications for a given product.\n\n    :param product_name: The name of the product.\n    :return: A dictionary containing the product's technical specifications.\n           Returns an empty dictionary if the product is not found.\"\"\"\n    pass\ndef set_competitive_pricing(product_name: str, price: float) -> bool:\n    \"\"\"Sets a competitive price for a given product.\n\n    :param product_name: The name of the product.\n    :param price: The desired price.\n    :return: True if the price was successfully set, False otherwise.\"\"\"\n    pass\n", "function_schema_json": [{"name": "update_product_catalog", "description": "Updates the product catalog with new product information.", "parameters": {"type": "object", "properties": {"products": {"type": "array", "items": {"type": "object"}, "description": "A list of dictionaries, where each dictionary represents a product"}, "num_new_products": {"type": "integer", "description": "The number of new products to add."}}, "required": ["products", "num_new_products"], "additionalProperties": false}}, {"name": "get_product_specifications", "description": "Retrieves technical specifications for a given product.", "parameters": {"type": "object", "properties": {"product_name": {"type": "string", "description": "The name of the product."}}, "required": ["product_name"], "additionalProperties": false}}, {"name": "set_competitive_pricing", "description": "Sets a competitive price for a given product.", "parameters": {"type": "object", "properties": {"product_name": {"type": "string", "description": "The name of the product."}, "price": {"type": "number", "description": "The desired price."}}, "required": ["product_name", "price"], "additionalProperties": false}}], "mock_functions": "def update_product_catalog(products: List[Dict], num_new_products: int) -> bool:\n    \"\"\"\n    Updates the product catalog with new product information.\n\n    :param products: A list of dictionaries, where each dictionary represents a product\n                   and contains product details (e.g., name, price, description).\n    :param num_new_products: The number of new products to add.\n    :return: True if the catalog was successfully updated, False otherwise.\n    \"\"\"\n    if not isinstance(products, list) or not all(isinstance(p, dict) for p in products):\n        return False\n    if not isinstance(num_new_products, int) or num_new_products < 0:\n        return False\n    \n    # Mock logic: Simulate updating the catalog.  In a real implementation,\n    # this would involve database operations or API calls.\n    if len(products) == 5000 and num_new_products == 25:\n        return True\n    return False\ndef get_product_specifications(product_name: str) -> Dict:\n    \"\"\"\n    Retrieves technical specifications for a given product.\n\n    :param product_name: The name of the product.\n    :return: A dictionary containing the product's technical specifications.\n           Returns an empty dictionary if the product is not found.\n    \"\"\"\n    if not isinstance(product_name, str):\n        return {}\n    # Mock logic: Simulate retrieving specifications for \"Smart Thermostat\" and \"Security Camera\".\n    if \"smart thermostat\" in product_name.lower():\n        return {\n            \"power\": \"120V\",\n            \"connectivity\": \"Wi-Fi\",\n            \"compatibility\": \"HomeSmart Hub\"\n        }\n    elif \"security camera\" in product_name.lower():\n        return {\n            \"resolution\": \"1080p\",\n            \"night vision\": \"Yes\",\n            \"storage\": \"Cloud\"\n        }\n    return {}\ndef set_competitive_pricing(product_name: str, price: float) -> bool:\n    \"\"\"\n    Sets a competitive price for a given product.\n\n    :param product_name: The name of the product.\n    :param price: The desired price.\n    :return: True if the price was successfully set, False otherwise.\n    \"\"\"\n    if not isinstance(product_name, str) or not isinstance(price, (int, float)):\n        return False\n\n    # Mock logic: Simulate setting the price.\n    if price > 0:  # Just a simple check for a valid price\n        return True\n    return False", "user_query": "Could you get the product specifications for \"HomeSmart Security Camera Pro\"?", "checklist": {"functions": ["get_product_specifications"], "values": [{"resolution": "1080p", "night vision": "Yes", "storage": "Cloud"}]}}
{"difficulty": "easy", "function_schema_python": "def update_product_catalog(products: List[Dict], num_new_products: int) -> bool:\n    \"\"\"Updates the product catalog with new product information.\n\n    :param products: A list of dictionaries, where each dictionary represents a product\n                   and contains product details (e.g., name, price, description).\n    :param num_new_products: The number of new products to add.\n    :return: True if the catalog was successfully updated, False otherwise.\"\"\"\n    pass\ndef get_product_specifications(product_name: str) -> Dict:\n    \"\"\"Retrieves technical specifications for a given product.\n\n    :param product_name: The name of the product.\n    :return: A dictionary containing the product's technical specifications.\n           Returns an empty dictionary if the product is not found.\"\"\"\n    pass\ndef set_competitive_pricing(product_name: str, price: float) -> bool:\n    \"\"\"Sets a competitive price for a given product.\n\n    :param product_name: The name of the product.\n    :param price: The desired price.\n    :return: True if the price was successfully set, False otherwise.\"\"\"\n    pass\n", "function_schema_json": [{"name": "update_product_catalog", "description": "Updates the product catalog with new product information.", "parameters": {"type": "object", "properties": {"products": {"type": "array", "items": {"type": "object"}, "description": "A list of dictionaries, where each dictionary represents a product"}, "num_new_products": {"type": "integer", "description": "The number of new products to add."}}, "required": ["products", "num_new_products"], "additionalProperties": false}}, {"name": "get_product_specifications", "description": "Retrieves technical specifications for a given product.", "parameters": {"type": "object", "properties": {"product_name": {"type": "string", "description": "The name of the product."}}, "required": ["product_name"], "additionalProperties": false}}, {"name": "set_competitive_pricing", "description": "Sets a competitive price for a given product.", "parameters": {"type": "object", "properties": {"product_name": {"type": "string", "description": "The name of the product."}, "price": {"type": "number", "description": "The desired price."}}, "required": ["product_name", "price"], "additionalProperties": false}}], "mock_functions": "def update_product_catalog(products: List[Dict], num_new_products: int) -> bool:\n    \"\"\"\n    Updates the product catalog with new product information.\n\n    :param products: A list of dictionaries, where each dictionary represents a product\n                   and contains product details (e.g., name, price, description).\n    :param num_new_products: The number of new products to add.\n    :return: True if the catalog was successfully updated, False otherwise.\n    \"\"\"\n    if not isinstance(products, list) or not all(isinstance(p, dict) for p in products):\n        return False\n    if not isinstance(num_new_products, int) or num_new_products < 0:\n        return False\n    \n    # Mock logic: Simulate updating the catalog.  In a real implementation,\n    # this would involve database operations or API calls.\n    if len(products) == 5000 and num_new_products == 25:\n        return True\n    return False\ndef get_product_specifications(product_name: str) -> Dict:\n    \"\"\"\n    Retrieves technical specifications for a given product.\n\n    :param product_name: The name of the product.\n    :return: A dictionary containing the product's technical specifications.\n           Returns an empty dictionary if the product is not found.\n    \"\"\"\n    if not isinstance(product_name, str):\n        return {}\n    # Mock logic: Simulate retrieving specifications for \"Smart Thermostat\" and \"Security Camera\".\n    if \"smart thermostat\" in product_name.lower():\n        return {\n            \"power\": \"120V\",\n            \"connectivity\": \"Wi-Fi\",\n            \"compatibility\": \"HomeSmart Hub\"\n        }\n    elif \"security camera\" in product_name.lower():\n        return {\n            \"resolution\": \"1080p\",\n            \"night vision\": \"Yes\",\n            \"storage\": \"Cloud\"\n        }\n    return {}\ndef set_competitive_pricing(product_name: str, price: float) -> bool:\n    \"\"\"\n    Sets a competitive price for a given product.\n\n    :param product_name: The name of the product.\n    :param price: The desired price.\n    :return: True if the price was successfully set, False otherwise.\n    \"\"\"\n    if not isinstance(product_name, str) or not isinstance(price, (int, float)):\n        return False\n\n    # Mock logic: Simulate setting the price.\n    if price > 0:  # Just a simple check for a valid price\n        return True\n    return False", "user_query": "Can you set the competitive pricing for \"HomeSmart Smart Thermostat Elite\" to $199.99?", "checklist": {"functions": ["set_competitive_pricing"], "values": [true]}}
{"difficulty": "easy", "function_schema_python": "def get_active_products(catalog_id: str) -> list:\n    \"\"\"Retrieves the list of active products in a given catalog.\n\n    :param catalog_id: The ID of the catalog to retrieve products from.\n    :return: A list of product IDs.\n    :raises ValueError: If catalog_id is empty.\"\"\"\n    pass\ndef remove_discontinued_products(product_list: list) -> list:\n    \"\"\"Removes discontinued products from the given list.\n\n    :param product_list: List of product IDs to be filtered.\n    :return: A list of active product IDs after filtering discontinued ones.\n    :raises ValueError: If product_list is empty or not a list.\"\"\"\n    pass\ndef update_product_images(product_id: str, image_urls: list) -> dict:\n    \"\"\"Updates the product images with the provided URLs.\n\n    :param product_id: The ID of the product to update.\n    :param image_urls: List of image URLs to update the product with.\n    :return: A dictionary containing the status of the image upload.\n        dict: A dictionary with the following keys:\n            - success (bool): True if images were successfully uploaded, False otherwise.\n            - message (str): Status message.\n    :raises ValueError: If product_id is empty or image_urls is not a list.\"\"\"\n    pass\ndef update_product_sizes(product_id: str, size_range: list) -> dict:\n    \"\"\"Updates the size range for a given product.\n\n    :param product_id: The ID of the product to update.\n    :param size_range: List of strings indicating the size range (e.g., [\"XS\", \"S\", \"M\"]).\n    :return: A dictionary containing the status of the size update.\n        dict: A dictionary with the following keys:\n            - success (bool): True if size range was successfully updated, False otherwise.\n            - message (str): Status message.\n    :raises ValueError: If product_id is empty or size_range is not a list.\"\"\"\n    pass\ndef update_product_prices(product_id: str, new_price: float) -> dict:\n    \"\"\"Updates the price for a given product.\n\n    :param product_id: The ID of the product to update.\n    :param new_price: The new price to set for the product.\n    :return: A dictionary containing the status of the price update.\n        dict: A dictionary with the following keys:\n            - success (bool): True if the price was successfully updated, False otherwise.\n            - message (str): Status message.\n    :raises ValueError: If product_id is empty or new_price is not a number.\"\"\"\n    pass\ndef consolidate_product_lines(product_list: list) -> dict:\n    \"\"\"Consolidates similar products into product lines.\n\n    :param product_list: List of product IDs to be consolidated.\n    :return: A dictionary with consolidated product lines.\n        dict: A dictionary with the following keys:\n            - product_line_1 (list): List of product IDs in the first product line.\n            - product_line_2 (list): List of product IDs in the second product line.\n            - ... (and so on for additional product lines).\n    :raises ValueError: If product_list is empty or not a list.\"\"\"\n    pass\n", "function_schema_json": [{"name": "get_active_products", "description": "Retrieves the list of active products in a given catalog.", "parameters": {"type": "object", "properties": {"catalog_id": {"type": "string", "description": "The ID of the catalog to retrieve products from."}}, "required": ["catalog_id"], "additionalProperties": false}}, {"name": "remove_discontinued_products", "description": "Removes discontinued products from the given list.", "parameters": {"type": "object", "properties": {"product_list": {"type": "array", "description": "List of product IDs to be filtered."}}, "required": ["product_list"], "additionalProperties": false}}, {"name": "update_product_images", "description": "Updates the product images with the provided URLs.", "parameters": {"type": "object", "properties": {"product_id": {"type": "string", "description": "The ID of the product to update."}, "image_urls": {"type": "array", "description": "List of image URLs to update the product with."}}, "required": ["product_id", "image_urls"], "additionalProperties": false}}, {"name": "update_product_sizes", "description": "Updates the size range for a given product.", "parameters": {"type": "object", "properties": {"product_id": {"type": "string", "description": "The ID of the product to update."}, "size_range": {"type": "array", "description": "List of strings indicating the size range (e.g., [\"XS\", \"S\", \"M\"])."}}, "required": ["product_id", "size_range"], "additionalProperties": false}}, {"name": "update_product_prices", "description": "Updates the price for a given product.", "parameters": {"type": "object", "properties": {"product_id": {"type": "string", "description": "The ID of the product to update."}, "new_price": {"type": "number", "description": "The new price to set for the product."}}, "required": ["product_id", "new_price"], "additionalProperties": false}}, {"name": "consolidate_product_lines", "description": "Consolidates similar products into product lines.", "parameters": {"type": "object", "properties": {"product_list": {"type": "array", "description": "List of product IDs to be consolidated."}}, "required": ["product_list"], "additionalProperties": false}}], "mock_functions": "def get_active_products(catalog_id: str) -> list:\n    \"\"\"\n    Retrieves the list of active products in a given catalog.\n    \n    :param catalog_id: The ID of the catalog to retrieve products from.\n    :return: A list of product IDs.\n    :raises ValueError: If catalog_id is empty.\n    \"\"\"\n    if not catalog_id:\n        raise ValueError(\"Catalog ID must be provided.\")\n    if catalog_id.lower() == \"styleconnect\":\n        return [\"product001\", \"product002\", \"product003\"]\n    return []\ndef remove_discontinued_products(product_list: list) -> list:\n    \"\"\"\n    Removes discontinued products from the given list.\n    \n    :param product_list: List of product IDs to be filtered.\n    :return: A list of active product IDs after filtering discontinued ones.\n    :raises ValueError: If product_list is empty or not a list.\n    \"\"\"\n    if not product_list or not isinstance(product_list, list):\n        raise ValueError(\"Product list must be a non-empty list.\")\n    # Mock logic: Simulate some products being discontinued\n    approved_products = [product for product in product_list if product != \"product002\"]\n    return approved_products\ndef update_product_images(product_id: str, image_urls: list) -> dict:\n    \"\"\"\n    Updates the product images with the provided URLs.\n    \n    :param product_id: The ID of the product to update.\n    :param image_urls: List of image URLs to update the product with.\n    :return: A dictionary containing the status of the image upload.\n        dict: A dictionary with the following keys:\n            - success (bool): True if images were successfully uploaded, False otherwise.\n            - message (str): Status message.\n    :raises ValueError: If product_id is empty or image_urls is not a list.\n    \"\"\"\n    if not product_id or not isinstance(image_urls, list):\n        raise ValueError(\"Product ID must be provided and image URLs must be a list.\")\n    if product_id.lower() in [\"product001\", \"product003\"] and image_urls:\n        return {\n            \"success\": True,\n            \"message\": \"Images successfully uploaded.\"\n        }\n    return {\n        \"success\": False,\n        \"message\": \"Failed to upload images.\"\n    }\ndef update_product_sizes(product_id: str, size_range: list) -> dict:\n    \"\"\"\n    Updates the size range for a given product.\n    \n    :param product_id: The ID of the product to update.\n    :param size_range: List of strings indicating the size range (e.g., [\"XS\", \"S\", \"M\"]).\n    :return: A dictionary containing the status of the size update.\n        dict: A dictionary with the following keys:\n            - success (bool): True if size range was successfully updated, False otherwise.\n            - message (str): Status message.\n    :raises ValueError: If product_id is empty or size_range is not a list.\n    \"\"\"\n    if not product_id or not isinstance(size_range, list):\n        raise ValueError(\"Product ID must be provided and size range must be a list.\")\n    if product_id.lower() in [\"product001\", \"product003\"] and size_range:\n        return {\n            \"success\": True,\n            \"message\": \"Size range successfully updated.\"\n        }\n    return {\n        \"success\": False,\n        \"message\": \"Failed to update size range.\"\n    }\ndef update_product_prices(product_id: str, new_price: float) -> dict:\n    \"\"\"\n    Updates the price for a given product.\n    \n    :param product_id: The ID of the product to update.\n    :param new_price: The new price to set for the product.\n    :return: A dictionary containing the status of the price update.\n        dict: A dictionary with the following keys:\n            - success (bool): True if the price was successfully updated, False otherwise.\n            - message (str): Status message.\n    :raises ValueError: If product_id is empty or new_price is not a number.\n    \"\"\"\n    if not product_id or not isinstance(new_price, (int, float)):\n        raise ValueError(\"Product ID must be provided and new price must be a number.\")\n    if product_id.lower() in [\"product001\", \"product003\"] and new_price > 0:\n        return {\n            \"success\": True,\n            \"message\": \"Price successfully updated.\"\n        }\n    return {\n        \"success\": False,\n        \"message\": \"Failed to update price.\"\n    }\ndef consolidate_product_lines(product_list: list) -> dict:\n    \"\"\"\n    Consolidates similar products into product lines.\n    \n    :param product_list: List of product IDs to be consolidated.\n    :return: A dictionary with consolidated product lines.\n        dict: A dictionary with the following keys:\n            - product_line_1 (list): List of product IDs in the first product line.\n            - product_line_2 (list): List of product IDs in the second product line.\n            - ... (and so on for additional product lines).\n    :raises ValueError: If product_list is empty or not a list.\n    \"\"\"\n    if not product_list or not isinstance(product_list, list):\n        raise ValueError(\"Product list must be a non-empty list.\")\n    # Mock logic: Assume some form of consolidation\n    return {\n        \"product_line_1\": [\"product001\", \"product002\"],\n        \"product_line_2\": [\"product003\"]\n    }", "user_query": "Could you get all active products from the \"StyleConnect\" catalog?", "checklist": {"functions": ["get_active_products"], "values": [["product001", "product002", "product003"]]}}
{"difficulty": "easy", "function_schema_python": "def get_bookworm_inventory(book_isbn: str) -> int:\n    \"\"\"Retrieves the inventory count for a specific book from BookWorm 2.0.\n\n    :param book_isbn: The ISBN of the book.\n    :return: The inventory count as an integer.\n    :raises ValueError: If the ISBN is invalid or not found.\"\"\"\n    pass\ndef get_physical_inventory(book_isbn: str) -> int:\n    \"\"\"Retrieves the physical inventory count for a specific book.\n\n    :param book_isbn: The ISBN of the book.\n    :return: The physical inventory count as an integer.\n    :raises ValueError: If the ISBN is invalid or not found.\"\"\"\n    pass\ndef generate_inventory_discrepancy_report(book_isbns: List[str]) -> Dict:\n    \"\"\"Generates a report comparing physical and BookWorm 2.0 inventory counts.\n\n    :param book_isbns: A list of ISBNs for the books to include in the report.\n    :return: A dictionary containing the discrepancy report data.\n        The dictionary has the following structure:\n        {\n            \"book_isbn\": {\n                \"physical_count\": int,\n                \"bookworm_count\": int,\n                \"discrepancy\": int\n            }\n        }\n\n    :raises ValueError: If any ISBN is invalid.\"\"\"\n    pass\n", "function_schema_json": [{"name": "get_bookworm_inventory", "description": "Retrieves the inventory count for a specific book from BookWorm 2.0.", "parameters": {"type": "object", "properties": {"book_isbn": {"type": "string", "description": "The ISBN of the book."}}, "required": ["book_isbn"], "additionalProperties": false}}, {"name": "get_physical_inventory", "description": "Retrieves the physical inventory count for a specific book.", "parameters": {"type": "object", "properties": {"book_isbn": {"type": "string", "description": "The ISBN of the book."}}, "required": ["book_isbn"], "additionalProperties": false}}, {"name": "generate_inventory_discrepancy_report", "description": "Generates a report comparing physical and BookWorm 2.0 inventory counts.", "parameters": {"type": "object", "properties": {"book_isbns": {"type": "array", "items": {"type": "string"}, "description": "A list of ISBNs for the books to include in the report."}}, "required": ["book_isbns"], "additionalProperties": false}}], "mock_functions": "def get_bookworm_inventory(book_isbn: str) -> int:\n    \"\"\"\n    Retrieves the inventory count for a specific book from BookWorm 2.0.\n\n    :param book_isbn: The ISBN of the book.\n    :return: The inventory count as an integer.\n    :raises ValueError: If the ISBN is invalid or not found.\n    \"\"\"\n    if book_isbn == \"978-0345391803\":\n        return 35\n    elif book_isbn == \"978-0141439518\":\n        return 23\n    else:\n        raise ValueError(\"Invalid or unknown ISBN.\")\ndef get_physical_inventory(book_isbn: str) -> int:\n    \"\"\"\n    Retrieves the physical inventory count for a specific book.\n\n    :param book_isbn: The ISBN of the book.\n    :return: The physical inventory count as an integer.\n    :raises ValueError: If the ISBN is invalid or not found.\n    \"\"\"\n    if book_isbn == \"978-0345391803\":\n        return 20\n    elif book_isbn == \"978-0141439518\":\n        return 16\n    else:\n        raise ValueError(\"Invalid or unknown ISBN.\")\ndef generate_inventory_discrepancy_report(book_isbns: List[str]) -> Dict:\n    \"\"\"\n    Generates a report comparing physical and BookWorm 2.0 inventory counts.\n\n    :param book_isbns: A list of ISBNs for the books to include in the report.\n    :return: A dictionary containing the discrepancy report data.\n        The dictionary has the following structure:\n        {\n            \"book_isbn\": {\n                \"physical_count\": int,\n                \"bookworm_count\": int,\n                \"discrepancy\": int\n            }\n        }\n\n    :raises ValueError: If any ISBN is invalid.\n    \"\"\"\n\n    report = {}\n    for isbn in book_isbns:\n        try:\n            physical_count = get_physical_inventory(isbn)\n            bookworm_count = get_bookworm_inventory(isbn)\n            discrepancy = bookworm_count - physical_count\n            report[isbn] = {\n                \"physical_count\": physical_count,\n                \"bookworm_count\": bookworm_count,\n                \"discrepancy\": discrepancy\n            }\n        except ValueError as e:\n            raise ValueError(f\"Error processing ISBN {isbn}: {e}\")\n    return report", "user_query": "What's the BookWorm 2.0 inventory count for \"The Hitchhiker's Guide to the Galaxy\" (ISBN: 978-0345391803)?", "checklist": {"functions": ["get_bookworm_inventory"], "values": [35]}}
{"difficulty": "easy", "function_schema_python": "def fetch_sales_data(start_date: str, end_date: str, product_ids: list) -> dict:\n    \"\"\"Fetches sales data for specified products within a given date range.\n\n    :param start_date: The start date of the sales period (e.g., \"2023-10-26\").\n    :param end_date: The end date of the sales period (e.g., \"2024-01-25\").\n    :param product_ids: A list of product IDs for which sales data is needed.\n    :return: A dictionary with product IDs as keys and their sales data as values.\n        - Each value is a dictionary with the following keys:\n            - total_units_sold (int): The total units sold.\n            - average_daily_sales (float): The average daily sales.\n    :raises ValueError: If start_date or end_date is invalid.\n    :raises KeyError: If a product ID is not recognized.\"\"\"\n    pass\ndef analyze_sales_data(sales_data: dict) -> dict:\n    \"\"\"Analyzes sales data to determine product popularity and suggest optimal storage locations.\n\n    :param sales_data: A dictionary containing sales data for products.\n    :return: A dictionary with product IDs as keys and their suggested storage slots as values.\n    :raises ValueError: If sales_data is empty or not in the expected format.\"\"\"\n    pass\ndef update_warehouse_layout(product_id: str, slot: str) -> bool:\n    \"\"\"Updates the warehouse layout to place a product in a specified storage slot.\n\n    :param product_id: The ID of the product to be relocated.\n    :param slot: The storage slot where the product should be placed (e.g., \"A1\").\n    :return: True if the layout was successfully updated, False otherwise.\n    :raises ValueError: If product_id or slot is empty.\"\"\"\n    pass\n", "function_schema_json": [{"name": "fetch_sales_data", "description": "Fetches sales data for specified products within a given date range.", "parameters": {"type": "object", "properties": {"start_date": {"type": "string", "description": "The start date of the sales period (e.g., \"2023-10-26\")."}, "end_date": {"type": "string", "description": "The end date of the sales period (e.g., \"2024-01-25\")."}, "product_ids": {"type": "array", "description": "A list of product IDs for which sales data is needed."}}, "required": ["start_date", "end_date", "product_ids"], "additionalProperties": false}}, {"name": "analyze_sales_data", "description": "Analyzes sales data to determine product popularity and suggest optimal storage locations.", "parameters": {"type": "object", "properties": {"sales_data": {"type": "object", "description": "A dictionary containing sales data for products."}}, "required": ["sales_data"], "additionalProperties": false}}, {"name": "update_warehouse_layout", "description": "Updates the warehouse layout to place a product in a specified storage slot.", "parameters": {"type": "object", "properties": {"product_id": {"type": "string", "description": "The ID of the product to be relocated."}, "slot": {"type": "string", "description": "The storage slot where the product should be placed (e.g., \"A1\")."}}, "required": ["product_id", "slot"], "additionalProperties": false}}], "mock_functions": "def fetch_sales_data(start_date: str, end_date: str, product_ids: list) -> dict:\n    \"\"\"\n    Fetches sales data for specified products within a given date range.\n    \n    :param start_date: The start date of the sales period (e.g., \"2023-10-26\").\n    :param end_date: The end date of the sales period (e.g., \"2024-01-25\").\n    :param product_ids: A list of product IDs for which sales data is needed.\n    :return: A dictionary with product IDs as keys and their sales data as values.\n        - Each value is a dictionary with the following keys:\n            - total_units_sold (int): The total units sold.\n            - average_daily_sales (float): The average daily sales.\n    :raises ValueError: If start_date or end_date is invalid.\n    :raises KeyError: If a product ID is not recognized.\n    \"\"\"\n    if not start_date or not end_date:\n        raise ValueError(\"Start date and end date must be provided.\")\n    if not product_ids:\n        raise ValueError(\"Product IDs must be provided.\")\n    \n    mock_sales_data = {\n        \"TG-EPMX23\": {\n            \"total_units_sold\": 4000,\n            \"average_daily_sales\": 4.44\n        },\n        \"TG-SW5000\": {\n            \"total_units_sold\": 2500,\n            \"average_daily_sales\": 2.78\n        }\n    }\n    \n    result = {product_id: mock_sales_data[product_id] for product_id in product_ids if product_id in mock_sales_data}\n    if not result:\n        raise KeyError(\"One or more product IDs are not recognized.\")\n    \n    return result\ndef analyze_sales_data(sales_data: dict) -> dict:\n    \"\"\"\n    Analyzes sales data to determine product popularity and suggest optimal storage locations.\n    \n    :param sales_data: A dictionary containing sales data for products.\n    :return: A dictionary with product IDs as keys and their suggested storage slots as values.\n    :raises ValueError: If sales_data is empty or not in the expected format.\n    \"\"\"\n    if not sales_data:\n        raise ValueError(\"Sales data must be provided and not empty.\")\n    \n    # Mock logic: Assuming storage slots are labeled as 'A1', 'A2', etc.\n    suggested_slots = {\n        \"TG-EPMX23\": \"A1\",  # More popular product, closer to entrance\n        \"TG-SW5000\": \"A2\"   # Less popular product, slightly further\n    }\n    \n    # Ensure only valid product IDs are processed\n    result = {product_id: suggested_slots[product_id] for product_id in sales_data.keys() if product_id in suggested_slots}\n    \n    if not result:\n        raise KeyError(\"No valid product IDs found in sales data.\")\n    \n    return result\ndef update_warehouse_layout(product_id: str, slot: str) -> bool:\n    \"\"\"\n    Updates the warehouse layout to place a product in a specified storage slot.\n    \n    :param product_id: The ID of the product to be relocated.\n    :param slot: The storage slot where the product should be placed (e.g., \"A1\").\n    :return: True if the layout was successfully updated, False otherwise.\n    :raises ValueError: If product_id or slot is empty.\n    \"\"\"\n    if not product_id or not slot:\n        raise ValueError(\"Product ID and slot must be provided.\")\n    \n    # Mock logic: Assume the update was successful\n    return True\n", "user_query": "Could you fetch the sales data for products TG-EPMX23 and TG-SW5000 between 2023-10-26 and 2024-01-25?", "checklist": {"functions": ["fetch_sales_data"], "values": [{"TG-EPMX23": {"total_units_sold": 4000, "average_daily_sales": 4.44}, "TG-SW5000": {"total_units_sold": 2500, "average_daily_sales": 2.78}}]}}
{"difficulty": "easy", "function_schema_python": "def analyze_batch_status(batch_id: str, product_name: str) -> dict:\n    \"\"\"Analyzes the current status of a specific batch of orders.\n\n    :param batch_id: The identifier for the batch (format: WS-XXXX)\n    :param product_name: The name of the product being processed\n    :return: Dictionary containing batch status information\n    :raises ValueError: If batch_id format is invalid\"\"\"\n    pass\ndef get_warehouse_locations(product_name: str) -> dict:\n    \"\"\"Retrieves the warehouse locations for a specific product.\n\n    :param product_name: Name of the product to locate\n    :return: Dictionary containing location information\"\"\"\n    pass\ndef get_processing_metrics(batch_id: str) -> dict:\n    \"\"\"Retrieves detailed processing metrics for each fulfillment stage.\n\n    :param batch_id: The identifier for the batch (format: WS-XXXX)\n    :return: Dictionary containing processing metrics for each stage\n    :raises ValueError: If batch_id format is invalid\"\"\"\n    pass\n", "function_schema_json": [{"name": "analyze_batch_status", "description": "Analyzes the current status of a specific batch of orders.", "parameters": {"type": "object", "properties": {"batch_id": {"type": "string", "description": "The identifier for the batch (format: WS-XXXX)"}, "product_name": {"type": "string", "description": "The name of the product being processed"}}, "required": ["batch_id", "product_name"], "additionalProperties": false}}, {"name": "get_warehouse_locations", "description": "Retrieves the warehouse locations for a specific product.", "parameters": {"type": "object", "properties": {"product_name": {"type": "string", "description": "Name of the product to locate"}}, "required": ["product_name"], "additionalProperties": false}}, {"name": "get_processing_metrics", "description": "Retrieves detailed processing metrics for each fulfillment stage.", "parameters": {"type": "object", "properties": {"batch_id": {"type": "string", "description": "The identifier for the batch (format: WS-XXXX)"}}, "required": ["batch_id"], "additionalProperties": false}}], "mock_functions": "def analyze_batch_status(batch_id: str, product_name: str) -> dict:\n    \"\"\"\n    Analyzes the current status of a specific batch of orders.\n    \n    :param batch_id: The identifier for the batch (format: WS-XXXX)\n    :param product_name: The name of the product being processed\n    :return: Dictionary containing batch status information\n    :raises ValueError: If batch_id format is invalid\n    \"\"\"\n    if not batch_id.startswith(\"WS-\") or len(batch_id) != 7:\n        raise ValueError(\"Invalid batch ID format\")\n    \n    if batch_id == \"WS-4789\" and \"headphone\" in product_name.lower():\n        return {\n            \"total_orders\": 150,\n            \"processed_orders\": 89,\n            \"pending_orders\": 61,\n            \"average_processing_time\": \"45 minutes\",\n            \"batch_completion\": \"59.3%\"\n        }\n    return {}\ndef get_warehouse_locations(product_name: str) -> dict:\n    \"\"\"\n    Retrieves the warehouse locations for a specific product.\n    \n    :param product_name: Name of the product to locate\n    :return: Dictionary containing location information\n    \"\"\"\n    if \"headphone\" in product_name.lower():\n        return {\n            \"primary_location\": \"Aisle B-12\",\n            \"secondary_location\": \"Overflow Area C-5\",\n            \"total_units\": 450,\n            \"units_by_location\": {\n                \"Aisle B-12\": 300,\n                \"Overflow Area C-5\": 150\n            }\n        }\n    return {}\ndef get_processing_metrics(batch_id: str) -> dict:\n    \"\"\"\n    Retrieves detailed processing metrics for each fulfillment stage.\n    \n    :param batch_id: The identifier for the batch (format: WS-XXXX)\n    :return: Dictionary containing processing metrics for each stage\n    :raises ValueError: If batch_id format is invalid\n    \"\"\"\n    if not batch_id.startswith(\"WS-\") or len(batch_id) != 7:\n        raise ValueError(\"Invalid batch ID format\")\n        \n    if batch_id == \"WS-4789\":\n        return {\n            \"picking\": {\n                \"average_time\": \"15 minutes\",\n                \"bottleneck_risk\": \"low\",\n                \"worker_efficiency\": \"92%\"\n            },\n            \"packing\": {\n                \"average_time\": \"20 minutes\",\n                \"bottleneck_risk\": \"high\",\n                \"worker_efficiency\": \"78%\"\n            },\n            \"shipping\": {\n                \"average_time\": \"10 minutes\",\n                \"bottleneck_risk\": \"medium\",\n                \"worker_efficiency\": \"85%\"\n            }\n        }\n    return {}", "user_query": "Can you retrieve the warehouse locations for XYZ Brand Headphones and show me how many units are in each location?", "checklist": {"functions": ["get_warehouse_locations"], "values": [{"primary_location": "Aisle B-12", "secondary_location": "Overflow Area C-5", "total_units": 450, "units_by_location": {"Aisle B-12": 300, "Overflow Area C-5": 150}}]}}
{"difficulty": "easy", "function_schema_python": "def extract_clauses_from_pdf(pdf_path: str, keywords: list) -> list:\n    \"\"\"Extracts specific clauses from a PDF document based on provided keywords.\n\n    :param pdf_path: The path to the PDF document.\n    :param keywords: A list of keywords to search for in the document.\n    :return: A list of strings, where each string represents an extracted clause.\n    :raises FileNotFoundError: If the PDF file is not found.\n    :raises ValueError: If keywords list is empty.\"\"\"\n    pass\ndef process_legal_document(document_path: str) -> str:\n    \"\"\"Processes a legal document and prepares it for analysis.\n\n    :param document_path: The path to the legal document.\n    :return: A string representing the processed document content.\n    :raises FileNotFoundError: If the document is not found.\"\"\"\n    pass\ndef analyze_legal_document(document_content: str) -> dict:\n    \"\"\"Analyzes the content of a legal document.\n\n    :param document_content: The content of the legal document.\n    :return:\n        dict: A dictionary containing analysis results with the following keys:\n            - key_terms (list[str]): List of key terms.\n            - key_clauses (list[str]): List of key clauses.\"\"\"\n    pass\ndef identify_key_information(text: str) -> list:\n    \"\"\"Identifies key information from a given text.\n\n    :param text: The input text for analysis.\n    :return: A list of key information extracted from the text.\"\"\"\n    pass\n", "function_schema_json": [{"name": "extract_clauses_from_pdf", "description": "Extracts specific clauses from a PDF document based on provided keywords.", "parameters": {"type": "object", "properties": {"pdf_path": {"type": "string", "description": "The path to the PDF document."}, "keywords": {"type": "array", "description": "A list of keywords to search for in the document."}}, "required": ["pdf_path", "keywords"], "additionalProperties": false}}, {"name": "process_legal_document", "description": "Processes a legal document and prepares it for analysis.", "parameters": {"type": "object", "properties": {"document_path": {"type": "string", "description": "The path to the legal document."}}, "required": ["document_path"], "additionalProperties": false}}, {"name": "analyze_legal_document", "description": "Analyzes the content of a legal document.", "parameters": {"type": "object", "properties": {"document_content": {"type": "string", "description": "The content of the legal document."}}, "required": ["document_content"], "additionalProperties": false}}, {"name": "identify_key_information", "description": "Identifies key information from a given text.", "parameters": {"type": "object", "properties": {"text": {"type": "string", "description": "The input text for analysis."}}, "required": ["text"], "additionalProperties": false}}], "mock_functions": "def extract_clauses_from_pdf(pdf_path: str, keywords: list) -> list:\n    \"\"\"\n    Extracts specific clauses from a PDF document based on provided keywords.\n\n    :param pdf_path: The path to the PDF document.\n    :param keywords: A list of keywords to search for in the document.\n    :return: A list of strings, where each string represents an extracted clause.\n    :raises FileNotFoundError: If the PDF file is not found.\n    :raises ValueError: If keywords list is empty.\n    \"\"\"\n    if not keywords:\n        raise ValueError(\"Keywords list cannot be empty.\")\n\n    if pdf_path == \"Contract_Agreement_2023.pdf\":\n        mock_clauses = []\n        if \"dispute\" in keywords:\n            mock_clauses.append(\"Clause regarding dispute resolution\")\n        if \"payment\" in keywords:\n            mock_clauses.append(\"Clause about payment terms\")\n\n        return mock_clauses\n    else:\n        raise FileNotFoundError(f\"File not found: {pdf_path}\")\ndef process_legal_document(document_path: str) -> str:\n    \"\"\"\n    Processes a legal document and prepares it for analysis.\n\n    :param document_path: The path to the legal document.\n    :return: A string representing the processed document content.\n    :raises FileNotFoundError: If the document is not found.\n    \"\"\"\n    if document_path == \"Contract_Agreement_2023.pdf\":\n        return \"Processed document content\"\n    else:\n        raise FileNotFoundError(f\"File not found: {document_path}\")\ndef analyze_legal_document(document_content: str) -> dict:\n    \"\"\"\n    Analyzes the content of a legal document.\n\n    :param document_content: The content of the legal document.\n    :return:\n        dict: A dictionary containing analysis results with the following keys:\n            - key_terms (list[str]): List of key terms.\n            - key_clauses (list[str]): List of key clauses.\n    \"\"\"\n\n    if document_content == \"Processed document content\":\n        return {\n            \"key_terms\": [\"contract\", \"dispute\", \"agreement\"],\n            \"key_clauses\": [\"Clause 1\", \"Clause 2\"]\n        }\n    return {}\ndef identify_key_information(text: str) -> list:\n    \"\"\"\n    Identifies key information from a given text.\n    \n    :param text: The input text for analysis.\n    :return: A list of key information extracted from the text.\n    \"\"\"\n    # Mock logic: Extracts keywords based on simple regex matching.\n    keywords = re.findall(r'[A-Za-z]+', text)\n    return keywords", "user_query": "Can you extract clauses from Contract_Agreement_2023.pdf that contain the keyword \"dispute\"?", "checklist": {"functions": ["extract_clauses_from_pdf"], "values": [["Clause regarding dispute resolution"]]}}
{"difficulty": "easy", "function_schema_python": "def extract_data_from_pdf(pdf_path: str, data_points: list) -> dict:\n    \"\"\"Extracts specified data points from a PDF document.\n\n    :param pdf_path: Path to the PDF file.\n    :param data_points: A list of data points to extract (e.g., [\"revenue\", \"expenses\"]).\n    :return: \n        dict: A dictionary containing the extracted data points and their values.\n             For example: {\"revenue\": 1000000, \"expenses\": 500000}\n    :raises FileNotFoundError: If the PDF file is not found.\n    :raises ValueError: If any of the specified data points are not found in the PDF.\"\"\"\n    pass\ndef update_financial_models(financial_data: dict) -> bool:\n    \"\"\"Updates financial models with the extracted data.\n\n    :param financial_data: A dictionary containing the financial data to update the model with.\n                          The dictionary should contain keys like \"revenue\", \"expenses\", \"profit margins\".\n    :return: True if the models were updated successfully, False otherwise.\n    :raises ValueError: If the input data is invalid or missing required keys.\"\"\"\n    pass\ndef parse_pdf_with_financepro(pdf_path: str) -> str:\n    \"\"\"Parses a PDF document using FinancePro.\n\n    :param pdf_path: The path to the PDF file.\n    :return: A string indicating success or failure.\n    :raises Exception: If an error occurs during parsing.\"\"\"\n    pass\n", "function_schema_json": [{"name": "extract_data_from_pdf", "description": "Extracts specified data points from a PDF document.", "parameters": {"type": "object", "properties": {"pdf_path": {"type": "string", "description": "Path to the PDF file."}, "data_points": {"type": "array", "description": "A list of data points to extract (e.g., [\"revenue\", \"expenses\"])."}}, "required": ["pdf_path", "data_points"], "additionalProperties": false}}, {"name": "update_financial_models", "description": "Updates financial models with the extracted data.", "parameters": {"type": "object", "properties": {"financial_data": {"type": "object", "description": "A dictionary containing the financial data to update the model with."}}, "required": ["financial_data"], "additionalProperties": false}}, {"name": "parse_pdf_with_financepro", "description": "Parses a PDF document using FinancePro.", "parameters": {"type": "object", "properties": {"pdf_path": {"type": "string", "description": "The path to the PDF file."}}, "required": ["pdf_path"], "additionalProperties": false}}], "mock_functions": "def extract_data_from_pdf(pdf_path: str, data_points: list) -> dict:\n    \"\"\"\n    Extracts specified data points from a PDF document.\n\n    :param pdf_path: Path to the PDF file.\n    :param data_points: A list of data points to extract (e.g., [\"revenue\", \"expenses\"]).\n    :return: \n        dict: A dictionary containing the extracted data points and their values.\n             For example: {\"revenue\": 1000000, \"expenses\": 500000}\n    :raises FileNotFoundError: If the PDF file is not found.\n    :raises ValueError: If any of the specified data points are not found in the PDF.\n    \"\"\"\n    if pdf_path == \"Q3_Financial_Report_2023.pdf\":\n        if all(item in [\"revenue\", \"expenses\", \"profit margins\"] for item in data_points):\n            return {\"revenue\": 1000000, \"expenses\": 500000, \"profit margins\": 0.5}\n        else:\n            raise ValueError(\"Not all data points found in the PDF.\")\n    else:\n        raise FileNotFoundError(\"PDF file not found.\")\ndef update_financial_models(financial_data: dict) -> bool:\n    \"\"\"\n    Updates financial models with the extracted data.\n\n    :param financial_data: A dictionary containing the financial data to update the model with.\n                          The dictionary should contain keys like \"revenue\", \"expenses\", \"profit margins\".\n    :return: True if the models were updated successfully, False otherwise.\n    :raises ValueError: If the input data is invalid or missing required keys.\n    \"\"\"\n    if financial_data and all(key in financial_data for key in [\"revenue\", \"expenses\", \"profit margins\"]):\n        if isinstance(financial_data[\"revenue\"], (int, float)) and \\\n           isinstance(financial_data[\"expenses\"], (int, float)) and \\\n           isinstance(financial_data[\"profit margins\"], (int, float)):\n            return True\n        else:\n            raise ValueError(\"Invalid data types in financial_data\")\n\n    else:\n        raise ValueError(\"Invalid or missing data in financial_data\")\ndef parse_pdf_with_financepro(pdf_path: str) -> str:\n    \"\"\"\n    Parses a PDF document using FinancePro.\n\n    :param pdf_path: The path to the PDF file.\n    :return: A string indicating success or failure.\n    :raises Exception: If an error occurs during parsing.\n    \"\"\"\n    if pdf_path == \"Q3_Financial_Report_2023.pdf\":\n        return \"PDF parsed successfully.\"\n    else:\n        raise FileNotFoundError(\"PDF file not found.\")", "user_query": "Can you parse the Q3_Financial_Report_2023.pdf file with FinancePro?", "checklist": {"functions": ["parse_pdf_with_financepro"], "values": ["PDF parsed successfully."]}}
{"difficulty": "easy", "function_schema_python": "def initialize_scraper(urls: list[str]) -> dict:\n    \"\"\"Initializes a scraper for multiple URLs.\n\n    :param urls: List of URLs to scrape.\n    :return: Dictionary containing scraper configurations and status.\n    :raises ValueError: If URLs list is empty or contains invalid URLs.\"\"\"\n    pass\ndef extract_content(url: str) -> dict:\n    \"\"\"Extracts main headings, subheadings, and body text from a webpage.\n\n    :param url: URL of the webpage to scrape.\n    :return: Dictionary containing extracted content.\n    :raises ValueError: If URL is invalid or content cannot be extracted.\"\"\"\n    pass\ndef format_article_content(contents: list[dict]) -> dict:\n    \"\"\"Formats extracted content into a structured article format.\n\n    :param contents: List of dictionaries containing extracted content from different URLs.\n    :return: Dictionary containing formatted article content.\n    :raises ValueError: If content format is invalid.\"\"\"\n    pass\n", "function_schema_json": [{"name": "initialize_scraper", "description": "Initializes a scraper for multiple URLs.", "parameters": {"type": "object", "properties": {"urls": {"type": "array", "items": {"type": "string"}, "description": "List of URLs to scrape."}}, "required": ["urls"], "additionalProperties": false}}, {"name": "extract_content", "description": "Extracts main headings, subheadings, and body text from a webpage.", "parameters": {"type": "object", "properties": {"url": {"type": "string", "description": "URL of the webpage to scrape."}}, "required": ["url"], "additionalProperties": false}}, {"name": "format_article_content", "description": "Formats extracted content into a structured article format.", "parameters": {"type": "object", "properties": {"contents": {"type": "array", "items": {"type": "object"}, "description": "List of dictionaries containing extracted content from different URLs."}}, "required": ["contents"], "additionalProperties": false}}], "mock_functions": "def initialize_scraper(urls: list[str]) -> dict:\n    \"\"\"\n    Initializes a scraper for multiple URLs.\n    \n    :param urls: List of URLs to scrape.\n    :return: Dictionary containing scraper configurations and status.\n    :raises ValueError: If URLs list is empty or contains invalid URLs.\n    \"\"\"\n    if not urls or not all(url.startswith(('http://', 'https://')) for url in urls):\n        raise ValueError(\"Valid URLs must be provided\")\n    \n    return {\n        \"status\": \"initialized\",\n        \"urls_count\": len(urls),\n        \"configs\": {\"user_agent\": \"Mozilla/5.0\", \"timeout\": 30}\n    }\ndef extract_content(url: str) -> dict:\n    \"\"\"\n    Extracts main headings, subheadings, and body text from a webpage.\n    \n    :param url: URL of the webpage to scrape.\n    :return: Dictionary containing extracted content.\n    :raises ValueError: If URL is invalid or content cannot be extracted.\n    \"\"\"\n    if not url.startswith(('http://', 'https://')):\n        raise ValueError(\"Invalid URL provided\")\n    \n    mock_content = {\n        \"headings\": [\"Latest Web Technologies 2023\", \"Frontend Frameworks\"],\n        \"subheadings\": [\"React Updates\", \"Vue.js Evolution\"],\n        \"body_text\": \"The web development landscape continues to evolve...\",\n        \"timestamp\": \"2023-08-20\"\n    }\n    return mock_content\ndef format_article_content(contents: list[dict]) -> dict:\n    \"\"\"\n    Formats extracted content into a structured article format.\n    \n    :param contents: List of dictionaries containing extracted content from different URLs.\n    :return: Dictionary containing formatted article content.\n    :raises ValueError: If content format is invalid.\n    \"\"\"\n    if not contents or not all(isinstance(c, dict) for c in contents):\n        raise ValueError(\"Invalid content format\")\n    \n    return {\n        \"title\": \"Web Technologies Overview\",\n        \"sections\": [\n            {\n                \"heading\": c[\"headings\"][0],\n                \"subheadings\": c[\"subheadings\"],\n                \"content\": c[\"body_text\"]\n            } for c in contents\n        ],\n        \"sources\": [f\"Source {i+1}\" for i in range(len(contents))],\n        \"last_updated\": \"2023-08-20\"\n    }", "user_query": "Could you initialize a scraper for [\"https://techcrunch.com/web-tech\", \"https://wired.com/web-future\", \"https://techradar.com/web-trends\"]?", "checklist": {"functions": ["initialize_scraper"], "values": [{"status": "initialized", "urls_count": 3, "configs": {"user_agent": "Mozilla/5.0", "timeout": 30}}]}}
{"difficulty": "easy", "function_schema_python": "def scrape_product_data(url: str) -> dict:\n    \"\"\"Scrapes product information from a given e-commerce URL.\n\n    :param url: The URL of the e-commerce product page.\n    :return: Dictionary containing product information with keys:\n        - product_name (str): Name of the product\n        - price (float): Price of the product\n        - review_count (int): Number of customer reviews\n    :raises ValueError: If URL is invalid or empty\"\"\"\n    pass\ndef process_multiple_urls(urls: list) -> list:\n    \"\"\"Processes multiple URLs to extract product data.\n\n    :param urls: List of e-commerce product URLs\n    :return: List of dictionaries containing product data\n    :raises ValueError: If URLs list is empty\"\"\"\n    pass\ndef export_to_spreadsheet(data: list, filename: str) -> bool:\n    \"\"\"Exports collected product data to a spreadsheet.\n\n    :param data: List of dictionaries containing product information\n    :param filename: Name of the output spreadsheet file\n    :return: True if export successful, False otherwise\n    :raises ValueError: If data is empty or filename is invalid\"\"\"\n    pass\n", "function_schema_json": [{"name": "scrape_product_data", "description": "Scrapes product information from a given e-commerce URL.", "parameters": {"type": "object", "properties": {"url": {"type": "string", "description": "The URL of the e-commerce product page."}}, "required": ["url"], "additionalProperties": false}}, {"name": "process_multiple_urls", "description": "Processes multiple URLs to extract product data.", "parameters": {"type": "object", "properties": {"urls": {"type": "array", "description": "List of e-commerce product URLs"}}, "required": ["urls"], "additionalProperties": false}}, {"name": "export_to_spreadsheet", "description": "Exports collected product data to a spreadsheet.", "parameters": {"type": "object", "properties": {"data": {"type": "array", "description": "List of dictionaries containing product information"}, "filename": {"type": "string", "description": "Name of the output spreadsheet file"}}, "required": ["data", "filename"], "additionalProperties": false}}], "mock_functions": "def scrape_product_data(url: str) -> dict:\n    \"\"\"\n    Scrapes product information from a given e-commerce URL.\n    \n    :param url: The URL of the e-commerce product page.\n    :return: Dictionary containing product information with keys:\n        - product_name (str): Name of the product\n        - price (float): Price of the product\n        - review_count (int): Number of customer reviews\n    :raises ValueError: If URL is invalid or empty\n    \"\"\"\n    if not url or not url.startswith('http'):\n        raise ValueError(\"Invalid URL provided\")\n    \n    if 'amazon.com' in url.lower():\n        return {\n            \"product_name\": \"Wireless Headphones Pro\",\n            \"price\": 129.99,\n            \"review_count\": 1250\n        }\n    return {}\ndef process_multiple_urls(urls: list) -> list:\n    \"\"\"\n    Processes multiple URLs to extract product data.\n    \n    :param urls: List of e-commerce product URLs\n    :return: List of dictionaries containing product data\n    :raises ValueError: If URLs list is empty\n    \"\"\"\n    if not urls or not isinstance(urls, list):\n        raise ValueError(\"Must provide a non-empty list of URLs\")\n    \n    if len(urls) > 0:\n        return [\n            {\n                \"product_name\": \"Wireless Headphones Pro\",\n                \"price\": 129.99,\n                \"review_count\": 1250\n            },\n            {\n                \"product_name\": \"Smart Watch X2\",\n                \"price\": 199.99,\n                \"review_count\": 856\n            }\n        ]\n    return []\ndef export_to_spreadsheet(data: list, filename: str) -> bool:\n    \"\"\"\n    Exports collected product data to a spreadsheet.\n    \n    :param data: List of dictionaries containing product information\n    :param filename: Name of the output spreadsheet file\n    :return: True if export successful, False otherwise\n    :raises ValueError: If data is empty or filename is invalid\n    \"\"\"\n    if not data or not filename:\n        raise ValueError(\"Data and filename must be provided\")\n    \n    if isinstance(data, list) and filename.endswith('.csv'):\n        return True\n    return False", "user_query": "Can you scrape product data from https://www.amazon.com/some-product?", "checklist": {"functions": ["scrape_product_data"], "values": [{"product_name": "Wireless Headphones Pro", "price": 129.99, "review_count": 1250}]}}
{"difficulty": "easy", "function_schema_python": "def scan_network_vulnerabilities(network_range: str, scan_depth: str) -> dict:\n    \"\"\"Performs a network vulnerability scan using VulnGuard AI.\n\n    :param network_range: CIDR notation of network range to scan (e.g., \"192.168.1.0/24\")\n    :param scan_depth: Scanning depth level (\"standard\", \"deep\", \"quick\")\n    :return: Dictionary containing scan results\n        - vulnerabilities (list[dict]): List of found vulnerabilities\n            - severity (str): Vulnerability severity level\n            - description (str): Description of vulnerability\n            - affected_host (str): IP of affected host\n        - scan_duration (str): Duration of scan\n        - total_hosts (int): Number of hosts scanned\n    :raises ValueError: If network range is invalid or scan depth is not recognized\"\"\"\n    pass\ndef analyze_web_application(url: str, auth_token: str) -> dict:\n    \"\"\"Analyzes a web application for security vulnerabilities.\n\n    :param url: Target web application URL\n    :param auth_token: Optional authentication token for authenticated scanning\n    :return: Dictionary containing analysis results\n        - vulnerabilities (list[dict]): List of found vulnerabilities\n            - type (str): Vulnerability type\n            - risk_level (str): Risk level\n            - description (str): Detailed description\n        - scan_coverage (float): Percentage of application covered\n        - recommendations (list[str]): List of security recommendations\n    :raises ValueError: If URL is invalid\"\"\"\n    pass\ndef prioritize_vulnerabilities(scan_results: dict, risk_threshold: float) -> dict:\n    \"\"\"Prioritizes discovered vulnerabilities based on risk assessment.\n\n    :param scan_results: Dictionary containing vulnerability scan results\n    :param risk_threshold: Minimum risk score to include (0.0 to 1.0)\n    :return: Dictionary containing prioritized vulnerabilities\n        - critical (list[dict]): Critical priority vulnerabilities\n        - high (list[dict]): High priority vulnerabilities\n        - medium (list[dict]): Medium priority vulnerabilities\n        - low (list[dict]): Low priority vulnerabilities\n    :raises ValueError: If risk_threshold is outside valid range\"\"\"\n    pass\n", "function_schema_json": [{"name": "scan_network_vulnerabilities", "description": "Performs a network vulnerability scan using VulnGuard AI.", "parameters": {"type": "object", "properties": {"network_range": {"type": "string", "description": "CIDR notation of network range to scan (e.g., \"192.168.1.0/24\")"}, "scan_depth": {"type": "string", "description": "Scanning depth level (\"standard\", \"deep\", \"quick\")"}}, "required": ["network_range", "scan_depth"], "additionalProperties": false}}, {"name": "analyze_web_application", "description": "Analyzes a web application for security vulnerabilities.", "parameters": {"type": "object", "properties": {"url": {"type": "string", "description": "Target web application URL"}, "auth_token": {"type": "string", "description": "Optional authentication token for authenticated scanning"}}, "required": ["url", "auth_token"], "additionalProperties": false}}, {"name": "prioritize_vulnerabilities", "description": "Prioritizes discovered vulnerabilities based on risk assessment.", "parameters": {"type": "object", "properties": {"scan_results": {"type": "object", "description": "Dictionary containing vulnerability scan results"}, "risk_threshold": {"type": "number", "description": "Minimum risk score to include (0.0 to 1.0)"}}, "required": ["scan_results", "risk_threshold"], "additionalProperties": false}}], "mock_functions": "def scan_network_vulnerabilities(network_range: str, scan_depth: str = \"standard\") -> dict:\n    \"\"\"\n    Performs a network vulnerability scan using VulnGuard AI.\n    \n    :param network_range: CIDR notation of network range to scan (e.g., \"192.168.1.0/24\")\n    :param scan_depth: Scanning depth level (\"standard\", \"deep\", \"quick\")\n    :return: Dictionary containing scan results\n        - vulnerabilities (list[dict]): List of found vulnerabilities\n            - severity (str): Vulnerability severity level\n            - description (str): Description of vulnerability\n            - affected_host (str): IP of affected host\n        - scan_duration (str): Duration of scan\n        - total_hosts (int): Number of hosts scanned\n    :raises ValueError: If network range is invalid or scan depth is not recognized\n    \"\"\"\n    if not network_range or not isinstance(network_range, str):\n        raise ValueError(\"Invalid network range\")\n    \n    if scan_depth not in [\"standard\", \"deep\", \"quick\"]:\n        raise ValueError(\"Invalid scan depth\")\n        \n    if network_range == \"192.168.1.0/24\":\n        return {\n            \"vulnerabilities\": [\n                {\n                    \"severity\": \"high\",\n                    \"description\": \"Open SSH port with weak encryption\",\n                    \"affected_host\": \"192.168.1.10\"\n                }\n            ],\n            \"scan_duration\": \"10 minutes\",\n            \"total_hosts\": 254\n        }\n    return {}\ndef analyze_web_application(url: str, auth_token: str = None) -> dict:\n    \"\"\"\n    Analyzes a web application for security vulnerabilities.\n    \n    :param url: Target web application URL\n    :param auth_token: Optional authentication token for authenticated scanning\n    :return: Dictionary containing analysis results\n        - vulnerabilities (list[dict]): List of found vulnerabilities\n            - type (str): Vulnerability type\n            - risk_level (str): Risk level\n            - description (str): Detailed description\n        - scan_coverage (float): Percentage of application covered\n        - recommendations (list[str]): List of security recommendations\n    :raises ValueError: If URL is invalid\n    \"\"\"\n    if not url.startswith((\"http://\", \"https://\")):\n        raise ValueError(\"Invalid URL format\")\n    \n    if url == \"https://cybtech.internal/app\":\n        return {\n            \"vulnerabilities\": [\n                {\n                    \"type\": \"SQL Injection\",\n                    \"risk_level\": \"critical\",\n                    \"description\": \"Potential SQL injection in login form\"\n                }\n            ],\n            \"scan_coverage\": 95.5,\n            \"recommendations\": [\n                \"Implement input validation\",\n                \"Update SQL query parameterization\"\n            ]\n        }\n    return {}\ndef prioritize_vulnerabilities(scan_results: dict, risk_threshold: float = 0.7) -> dict:\n    \"\"\"\n    Prioritizes discovered vulnerabilities based on risk assessment.\n    \n    :param scan_results: Dictionary containing vulnerability scan results\n    :param risk_threshold: Minimum risk score to include (0.0 to 1.0)\n    :return: Dictionary containing prioritized vulnerabilities\n        - critical (list[dict]): Critical priority vulnerabilities\n        - high (list[dict]): High priority vulnerabilities\n        - medium (list[dict]): Medium priority vulnerabilities\n        - low (list[dict]): Low priority vulnerabilities\n    :raises ValueError: If risk_threshold is outside valid range\n    \"\"\"\n    if not 0.0 <= risk_threshold <= 1.0:\n        raise ValueError(\"Risk threshold must be between 0.0 and 1.0\")\n    \n    if isinstance(scan_results, dict) and \"vulnerabilities\" in scan_results:\n        return {\n            \"critical\": [\n                {\n                    \"issue\": \"SQL Injection\",\n                    \"risk_score\": 0.95,\n                    \"remediation_priority\": 1\n                }\n            ],\n            \"high\": [\n                {\n                    \"issue\": \"Weak SSH Encryption\",\n                    \"risk_score\": 0.85,\n                    \"remediation_priority\": 2\n                }\n            ],\n            \"medium\": [],\n            \"low\": []\n        }\n    return {}", "user_query": "Can you scan the network range \"192.168.1.0/24\" for vulnerabilities?", "checklist": {"functions": ["scan_network_vulnerabilities"], "values": [{"vulnerabilities": [{"severity": "high", "description": "Open SSH port with weak encryption", "affected_host": "192.168.1.10"}], "scan_duration": "10 minutes", "total_hosts": 254}]}}
{"difficulty": "easy", "function_schema_python": "def filter_logs_by_ip(logs: str, ip_range: str) -> str:\n    \"\"\"Filters log entries to include only those from a specific IP range.\n\n    :param logs: The raw log data as a string.\n    :param ip_range: The IP range to filter by (e.g., \"104.20.0.0/16\").\n    :return: Filtered log data as a string.\n    :raises ValueError: If the IP range is invalid.\"\"\"\n    pass\ndef analyze_login_attempts(filtered_logs: str, time_window: str) -> Dict[str, int]:\n    \"\"\"Analyzes filtered log data to identify failed login attempts within a time window.\n\n    :param filtered_logs: The filtered log data.\n    :param time_window: The time window to analyze (e.g., \"last hour\").\n    :return: \n        dict: A dictionary with IP addresses as keys and the number of failed login attempts as values.\n            - ip_address (str): Source IP Address.\n            - failed_attempts (int): Number of failed logins.\n    :raises ValueError: If the time window is invalid.\"\"\"\n    pass\ndef generate_report(analysis_results: Dict[str, int]) -> str:\n    \"\"\"Generates a report summarizing attack patterns and failed login attempts.\n\n    :param analysis_results:  A dictionary containing the analysis results.\n    :return: A string representing the generated report.\"\"\"\n    pass\n", "function_schema_json": [{"name": "filter_logs_by_ip", "description": "Filters log entries to include only those from a specific IP range.", "parameters": {"type": "object", "properties": {"logs": {"type": "string", "description": "The raw log data as a string."}, "ip_range": {"type": "string", "description": "The IP range to filter by (e.g., \"104.20.0.0/16\")."}}, "required": ["logs", "ip_range"], "additionalProperties": false}}, {"name": "analyze_login_attempts", "description": "Analyzes filtered log data to identify failed login attempts within a time window.", "parameters": {"type": "object", "properties": {"filtered_logs": {"type": "string", "description": "The filtered log data."}, "time_window": {"type": "string", "description": "The time window to analyze (e.g., \"last hour\")."}}, "required": ["filtered_logs", "time_window"], "additionalProperties": false}}, {"name": "generate_report", "description": "Generates a report summarizing attack patterns and failed login attempts.", "parameters": {"type": "object", "properties": {"analysis_results": {"type": "object", "description": "A dictionary containing the analysis results."}}, "required": ["analysis_results"], "additionalProperties": false}}], "mock_functions": "def filter_logs_by_ip(logs: str, ip_range: str) -> str:\n    \"\"\"\n    Filters log entries to include only those from a specific IP range.\n\n    :param logs: The raw log data as a string.\n    :param ip_range: The IP range to filter by (e.g., \"104.20.0.0/16\").\n    :return: Filtered log data as a string.\n    :raises ValueError: If the IP range is invalid.\n    \"\"\"\n    if not ip_range:\n        raise ValueError(\"IP range cannot be empty.\")\n    if ip_range == \"104.20.0.0/16\":\n        # Mock filtering logic\n        filtered_logs = \"Filtered logs for 104.20.0.0/16\"\n        return filtered_logs\n    return \"\"\ndef analyze_login_attempts(filtered_logs: str, time_window: str) -> Dict[str, int]:\n    \"\"\"\n    Analyzes filtered log data to identify failed login attempts within a time window.\n\n    :param filtered_logs: The filtered log data.\n    :param time_window: The time window to analyze (e.g., \"last hour\").\n    :return: \n        dict: A dictionary with IP addresses as keys and the number of failed login attempts as values.\n            - ip_address (str): Source IP Address.\n            - failed_attempts (int): Number of failed logins.\n    :raises ValueError: If the time window is invalid.\n    \"\"\"\n    if not time_window:\n        raise ValueError(\"Time window cannot be empty.\")\n\n    if filtered_logs == \"Filtered logs for 104.20.0.0/16\" and time_window == \"last hour\":\n        return {\n            \"104.20.1.1\": 120,\n            \"104.20.2.2\": 53,\n            \"104.20.3.3\": 87\n        }\n    return {}\ndef generate_report(analysis_results: Dict[str, int]) -> str:\n    \"\"\"\n    Generates a report summarizing attack patterns and failed login attempts.\n\n    :param analysis_results:  A dictionary containing the analysis results.\n    :return: A string representing the generated report.\n    \"\"\"\n    if analysis_results:\n        report = \"Attack Pattern Report:\\n\"\n        for ip, count in analysis_results.items():\n            report += f\"IP: {ip}, Failed Attempts: {count}\\n\"\n        return report\n    return \"\"", "user_query": "Can you filter the logs by the IP range 104.20.0.0/16?", "checklist": {"functions": ["filter_logs_by_ip"], "values": ["Filtered logs for 104.20.0.0/16"]}}
{"difficulty": "easy", "function_schema_python": "def analyze_network_traffic(ip_address: str, interface: str) -> dict:\n    \"\"\"Analyzes network traffic for a specific IP address using Wireshark-like functionality.\n\n    :param ip_address: The IP address to analyze.\n    :param interface: The network interface to monitor.\n    :return: Dictionary containing traffic analysis results:\n        - packet_count (int): Number of packets detected\n        - protocols (list): List of protocols used\n        - suspicious_patterns (list): List of suspicious patterns\n    :raises ValueError: If IP address format is invalid.\"\"\"\n    pass\ndef scan_ports(target_ip: str, port_range: str) -> dict:\n    \"\"\"Performs port scanning using nmap-like functionality.\n\n    :param target_ip: The IP address to scan.\n    :param port_range: Range of ports to scan (e.g., \"1-1000\").\n    :return: Dictionary containing scan results:\n        - open_ports (list): List of open ports\n        - services (dict): Dictionary mapping ports to services\n    :raises ValueError: If IP address or port range is invalid.\"\"\"\n    pass\ndef calculate_threat_score(ip_address: str, traffic_data: dict, scan_results: dict) -> float:\n    \"\"\"Calculates threat score based on analysis results.\n\n    :param ip_address: The IP address being analyzed.\n    :param traffic_data: Network traffic analysis results.\n    :param scan_results: Port scan results.\n    :return: Threat score between 0 and 1 (1 being highest threat).\n    :raises ValueError: If input data is invalid.\"\"\"\n    pass\ndef generate_mitigation_actions(threat_score: float) -> list:\n    \"\"\"Generates recommended actions based on threat score.\n\n    :param threat_score: Calculated threat score (0-1).\n    :return: List of recommended actions.\n    :raises ValueError: If threat score is not between 0 and 1.\"\"\"\n    pass\n", "function_schema_json": [{"name": "analyze_network_traffic", "description": "Analyzes network traffic for a specific IP address using Wireshark-like functionality.", "parameters": {"type": "object", "properties": {"ip_address": {"type": "string", "description": "The IP address to analyze."}, "interface": {"type": "string", "description": "The network interface to monitor."}}, "required": ["ip_address", "interface"], "additionalProperties": false}}, {"name": "scan_ports", "description": "Performs port scanning using nmap-like functionality.", "parameters": {"type": "object", "properties": {"target_ip": {"type": "string", "description": "The IP address to scan."}, "port_range": {"type": "string", "description": "Range of ports to scan (e.g., \"1-1000\")."}}, "required": ["target_ip", "port_range"], "additionalProperties": false}}, {"name": "calculate_threat_score", "description": "Calculates threat score based on analysis results.", "parameters": {"type": "object", "properties": {"ip_address": {"type": "string", "description": "The IP address being analyzed."}, "traffic_data": {"type": "object", "description": "Network traffic analysis results."}, "scan_results": {"type": "object", "description": "Port scan results."}}, "required": ["ip_address", "traffic_data", "scan_results"], "additionalProperties": false}}, {"name": "generate_mitigation_actions", "description": "Generates recommended actions based on threat score.", "parameters": {"type": "object", "properties": {"threat_score": {"type": "number", "description": "Calculated threat score (0-1)."}}, "required": ["threat_score"], "additionalProperties": false}}], "mock_functions": "def analyze_network_traffic(ip_address: str, interface: str = \"eth0\") -> dict:\n    \"\"\"\n    Analyzes network traffic for a specific IP address using Wireshark-like functionality.\n    \n    :param ip_address: The IP address to analyze.\n    :param interface: The network interface to monitor.\n    :return: Dictionary containing traffic analysis results:\n        - packet_count (int): Number of packets detected\n        - protocols (list): List of protocols used\n        - suspicious_patterns (list): List of suspicious patterns\n    :raises ValueError: If IP address format is invalid.\n    \"\"\"\n    if not ip_address.startswith(\"192.168.\"):\n        raise ValueError(\"Invalid IP address format\")\n    \n    if ip_address == \"192.168.1.100\":\n        return {\n            \"packet_count\": 1500,\n            \"protocols\": [\"HTTP\", \"SSH\", \"DNS\"],\n            \"suspicious_patterns\": [\"Port scanning\", \"Multiple failed login attempts\"]\n        }\n    return {\"packet_count\": 0, \"protocols\": [], \"suspicious_patterns\": []}\ndef scan_ports(target_ip: str, port_range: str = \"1-1000\") -> dict:\n    \"\"\"\n    Performs port scanning using nmap-like functionality.\n    \n    :param target_ip: The IP address to scan.\n    :param port_range: Range of ports to scan (e.g., \"1-1000\").\n    :return: Dictionary containing scan results:\n        - open_ports (list): List of open ports\n        - services (dict): Dictionary mapping ports to services\n    :raises ValueError: If IP address or port range is invalid.\n    \"\"\"\n    if target_ip == \"192.168.1.100\":\n        return {\n            \"open_ports\": [22, 80, 443, 3389],\n            \"services\": {\n                \"22\": \"SSH\",\n                \"80\": \"HTTP\",\n                \"443\": \"HTTPS\",\n                \"3389\": \"RDP\"\n            }\n        }\n    return {\"open_ports\": [], \"services\": {}}\ndef calculate_threat_score(ip_address: str, traffic_data: dict, scan_results: dict) -> float:\n    \"\"\"\n    Calculates threat score based on analysis results.\n    \n    :param ip_address: The IP address being analyzed.\n    :param traffic_data: Network traffic analysis results.\n    :param scan_results: Port scan results.\n    :return: Threat score between 0 and 1 (1 being highest threat).\n    :raises ValueError: If input data is invalid.\n    \"\"\"\n    if (ip_address == \"192.168.1.100\" and \n        traffic_data.get(\"suspicious_patterns\") and \n        scan_results.get(\"open_ports\")):\n        return 0.85\n    return 0.1\ndef generate_mitigation_actions(threat_score: float) -> list:\n    \"\"\"\n    Generates recommended actions based on threat score.\n    \n    :param threat_score: Calculated threat score (0-1).\n    :return: List of recommended actions.\n    :raises ValueError: If threat score is not between 0 and 1.\n    \"\"\"\n    if not 0 <= threat_score <= 1:\n        raise ValueError(\"Threat score must be between 0 and 1\")\n    \n    if threat_score > 0.8:\n        return [\n            \"Block IP address immediately\",\n            \"Enable enhanced monitoring\",\n            \"Update firewall rules\",\n            \"Notify security team\"\n        ]\n    return [\"Continue monitoring\"]", "user_query": "Please scan the ports for IP 192.168.1.100 and check what services are running.", "checklist": {"functions": ["scan_ports"], "values": [{"open_ports": [22, 80, 443, 3389], "services": {"22": "SSH", "80": "HTTP", "443": "HTTPS", "3389": "RDP"}}]}}
{"difficulty": "easy", "function_schema_python": "def setup_testing_environment(host: str, ports: list) -> dict:\n    \"\"\"Sets up the initial testing environment by configuring network settings and tools.\n\n    :param host: The target host IP address or domain name for the pentest.\n    :param ports: A list of ports to be tested.\n    :return:\n        dict: A dictionary with the following keys:\n            - environment (str): Description of the setup environment.\n            - status (bool): Indicates whether the setup was successful.\n    :raises ValueError: If host or ports are invalid.\"\"\"\n    pass\ndef configure_scapy(filter: str) -> str:\n    \"\"\"Configures the Scapy tool for packet manipulation and analysis.\n\n    :param filter: The BPF filter string to capture specific packets.\n    :return: A string indicating the configuration status and details.\n    :raises ValueError: If the filter is empty or invalid.\"\"\"\n    pass\ndef configure_nmap(target: str, options: str) -> str:\n    \"\"\"Configures the Nmap tool for network scanning.\n\n    :param target: The target IP address or domain name.\n    :param options: The options and parameters for the Nmap scan.\n    :return: A string indicating the configuration status and details.\n    :raises ValueError: If the target or options are invalid or empty.\"\"\"\n    pass\ndef configure_metasploit(module: str, payload: str) -> str:\n    \"\"\"Configures the Metasploit tool for exploiting vulnerabilities.\n\n    :param module: The Metasploit module to be used.\n    :param payload: The payload that will be delivered by the module.\n    :return: A string indicating the configuration status and details.\n    :raises ValueError: If the module or payload is empty.\"\"\"\n    pass\ndef configure_wireshark(interface: str, filter: str) -> str:\n    \"\"\"Configures the Wireshark tool for packet capturing and analysis.\n\n    :param interface: The network interface to capture data from.\n    :param filter: The BPF filter string to capture specific packets.\n    :return: A string indicating the configuration status and details.\n    :raises ValueError: If the interface or filter is empty.\"\"\"\n    pass\ndef configure_burp_suite(target: str, proxy_port: int) -> str:\n    \"\"\"Configures the Burp Suite tool for web application security testing.\n\n    :param target: The target web application URL.\n    :param proxy_port: The port number on which the proxy will listen.\n    :return: A string indicating the configuration status and details.\n    :raises ValueError: If the target URL is empty or proxy_port is not a valid integer.\"\"\"\n    pass\ndef request_client_permissions(contact_name: str, scope_details: str) -> bool:\n    \"\"\"Requests necessary permissions and access from the client for the pentest.\n\n    :param contact_name: The name of the client contact person.\n    :param scope_details: The details of the pentest scope.\n    :return: True if permissions were successfully granted, False otherwise.\n    :raises ValueError: If the contact_name or scope_details are empty or invalid.\"\"\"\n    pass\ndef log_pentest_activity(activity_description: str, timestamp: str) -> str:\n    \"\"\"Logs an activity related to the pentest.\n\n    :param activity_description: A description of the activity performed.\n    :param timestamp: The timestamp at which the activity occurred.\n    :return: A string indicating the log entry details.\n    :raises ValueError: If the activity_description or timestamp is empty.\"\"\"\n    pass\n", "function_schema_json": [{"name": "setup_testing_environment", "description": "Sets up the initial testing environment by configuring network settings and tools.", "parameters": {"type": "object", "properties": {"host": {"type": "string", "description": "The target host IP address or domain name for the pentest."}, "ports": {"type": "array", "description": "A list of ports to be tested."}}, "required": ["host", "ports"], "additionalProperties": false}}, {"name": "configure_scapy", "description": "Configures the Scapy tool for packet manipulation and analysis.", "parameters": {"type": "object", "properties": {"filter": {"type": "string", "description": "The BPF filter string to capture specific packets."}}, "required": ["filter"], "additionalProperties": false}}, {"name": "configure_nmap", "description": "Configures the Nmap tool for network scanning.", "parameters": {"type": "object", "properties": {"target": {"type": "string", "description": "The target IP address or domain name."}, "options": {"type": "string", "description": "The options and parameters for the Nmap scan."}}, "required": ["target", "options"], "additionalProperties": false}}, {"name": "configure_metasploit", "description": "Configures the Metasploit tool for exploiting vulnerabilities.", "parameters": {"type": "object", "properties": {"module": {"type": "string", "description": "The Metasploit module to be used."}, "payload": {"type": "string", "description": "The payload that will be delivered by the module."}}, "required": ["module", "payload"], "additionalProperties": false}}, {"name": "configure_wireshark", "description": "Configures the Wireshark tool for packet capturing and analysis.", "parameters": {"type": "object", "properties": {"interface": {"type": "string", "description": "The network interface to capture data from."}, "filter": {"type": "string", "description": "The BPF filter string to capture specific packets."}}, "required": ["interface", "filter"], "additionalProperties": false}}, {"name": "configure_burp_suite", "description": "Configures the Burp Suite tool for web application security testing.", "parameters": {"type": "object", "properties": {"target": {"type": "string", "description": "The target web application URL."}, "proxy_port": {"type": "integer", "description": "The port number on which the proxy will listen."}}, "required": ["target", "proxy_port"], "additionalProperties": false}}, {"name": "request_client_permissions", "description": "Requests necessary permissions and access from the client for the pentest.", "parameters": {"type": "object", "properties": {"contact_name": {"type": "string", "description": "The name of the client contact person."}, "scope_details": {"type": "string", "description": "The details of the pentest scope."}}, "required": ["contact_name", "scope_details"], "additionalProperties": false}}, {"name": "log_pentest_activity", "description": "Logs an activity related to the pentest.", "parameters": {"type": "object", "properties": {"activity_description": {"type": "string", "description": "A description of the activity performed."}, "timestamp": {"type": "string", "description": "The timestamp at which the activity occurred."}}, "required": ["activity_description", "timestamp"], "additionalProperties": false}}], "mock_functions": "def setup_testing_environment(host: str, ports: list) -> dict:\n    \"\"\"\n    Sets up the initial testing environment by configuring network settings and tools.\n    \n    :param host: The target host IP address or domain name for the pentest.\n    :param ports: A list of ports to be tested.\n    :return:\n        dict: A dictionary with the following keys:\n            - environment (str): Description of the setup environment.\n            - status (bool): Indicates whether the setup was successful.\n    :raises ValueError: If host or ports are invalid.\n    \"\"\"\n    if not host or not isinstance(ports, list) or len(ports) == 0:\n        raise ValueError(\"A valid host and list of ports must be provided.\")\n    return {\n        \"environment\": f\"Testing environment set up for host {host} on ports {', '.join(map(str, ports))}\",\n        \"status\": True\n    }\ndef configure_scapy(filter: str) -> str:\n    \"\"\"\n    Configures the Scapy tool for packet manipulation and analysis.\n    \n    :param filter: The BPF filter string to capture specific packets.\n    :return: A string indicating the configuration status and details.\n    :raises ValueError: If the filter is empty or invalid.\n    \"\"\"\n    if not filter:\n        raise ValueError(\"A valid filter string must be provided.\")\n    return f\"Scapy configured with filter: {filter}\"\ndef configure_nmap(target: str, options: str) -> str:\n    \"\"\"\n    Configures the Nmap tool for network scanning.\n    \n    :param target: The target IP address or domain name.\n    :param options: The options and parameters for the Nmap scan.\n    :return: A string indicating the configuration status and details.\n    :raises ValueError: If the target or options are invalid or empty.\n    \"\"\"\n    if not target or not options:\n        raise ValueError(\"A valid target and options must be provided.\")\n    return f\"Nmap configured for target {target} with options: {options}\"\ndef configure_metasploit(module: str, payload: str) -> str:\n    \"\"\"\n    Configures the Metasploit tool for exploiting vulnerabilities.\n    \n    :param module: The Metasploit module to be used.\n    :param payload: The payload that will be delivered by the module.\n    :return: A string indicating the configuration status and details.\n    :raises ValueError: If the module or payload is empty.\n    \"\"\"\n    if not module or not payload:\n        raise ValueError(\"A valid module and payload must be provided.\")\n    return f\"Metasploit configured with module: {module} and payload: {payload}\"\ndef configure_wireshark(interface: str, filter: str) -> str:\n    \"\"\"\n    Configures the Wireshark tool for packet capturing and analysis.\n    \n    :param interface: The network interface to capture data from.\n    :param filter: The BPF filter string to capture specific packets.\n    :return: A string indicating the configuration status and details.\n    :raises ValueError: If the interface or filter is empty.\n    \"\"\"\n    if not interface or not filter:\n        raise ValueError(\"A valid network interface and filter must be provided.\")\n    return f\"Wireshark configured for interface {interface} with filter: {filter}\"\ndef configure_burp_suite(target: str, proxy_port: int) -> str:\n    \"\"\"\n    Configures the Burp Suite tool for web application security testing.\n    \n    :param target: The target web application URL.\n    :param proxy_port: The port number on which the proxy will listen.\n    :return: A string indicating the configuration status and details.\n    :raises ValueError: If the target URL is empty or proxy_port is not a valid integer.\n    \"\"\"\n    if not target or not isinstance(proxy_port, int) or proxy_port <= 0:\n        raise ValueError(\"A valid target URL and proxy port must be provided.\")\n    return f\"Burp Suite configured for target {target} with proxy port: {proxy_port}\"\ndef request_client_permissions(contact_name: str, scope_details: str) -> bool:\n    \"\"\"\n    Requests necessary permissions and access from the client for the pentest.\n    \n    :param contact_name: The name of the client contact person.\n    :param scope_details: The details of the pentest scope.\n    :return: True if permissions were successfully granted, False otherwise.\n    :raises ValueError: If the contact_name or scope_details are empty or invalid.\n    \"\"\"\n    if not contact_name or not scope_details:\n        raise ValueError(\"A valid contact name and scope details must be provided.\")\n    # Mock logic: Grant permissions for a specific contact and scope.\n    if contact_name.lower() == \"john doe\" and \"financial transactions\" in scope_details:\n        return True\n    return False\ndef log_pentest_activity(activity_description: str, timestamp: str) -> str:\n    \"\"\"\n    Logs an activity related to the pentest.\n    \n    :param activity_description: A description of the activity performed.\n    :param timestamp: The timestamp at which the activity occurred.\n    :return: A string indicating the log entry details.\n    :raises ValueError: If the activity_description or timestamp is empty.\n    \"\"\"\n    if not activity_description or not timestamp:\n        raise ValueError(\"An activity description and timestamp must be provided.\")\n    return f\"Logged activity: {activity_description} at {timestamp}\"", "user_query": "Could you set up a testing environment for fiscalbridge.com with ports [80, 443, 8080]?", "checklist": {"functions": ["setup_testing_environment"], "values": [{"environment": "Testing environment set up for host fiscalbridge.com on ports 80, 443, 8080", "status": true}]}}
{"difficulty": "easy", "function_schema_python": "def ensure_latest_app_version(app_name: str, project_manager: str) -> bool:\n    \"\"\"Ensures that the team has access to the latest version of the mobile app.\n\n    :param app_name: The name of the mobile app.\n    :param project_manager: The name of the project manager overseeing the app's security testing.\n    :return: True if the latest app version is successfully secured, False otherwise.\n    :raises ValueError: If app_name or project_manager is not provided or is invalid.\"\"\"\n    pass\ndef setup_testing_environment(tool_name: str, tester: str) -> bool:\n    \"\"\"Sets up the necessary testing environment for a given security tool.\n\n    :param tool_name: The name of the security tool to be set up.\n    :param tester: The name of the tester setting up the environment.\n    :return: True if the testing environment is set up successfully, False otherwise.\n    :raises ValueError: If tool_name or tester is not provided or is invalid.\"\"\"\n    pass\ndef coordinate_with_development(team: list, project_manager: str) -> dict:\n    \"\"\"Coordinates with the development team to streamline the testing process.\n\n    :param team: A list containing the names of the pentesters involved in the project.\n    :param project_manager: The name of the project manager coordinating with the development team.\n    :return:\n        dict: A dictionary with the following keys:\n            - success (bool): Indicates if the coordination was successful.\n            - notes (str): Any additional notes related to the coordination process.\n    :raises ValueError: If the team list is empty or the project_manager is not provided.\"\"\"\n    pass\ndef document_security_vulnerabilities(app_name: str, vulnerabilities: list) -> dict:\n    \"\"\"Documents the identified security vulnerabilities in a structured format.\n\n    :param app_name: The name of the mobile app being tested.\n    :param vulnerabilities: A list of security vulnerabilities found during testing.\n    :return: \n        dict: A dictionary with the following keys:\n            - app_name (str): The name of the app.\n            - vulnerabilities (list[str]): The list of vulnerabilities.\n    :raises ValueError: If app_name or vulnerabilities list is invalid.\"\"\"\n    pass\ndef provide_mitigation_recommendations(app_name: str, vulnerabilities: list) -> dict:\n    \"\"\"Provides recommendations for mitigating identified security vulnerabilities.\n\n    :param app_name: The name of the mobile app being tested.\n    :param vulnerabilities: A list of security vulnerabilities found during testing.\n    :return:\n        dict: A dictionary with the following keys:\n            - app_name (str): The name of the app.\n            - recommendations (list[str]): The list of mitigation recommendations.\n    :raises ValueError: If app_name or vulnerabilities list is invalid.\"\"\"\n    pass\n", "function_schema_json": [{"name": "ensure_latest_app_version", "description": "Ensures that the team has access to the latest version of the mobile app.", "parameters": {"type": "object", "properties": {"app_name": {"type": "string", "description": "The name of the mobile app."}, "project_manager": {"type": "string", "description": "The name of the project manager overseeing the app's security testing."}}, "required": ["app_name", "project_manager"], "additionalProperties": false}}, {"name": "setup_testing_environment", "description": "Sets up the necessary testing environment for a given security tool.", "parameters": {"type": "object", "properties": {"tool_name": {"type": "string", "description": "The name of the security tool to be set up."}, "tester": {"type": "string", "description": "The name of the tester setting up the environment."}}, "required": ["tool_name", "tester"], "additionalProperties": false}}, {"name": "coordinate_with_development", "description": "Coordinates with the development team to streamline the testing process.", "parameters": {"type": "object", "properties": {"team": {"type": "array", "description": "A list containing the names of the pentesters involved in the project."}, "project_manager": {"type": "string", "description": "The name of the project manager coordinating with the development team."}}, "required": ["team", "project_manager"], "additionalProperties": false}}, {"name": "document_security_vulnerabilities", "description": "Documents the identified security vulnerabilities in a structured format.", "parameters": {"type": "object", "properties": {"app_name": {"type": "string", "description": "The name of the mobile app being tested."}, "vulnerabilities": {"type": "array", "description": "A list of security vulnerabilities found during testing."}}, "required": ["app_name", "vulnerabilities"], "additionalProperties": false}}, {"name": "provide_mitigation_recommendations", "description": "Provides recommendations for mitigating identified security vulnerabilities.", "parameters": {"type": "object", "properties": {"app_name": {"type": "string", "description": "The name of the mobile app being tested."}, "vulnerabilities": {"type": "array", "description": "A list of security vulnerabilities found during testing."}}, "required": ["app_name", "vulnerabilities"], "additionalProperties": false}}], "mock_functions": "def ensure_latest_app_version(app_name: str, project_manager: str) -> bool:\n    \"\"\"\n    Ensures that the team has access to the latest version of the mobile app.\n    \n    :param app_name: The name of the mobile app.\n    :param project_manager: The name of the project manager overseeing the app's security testing.\n    :return: True if the latest app version is successfully secured, False otherwise.\n    :raises ValueError: If app_name or project_manager is not provided or is invalid.\n    \"\"\"\n    # Mock logic: If the app name is \"TechVenture\" and the manager is \"Mia\", return True.\n    if app_name.strip().lower() == \"techventure\" and project_manager.strip().lower() == \"mia\":\n        return True\n    raise ValueError(\"Invalid app name or project manager.\")\ndef setup_testing_environment(tool_name: str, tester: str) -> bool:\n    \"\"\"\n    Sets up the necessary testing environment for a given security tool.\n    \n    :param tool_name: The name of the security tool to be set up.\n    :param tester: The name of the tester setting up the environment.\n    :return: True if the testing environment is set up successfully, False otherwise.\n    :raises ValueError: If tool_name or tester is not provided or is invalid.\n    \"\"\"\n    # Mock logic: If the tool is in the list and tester is part of the \"SecureNet Solutions\", return True.\n    valid_tools = ['scapy', 'nmap', 'metasploit', 'wireshark', 'burp-suite']\n    valid_testers = ['Leo', 'Carmen', 'Tyler', 'Mia']\n    \n    if tool_name.strip().lower() not in valid_tools or tester.strip().lower() not in valid_testers:\n        raise ValueError(\"Invalid tool name or tester.\")\n    return True\ndef coordinate_with_development(team: list, project_manager: str) -> dict:\n    \"\"\"\n    Coordinates with the development team to streamline the testing process.\n    \n    :param team: A list containing the names of the pentesters involved in the project.\n    :param project_manager: The name of the project manager coordinating with the development team.\n    :return:\n        dict: A dictionary with the following keys:\n            - success (bool): Indicates if the coordination was successful.\n            - notes (str): Any additional notes related to the coordination process.\n    :raises ValueError: If the team list is empty or the project_manager is not provided.\n    \"\"\"\n    # Mock logic: If the team list contains valid names and project manager is \"Mia\", return successful coordination.\n    valid_testers = ['Leo', 'Carmen', 'Tyler', 'Mia']\n    \n    if not team or project_manager.strip().lower() != \"mia\" or not all(tester.strip().lower() in valid_testers for tester in team):\n        raise ValueError(\"Invalid team list or project manager.\")\n    return {\n        \"success\": True,\n        \"notes\": \"Coordination successful. Testing can proceed.\"\n    }\ndef document_security_vulnerabilities(app_name: str, vulnerabilities: list) -> dict:\n    \"\"\"\n    Documents the identified security vulnerabilities in a structured format.\n    \n    :param app_name: The name of the mobile app being tested.\n    :param vulnerabilities: A list of security vulnerabilities found during testing.\n    :return: \n        dict: A dictionary with the following keys:\n            - app_name (str): The name of the app.\n            - vulnerabilities (list[str]): The list of vulnerabilities.\n    :raises ValueError: If app_name or vulnerabilities list is invalid.\n    \"\"\"\n    # Mock logic: If the app name is \"TechVenture\" and vulnerabilities list is not empty, return documentation.\n    if app_name.strip().lower() != \"techventure\" or not vulnerabilities:\n        raise ValueError(\"Invalid app name or vulnerabilities list.\")\n    return {\n        \"app_name\": app_name,\n        \"vulnerabilities\": vulnerabilities\n    }\ndef provide_mitigation_recommendations(app_name: str, vulnerabilities: list) -> dict:\n    \"\"\"\n    Provides recommendations for mitigating identified security vulnerabilities.\n    \n    :param app_name: The name of the mobile app being tested.\n    :param vulnerabilities: A list of security vulnerabilities found during testing.\n    :return:\n        dict: A dictionary with the following keys:\n            - app_name (str): The name of the app.\n            - recommendations (list[str]): The list of mitigation recommendations.\n    :raises ValueError: If app_name or vulnerabilities list is invalid.\n    \"\"\"\n    # Mock logic: If the app name is \"TechVenture\" and vulnerabilities list is not empty, provide recommendations.\n    if app_name.strip().lower() != \"techventure\" or not vulnerabilities:\n        raise ValueError(\"Invalid app name or vulnerabilities list.\")\n    \n    # Creating a simplistic recommendation for demonstration.\n    recommendations = [f\"Mitigate {vuln} by updating the app's security protocols.\" for vuln in vulnerabilities]\n    return {\n        \"app_name\": app_name,\n        \"recommendations\": recommendations\n    }", "user_query": "Is the latest version of the app \"TechVenture\" available for project manager Mia?", "checklist": {"functions": ["ensure_latest_app_version"], "values": [true]}}
{"difficulty": "easy", "function_schema_python": "def analyze_network_traffic(duration_mins: int, interface: str) -> dict:\n    \"\"\"Analyzes network traffic for a specified duration using Wireshark.\n\n    :param duration_mins: Duration of traffic capture in minutes.\n    :param interface: Network interface to monitor (e.g., 'eth0', 'wlan0').\n    :return: Dictionary containing traffic analysis results.\n            Keys:\n            - total_packets (int): Total number of packets captured\n            - suspicious_packets (int): Number of suspicious packets\n            - top_protocols (list): Most frequent protocols\n            - anomaly_score (float): 0-1 score indicating traffic anomaly level\n    :raises ValueError: If duration is negative or interface is invalid.\"\"\"\n    pass\ndef scan_iot_devices(network_range: str) -> dict:\n    \"\"\"Scans network for IoT devices using nmap.\n\n    :param network_range: CIDR notation of network range (e.g., '192.168.1.0/24')\n    :return: Dictionary containing scan results.\n            Keys:\n            - active_devices (int): Number of active IoT devices\n            - suspicious_devices (list): List of suspicious device IPs\n            - open_ports (dict): Dictionary of IP to open ports mapping\n    :raises ValueError: If network range is invalid.\"\"\"\n    pass\ndef detect_traffic_anomalies(baseline_traffic: float, current_traffic: float) -> dict:\n    \"\"\"Detects network traffic anomalies by comparing current traffic with baseline.\n\n    :param baseline_traffic: Baseline traffic in Mbps\n    :param current_traffic: Current traffic in Mbps\n    :return: Dictionary containing anomaly analysis.\n            Keys:\n            - is_anomalous (bool): Whether traffic is anomalous\n            - deviation_percent (float): Percentage deviation from baseline\n            - risk_level (str): Low/Medium/High risk assessment\n    :raises ValueError: If traffic values are negative\"\"\"\n    pass\n", "function_schema_json": [{"name": "analyze_network_traffic", "description": "Analyzes network traffic for a specified duration using Wireshark.", "parameters": {"type": "object", "properties": {"duration_mins": {"type": "integer", "description": "Duration of traffic capture in minutes."}, "interface": {"type": "string", "description": "Network interface to monitor (e.g., 'eth0', 'wlan0')."}}, "required": ["duration_mins", "interface"], "additionalProperties": false}}, {"name": "scan_iot_devices", "description": "Scans network for IoT devices using nmap.", "parameters": {"type": "object", "properties": {"network_range": {"type": "string", "description": "CIDR notation of network range (e.g., '192.168.1.0/24')"}}, "required": ["network_range"], "additionalProperties": false}}, {"name": "detect_traffic_anomalies", "description": "Detects network traffic anomalies by comparing current traffic with baseline.", "parameters": {"type": "object", "properties": {"baseline_traffic": {"type": "number", "description": "Baseline traffic in Mbps"}, "current_traffic": {"type": "number", "description": "Current traffic in Mbps"}}, "required": ["baseline_traffic", "current_traffic"], "additionalProperties": false}}], "mock_functions": "def analyze_network_traffic(duration_mins: int, interface: str) -> dict:\n    \"\"\"\n    Analyzes network traffic for a specified duration using Wireshark.\n    \n    :param duration_mins: Duration of traffic capture in minutes.\n    :param interface: Network interface to monitor (e.g., 'eth0', 'wlan0').\n    :return: Dictionary containing traffic analysis results.\n            Keys:\n            - total_packets (int): Total number of packets captured\n            - suspicious_packets (int): Number of suspicious packets\n            - top_protocols (list): Most frequent protocols\n            - anomaly_score (float): 0-1 score indicating traffic anomaly level\n    :raises ValueError: If duration is negative or interface is invalid.\n    \"\"\"\n    if duration_mins <= 0:\n        raise ValueError(\"Duration must be positive\")\n    if not isinstance(interface, str) or not interface:\n        raise ValueError(\"Invalid interface\")\n    \n    return {\n        \"total_packets\": 15000,\n        \"suspicious_packets\": 450,\n        \"top_protocols\": [\"HTTP\", \"MQTT\", \"TCP\"],\n        \"anomaly_score\": 0.75\n    }\ndef scan_iot_devices(network_range: str) -> dict:\n    \"\"\"\n    Scans network for IoT devices using nmap.\n    \n    :param network_range: CIDR notation of network range (e.g., '192.168.1.0/24')\n    :return: Dictionary containing scan results.\n            Keys:\n            - active_devices (int): Number of active IoT devices\n            - suspicious_devices (list): List of suspicious device IPs\n            - open_ports (dict): Dictionary of IP to open ports mapping\n    :raises ValueError: If network range is invalid.\n    \"\"\"\n    if not isinstance(network_range, str) or '/' not in network_range:\n        raise ValueError(\"Invalid network range\")\n    \n    return {\n        \"active_devices\": 12,\n        \"suspicious_devices\": [\"192.168.1.45\", \"192.168.1.72\"],\n        \"open_ports\": {\n            \"192.168.1.45\": [80, 23, 8080],\n            \"192.168.1.72\": [443, 22, 9000]\n        }\n    }\ndef detect_traffic_anomalies(baseline_traffic: float, current_traffic: float) -> dict:\n    \"\"\"\n    Detects network traffic anomalies by comparing current traffic with baseline.\n    \n    :param baseline_traffic: Baseline traffic in Mbps\n    :param current_traffic: Current traffic in Mbps\n    :return: Dictionary containing anomaly analysis.\n            Keys:\n            - is_anomalous (bool): Whether traffic is anomalous\n            - deviation_percent (float): Percentage deviation from baseline\n            - risk_level (str): Low/Medium/High risk assessment\n    :raises ValueError: If traffic values are negative\n    \"\"\"\n    if baseline_traffic < 0 or current_traffic < 0:\n        raise ValueError(\"Traffic values cannot be negative\")\n    \n    return {\n        \"is_anomalous\": True,\n        \"deviation_percent\": 156.5,\n        \"risk_level\": \"High\"\n    }", "user_query": "Can you analyze network traffic for 'eth0' interface for the last 15 minutes?", "checklist": {"functions": ["analyze_network_traffic"], "values": [{"total_packets": 15000, "suspicious_packets": 450, "top_protocols": ["HTTP", "MQTT", "TCP"], "anomaly_score": 0.75}]}}
{"difficulty": "easy", "function_schema_python": "def analyze_network_traffic(duration_mins: int, interface: str) -> dict:\n    \"\"\"Analyzes network traffic for a specified duration using Wireshark.\n\n    :param duration_mins: Duration of traffic capture in minutes.\n    :param interface: Network interface to monitor (e.g., 'eth0', 'wlan0').\n    :return: Dictionary containing traffic analysis results.\n            Keys:\n            - total_packets (int): Total number of packets captured\n            - suspicious_packets (int): Number of suspicious packets\n            - top_protocols (list): Most frequent protocols\n            - anomaly_score (float): 0-1 score indicating traffic anomaly level\n    :raises ValueError: If duration is negative or interface is invalid.\"\"\"\n    pass\ndef scan_iot_devices(network_range: str) -> dict:\n    \"\"\"Scans network for IoT devices using nmap.\n\n    :param network_range: CIDR notation of network range (e.g., '192.168.1.0/24')\n    :return: Dictionary containing scan results.\n            Keys:\n            - active_devices (int): Number of active IoT devices\n            - suspicious_devices (list): List of suspicious device IPs\n            - open_ports (dict): Dictionary of IP to open ports mapping\n    :raises ValueError: If network range is invalid.\"\"\"\n    pass\ndef detect_traffic_anomalies(baseline_traffic: float, current_traffic: float) -> dict:\n    \"\"\"Detects network traffic anomalies by comparing current traffic with baseline.\n\n    :param baseline_traffic: Baseline traffic in Mbps\n    :param current_traffic: Current traffic in Mbps\n    :return: Dictionary containing anomaly analysis.\n            Keys:\n            - is_anomalous (bool): Whether traffic is anomalous\n            - deviation_percent (float): Percentage deviation from baseline\n            - risk_level (str): Low/Medium/High risk assessment\n    :raises ValueError: If traffic values are negative\"\"\"\n    pass\n", "function_schema_json": [{"name": "analyze_network_traffic", "description": "Analyzes network traffic for a specified duration using Wireshark.", "parameters": {"type": "object", "properties": {"duration_mins": {"type": "integer", "description": "Duration of traffic capture in minutes."}, "interface": {"type": "string", "description": "Network interface to monitor (e.g., 'eth0', 'wlan0')."}}, "required": ["duration_mins", "interface"], "additionalProperties": false}}, {"name": "scan_iot_devices", "description": "Scans network for IoT devices using nmap.", "parameters": {"type": "object", "properties": {"network_range": {"type": "string", "description": "CIDR notation of network range (e.g., '192.168.1.0/24')"}}, "required": ["network_range"], "additionalProperties": false}}, {"name": "detect_traffic_anomalies", "description": "Detects network traffic anomalies by comparing current traffic with baseline.", "parameters": {"type": "object", "properties": {"baseline_traffic": {"type": "number", "description": "Baseline traffic in Mbps"}, "current_traffic": {"type": "number", "description": "Current traffic in Mbps"}}, "required": ["baseline_traffic", "current_traffic"], "additionalProperties": false}}], "mock_functions": "def analyze_network_traffic(duration_mins: int, interface: str) -> dict:\n    \"\"\"\n    Analyzes network traffic for a specified duration using Wireshark.\n    \n    :param duration_mins: Duration of traffic capture in minutes.\n    :param interface: Network interface to monitor (e.g., 'eth0', 'wlan0').\n    :return: Dictionary containing traffic analysis results.\n            Keys:\n            - total_packets (int): Total number of packets captured\n            - suspicious_packets (int): Number of suspicious packets\n            - top_protocols (list): Most frequent protocols\n            - anomaly_score (float): 0-1 score indicating traffic anomaly level\n    :raises ValueError: If duration is negative or interface is invalid.\n    \"\"\"\n    if duration_mins <= 0:\n        raise ValueError(\"Duration must be positive\")\n    if not isinstance(interface, str) or not interface:\n        raise ValueError(\"Invalid interface\")\n    \n    return {\n        \"total_packets\": 15000,\n        \"suspicious_packets\": 450,\n        \"top_protocols\": [\"HTTP\", \"MQTT\", \"TCP\"],\n        \"anomaly_score\": 0.75\n    }\ndef scan_iot_devices(network_range: str) -> dict:\n    \"\"\"\n    Scans network for IoT devices using nmap.\n    \n    :param network_range: CIDR notation of network range (e.g., '192.168.1.0/24')\n    :return: Dictionary containing scan results.\n            Keys:\n            - active_devices (int): Number of active IoT devices\n            - suspicious_devices (list): List of suspicious device IPs\n            - open_ports (dict): Dictionary of IP to open ports mapping\n    :raises ValueError: If network range is invalid.\n    \"\"\"\n    if not isinstance(network_range, str) or '/' not in network_range:\n        raise ValueError(\"Invalid network range\")\n    \n    return {\n        \"active_devices\": 12,\n        \"suspicious_devices\": [\"192.168.1.45\", \"192.168.1.72\"],\n        \"open_ports\": {\n            \"192.168.1.45\": [80, 23, 8080],\n            \"192.168.1.72\": [443, 22, 9000]\n        }\n    }\ndef detect_traffic_anomalies(baseline_traffic: float, current_traffic: float) -> dict:\n    \"\"\"\n    Detects network traffic anomalies by comparing current traffic with baseline.\n    \n    :param baseline_traffic: Baseline traffic in Mbps\n    :param current_traffic: Current traffic in Mbps\n    :return: Dictionary containing anomaly analysis.\n            Keys:\n            - is_anomalous (bool): Whether traffic is anomalous\n            - deviation_percent (float): Percentage deviation from baseline\n            - risk_level (str): Low/Medium/High risk assessment\n    :raises ValueError: If traffic values are negative\n    \"\"\"\n    if baseline_traffic < 0 or current_traffic < 0:\n        raise ValueError(\"Traffic values cannot be negative\")\n    \n    return {\n        \"is_anomalous\": True,\n        \"deviation_percent\": 156.5,\n        \"risk_level\": \"High\"\n    }", "user_query": "This is Alice from TechSecure Solutions. Can you scan the network range '192.168.1.0/24' and identify any suspicious IoT devices with open ports?", "checklist": {"functions": ["scan_iot_devices"], "values": [{"active_devices": 12, "suspicious_devices": ["192.168.1.45", "192.168.1.72"], "open_ports": {"192.168.1.45": [80, 23, 8080], "192.168.1.72": [443, 22, 9000]}}]}}
{"difficulty": "easy", "function_schema_python": "def analyze_login_attempts(start_time: str, end_time: str) -> dict:\n    \"\"\"Analyzes login attempts within a specified time range.\n\n    :param start_time: Start time in ISO format (YYYY-MM-DD HH:MM:SS)\n    :param end_time: End time in ISO format (YYYY-MM-DD HH:MM:SS)\n    :return: Dictionary containing login attempt analysis\n    :raises ValueError: If time format is invalid\"\"\"\n    pass\ndef detect_intrusion_signatures(network_logs: str, threshold: int) -> dict:\n    \"\"\"Analyzes network logs for potential intrusion signatures.\n\n    :param network_logs: Path to network log file\n    :param threshold: Sensitivity threshold for detection (1-10)\n    :return: Dictionary containing detected intrusion attempts\n    :raises ValueError: If threshold is out of range or logs not found\"\"\"\n    pass\ndef configure_security_alerts(email: str, alert_level: str) -> bool:\n    \"\"\"Configures security alerts for specified email address.\n\n    :param email: Email address to receive alerts\n    :param alert_level: Alert level (LOW, MEDIUM, HIGH)\n    :return: Boolean indicating success of configuration\n    :raises ValueError: If email format is invalid or alert level is incorrect\"\"\"\n    pass\n", "function_schema_json": [{"name": "analyze_login_attempts", "description": "Analyzes login attempts within a specified time range.", "parameters": {"type": "object", "properties": {"start_time": {"type": "string", "description": "Start time in ISO format (YYYY-MM-DD HH:MM:SS)"}, "end_time": {"type": "string", "description": "End time in ISO format (YYYY-MM-DD HH:MM:SS)"}}, "required": ["start_time", "end_time"], "additionalProperties": false}}, {"name": "detect_intrusion_signatures", "description": "Analyzes network logs for potential intrusion signatures.", "parameters": {"type": "object", "properties": {"network_logs": {"type": "string", "description": "Path to network log file"}, "threshold": {"type": "integer", "description": "Sensitivity threshold for detection (1-10)"}}, "required": ["network_logs", "threshold"], "additionalProperties": false}}, {"name": "configure_security_alerts", "description": "Configures security alerts for specified email address.", "parameters": {"type": "object", "properties": {"email": {"type": "string", "description": "Email address to receive alerts"}, "alert_level": {"type": "string", "description": "Alert level (LOW, MEDIUM, HIGH)"}}, "required": ["email", "alert_level"], "additionalProperties": false}}], "mock_functions": "def analyze_login_attempts(start_time: str, end_time: str) -> dict:\n    \"\"\"\n    Analyzes login attempts within a specified time range.\n    \n    :param start_time: Start time in ISO format (YYYY-MM-DD HH:MM:SS)\n    :param end_time: End time in ISO format (YYYY-MM-DD HH:MM:SS)\n    :return: Dictionary containing login attempt analysis\n    :raises ValueError: If time format is invalid\n    \"\"\"\n    if not all(map(lambda x: len(x) == 19, [start_time, end_time])):\n        raise ValueError(\"Invalid time format\")\n    \n    return {\n        \"total_attempts\": 157,\n        \"suspicious_attempts\": 23,\n        \"ip_addresses\": [\"192.168.1.100\", \"45.67.89.123\"],\n        \"failed_attempts\": 18,\n        \"successful_logins\": 139\n    }\ndef detect_intrusion_signatures(network_logs: str, threshold: int = 5) -> dict:\n    \"\"\"\n    Analyzes network logs for potential intrusion signatures.\n    \n    :param network_logs: Path to network log file\n    :param threshold: Sensitivity threshold for detection (1-10)\n    :return: Dictionary containing detected intrusion attempts\n    :raises ValueError: If threshold is out of range or logs not found\n    \"\"\"\n    if not (1 <= threshold <= 10) or not network_logs.endswith('.log'):\n        raise ValueError(\"Invalid threshold or log file\")\n    \n    return {\n        \"detected_threats\": 3,\n        \"severity_levels\": [\"HIGH\", \"MEDIUM\", \"LOW\"],\n        \"affected_systems\": [\"auth_server\", \"file_server\"],\n        \"timestamp\": \"2024-01-20 15:30:45\"\n    }\ndef configure_security_alerts(email: str, alert_level: str) -> bool:\n    \"\"\"\n    Configures security alerts for specified email address.\n    \n    :param email: Email address to receive alerts\n    :param alert_level: Alert level (LOW, MEDIUM, HIGH)\n    :return: Boolean indicating success of configuration\n    :raises ValueError: If email format is invalid or alert level is incorrect\n    \"\"\"\n    if not '@' in email or alert_level not in ['LOW', 'MEDIUM', 'HIGH']:\n        raise ValueError(\"Invalid email or alert level\")\n    \n    if email == \"bob@financialfortitude.com\" and alert_level == \"HIGH\":\n        return True\n    return False", "user_query": "Can you analyze login attempts between 2024-07-26 00:00:00 and 2024-07-27 00:00:00?", "checklist": {"functions": ["analyze_login_attempts"], "values": [{"total_attempts": 157, "suspicious_attempts": 23, "ip_addresses": ["192.168.1.100", "45.67.89.123"], "failed_attempts": 18, "successful_logins": 139}]}}
{"difficulty": "easy", "function_schema_python": "def analyze_login_attempts(start_time: str, end_time: str) -> dict:\n    \"\"\"Analyzes login attempts within a specified time range.\n\n    :param start_time: Start time in ISO format (YYYY-MM-DD HH:MM:SS)\n    :param end_time: End time in ISO format (YYYY-MM-DD HH:MM:SS)\n    :return: Dictionary containing login attempt analysis\n    :raises ValueError: If time format is invalid\"\"\"\n    pass\ndef detect_intrusion_signatures(network_logs: str, threshold: int) -> dict:\n    \"\"\"Analyzes network logs for potential intrusion signatures.\n\n    :param network_logs: Path to network log file\n    :param threshold: Sensitivity threshold for detection (1-10)\n    :return: Dictionary containing detected intrusion attempts\n    :raises ValueError: If threshold is out of range or logs not found\"\"\"\n    pass\ndef configure_security_alerts(email: str, alert_level: str) -> bool:\n    \"\"\"Configures security alerts for specified email address.\n\n    :param email: Email address to receive alerts\n    :param alert_level: Alert level (LOW, MEDIUM, HIGH)\n    :return: Boolean indicating success of configuration\n    :raises ValueError: If email format is invalid or alert level is incorrect\"\"\"\n    pass\n", "function_schema_json": [{"name": "analyze_login_attempts", "description": "Analyzes login attempts within a specified time range.", "parameters": {"type": "object", "properties": {"start_time": {"type": "string", "description": "Start time in ISO format (YYYY-MM-DD HH:MM:SS)"}, "end_time": {"type": "string", "description": "End time in ISO format (YYYY-MM-DD HH:MM:SS)"}}, "required": ["start_time", "end_time"], "additionalProperties": false}}, {"name": "detect_intrusion_signatures", "description": "Analyzes network logs for potential intrusion signatures.", "parameters": {"type": "object", "properties": {"network_logs": {"type": "string", "description": "Path to network log file"}, "threshold": {"type": "integer", "description": "Sensitivity threshold for detection (1-10)"}}, "required": ["network_logs", "threshold"], "additionalProperties": false}}, {"name": "configure_security_alerts", "description": "Configures security alerts for specified email address.", "parameters": {"type": "object", "properties": {"email": {"type": "string", "description": "Email address to receive alerts"}, "alert_level": {"type": "string", "description": "Alert level (LOW, MEDIUM, HIGH)"}}, "required": ["email", "alert_level"], "additionalProperties": false}}], "mock_functions": "def analyze_login_attempts(start_time: str, end_time: str) -> dict:\n    \"\"\"\n    Analyzes login attempts within a specified time range.\n    \n    :param start_time: Start time in ISO format (YYYY-MM-DD HH:MM:SS)\n    :param end_time: End time in ISO format (YYYY-MM-DD HH:MM:SS)\n    :return: Dictionary containing login attempt analysis\n    :raises ValueError: If time format is invalid\n    \"\"\"\n    if not all(map(lambda x: len(x) == 19, [start_time, end_time])):\n        raise ValueError(\"Invalid time format\")\n    \n    return {\n        \"total_attempts\": 157,\n        \"suspicious_attempts\": 23,\n        \"ip_addresses\": [\"192.168.1.100\", \"45.67.89.123\"],\n        \"failed_attempts\": 18,\n        \"successful_logins\": 139\n    }\ndef detect_intrusion_signatures(network_logs: str, threshold: int = 5) -> dict:\n    \"\"\"\n    Analyzes network logs for potential intrusion signatures.\n    \n    :param network_logs: Path to network log file\n    :param threshold: Sensitivity threshold for detection (1-10)\n    :return: Dictionary containing detected intrusion attempts\n    :raises ValueError: If threshold is out of range or logs not found\n    \"\"\"\n    if not (1 <= threshold <= 10) or not network_logs.endswith('.log'):\n        raise ValueError(\"Invalid threshold or log file\")\n    \n    return {\n        \"detected_threats\": 3,\n        \"severity_levels\": [\"HIGH\", \"MEDIUM\", \"LOW\"],\n        \"affected_systems\": [\"auth_server\", \"file_server\"],\n        \"timestamp\": \"2024-01-20 15:30:45\"\n    }\ndef configure_security_alerts(email: str, alert_level: str) -> bool:\n    \"\"\"\n    Configures security alerts for specified email address.\n    \n    :param email: Email address to receive alerts\n    :param alert_level: Alert level (LOW, MEDIUM, HIGH)\n    :return: Boolean indicating success of configuration\n    :raises ValueError: If email format is invalid or alert level is incorrect\n    \"\"\"\n    if not '@' in email or alert_level not in ['LOW', 'MEDIUM', 'HIGH']:\n        raise ValueError(\"Invalid email or alert level\")\n    \n    if email == \"bob@financialfortitude.com\" and alert_level == \"HIGH\":\n        return True\n    return False", "user_query": "This is Bob from Financial Fortitude.  Please analyze network_logs.log with a threshold of 7 for intrusion signatures.", "checklist": {"functions": ["detect_intrusion_signatures"], "values": [{"detected_threats": 3, "severity_levels": ["HIGH", "MEDIUM", "LOW"], "affected_systems": ["auth_server", "file_server"], "timestamp": "2024-01-20 15:30:45"}]}}
{"difficulty": "easy", "function_schema_python": "def load_transaction_data(file_path: str, data_format: str) -> dict:\n    \"\"\"Loads transaction data from various sources into a standardized format.\n\n    :param file_path: Path to the data file\n    :param data_format: Format of the input data (csv, json, parquet)\n    :return: Dictionary containing loaded data with keys:\n        - data (pd.DataFrame): The loaded dataset\n        - rows (int): Number of rows\n        - columns (list): List of column names\n    :raises ValueError: If file format is not supported\"\"\"\n    pass\ndef identify_data_issues(data: str) -> dict:\n    \"\"\"Analyzes the dataset to identify various data quality issues.\n\n    :param data: The input dataset (expected as DataFrame)\n    :return: Dictionary containing identified issues with keys:\n        - missing_values (dict): Count of missing values per column\n        - duplicates (int): Number of duplicate rows\n        - inconsistencies (list): List of detected data inconsistencies\n    :raises ValueError: If input data is invalid\"\"\"\n    pass\ndef clean_transaction_data(data: str, cleaning_config: dict) -> dict:\n    \"\"\"Cleans the transaction data based on specified configuration.\n\n    :param data: The input dataset (expected as DataFrame)\n    :param cleaning_config: Dictionary specifying cleaning operations\n    :return: Dictionary containing cleaned data with keys:\n        - cleaned_data (pd.DataFrame): The cleaned dataset\n        - cleaning_summary (dict): Summary of cleaning operations performed\n    :raises ValueError: If cleaning configuration is invalid\"\"\"\n    pass\n", "function_schema_json": [{"name": "load_transaction_data", "description": "Loads transaction data from various sources into a standardized format.", "parameters": {"type": "object", "properties": {"file_path": {"type": "string", "description": "Path to the data file"}, "data_format": {"type": "string", "description": "Format of the input data (csv, json, parquet)"}}, "required": ["file_path", "data_format"], "additionalProperties": false}}, {"name": "identify_data_issues", "description": "Analyzes the dataset to identify various data quality issues.", "parameters": {"type": "object", "properties": {"data": {"type": "string", "description": "The input dataset (expected as DataFrame)"}}, "required": ["data"], "additionalProperties": false}}, {"name": "clean_transaction_data", "description": "Cleans the transaction data based on specified configuration.", "parameters": {"type": "object", "properties": {"data": {"type": "string", "description": "The input dataset (expected as DataFrame)"}, "cleaning_config": {"type": "object", "description": "Dictionary specifying cleaning operations"}}, "required": ["data", "cleaning_config"], "additionalProperties": false}}], "mock_functions": "def load_transaction_data(file_path: str, data_format: str) -> dict:\n    \"\"\"\n    Loads transaction data from various sources into a standardized format.\n    \n    :param file_path: Path to the data file\n    :param data_format: Format of the input data (csv, json, parquet)\n    :return: Dictionary containing loaded data with keys:\n        - data (pd.DataFrame): The loaded dataset\n        - rows (int): Number of rows\n        - columns (list): List of column names\n    :raises ValueError: If file format is not supported\n    \"\"\"\n    supported_formats = ['csv', 'json', 'parquet']\n    if data_format.lower() not in supported_formats:\n        raise ValueError(f\"Unsupported format. Must be one of {supported_formats}\")\n    \n    if not file_path.endswith(data_format):\n        raise ValueError(\"File path extension doesn't match specified format\")\n        \n    return {\n        \"data\": \"mock_dataframe\",\n        \"rows\": 10000,\n        \"columns\": [\"transaction_id\", \"customer_id\", \"amount\", \"date\", \"category\"]\n    }\ndef identify_data_issues(data: str) -> dict:\n    \"\"\"\n    Analyzes the dataset to identify various data quality issues.\n    \n    :param data: The input dataset (expected as DataFrame)\n    :return: Dictionary containing identified issues with keys:\n        - missing_values (dict): Count of missing values per column\n        - duplicates (int): Number of duplicate rows\n        - inconsistencies (list): List of detected data inconsistencies\n    :raises ValueError: If input data is invalid\n    \"\"\"\n    if data != \"mock_dataframe\":\n        raise ValueError(\"Invalid input data format\")\n        \n    return {\n        \"missing_values\": {\n            \"transaction_id\": 0,\n            \"customer_id\": 15,\n            \"amount\": 25,\n            \"date\": 10,\n            \"category\": 50\n        },\n        \"duplicates\": 120,\n        \"inconsistencies\": [\n            \"Invalid date formats in 'date' column\",\n            \"Negative amounts in 'amount' column\",\n            \"Inconsistent category naming\"\n        ]\n    }\ndef clean_transaction_data(data: str, cleaning_config: dict) -> dict:\n    \"\"\"\n    Cleans the transaction data based on specified configuration.\n    \n    :param data: The input dataset (expected as DataFrame)\n    :param cleaning_config: Dictionary specifying cleaning operations\n    :return: Dictionary containing cleaned data with keys:\n        - cleaned_data (pd.DataFrame): The cleaned dataset\n        - cleaning_summary (dict): Summary of cleaning operations performed\n    :raises ValueError: If cleaning configuration is invalid\n    \"\"\"\n    expected_config_keys = {\"fill_missing\", \"remove_duplicates\", \"standardize_categories\"}\n    if not all(key in cleaning_config for key in expected_config_keys):\n        raise ValueError(\"Invalid cleaning configuration\")\n        \n    if data != \"mock_dataframe\":\n        raise ValueError(\"Invalid input data format\")\n        \n    return {\n        \"cleaned_data\": \"cleaned_mock_dataframe\",\n        \"cleaning_summary\": {\n            \"missing_values_filled\": 100,\n            \"duplicates_removed\": 120,\n            \"categories_standardized\": 45\n        }\n    }", "user_query": "Can you load my transaction data from \"customer_data_2024.csv\" in CSV format?", "checklist": {"functions": ["load_transaction_data"], "values": [{"data": "mock_dataframe", "rows": 10000, "columns": ["transaction_id", "customer_id", "amount", "date", "category"]}]}}
{"difficulty": "easy", "function_schema_python": "def load_sensor_data(file_path: str, data_format: str) -> dict:\n    \"\"\"Loads environmental sensor data from various file formats.\n\n    :param file_path: Path to the sensor data file.\n    :param data_format: Format of the data file (csv, json, xml).\n    :return: Dictionary containing:\n        - data (list): Raw sensor readings\n        - metadata (dict): Sensor information\n        - format (str): Original format\n    :raises ValueError: If file format is unsupported.\"\"\"\n    pass\ndef standardize_data_format(data: dict, target_format: str) -> dict:\n    \"\"\"Standardizes data format using Polars.\n\n    :param data: Dictionary containing sensor data.\n    :param target_format: Desired output format.\n    :return: Dictionary containing:\n        - standardized_data (list): Cleaned data\n        - validation_report (dict): Data quality metrics\n    :raises ValueError: If target format is invalid.\"\"\"\n    pass\ndef validate_data_quality(data: dict, rules: dict) -> dict:\n    \"\"\"Validates data quality using Spark.\n\n    :param data: Dictionary containing standardized data.\n    :param rules: Dictionary of validation rules.\n    :return: Dictionary containing:\n        - quality_score (float): Overall quality score\n        - issues (list): List of identified issues\n        - recommendations (list): Suggested fixes\n    :raises ValueError: If validation rules are invalid.\"\"\"\n    pass\n", "function_schema_json": [{"name": "load_sensor_data", "description": "Loads environmental sensor data from various file formats.", "parameters": {"type": "object", "properties": {"file_path": {"type": "string", "description": "Path to the sensor data file."}, "data_format": {"type": "string", "description": "Format of the data file (csv, json, xml)."}}, "required": ["file_path", "data_format"], "additionalProperties": false}}, {"name": "standardize_data_format", "description": "Standardizes data format using Polars.", "parameters": {"type": "object", "properties": {"data": {"type": "object", "description": "Dictionary containing sensor data."}, "target_format": {"type": "string", "description": "Desired output format."}}, "required": ["data", "target_format"], "additionalProperties": false}}, {"name": "validate_data_quality", "description": "Validates data quality using Spark.", "parameters": {"type": "object", "properties": {"data": {"type": "object", "description": "Dictionary containing standardized data."}, "rules": {"type": "object", "description": "Dictionary of validation rules."}}, "required": ["data", "rules"], "additionalProperties": false}}], "mock_functions": "def load_sensor_data(file_path: str, data_format: str) -> dict:\n    \"\"\"\n    Loads environmental sensor data from various file formats.\n    \n    :param file_path: Path to the sensor data file.\n    :param data_format: Format of the data file (csv, json, xml).\n    :return: Dictionary containing:\n        - data (list): Raw sensor readings\n        - metadata (dict): Sensor information\n        - format (str): Original format\n    :raises ValueError: If file format is unsupported.\n    \"\"\"\n    if not file_path or not data_format:\n        raise ValueError(\"File path and format must be provided\")\n    \n    if data_format.lower() in ['csv', 'json', 'xml']:\n        return {\n            \"data\": [\n                {\"timestamp\": \"2023-01-01\", \"reading\": 23.5},\n                {\"timestamp\": \"2023-01-02\", \"reading\": 24.1}\n            ],\n            \"metadata\": {\"sensor_type\": \"air_quality\", \"location\": \"downtown\"},\n            \"format\": data_format\n        }\n    raise ValueError(\"Unsupported file format\")\ndef standardize_data_format(data: dict, target_format: str) -> dict:\n    \"\"\"\n    Standardizes data format using Polars.\n    \n    :param data: Dictionary containing sensor data.\n    :param target_format: Desired output format.\n    :return: Dictionary containing:\n        - standardized_data (list): Cleaned data\n        - validation_report (dict): Data quality metrics\n    :raises ValueError: If target format is invalid.\n    \"\"\"\n    if not isinstance(data, dict) or 'data' not in data:\n        raise ValueError(\"Invalid data structure\")\n    \n    if target_format.lower() == 'standard':\n        return {\n            \"standardized_data\": [\n                {\"date\": \"2023-01-01\", \"value\": 23.5},\n                {\"date\": \"2023-01-02\", \"value\": 24.1}\n            ],\n            \"validation_report\": {\n                \"missing_values\": 0,\n                \"outliers\": 0\n            }\n        }\n    raise ValueError(\"Invalid target format\")\ndef validate_data_quality(data: dict, rules: dict) -> dict:\n    \"\"\"\n    Validates data quality using Spark.\n    \n    :param data: Dictionary containing standardized data.\n    :param rules: Dictionary of validation rules.\n    :return: Dictionary containing:\n        - quality_score (float): Overall quality score\n        - issues (list): List of identified issues\n        - recommendations (list): Suggested fixes\n    :raises ValueError: If validation rules are invalid.\n    \"\"\"\n    if not isinstance(data, dict) or not isinstance(rules, dict):\n        raise ValueError(\"Invalid data or rules format\")\n    \n    if \"standardized_data\" in data:\n        return {\n            \"quality_score\": 0.95,\n            \"issues\": [\"Minor timestamp inconsistencies\"],\n            \"recommendations\": [\"Standardize timestamp format\"]\n        }\n    raise ValueError(\"Invalid data structure\")", "user_query": "Can you load the sensor data from /data/environmental_readings.csv in csv format?", "checklist": {"functions": ["load_sensor_data"], "values": [{"data": [{"timestamp": "2023-01-01", "reading": 23.5}, {"timestamp": "2023-01-02", "reading": 24.1}], "metadata": {"sensor_type": "air_quality", "location": "downtown"}, "format": "csv"}]}}
{"difficulty": "easy", "function_schema_python": "def load_customer_data(file_path: str) -> dict:\n    \"\"\"Loads customer data from a specified file path.\n\n    :param file_path: Path to the customer data file\n    :return: Dictionary containing:\n        - data (pd.DataFrame): The loaded customer data\n        - row_count (int): Number of rows loaded\n        - columns (list): List of column names\n    :raises FileNotFoundError: If the file doesn't exist\"\"\"\n    pass\ndef normalize_column(data: dict, column_name: str) -> dict:\n    \"\"\"Normalizes the specified column in the dataset.\n\n    :param data: Dictionary containing the customer data\n    :param column_name: Name of the column to normalize\n    :return: Dictionary containing:\n        - normalized_data (array): Normalized values\n        - min_value (float): Original minimum value\n        - max_value (float): Original maximum value\n        - mean (float): Mean of normalized values\n        - std (float): Standard deviation of normalized values\n    :raises ValueError: If column name is invalid\"\"\"\n    pass\ndef generate_normalization_report(normalization_results: dict) -> dict:\n    \"\"\"Generates a report summarizing the normalization results.\n\n    :param normalization_results: Dictionary containing normalization statistics\n    :return: Dictionary containing:\n        - summary (str): Text summary of normalization\n        - statistics (dict): Key statistics\n        - visualization (str): Path to generated visualization\n    :raises ValueError: If normalization results are invalid\"\"\"\n    pass\n", "function_schema_json": [{"name": "load_customer_data", "description": "Loads customer data from a specified file path.", "parameters": {"type": "object", "properties": {"file_path": {"type": "string", "description": "Path to the customer data file"}}, "required": ["file_path"], "additionalProperties": false}}, {"name": "normalize_column", "description": "Normalizes the specified column in the dataset.", "parameters": {"type": "object", "properties": {"data": {"type": "object", "description": "Dictionary containing the customer data"}, "column_name": {"type": "string", "description": "Name of the column to normalize"}}, "required": ["data", "column_name"], "additionalProperties": false}}, {"name": "generate_normalization_report", "description": "Generates a report summarizing the normalization results.", "parameters": {"type": "object", "properties": {"normalization_results": {"type": "object", "description": "Dictionary containing normalization statistics"}}, "required": ["normalization_results"], "additionalProperties": false}}], "mock_functions": "def load_customer_data(file_path: str) -> dict:\n    \"\"\"\n    Loads customer data from a specified file path.\n    \n    :param file_path: Path to the customer data file\n    :return: Dictionary containing:\n        - data (pd.DataFrame): The loaded customer data\n        - row_count (int): Number of rows loaded\n        - columns (list): List of column names\n    :raises FileNotFoundError: If the file doesn't exist\n    \"\"\"\n    if not file_path.endswith('.csv'):\n        raise ValueError(\"File must be a CSV file\")\n    \n    if file_path == \"customer_data.csv\":\n        return {\n            \"data\": \"mock_dataframe\",\n            \"row_count\": 10000,\n            \"columns\": [\"Customer ID\", \"Purchase Date\", \"Product Type\", \n                       \"Quantity Purchased\", \"Total Amount Spent\"]\n        }\n    raise FileNotFoundError(\"File not found\")\ndef normalize_column(data: dict, column_name: str) -> dict:\n    \"\"\"\n    Normalizes the specified column in the dataset.\n    \n    :param data: Dictionary containing the customer data\n    :param column_name: Name of the column to normalize\n    :return: Dictionary containing:\n        - normalized_data (array): Normalized values\n        - min_value (float): Original minimum value\n        - max_value (float): Original maximum value\n        - mean (float): Mean of normalized values\n        - std (float): Standard deviation of normalized values\n    :raises ValueError: If column name is invalid\n    \"\"\"\n    valid_columns = [\"Total Amount Spent\", \"Quantity Purchased\"]\n    if column_name not in valid_columns:\n        raise ValueError(f\"Column must be one of {valid_columns}\")\n    \n    if column_name == \"Total Amount Spent\":\n        return {\n            \"normalized_data\": \"mock_normalized_array\",\n            \"min_value\": 0.0,\n            \"max_value\": 1.0,\n            \"mean\": 0.5,\n            \"std\": 0.2\n        }\n    return {}\ndef generate_normalization_report(normalization_results: dict) -> dict:\n    \"\"\"\n    Generates a report summarizing the normalization results.\n    \n    :param normalization_results: Dictionary containing normalization statistics\n    :return: Dictionary containing:\n        - summary (str): Text summary of normalization\n        - statistics (dict): Key statistics\n        - visualization (str): Path to generated visualization\n    :raises ValueError: If normalization results are invalid\n    \"\"\"\n    if not all(key in normalization_results for key in [\"min_value\", \"max_value\", \"mean\", \"std\"]):\n        raise ValueError(\"Invalid normalization results\")\n    \n    return {\n        \"summary\": \"Normalization successful. Data scaled to range [0,1]\",\n        \"statistics\": {\n            \"original_range\": \"$0-$1000\",\n            \"normalized_range\": \"0-1\",\n            \"mean\": 0.5,\n            \"std\": 0.2\n        },\n        \"visualization\": \"normalization_plot.png\"\n    }", "user_query": "Can you load the customer data from customer_data.csv?", "checklist": {"functions": ["load_customer_data"], "values": [{"data": "mock_dataframe", "row_count": 10000, "columns": ["Customer ID", "Purchase Date", "Product Type", "Quantity Purchased", "Total Amount Spent"]}]}}
{"difficulty": "easy", "function_schema_python": "def extract_sales_data(warehouse_id: str) -> list:\n    \"\"\"Extracts sales data from the specified warehouse.\n\n    :param warehouse_id: The ID of the warehouse to extract data from (e.g., \"WA-2024-Q1\").\n    :return: A list of dictionaries, each representing a sales record with the following keys:\n        - product_category (str): The category of the product.\n        - revenue (float): The revenue generated from the sale.\n    :raises ValueError: If the warehouse_id is not recognized.\"\"\"\n    pass\ndef extract_customer_data(warehouse_id: str) -> list:\n    \"\"\"Extracts customer demographic data from the specified warehouse.\n\n    :param warehouse_id: The ID of the warehouse to extract data from (e.g., \"WC-2024\").\n    :return: A list of dictionaries, each representing a customer record with the following keys:\n        - product_category (str): The category of the product.\n        - customer_age (int): The age of the customer.\n        - customer_location (str): The location of the customer.\n    :raises ValueError: If the warehouse_id is not recognized.\"\"\"\n    pass\ndef aggregate_sales_data(sales_data: list) -> dict:\n    \"\"\"Aggregates sales data by product category.\n\n    :param sales_data: A list of sales records, where each record is a dictionary with the following keys:\n        - product_category (str): The category of the product.\n        - revenue (float): The revenue generated from the sale.\n    :return: A dictionary with aggregated sales revenue by product category, where the keys are product categories \n             and the values are the aggregated revenues (float).\"\"\"\n    pass\ndef consolidate_data(sales_data_aggregated: dict, customer_data: list) -> dict:\n    \"\"\"Consolidates aggregated sales data with customer demographic data.\n\n    :param sales_data_aggregated: A dictionary with aggregated sales revenue by product category.\n    :param customer_data: A list of customer records.\n    :return: A consolidated dictionary with the following keys:\n        - product_category (str): The category of the product.\n        - total_revenue (float): The total revenue for the product category.\n        - customer_info (list): A list of dictionaries with customer demographic information for the product category.\"\"\"\n    pass\ndef generate_report(consolidated_data: dict) -> str:\n    \"\"\"Generates a report from the consolidated data.\n\n    :param consolidated_data: A consolidated dictionary with product category, total revenue, and customer information.\n    :return: A string representing the report.\"\"\"\n    pass\n", "function_schema_json": [{"name": "extract_sales_data", "description": "Extracts sales data from the specified warehouse.", "parameters": {"type": "object", "properties": {"warehouse_id": {"type": "string", "description": "The ID of the warehouse to extract data from (e.g., \"WA-2024-Q1\")."}}, "required": ["warehouse_id"], "additionalProperties": false}}, {"name": "extract_customer_data", "description": "Extracts customer demographic data from the specified warehouse.", "parameters": {"type": "object", "properties": {"warehouse_id": {"type": "string", "description": "The ID of the warehouse to extract data from (e.g., \"WC-2024\")."}}, "required": ["warehouse_id"], "additionalProperties": false}}, {"name": "aggregate_sales_data", "description": "Aggregates sales data by product category.", "parameters": {"type": "object", "properties": {"sales_data": {"type": "array", "description": "A list of sales records, where each record is a dictionary with the following keys:"}}, "required": ["sales_data"], "additionalProperties": false}}, {"name": "consolidate_data", "description": "Consolidates aggregated sales data with customer demographic data.", "parameters": {"type": "object", "properties": {"sales_data_aggregated": {"type": "object", "description": "A dictionary with aggregated sales revenue by product category."}, "customer_data": {"type": "array", "description": "A list of customer records."}}, "required": ["sales_data_aggregated", "customer_data"], "additionalProperties": false}}, {"name": "generate_report", "description": "Generates a report from the consolidated data.", "parameters": {"type": "object", "properties": {"consolidated_data": {"type": "object", "description": "A consolidated dictionary with product category, total revenue, and customer information."}}, "required": ["consolidated_data"], "additionalProperties": false}}], "mock_functions": "def extract_sales_data(warehouse_id: str) -> list:\n    \"\"\"\n    Extracts sales data from the specified warehouse.\n    \n    :param warehouse_id: The ID of the warehouse to extract data from (e.g., \"WA-2024-Q1\").\n    :return: A list of dictionaries, each representing a sales record with the following keys:\n        - product_category (str): The category of the product.\n        - revenue (float): The revenue generated from the sale.\n    :raises ValueError: If the warehouse_id is not recognized.\n    \"\"\"\n    if warehouse_id not in [\"WA-2024-Q1\", \"WB-2024-Q2\"]:\n        raise ValueError(\"Unrecognized warehouse ID.\")\n    \n    # Mock data for demonstration\n    if warehouse_id == \"WA-2024-Q1\":\n        return [\n            {\"product_category\": \"Electronics\", \"revenue\": 1500.0},\n            {\"product_category\": \"Clothing\", \"revenue\": 2000.0},\n            {\"product_category\": \"Electronics\", \"revenue\": 2500.0},\n        ]\n    elif warehouse_id == \"WB-2024-Q2\":\n        return [\n            {\"product_category\": \"Clothing\", \"revenue\": 1200.0},\n            {\"product_category\": \"Home Appliances\", \"revenue\": 4000.0},\n            {\"product_category\": \"Clothing\", \"revenue\": 1800.0},\n        ]\ndef extract_customer_data(warehouse_id: str) -> list:\n    \"\"\"\n    Extracts customer demographic data from the specified warehouse.\n    \n    :param warehouse_id: The ID of the warehouse to extract data from (e.g., \"WC-2024\").\n    :return: A list of dictionaries, each representing a customer record with the following keys:\n        - product_category (str): The category of the product.\n        - customer_age (int): The age of the customer.\n        - customer_location (str): The location of the customer.\n    :raises ValueError: If the warehouse_id is not recognized.\n    \"\"\"\n    if warehouse_id != \"WC-2024\":\n        raise ValueError(\"Unrecognized warehouse ID.\")\n    \n    # Mock data for demonstration\n    return [\n        {\"product_category\": \"Electronics\", \"customer_age\": 30, \"customer_location\": \"New York\"},\n        {\"product_category\": \"Clothing\", \"customer_age\": 25, \"customer_location\": \"Los Angeles\"},\n        {\"product_category\": \"Home Appliances\", \"customer_age\": 45, \"customer_location\": \"Chicago\"},\n    ]\ndef aggregate_sales_data(sales_data: list) -> dict:\n    \"\"\"\n    Aggregates sales data by product category.\n    \n    :param sales_data: A list of sales records, where each record is a dictionary with the following keys:\n        - product_category (str): The category of the product.\n        - revenue (float): The revenue generated from the sale.\n    :return: A dictionary with aggregated sales revenue by product category, where the keys are product categories \n             and the values are the aggregated revenues (float).\n    \"\"\"\n    aggregated_data = {}\n    for record in sales_data:\n        category = record[\"product_category\"]\n        revenue = record[\"revenue\"]\n        if category not in aggregated_data:\n            aggregated_data[category] = 0.0\n        aggregated_data[category] += revenue\n    \n    return aggregated_data\ndef consolidate_data(sales_data_aggregated: dict, customer_data: list) -> dict:\n    \"\"\"\n    Consolidates aggregated sales data with customer demographic data.\n    \n    :param sales_data_aggregated: A dictionary with aggregated sales revenue by product category.\n    :param customer_data: A list of customer records.\n    :return: A consolidated dictionary with the following keys:\n        - product_category (str): The category of the product.\n        - total_revenue (float): The total revenue for the product category.\n        - customer_info (list): A list of dictionaries with customer demographic information for the product category.\n    \"\"\"\n    consolidated = {}\n    for category, revenue in sales_data_aggregated.items():\n        associated_customers = [customer for customer in customer_data if customer[\"product_category\"] == category]\n        consolidated[category] = {\n            \"total_revenue\": revenue,\n            \"customer_info\": associated_customers\n        }\n    \n    return consolidated\ndef generate_report(consolidated_data: dict) -> str:\n    \"\"\"\n    Generates a report from the consolidated data.\n    \n    :param consolidated_data: A consolidated dictionary with product category, total revenue, and customer information.\n    :return: A string representing the report.\n    \"\"\"\n    report_lines = [\"Sales Report for Q1 and Q2 2024:\\n\"]\n    for category, details in consolidated_data.items():\n        report_lines.append(f\"Product Category: {category}\")\n        report_lines.append(f\"Total Revenue: ${details['total_revenue']:.2f}\")\n        report_lines.append(\"Customer Information:\")\n        for customer in details[\"customer_info\"]:\n            report_lines.append(f\"  Age: {customer['customer_age']}, Location: {customer['customer_location']}\")\n        report_lines.append(\"\")  # Separator between categories\n    \n    return \"\\n\".join(report_lines)", "user_query": "Sarah here. Can you extract sales data from warehouse WA-2024-Q1?", "checklist": {"functions": ["extract_sales_data"], "values": [[{"product_category": "Electronics", "revenue": 1500.0}, {"product_category": "Clothing", "revenue": 2000.0}, {"product_category": "Electronics", "revenue": 2500.0}]]}}
{"difficulty": "easy", "function_schema_python": "def extract_website_data(source_id: str, start_date: str, end_date: str) -> dict:\n    \"\"\"Extracts website analytics data from a specified source between given dates.\n\n    :param source_id: The identifier of the data source (e.g., \"GT-Web-Analytics-2024\").\n    :param start_date: The start date in the format \"YYYY-MM-DD\".\n    :param end_date: The end date in the format \"YYYY-MM-DD\".\n    :return:\n        dict: A dictionary with the following keys:\n            - user_ids (list[int]): List of user IDs.\n            - timestamps (list[str]): List of timestamps in the format \"YYYY-MM-DD HH:MM:SS\".\n            - product_ids (list[str]): List of product IDs.\n            - visits (list[int]): Number of visits for each user/product entry.\n    :raises ValueError: If any parameter is invalid.\"\"\"\n    pass\ndef extract_social_media_data(source_id: str, start_date: str, end_date: str) -> dict:\n    \"\"\"Extracts social media engagement data from a specified source between given dates.\n\n    :param source_id: The identifier of the data source (e.g., \"GT-Social-2024\").\n    :param start_date: The start date in the format \"YYYY-MM-DD\".\n    :param end_date: The end date in the format \"YYYY-MM-DD\".\n    :return:\n        dict: A dictionary with the following keys:\n            - user_ids (list[int]): List of user IDs.\n            - timestamps (list[str]): List of timestamps in the format \"YYYY-MM-DD HH:MM:SS\".\n            - product_ids (list[str]): List of product IDs.\n            - likes (list[int]): Number of likes for each user/product entry.\n            - shares (list[int]): Number of shares for each user/product entry.\n            - comments (list[int]): Number of comments for each user/product entry.\n    :raises ValueError: If any parameter is invalid.\"\"\"\n    pass\ndef aggregate_daily_engagement(web_data: dict, social_data: dict) -> dict:\n    \"\"\"Aggregates daily engagement data from website and social media sources for each product.\n\n    :param web_data: Website analytics data dictionary.\n    :param social_data: Social media engagement data dictionary.\n    :return:\n        dict: A dictionary with the following keys:\n            - product_ids (list[str]): List of product IDs.\n            - dates (list[str]): List of dates in the format \"YYYY-MM-DD\".\n            - visits (list[int]): Total website visits for each product and date.\n            - likes (list[int]): Total likes for each product and date.\n            - shares (list[int]): Total shares for each product and date.\n            - comments (list[int]): Total comments for each product and date.\n    :raises ValueError: If any parameter is invalid.\"\"\"\n    pass\ndef generate_engagement_graph(aggregated_data: dict) -> str:\n    \"\"\"Generates a graph visualizing combined daily engagement metrics for each product.\n\n    :param aggregated_data: Aggregated engagement data dictionary.\n    :return:\n        str: A string representation of the generated graph.\n    :raises ValueError: If the aggregated data is invalid.\"\"\"\n    pass\n", "function_schema_json": [{"name": "extract_website_data", "description": "Extracts website analytics data from a specified source between given dates.", "parameters": {"type": "object", "properties": {"source_id": {"type": "string", "description": "The identifier of the data source (e.g., \"GT-Web-Analytics-2024\")."}, "start_date": {"type": "string", "description": "The start date in the format \"YYYY-MM-DD\"."}, "end_date": {"type": "string", "description": "The end date in the format \"YYYY-MM-DD\"."}}, "required": ["source_id", "start_date", "end_date"], "additionalProperties": false}}, {"name": "extract_social_media_data", "description": "Extracts social media engagement data from a specified source between given dates.", "parameters": {"type": "object", "properties": {"source_id": {"type": "string", "description": "The identifier of the data source (e.g., \"GT-Social-2024\")."}, "start_date": {"type": "string", "description": "The start date in the format \"YYYY-MM-DD\"."}, "end_date": {"type": "string", "description": "The end date in the format \"YYYY-MM-DD\"."}}, "required": ["source_id", "start_date", "end_date"], "additionalProperties": false}}, {"name": "aggregate_daily_engagement", "description": "Aggregates daily engagement data from website and social media sources for each product.", "parameters": {"type": "object", "properties": {"web_data": {"type": "object", "description": "Website analytics data dictionary."}, "social_data": {"type": "object", "description": "Social media engagement data dictionary."}}, "required": ["web_data", "social_data"], "additionalProperties": false}}, {"name": "generate_engagement_graph", "description": "Generates a graph visualizing combined daily engagement metrics for each product.", "parameters": {"type": "object", "properties": {"aggregated_data": {"type": "object", "description": "Aggregated engagement data dictionary."}}, "required": ["aggregated_data"], "additionalProperties": false}}], "mock_functions": "def extract_website_data(source_id: str, start_date: str, end_date: str) -> dict:\n    \"\"\"\n    Extracts website analytics data from a specified source between given dates.\n    \n    :param source_id: The identifier of the data source (e.g., \"GT-Web-Analytics-2024\").\n    :param start_date: The start date in the format \"YYYY-MM-DD\".\n    :param end_date: The end date in the format \"YYYY-MM-DD\".\n    :return:\n        dict: A dictionary with the following keys:\n            - user_ids (list[int]): List of user IDs.\n            - timestamps (list[str]): List of timestamps in the format \"YYYY-MM-DD HH:MM:SS\".\n            - product_ids (list[str]): List of product IDs.\n            - visits (list[int]): Number of visits for each user/product entry.\n    :raises ValueError: If any parameter is invalid.\n    \"\"\"\n    if not source_id or not start_date or not end_date:\n        raise ValueError(\"Source ID, start date, and end date must be provided.\")\n    if source_id != \"GT-Web-Analytics-2024\":\n        raise ValueError(\"Invalid source ID.\")\n    if start_date > end_date:\n        raise ValueError(\"Start date must be before end date.\")\n    \n    # Mock data\n    return {\n        \"user_ids\": [101, 102, 103],\n        \"timestamps\": [\"2024-07-01 12:34:56\", \"2024-07-01 15:01:01\", \"2024-07-02 08:23:45\"],\n        \"product_ids\": [\"P001\", \"P002\", \"P001\"],\n        \"visits\": [1, 1, 2]\n    }\ndef extract_social_media_data(source_id: str, start_date: str, end_date: str) -> dict:\n    \"\"\"\n    Extracts social media engagement data from a specified source between given dates.\n    \n    :param source_id: The identifier of the data source (e.g., \"GT-Social-2024\").\n    :param start_date: The start date in the format \"YYYY-MM-DD\".\n    :param end_date: The end date in the format \"YYYY-MM-DD\".\n    :return:\n        dict: A dictionary with the following keys:\n            - user_ids (list[int]): List of user IDs.\n            - timestamps (list[str]): List of timestamps in the format \"YYYY-MM-DD HH:MM:SS\".\n            - product_ids (list[str]): List of product IDs.\n            - likes (list[int]): Number of likes for each user/product entry.\n            - shares (list[int]): Number of shares for each user/product entry.\n            - comments (list[int]): Number of comments for each user/product entry.\n    :raises ValueError: If any parameter is invalid.\n    \"\"\"\n    if not source_id or not start_date or not end_date:\n        raise ValueError(\"Source ID, start date, and end date must be provided.\")\n    if source_id != \"GT-Social-2024\":\n        raise ValueError(\"Invalid source ID.\")\n    if start_date > end_date:\n        raise ValueError(\"Start date must be before end date.\")\n    \n    # Mock data\n    return {\n        \"user_ids\": [101, 102, 103],\n        \"timestamps\": [\"2024-07-01 13:01:01\", \"2024-07-01 16:34:56\", \"2024-07-02 09:30:45\"],\n        \"product_ids\": [\"P001\", \"P002\", \"P001\"],\n        \"likes\": [5, 3, 7],\n        \"shares\": [2, 1, 3],\n        \"comments\": [1, 0, 2]\n    }\ndef aggregate_daily_engagement(web_data: dict, social_data: dict) -> dict:\n    \"\"\"\n    Aggregates daily engagement data from website and social media sources for each product.\n    \n    :param web_data: Website analytics data dictionary.\n    :param social_data: Social media engagement data dictionary.\n    :return:\n        dict: A dictionary with the following keys:\n            - product_ids (list[str]): List of product IDs.\n            - dates (list[str]): List of dates in the format \"YYYY-MM-DD\".\n            - visits (list[int]): Total website visits for each product and date.\n            - likes (list[int]): Total likes for each product and date.\n            - shares (list[int]): Total shares for each product and date.\n            - comments (list[int]): Total comments for each product and date.\n    :raises ValueError: If any parameter is invalid.\n    \"\"\"\n    if not web_data or not social_data:\n        raise ValueError(\"Website and social data must be provided.\")\n    \n    # Mock aggregation logic\n    aggregated_data = {\n        \"product_ids\": [\"P001\", \"P001\", \"P002\"],\n        \"dates\": [\"2024-07-01\", \"2024-07-02\", \"2024-07-01\"],\n        \"visits\": [3, 2, 1],\n        \"likes\": [12, 7, 3],\n        \"shares\": [5, 3, 1],\n        \"comments\": [3, 2, 0]\n    }\n    return aggregated_data\ndef generate_engagement_graph(aggregated_data: dict) -> str:\n    \"\"\"\n    Generates a graph visualizing combined daily engagement metrics for each product.\n    \n    :param aggregated_data: Aggregated engagement data dictionary.\n    :return:\n        str: A string representation of the generated graph.\n    :raises ValueError: If the aggregated data is invalid.\n    \"\"\"\n    if not aggregated_data:\n        raise ValueError(\"Aggregated data must be provided.\")\n    \n    # Mock graph generation logic\n    return f\"Graph generated for products: {aggregated_data['product_ids']} on dates: {aggregated_data['dates']} with combined metrics.\"", "user_query": "David from Global Trends Inc. here. Please extract website data from GT-Web-Analytics-2024 between 2024-07-01 and 2024-08-31.", "checklist": {"functions": ["extract_website_data"], "values": [{"user_ids": [101, 102, 103], "timestamps": ["2024-07-01 12:34:56", "2024-07-01 15:01:01", "2024-07-02 08:23:45"], "product_ids": ["P001", "P002", "P001"], "visits": [1, 1, 2]}]}}
{"difficulty": "easy", "function_schema_python": "def scrape_patient_data(url: str, file_format: str) -> str:\n    \"\"\"Scrapes patient health data from a specified URL in the given format.\n\n    :param url: The URL from which to scrape the data.\n    :param file_format: The format of the data file (e.g., \"CSV\", \"XML\", \"JSON\").\n    :return: A string indicating the success of the task.\n    :raises ValueError: If an unsupported file format is provided.\"\"\"\n    pass\ndef transform_with_polars(df: object, transformation_config: dict) -> object:\n    \"\"\"Transforms a DataFrame using Polars based on the provided configuration.\n\n    :param df: The input DataFrame to be transformed.\n    :param transformation_config: A dictionary containing transformation rules.\n    :return: The transformed DataFrame.\n    :raises ValueError: If the DataFrame or transformation_config is invalid.\"\"\"\n    pass\ndef normalize_data(df: object, normalization_rules: dict) -> object:\n    \"\"\"Normalizes a DataFrame based on given normalization rules.\n\n    :param df: The input DataFrame to be normalized.\n    :param normalization_rules: A dictionary containing normalization rules.\n    :return: The normalized DataFrame.\n    :raises ValueError: If the DataFrame or normalization_rules is invalid.\"\"\"\n    pass\ndef convert_units(df: object, conversion_rules: dict) -> object:\n    \"\"\"Converts units of measurement in a DataFrame based on given rules.\n\n    :param df: The input DataFrame containing raw measurements.\n    :param conversion_rules: A dictionary containing unit conversion rules.\n    :return: The DataFrame with converted measurements.\n    :raises ValueError: If the DataFrame or conversion_rules is invalid.\"\"\"\n    pass\ndef ensure_data_integrity(df: object, validation_rules: dict) -> bool:\n    \"\"\"Ensures the integrity of data in a DataFrame using specified validation rules.\n\n    :param df: The DataFrame to be validated.\n    :param validation_rules: A dictionary containing validation rules.\n    :return: True if data integrity is ensured, False otherwise.\n    :raises ValueError: If the DataFrame or validation_rules is invalid.\"\"\"\n    pass\ndef create_airflow_dag(dag_id: str, task_details: list) -> dict:\n    \"\"\"Creates an Airflow DAG with the specified tasks.\n\n    :param dag_id: The unique identifier for the DAG.\n    :param task_details: A list of dictionaries containing task details.\n    :return: A dictionary representing the DAG with the following keys:\n        - dag_id (str): The ID of the DAG.\n        - tasks (list[dict]): A list of dictionaries representing each task.\n    :raises ValueError: If dag_id is empty or task_details is invalid.\"\"\"\n    pass\n", "function_schema_json": [{"name": "scrape_patient_data", "description": "Scrapes patient health data from a specified URL in the given format.", "parameters": {"type": "object", "properties": {"url": {"type": "string", "description": "The URL from which to scrape the data."}, "file_format": {"type": "string", "description": "The format of the data file (e.g., \"CSV\", \"XML\", \"JSON\")."}}, "required": ["url", "file_format"], "additionalProperties": false}}, {"name": "transform_with_polars", "description": "Transforms a DataFrame using Polars based on the provided configuration.", "parameters": {"type": "object", "properties": {"df": {"type": "string", "description": "The input DataFrame to be transformed."}, "transformation_config": {"type": "object", "description": "A dictionary containing transformation rules."}}, "required": ["df", "transformation_config"], "additionalProperties": false}}, {"name": "normalize_data", "description": "Normalizes a DataFrame based on given normalization rules.", "parameters": {"type": "object", "properties": {"df": {"type": "string", "description": "The input DataFrame to be normalized."}, "normalization_rules": {"type": "object", "description": "A dictionary containing normalization rules."}}, "required": ["df", "normalization_rules"], "additionalProperties": false}}, {"name": "convert_units", "description": "Converts units of measurement in a DataFrame based on given rules.", "parameters": {"type": "object", "properties": {"df": {"type": "string", "description": "The input DataFrame containing raw measurements."}, "conversion_rules": {"type": "object", "description": "A dictionary containing unit conversion rules."}}, "required": ["df", "conversion_rules"], "additionalProperties": false}}, {"name": "ensure_data_integrity", "description": "Ensures the integrity of data in a DataFrame using specified validation rules.", "parameters": {"type": "object", "properties": {"df": {"type": "string", "description": "The DataFrame to be validated."}, "validation_rules": {"type": "object", "description": "A dictionary containing validation rules."}}, "required": ["df", "validation_rules"], "additionalProperties": false}}, {"name": "create_airflow_dag", "description": "Creates an Airflow DAG with the specified tasks.", "parameters": {"type": "object", "properties": {"dag_id": {"type": "string", "description": "The unique identifier for the DAG."}, "task_details": {"type": "array", "description": "A list of dictionaries containing task details."}}, "required": ["dag_id", "task_details"], "additionalProperties": false}}], "mock_functions": "def scrape_patient_data(url: str, file_format: str) -> str:\n    \"\"\"\n    Scrapes patient health data from a specified URL in the given format.\n    \n    :param url: The URL from which to scrape the data.\n    :param file_format: The format of the data file (e.g., \"CSV\", \"XML\", \"JSON\").\n    :return: A string indicating the success of the task.\n    :raises ValueError: If an unsupported file format is provided.\n    \"\"\"\n    if file_format.upper() not in [\"CSV\", \"XML\", \"JSON\"]:\n        raise ValueError(\"Unsupported file format. Please use 'CSV', 'XML', or 'JSON'.\")\n    return f\"Data successfully scraped from {url} in {file_format} format.\"\ndef transform_with_polars(df: object, transformation_config: dict) -> object:\n    \"\"\"\n    Transforms a DataFrame using Polars based on the provided configuration.\n    \n    :param df: The input DataFrame to be transformed.\n    :param transformation_config: A dictionary containing transformation rules.\n    :return: The transformed DataFrame.\n    :raises ValueError: If the DataFrame or transformation_config is invalid.\n    \"\"\"\n    if not df or not isinstance(transformation_config, dict):\n        raise ValueError(\"Invalid DataFrame or transformation configuration.\")\n    # Mock implementation: Return a new DataFrame object\n    transformed_df = df  # In a real scenario, df would be transformed\n    return transformed_df\ndef normalize_data(df: object, normalization_rules: dict) -> object:\n    \"\"\"\n    Normalizes a DataFrame based on given normalization rules.\n    \n    :param df: The input DataFrame to be normalized.\n    :param normalization_rules: A dictionary containing normalization rules.\n    :return: The normalized DataFrame.\n    :raises ValueError: If the DataFrame or normalization_rules is invalid.\n    \"\"\"\n    if not df or not isinstance(normalization_rules, dict):\n        raise ValueError(\"Invalid DataFrame or normalization rules.\")\n    # Mock implementation: Return a new DataFrame object\n    normalized_df = df  # In a real scenario, df would be normalized\n    return normalized_df\ndef convert_units(df: object, conversion_rules: dict) -> object:\n    \"\"\"\n    Converts units of measurement in a DataFrame based on given rules.\n    \n    :param df: The input DataFrame containing raw measurements.\n    :param conversion_rules: A dictionary containing unit conversion rules.\n    :return: The DataFrame with converted measurements.\n    :raises ValueError: If the DataFrame or conversion_rules is invalid.\n    \"\"\"\n    if not df or not isinstance(conversion_rules, dict):\n        raise ValueError(\"Invalid DataFrame or conversion rules.\")\n    # Mock implementation: Return a new DataFrame object\n    converted_df = df  # In a real scenario, df would have new units\n    return converted_df\ndef ensure_data_integrity(df: object, validation_rules: dict) -> bool:\n    \"\"\"\n    Ensures the integrity of data in a DataFrame using specified validation rules.\n    \n    :param df: The DataFrame to be validated.\n    :param validation_rules: A dictionary containing validation rules.\n    :return: True if data integrity is ensured, False otherwise.\n    :raises ValueError: If the DataFrame or validation_rules is invalid.\n    \"\"\"\n    if not df or not isinstance(validation_rules, dict):\n        raise ValueError(\"Invalid DataFrame or validation rules.\")\n    # Mock implementation: Assume data integrity is ensured\n    data_integrity_ensured = True\n    return data_integrity_ensured\ndef create_airflow_dag(dag_id: str, task_details: list) -> dict:\n    \"\"\"\n    Creates an Airflow DAG with the specified tasks.\n    \n    :param dag_id: The unique identifier for the DAG.\n    :param task_details: A list of dictionaries containing task details.\n    :return: A dictionary representing the DAG with the following keys:\n        - dag_id (str): The ID of the DAG.\n        - tasks (list[dict]): A list of dictionaries representing each task.\n    :raises ValueError: If dag_id is empty or task_details is invalid.\n    \"\"\"\n    if not dag_id or not isinstance(task_details, list):\n        raise ValueError(\"dag_id must be non-empty, and task_details must be a list.\")\n    # Mock implementation: Create a DAG representation as a dictionary\n    dag_representation = {\n        \"dag_id\": dag_id,\n        \"tasks\": task_details\n    }\n    return dag_representation", "user_query": "Can you scrape patient health data from https://clinicdata.medtech.com/records in CSV format?", "checklist": {"functions": ["scrape_patient_data"], "values": ["Data successfully scraped from https://clinicdata.medtech.com/records in CSV format."]}}
{"difficulty": "easy", "function_schema_python": "def convert_currency(data: list, source_currency: str, target_currency: str) -> list:\n    \"\"\"Converts transaction data from source currency to target currency.\n\n    :param data: List of transaction amounts in source currency.\n    :param source_currency: Three-letter code for the source currency.\n    :param target_currency: Three-letter code for the target currency.\n    :return: List of transaction amounts converted to the target currency.\n    :raises ValueError: If input data is not a list or currency codes are invalid.\"\"\"\n    pass\ndef standardize_timestamps(data: list, timezone: str) -> list:\n    \"\"\"Standardizes timestamps to a specified timezone.\n\n    :param data: List of timestamps to standardize.\n    :param timezone: Destination timezone in 'Area/Location' format.\n    :return: List of timestamps standardized to the specified timezone.\n    :raises ValueError: If input data is not a list or timezone is invalid.\"\"\"\n    pass\ndef clean_financial_records(data: list) -> dict:\n    \"\"\"Cleans inconsistent financial records.\n\n    :param data: List of financial records to clean.\n    :return:\n        dict: A dictionary with the following keys:\n            - cleaned_data (list): List of cleaned financial records.\n            - removed_records (list): List of removed records due to inconsistencies.\n    :raises ValueError: If input data is not a list.\"\"\"\n    pass\n", "function_schema_json": [{"name": "convert_currency", "description": "Converts transaction data from source currency to target currency.", "parameters": {"type": "object", "properties": {"data": {"type": "array", "description": "List of transaction amounts in source currency."}, "source_currency": {"type": "string", "description": "Three-letter code for the source currency."}, "target_currency": {"type": "string", "description": "Three-letter code for the target currency."}}, "required": ["data", "source_currency", "target_currency"], "additionalProperties": false}}, {"name": "standardize_timestamps", "description": "Standardizes timestamps to a specified timezone.", "parameters": {"type": "object", "properties": {"data": {"type": "array", "description": "List of timestamps to standardize."}, "timezone": {"type": "string", "description": "Destination timezone in 'Area/Location' format."}}, "required": ["data", "timezone"], "additionalProperties": false}}, {"name": "clean_financial_records", "description": "Cleans inconsistent financial records.", "parameters": {"type": "object", "properties": {"data": {"type": "array", "description": "List of financial records to clean."}}, "required": ["data"], "additionalProperties": false}}], "mock_functions": "def convert_currency(data: list, source_currency: str, target_currency: str) -> list:\n    \"\"\"\n    Converts transaction data from source currency to target currency.\n    \n    :param data: List of transaction amounts in source currency.\n    :param source_currency: Three-letter code for the source currency.\n    :param target_currency: Three-letter code for the target currency.\n    :return: List of transaction amounts converted to the target currency.\n    :raises ValueError: If input data is not a list or currency codes are invalid.\n    \"\"\"\n    if not isinstance(data, list) or not all(isinstance(x, (int, float)) for x in data):\n        raise ValueError(\"Data must be a list of numeric transaction amounts.\")\n    if len(source_currency) != 3 or len(target_currency) != 3:\n        raise ValueError(\"Currency codes must be three-letter ISO codes.\")\n    \n    # Mock conversion rate (e.g., 1 USD = 0.85 EUR)\n    conversion_rate = 0.85 if source_currency == \"USD\" and target_currency == \"EUR\" else 1.0\n    \n    return [amount * conversion_rate for amount in data]\ndef standardize_timestamps(data: list, timezone: str) -> list:\n    \"\"\"\n    Standardizes timestamps to a specified timezone.\n    \n    :param data: List of timestamps to standardize.\n    :param timezone: Destination timezone in 'Area/Location' format.\n    :return: List of timestamps standardized to the specified timezone.\n    :raises ValueError: If input data is not a list or timezone is invalid.\n    \"\"\"\n    if not isinstance(data, list) or not all(isinstance(x, str) for x in data):\n        raise ValueError(\"Data must be a list of string timestamp representations.\")\n    if not timezone:\n        raise ValueError(\"Timezone must be provided.\")\n    \n    # Mock standardization by appending the timezone string\n    return [f\"{timestamp} {timezone}\" for timestamp in data]\ndef clean_financial_records(data: list) -> dict:\n    \"\"\"\n    Cleans inconsistent financial records.\n    \n    :param data: List of financial records to clean.\n    :return:\n        dict: A dictionary with the following keys:\n            - cleaned_data (list): List of cleaned financial records.\n            - removed_records (list): List of removed records due to inconsistencies.\n    :raises ValueError: If input data is not a list.\n    \"\"\"\n    if not isinstance(data, list):\n        raise ValueError(\"Data must be a list of financial records.\")\n    \n    # Mock cleaning logic: remove records with negative amounts\n    cleaned_data = [record for record in data if record['amount'] >= 0]\n    removed_records = [record for record in data if record['amount'] < 0]\n    \n    return {\n        \"cleaned_data\": cleaned_data,\n        \"removed_records\": removed_records\n    }\n", "user_query": "Can you convert the transaction amounts in this list: [100, 200, 300] from USD to EUR?", "checklist": {"functions": ["convert_currency"], "values": [[85.0, 170.0, 255.0]]}}
{"difficulty": "easy", "function_schema_python": "def convert_currency(data: list, source_currency: str, target_currency: str) -> list:\n    \"\"\"Converts transaction data from source currency to target currency.\n\n    :param data: List of transaction amounts in source currency.\n    :param source_currency: Three-letter code for the source currency.\n    :param target_currency: Three-letter code for the target currency.\n    :return: List of transaction amounts converted to the target currency.\n    :raises ValueError: If input data is not a list or currency codes are invalid.\"\"\"\n    pass\ndef standardize_timestamps(data: list, timezone: str) -> list:\n    \"\"\"Standardizes timestamps to a specified timezone.\n\n    :param data: List of timestamps to standardize.\n    :param timezone: Destination timezone in 'Area/Location' format.\n    :return: List of timestamps standardized to the specified timezone.\n    :raises ValueError: If input data is not a list or timezone is invalid.\"\"\"\n    pass\ndef clean_financial_records(data: list) -> dict:\n    \"\"\"Cleans inconsistent financial records.\n\n    :param data: List of financial records to clean.\n    :return:\n        dict: A dictionary with the following keys:\n            - cleaned_data (list): List of cleaned financial records.\n            - removed_records (list): List of removed records due to inconsistencies.\n    :raises ValueError: If input data is not a list.\"\"\"\n    pass\n", "function_schema_json": [{"name": "convert_currency", "description": "Converts transaction data from source currency to target currency.", "parameters": {"type": "object", "properties": {"data": {"type": "array", "description": "List of transaction amounts in source currency."}, "source_currency": {"type": "string", "description": "Three-letter code for the source currency."}, "target_currency": {"type": "string", "description": "Three-letter code for the target currency."}}, "required": ["data", "source_currency", "target_currency"], "additionalProperties": false}}, {"name": "standardize_timestamps", "description": "Standardizes timestamps to a specified timezone.", "parameters": {"type": "object", "properties": {"data": {"type": "array", "description": "List of timestamps to standardize."}, "timezone": {"type": "string", "description": "Destination timezone in 'Area/Location' format."}}, "required": ["data", "timezone"], "additionalProperties": false}}, {"name": "clean_financial_records", "description": "Cleans inconsistent financial records.", "parameters": {"type": "object", "properties": {"data": {"type": "array", "description": "List of financial records to clean."}}, "required": ["data"], "additionalProperties": false}}], "mock_functions": "def convert_currency(data: list, source_currency: str, target_currency: str) -> list:\n    \"\"\"\n    Converts transaction data from source currency to target currency.\n    \n    :param data: List of transaction amounts in source currency.\n    :param source_currency: Three-letter code for the source currency.\n    :param target_currency: Three-letter code for the target currency.\n    :return: List of transaction amounts converted to the target currency.\n    :raises ValueError: If input data is not a list or currency codes are invalid.\n    \"\"\"\n    if not isinstance(data, list) or not all(isinstance(x, (int, float)) for x in data):\n        raise ValueError(\"Data must be a list of numeric transaction amounts.\")\n    if len(source_currency) != 3 or len(target_currency) != 3:\n        raise ValueError(\"Currency codes must be three-letter ISO codes.\")\n    \n    # Mock conversion rate (e.g., 1 USD = 0.85 EUR)\n    conversion_rate = 0.85 if source_currency == \"USD\" and target_currency == \"EUR\" else 1.0\n    \n    return [amount * conversion_rate for amount in data]\ndef standardize_timestamps(data: list, timezone: str) -> list:\n    \"\"\"\n    Standardizes timestamps to a specified timezone.\n    \n    :param data: List of timestamps to standardize.\n    :param timezone: Destination timezone in 'Area/Location' format.\n    :return: List of timestamps standardized to the specified timezone.\n    :raises ValueError: If input data is not a list or timezone is invalid.\n    \"\"\"\n    if not isinstance(data, list) or not all(isinstance(x, str) for x in data):\n        raise ValueError(\"Data must be a list of string timestamp representations.\")\n    if not timezone:\n        raise ValueError(\"Timezone must be provided.\")\n    \n    # Mock standardization by appending the timezone string\n    return [f\"{timestamp} {timezone}\" for timestamp in data]\ndef clean_financial_records(data: list) -> dict:\n    \"\"\"\n    Cleans inconsistent financial records.\n    \n    :param data: List of financial records to clean.\n    :return:\n        dict: A dictionary with the following keys:\n            - cleaned_data (list): List of cleaned financial records.\n            - removed_records (list): List of removed records due to inconsistencies.\n    :raises ValueError: If input data is not a list.\n    \"\"\"\n    if not isinstance(data, list):\n        raise ValueError(\"Data must be a list of financial records.\")\n    \n    # Mock cleaning logic: remove records with negative amounts\n    cleaned_data = [record for record in data if record['amount'] >= 0]\n    removed_records = [record for record in data if record['amount'] < 0]\n    \n    return {\n        \"cleaned_data\": cleaned_data,\n        \"removed_records\": removed_records\n    }\n", "user_query": "I have a list of timestamps: ['2024-01-20 10:00:00', '2024-01-21 12:30:00', '2024-01-22 15:45:00'].  Can you standardize them to America/New_York timezone?", "checklist": {"functions": ["standardize_timestamps"], "values": [["2024-01-20 10:00:00 America/New_York", "2024-01-21 12:30:00 America/New_York", "2024-01-22 15:45:00 America/New_York"]]}}
{"difficulty": "easy", "function_schema_python": "def generate_purchase_report(threshold: float, time_frame_months: int) -> str:\n    \"\"\"Generates a SQL query to retrieve the names, email addresses, and purchase amounts\n    of all customers who made purchases over a specified threshold in the last given months.\n\n    :param threshold: The purchase amount threshold (e.g., 1000 for over $1000).\n    :param time_frame_months: The time frame in months (e.g., 3 for the last three months).\n    :return: A string representing the SQL query.\n    :raises ValueError: If threshold is not a positive number or time_frame_months is not a positive integer.\"\"\"\n    pass\ndef connect_to_postgresql_database(connection_string: str) -> bool:\n    \"\"\"Attempts to connect to a PostgreSQL database using a given connection string.\n\n    :param connection_string: The connection string for the PostgreSQL database.\n    :return: True if the connection is successful, False otherwise.\"\"\"\n    pass\ndef execute_sql_query(connection: bool, query: str) -> list:\n    \"\"\"Executes a given SQL query on a database connection.\n\n    :param connection: The database connection object (mocked as a bool for this function).\n    :param query: The SQL query to be executed.\n    :return: A list of dictionaries representing the query results.\n    :raises RuntimeError: If the connection is not established.\n    :raises ValueError: If the query string is empty.\"\"\"\n    pass\n", "function_schema_json": [{"name": "generate_purchase_report", "description": "Generates a SQL query to retrieve the names, email addresses, and purchase amounts", "parameters": {"type": "object", "properties": {"threshold": {"type": "number", "description": "The purchase amount threshold (e.g., 1000 for over $1000)."}, "time_frame_months": {"type": "integer", "description": "The time frame in months (e.g., 3 for the last three months)."}}, "required": ["threshold", "time_frame_months"], "additionalProperties": false}}, {"name": "connect_to_postgresql_database", "description": "Attempts to connect to a PostgreSQL database using a given connection string.", "parameters": {"type": "object", "properties": {"connection_string": {"type": "string", "description": "The connection string for the PostgreSQL database."}}, "required": ["connection_string"], "additionalProperties": false}}, {"name": "execute_sql_query", "description": "Executes a given SQL query on a database connection.", "parameters": {"type": "object", "properties": {"connection": {"type": "boolean", "description": "The database connection object (mocked as a bool for this function)."}, "query": {"type": "string", "description": "The SQL query to be executed."}}, "required": ["connection", "query"], "additionalProperties": false}}], "mock_functions": "def generate_purchase_report(threshold: float, time_frame_months: int) -> str:\n    \"\"\"\n    Generates a SQL query to retrieve the names, email addresses, and purchase amounts\n    of all customers who made purchases over a specified threshold in the last given months.\n    \n    :param threshold: The purchase amount threshold (e.g., 1000 for over $1000).\n    :param time_frame_months: The time frame in months (e.g., 3 for the last three months).\n    :return: A string representing the SQL query.\n    :raises ValueError: If threshold is not a positive number or time_frame_months is not a positive integer.\n    \"\"\"\n    if threshold <= 0:\n        raise ValueError(\"Threshold must be a positive number.\")\n    if time_frame_months <= 0:\n        raise ValueError(\"Time frame in months must be a positive integer.\")\n    \n    query = f\"\"\"\n    SELECT customer_name, customer_email, purchase_amount\n    FROM purchases\n    WHERE purchase_amount > {threshold}\n    AND purchase_date >= CURRENT_DATE - INTERVAL '{time_frame_months} months';\n    \"\"\"\n    return query\ndef connect_to_postgresql_database(connection_string: str) -> bool:\n    \"\"\"\n    Attempts to connect to a PostgreSQL database using a given connection string.\n    \n    :param connection_string: The connection string for the PostgreSQL database.\n    :return: True if the connection is successful, False otherwise.\n    \"\"\"\n    # Mock logic: Handle a known connection string successfully, fail otherwise.\n    if connection_string == \"postgresql://user:password@localhost:5432/customers_db\":\n        return True\n    return False\ndef execute_sql_query(connection: bool, query: str) -> list:\n    \"\"\"\n    Executes a given SQL query on a database connection.\n    \n    :param connection: The database connection object (mocked as a bool for this function).\n    :param query: The SQL query to be executed.\n    :return: A list of dictionaries representing the query results.\n    :raises RuntimeError: If the connection is not established.\n    :raises ValueError: If the query string is empty.\n    \"\"\"\n    if not connection:\n        raise RuntimeError(\"Database connection is not established.\")\n    if not query:\n        raise ValueError(\"SQL query string must not be empty.\")\n    \n    # Mock logic: Return a list of dictionaries as the query result.\n    mock_results = [\n        {\"customer_name\": \"Alice Johnson\", \"customer_email\": \"alice.johnson@example.com\", \"purchase_amount\": 1200},\n        {\"customer_name\": \"Bob Smith\", \"customer_email\": \"bob.smith@example.com\", \"purchase_amount\": 1500}\n    ]\n    return mock_results", "user_query": "Alice needs to connect to the PostgreSQL database. Can you verify if the connection string \"postgresql://user:password@localhost:5432/customers_db\" is working?", "checklist": {"functions": ["connect_to_postgresql_database"], "values": [true]}}
{"difficulty": "easy", "function_schema_python": "def get_transaction_data(start_date: str, end_date: str, db_type: str) -> dict:\n    \"\"\"Retrieves transaction data for a specified date range.\n\n    :param start_date: Start date in ISO format (YYYY-MM-DD)\n    :param end_date: End date in ISO format (YYYY-MM-DD)\n    :param db_type: Database type to query from (postgresql or mongodb)\n    :return: Dictionary containing transaction data\n    :raises ValueError: If dates are invalid or db_type is not supported\"\"\"\n    pass\ndef analyze_transactions_by_type(transactions: list) -> dict:\n    \"\"\"Analyzes transactions and groups them by type.\n\n    :param transactions: List of transaction dictionaries with keys: type, amount, date\n    :return: Dictionary containing transaction counts and totals by type\n    :raises ValueError: If transaction data is invalid\"\"\"\n    pass\ndef generate_sql_query(transaction_types: list, time_period: str) -> str:\n    \"\"\"Generates a SQL query for analyzing transactions.\n\n    :param transaction_types: List of transaction types to analyze\n    :param time_period: Time period for analysis (e.g., 'last_month', 'last_week')\n    :return: SQL query string\n    :raises ValueError: If parameters are invalid\"\"\"\n    pass\n", "function_schema_json": [{"name": "get_transaction_data", "description": "Retrieves transaction data for a specified date range.", "parameters": {"type": "object", "properties": {"start_date": {"type": "string", "description": "Start date in ISO format (YYYY-MM-DD)"}, "end_date": {"type": "string", "description": "End date in ISO format (YYYY-MM-DD)"}, "db_type": {"type": "string", "description": "Database type to query from (postgresql or mongodb)"}}, "required": ["start_date", "end_date", "db_type"], "additionalProperties": false}}, {"name": "analyze_transactions_by_type", "description": "Analyzes transactions and groups them by type.", "parameters": {"type": "object", "properties": {"transactions": {"type": "array", "description": "List of transaction dictionaries with keys: type, amount, date"}}, "required": ["transactions"], "additionalProperties": false}}, {"name": "generate_sql_query", "description": "Generates a SQL query for analyzing transactions.", "parameters": {"type": "object", "properties": {"transaction_types": {"type": "array", "description": "List of transaction types to analyze"}, "time_period": {"type": "string", "description": "Time period for analysis (e.g., 'last_month', 'last_week')"}}, "required": ["transaction_types", "time_period"], "additionalProperties": false}}], "mock_functions": "def get_transaction_data(start_date: str, end_date: str, db_type: str = \"postgresql\") -> dict:\n    \"\"\"\n    Retrieves transaction data for a specified date range.\n    \n    :param start_date: Start date in ISO format (YYYY-MM-DD)\n    :param end_date: End date in ISO format (YYYY-MM-DD)\n    :param db_type: Database type to query from (postgresql or mongodb)\n    :return: Dictionary containing transaction data\n    :raises ValueError: If dates are invalid or db_type is not supported\n    \"\"\"\n    if not all([start_date, end_date]):\n        raise ValueError(\"Both start and end dates are required\")\n    \n    if db_type.lower() not in [\"postgresql\", \"mongodb\"]:\n        raise ValueError(\"Unsupported database type\")\n        \n    if start_date == \"2023-10-01\" and end_date == \"2023-10-31\":\n        return {\n            \"transactions\": [\n                {\"type\": \"PAYMENT\", \"amount\": 1000, \"date\": \"2023-10-15\"},\n                {\"type\": \"TRANSFER\", \"amount\": 500, \"date\": \"2023-10-16\"},\n                {\"type\": \"DEPOSIT\", \"amount\": 2000, \"date\": \"2023-10-17\"}\n            ]\n        }\n    return {\"transactions\": []}\ndef analyze_transactions_by_type(transactions: list) -> dict:\n    \"\"\"\n    Analyzes transactions and groups them by type.\n    \n    :param transactions: List of transaction dictionaries with keys: type, amount, date\n    :return: Dictionary containing transaction counts and totals by type\n    :raises ValueError: If transaction data is invalid\n    \"\"\"\n    if not isinstance(transactions, list):\n        raise ValueError(\"Transactions must be provided as a list\")\n        \n    if not all(isinstance(t, dict) and \"type\" in t for t in transactions):\n        raise ValueError(\"Invalid transaction format\")\n        \n    return {\n        \"transaction_summary\": {\n            \"PAYMENT\": {\"count\": 150, \"total_amount\": 75000},\n            \"TRANSFER\": {\"count\": 89, \"total_amount\": 44500},\n            \"DEPOSIT\": {\"count\": 45, \"total_amount\": 90000}\n        },\n        \"total_transactions\": 284,\n        \"total_amount\": 209500\n    }\ndef generate_sql_query(transaction_types: list, time_period: str) -> str:\n    \"\"\"\n    Generates a SQL query for analyzing transactions.\n    \n    :param transaction_types: List of transaction types to analyze\n    :param time_period: Time period for analysis (e.g., 'last_month', 'last_week')\n    :return: SQL query string\n    :raises ValueError: If parameters are invalid\n    \"\"\"\n    if not transaction_types or not time_period:\n        raise ValueError(\"Transaction types and time period must be provided\")\n        \n    if time_period.lower() == \"last_month\":\n        return \"\"\"\n        SELECT transaction_type, COUNT(*) as transaction_count\n        FROM transactions\n        WHERE transaction_date >= DATE_TRUNC('month', CURRENT_DATE - INTERVAL '1' MONTH)\n        AND transaction_date < DATE_TRUNC('month', CURRENT_DATE)\n        GROUP BY transaction_type\n        ORDER BY transaction_count DESC;\n        \"\"\"\n    return \"\"", "user_query": "Can you get the transaction data from postgresql database between 2023-10-01 and 2023-10-31?", "checklist": {"functions": ["get_transaction_data"], "values": [{"transactions": [{"type": "PAYMENT", "amount": 1000, "date": "2023-10-15"}, {"type": "TRANSFER", "amount": 500, "date": "2023-10-16"}, {"type": "DEPOSIT", "amount": 2000, "date": "2023-10-17"}]}]}}
{"difficulty": "easy", "function_schema_python": "def get_query_execution_plan(query_id: str, db_instance_id: str) -> dict:\n    \"\"\"Retrieves the query execution plan for a given query ID on a specified database instance.\n\n    :param query_id: The ID of the query for which the execution plan is requested.\n    :param db_instance_id: The ID of the database instance.\n    :return:\n        dict: A dictionary with the following keys:\n            - query (str): The SQL query.\n            - execution_plan (str): The execution plan of the query.\n    :raises ValueError: If query_id or db_instance_id is empty or incorrect.\"\"\"\n    pass\ndef analyze_query_performance(query_id: str, db_instance_id: str, time_range: str) -> dict:\n    \"\"\"Analyzes the performance of a given query over a specified time range on a database instance.\n\n    :param query_id: The ID of the query for which performance is analyzed.\n    :param db_instance_id: The ID of the database instance.\n    :param time_range: The time range for the analysis (e.g., \"last 24 hours\").\n    :return:\n        dict: A dictionary with the following keys:\n            - query_id (str): The ID of the query.\n            - avg_execution_time (float): Average execution time of the query in milliseconds.\n            - execution_count (int): Number of times the query was executed.\n    :raises ValueError: If any parameter is empty or incorrect.\"\"\"\n    pass\ndef suggest_indexing_strategy(query_execution_plan: dict) -> list:\n    \"\"\"Suggests indexing strategies based on the provided query execution plan.\n\n    :param query_execution_plan: A dictionary containing the query and its execution plan.\n    :return:\n        list: A list of indexing suggestions.\n    :raises ValueError: If the query execution plan is empty or incorrect.\"\"\"\n    pass\ndef generate_performance_report(query_id: str, db_instance_id: str, time_range: str) -> dict:\n    \"\"\"Generates a performance report for a given query over a specified time range on a database instance.\n\n    :param query_id: The ID of the query for which the report is generated.\n    :param db_instance_id: The ID of the database instance.\n    :param time_range: The time range for the performance analysis (e.g., \"last 24 hours\").\n    :return:\n        dict: A dictionary with the following keys:\n            - query_id (str): The ID of the query.\n            - avg_execution_time (float): Average execution time of the query in milliseconds.\n            - execution_count (int): Number of times the query was executed.\n            - indexing_suggestions (list): List of suggested indexing strategies.\n    :raises ValueError: If any parameter is empty or incorrect.\"\"\"\n    pass\n", "function_schema_json": [{"name": "get_query_execution_plan", "description": "Retrieves the query execution plan for a given query ID on a specified database instance.", "parameters": {"type": "object", "properties": {"query_id": {"type": "string", "description": "The ID of the query for which the execution plan is requested."}, "db_instance_id": {"type": "string", "description": "The ID of the database instance."}}, "required": ["query_id", "db_instance_id"], "additionalProperties": false}}, {"name": "analyze_query_performance", "description": "Analyzes the performance of a given query over a specified time range on a database instance.", "parameters": {"type": "object", "properties": {"query_id": {"type": "string", "description": "The ID of the query for which performance is analyzed."}, "db_instance_id": {"type": "string", "description": "The ID of the database instance."}, "time_range": {"type": "string", "description": "The time range for the analysis (e.g., \"last 24 hours\")."}}, "required": ["query_id", "db_instance_id", "time_range"], "additionalProperties": false}}, {"name": "suggest_indexing_strategy", "description": "Suggests indexing strategies based on the provided query execution plan.", "parameters": {"type": "object", "properties": {"query_execution_plan": {"type": "object", "description": "A dictionary containing the query and its execution plan."}}, "required": ["query_execution_plan"], "additionalProperties": false}}, {"name": "generate_performance_report", "description": "Generates a performance report for a given query over a specified time range on a database instance.", "parameters": {"type": "object", "properties": {"query_id": {"type": "string", "description": "The ID of the query for which the report is generated."}, "db_instance_id": {"type": "string", "description": "The ID of the database instance."}, "time_range": {"type": "string", "description": "The time range for the performance analysis (e.g., \"last 24 hours\")."}}, "required": ["query_id", "db_instance_id", "time_range"], "additionalProperties": false}}], "mock_functions": "def get_query_execution_plan(query_id: str, db_instance_id: str) -> dict:\n    \"\"\"\n    Retrieves the query execution plan for a given query ID on a specified database instance.\n    \n    :param query_id: The ID of the query for which the execution plan is requested.\n    :param db_instance_id: The ID of the database instance.\n    :return:\n        dict: A dictionary with the following keys:\n            - query (str): The SQL query.\n            - execution_plan (str): The execution plan of the query.\n    :raises ValueError: If query_id or db_instance_id is empty or incorrect.\n    \"\"\"\n    if not query_id or not db_instance_id:\n        raise ValueError(\"Query ID and database instance ID must be provided.\")\n    if query_id == \"customerSearch\" and db_instance_id == \"db-instance-XYZ123\":\n        return {\n            \"query\": \"SELECT * FROM customers WHERE name = 'John Doe'\",\n            \"execution_plan\": \"Seq Scan on customers\"  # Simplified execution plan\n        }\n    return {}\ndef analyze_query_performance(query_id: str, db_instance_id: str, time_range: str) -> dict:\n    \"\"\"\n    Analyzes the performance of a given query over a specified time range on a database instance.\n    \n    :param query_id: The ID of the query for which performance is analyzed.\n    :param db_instance_id: The ID of the database instance.\n    :param time_range: The time range for the analysis (e.g., \"last 24 hours\").\n    :return:\n        dict: A dictionary with the following keys:\n            - query_id (str): The ID of the query.\n            - avg_execution_time (float): Average execution time of the query in milliseconds.\n            - execution_count (int): Number of times the query was executed.\n    :raises ValueError: If any parameter is empty or incorrect.\n    \"\"\"\n    if not query_id or not db_instance_id or not time_range:\n        raise ValueError(\"Query ID, database instance ID, and time range must be provided.\")\n    if query_id == \"customerSearch\" and db_instance_id == \"db-instance-XYZ123\" and time_range == \"last 24 hours\":\n        return {\n            \"query_id\": \"customerSearch\",\n            \"avg_execution_time\": 150.25,\n            \"execution_count\": 120\n        }\n    return {}\ndef suggest_indexing_strategy(query_execution_plan: dict) -> list:\n    \"\"\"\n    Suggests indexing strategies based on the provided query execution plan.\n    \n    :param query_execution_plan: A dictionary containing the query and its execution plan.\n    :return:\n        list: A list of indexing suggestions.\n    :raises ValueError: If the query execution plan is empty or incorrect.\n    \"\"\"\n    if not query_execution_plan or not query_execution_plan.get(\"execution_plan\"):\n        raise ValueError(\"A valid query execution plan must be provided.\")\n    if \"Seq Scan\" in query_execution_plan.get(\"execution_plan\"):\n        return [\"Create index on customers(name)\"]\n    return []\ndef generate_performance_report(query_id: str, db_instance_id: str, time_range: str) -> dict:\n    \"\"\"\n    Generates a performance report for a given query over a specified time range on a database instance.\n    \n    :param query_id: The ID of the query for which the report is generated.\n    :param db_instance_id: The ID of the database instance.\n    :param time_range: The time range for the performance analysis (e.g., \"last 24 hours\").\n    :return:\n        dict: A dictionary with the following keys:\n            - query_id (str): The ID of the query.\n            - avg_execution_time (float): Average execution time of the query in milliseconds.\n            - execution_count (int): Number of times the query was executed.\n            - indexing_suggestions (list): List of suggested indexing strategies.\n    :raises ValueError: If any parameter is empty or incorrect.\n    \"\"\"\n    performance_data = analyze_query_performance(query_id, db_instance_id, time_range)\n    query_execution_plan = get_query_execution_plan(query_id, db_instance_id)\n    indexing_suggestions = suggest_indexing_strategy(query_execution_plan)\n    \n    if not performance_data or not indexing_suggestions:\n        raise ValueError(\"Unable to generate a performance report with the provided data.\")\n    \n    return {\n        \"query_id\": performance_data[\"query_id\"],\n        \"avg_execution_time\": performance_data[\"avg_execution_time\"],\n        \"execution_count\": performance_data[\"execution_count\"],\n        \"indexing_suggestions\": indexing_suggestions\n    }", "user_query": "Can you retrieve the execution plan for the customerSearch query on db-instance-XYZ123?", "checklist": {"functions": ["get_query_execution_plan"], "values": [{"query": "SELECT * FROM customers WHERE name = 'John Doe'", "execution_plan": "Seq Scan on customers"}]}}
{"difficulty": "easy", "function_schema_python": "def get_query_execution_plan(query_id: str, db_instance_id: str) -> dict:\n    \"\"\"Retrieves the query execution plan for a given query ID on a specified database instance.\n\n    :param query_id: The ID of the query for which the execution plan is requested.\n    :param db_instance_id: The ID of the database instance.\n    :return:\n        dict: A dictionary with the following keys:\n            - query (str): The SQL query.\n            - execution_plan (str): The execution plan of the query.\n    :raises ValueError: If query_id or db_instance_id is empty or incorrect.\"\"\"\n    pass\ndef analyze_query_performance(query_id: str, db_instance_id: str, time_range: str) -> dict:\n    \"\"\"Analyzes the performance of a given query over a specified time range on a database instance.\n\n    :param query_id: The ID of the query for which performance is analyzed.\n    :param db_instance_id: The ID of the database instance.\n    :param time_range: The time range for the analysis (e.g., \"last 24 hours\").\n    :return:\n        dict: A dictionary with the following keys:\n            - query_id (str): The ID of the query.\n            - avg_execution_time (float): Average execution time of the query in milliseconds.\n            - execution_count (int): Number of times the query was executed.\n    :raises ValueError: If any parameter is empty or incorrect.\"\"\"\n    pass\ndef suggest_indexing_strategy(query_execution_plan: dict) -> list:\n    \"\"\"Suggests indexing strategies based on the provided query execution plan.\n\n    :param query_execution_plan: A dictionary containing the query and its execution plan.\n    :return:\n        list: A list of indexing suggestions.\n    :raises ValueError: If the query execution plan is empty or incorrect.\"\"\"\n    pass\ndef generate_performance_report(query_id: str, db_instance_id: str, time_range: str) -> dict:\n    \"\"\"Generates a performance report for a given query over a specified time range on a database instance.\n\n    :param query_id: The ID of the query for which the report is generated.\n    :param db_instance_id: The ID of the database instance.\n    :param time_range: The time range for the performance analysis (e.g., \"last 24 hours\").\n    :return:\n        dict: A dictionary with the following keys:\n            - query_id (str): The ID of the query.\n            - avg_execution_time (float): Average execution time of the query in milliseconds.\n            - execution_count (int): Number of times the query was executed.\n            - indexing_suggestions (list): List of suggested indexing strategies.\n    :raises ValueError: If any parameter is empty or incorrect.\"\"\"\n    pass\n", "function_schema_json": [{"name": "get_query_execution_plan", "description": "Retrieves the query execution plan for a given query ID on a specified database instance.", "parameters": {"type": "object", "properties": {"query_id": {"type": "string", "description": "The ID of the query for which the execution plan is requested."}, "db_instance_id": {"type": "string", "description": "The ID of the database instance."}}, "required": ["query_id", "db_instance_id"], "additionalProperties": false}}, {"name": "analyze_query_performance", "description": "Analyzes the performance of a given query over a specified time range on a database instance.", "parameters": {"type": "object", "properties": {"query_id": {"type": "string", "description": "The ID of the query for which performance is analyzed."}, "db_instance_id": {"type": "string", "description": "The ID of the database instance."}, "time_range": {"type": "string", "description": "The time range for the analysis (e.g., \"last 24 hours\")."}}, "required": ["query_id", "db_instance_id", "time_range"], "additionalProperties": false}}, {"name": "suggest_indexing_strategy", "description": "Suggests indexing strategies based on the provided query execution plan.", "parameters": {"type": "object", "properties": {"query_execution_plan": {"type": "object", "description": "A dictionary containing the query and its execution plan."}}, "required": ["query_execution_plan"], "additionalProperties": false}}, {"name": "generate_performance_report", "description": "Generates a performance report for a given query over a specified time range on a database instance.", "parameters": {"type": "object", "properties": {"query_id": {"type": "string", "description": "The ID of the query for which the report is generated."}, "db_instance_id": {"type": "string", "description": "The ID of the database instance."}, "time_range": {"type": "string", "description": "The time range for the performance analysis (e.g., \"last 24 hours\")."}}, "required": ["query_id", "db_instance_id", "time_range"], "additionalProperties": false}}], "mock_functions": "def get_query_execution_plan(query_id: str, db_instance_id: str) -> dict:\n    \"\"\"\n    Retrieves the query execution plan for a given query ID on a specified database instance.\n    \n    :param query_id: The ID of the query for which the execution plan is requested.\n    :param db_instance_id: The ID of the database instance.\n    :return:\n        dict: A dictionary with the following keys:\n            - query (str): The SQL query.\n            - execution_plan (str): The execution plan of the query.\n    :raises ValueError: If query_id or db_instance_id is empty or incorrect.\n    \"\"\"\n    if not query_id or not db_instance_id:\n        raise ValueError(\"Query ID and database instance ID must be provided.\")\n    if query_id == \"customerSearch\" and db_instance_id == \"db-instance-XYZ123\":\n        return {\n            \"query\": \"SELECT * FROM customers WHERE name = 'John Doe'\",\n            \"execution_plan\": \"Seq Scan on customers\"  # Simplified execution plan\n        }\n    return {}\ndef analyze_query_performance(query_id: str, db_instance_id: str, time_range: str) -> dict:\n    \"\"\"\n    Analyzes the performance of a given query over a specified time range on a database instance.\n    \n    :param query_id: The ID of the query for which performance is analyzed.\n    :param db_instance_id: The ID of the database instance.\n    :param time_range: The time range for the analysis (e.g., \"last 24 hours\").\n    :return:\n        dict: A dictionary with the following keys:\n            - query_id (str): The ID of the query.\n            - avg_execution_time (float): Average execution time of the query in milliseconds.\n            - execution_count (int): Number of times the query was executed.\n    :raises ValueError: If any parameter is empty or incorrect.\n    \"\"\"\n    if not query_id or not db_instance_id or not time_range:\n        raise ValueError(\"Query ID, database instance ID, and time range must be provided.\")\n    if query_id == \"customerSearch\" and db_instance_id == \"db-instance-XYZ123\" and time_range == \"last 24 hours\":\n        return {\n            \"query_id\": \"customerSearch\",\n            \"avg_execution_time\": 150.25,\n            \"execution_count\": 120\n        }\n    return {}\ndef suggest_indexing_strategy(query_execution_plan: dict) -> list:\n    \"\"\"\n    Suggests indexing strategies based on the provided query execution plan.\n    \n    :param query_execution_plan: A dictionary containing the query and its execution plan.\n    :return:\n        list: A list of indexing suggestions.\n    :raises ValueError: If the query execution plan is empty or incorrect.\n    \"\"\"\n    if not query_execution_plan or not query_execution_plan.get(\"execution_plan\"):\n        raise ValueError(\"A valid query execution plan must be provided.\")\n    if \"Seq Scan\" in query_execution_plan.get(\"execution_plan\"):\n        return [\"Create index on customers(name)\"]\n    return []\ndef generate_performance_report(query_id: str, db_instance_id: str, time_range: str) -> dict:\n    \"\"\"\n    Generates a performance report for a given query over a specified time range on a database instance.\n    \n    :param query_id: The ID of the query for which the report is generated.\n    :param db_instance_id: The ID of the database instance.\n    :param time_range: The time range for the performance analysis (e.g., \"last 24 hours\").\n    :return:\n        dict: A dictionary with the following keys:\n            - query_id (str): The ID of the query.\n            - avg_execution_time (float): Average execution time of the query in milliseconds.\n            - execution_count (int): Number of times the query was executed.\n            - indexing_suggestions (list): List of suggested indexing strategies.\n    :raises ValueError: If any parameter is empty or incorrect.\n    \"\"\"\n    performance_data = analyze_query_performance(query_id, db_instance_id, time_range)\n    query_execution_plan = get_query_execution_plan(query_id, db_instance_id)\n    indexing_suggestions = suggest_indexing_strategy(query_execution_plan)\n    \n    if not performance_data or not indexing_suggestions:\n        raise ValueError(\"Unable to generate a performance report with the provided data.\")\n    \n    return {\n        \"query_id\": performance_data[\"query_id\"],\n        \"avg_execution_time\": performance_data[\"avg_execution_time\"],\n        \"execution_count\": performance_data[\"execution_count\"],\n        \"indexing_suggestions\": indexing_suggestions\n    }", "user_query": "Please analyze the performance of the customerSearch query on db-instance-XYZ123 for the last 24 hours, including average execution time and number of executions.", "checklist": {"functions": ["analyze_query_performance"], "values": [{"query_id": "customerSearch", "avg_execution_time": 150.25, "execution_count": 120}]}}
{"difficulty": "easy", "function_schema_python": "def get_popular_routes(limit: int) -> list[str]:\n    \"\"\"Retrieves the most popular flight routes from the database.\n\n    :param limit: Number of routes to retrieve (e.g., 20 for top 20).\n    :return: List of route identifiers.\n    :raises ValueError: If limit is not between 1 and 100.\"\"\"\n    pass\ndef cache_route_data(route_id: str, price: float, availability: int) -> bool:\n    \"\"\"Caches flight route data in Redis.\n\n    :param route_id: Unique identifier for the route.\n    :param price: Current price for the route.\n    :param availability: Number of available seats.\n    :return: True if successfully cached, False otherwise.\n    :raises ValueError: If price is negative or availability is invalid.\"\"\"\n    pass\ndef get_flight_data(route_id: str) -> dict:\n    \"\"\"Retrieves flight data from Redis cache or PostgreSQL database.\n\n    :return: \n        dict: A dictionary with the following keys:\n            - route_id (str): The route identifier\n            - price (float): Current price\n            - availability (int): Available seats\n            - last_updated (str): Timestamp of last update\n    :raises ValueError: If route_id is invalid.\"\"\"\n    pass\ndef update_cache_ttl(route_id: str, ttl_minutes: int) -> bool:\n    \"\"\"Updates the TTL (Time To Live) for a cached route.\n\n    :param route_id: The route identifier.\n    :param ttl_minutes: Cache expiration time in minutes.\n    :return: True if TTL was successfully updated, False otherwise.\n    :raises ValueError: If ttl_minutes is not positive.\"\"\"\n    pass\n", "function_schema_json": [{"name": "get_popular_routes", "description": "Retrieves the most popular flight routes from the database.", "parameters": {"type": "object", "properties": {"limit": {"type": "integer", "description": "Number of routes to retrieve (e.g., 20 for top 20)."}}, "required": ["limit"], "additionalProperties": false}}, {"name": "cache_route_data", "description": "Caches flight route data in Redis.", "parameters": {"type": "object", "properties": {"route_id": {"type": "string", "description": "Unique identifier for the route."}, "price": {"type": "number", "description": "Current price for the route."}, "availability": {"type": "integer", "description": "Number of available seats."}}, "required": ["route_id", "price", "availability"], "additionalProperties": false}}, {"name": "get_flight_data", "description": "Retrieves flight data from Redis cache or PostgreSQL database.", "parameters": {"type": "object", "properties": {"route_id": {"type": "string", "description": "Parameter route_id"}}, "required": ["route_id"], "additionalProperties": false}}, {"name": "update_cache_ttl", "description": "Updates the TTL (Time To Live) for a cached route.", "parameters": {"type": "object", "properties": {"route_id": {"type": "string", "description": "The route identifier."}, "ttl_minutes": {"type": "integer", "description": "Cache expiration time in minutes."}}, "required": ["route_id", "ttl_minutes"], "additionalProperties": false}}], "mock_functions": "def get_popular_routes(limit: int) -> list[str]:\n    \"\"\"\n    Retrieves the most popular flight routes from the database.\n    \n    :param limit: Number of routes to retrieve (e.g., 20 for top 20).\n    :return: List of route identifiers.\n    :raises ValueError: If limit is not between 1 and 100.\n    \"\"\"\n    if not 1 <= limit <= 100:\n        raise ValueError(\"Limit must be between 1 and 100\")\n    if limit == 20:\n        return [f\"route_{i}\" for i in range(1, 21)]\n    return []\ndef cache_route_data(route_id: str, price: float, availability: int) -> bool:\n    \"\"\"\n    Caches flight route data in Redis.\n    \n    :param route_id: Unique identifier for the route.\n    :param price: Current price for the route.\n    :param availability: Number of available seats.\n    :return: True if successfully cached, False otherwise.\n    :raises ValueError: If price is negative or availability is invalid.\n    \"\"\"\n    if price < 0 or availability < 0:\n        raise ValueError(\"Price and availability must be non-negative\")\n    if route_id.startswith(\"route_\") and 0 <= price <= 10000 and 0 <= availability <= 500:\n        return True\n    return False\ndef get_flight_data(route_id: str) -> dict:\n    \"\"\"\n    Retrieves flight data from Redis cache or PostgreSQL database.\n    \n    :return: \n        dict: A dictionary with the following keys:\n            - route_id (str): The route identifier\n            - price (float): Current price\n            - availability (int): Available seats\n            - last_updated (str): Timestamp of last update\n    :raises ValueError: If route_id is invalid.\n    \"\"\"\n    if not route_id.startswith(\"route_\"):\n        raise ValueError(\"Invalid route ID format\")\n    if route_id in [f\"route_{i}\" for i in range(1, 21)]:\n        return {\n            \"route_id\": route_id,\n            \"price\": 299.99,\n            \"availability\": 45,\n            \"last_updated\": \"2024-01-20T14:30:00Z\"\n        }\n    return {}\ndef update_cache_ttl(route_id: str, ttl_minutes: int) -> bool:\n    \"\"\"\n    Updates the TTL (Time To Live) for a cached route.\n    \n    :param route_id: The route identifier.\n    :param ttl_minutes: Cache expiration time in minutes.\n    :return: True if TTL was successfully updated, False otherwise.\n    :raises ValueError: If ttl_minutes is not positive.\n    \"\"\"\n    if ttl_minutes <= 0:\n        raise ValueError(\"TTL must be positive\")\n    if route_id.startswith(\"route_\") and ttl_minutes == 30:\n        return True\n    return False", "user_query": "What are the top 20 popular flight routes?", "checklist": {"functions": ["get_popular_routes"], "values": [["route_1", "route_2", "route_3", "route_4", "route_5", "route_6", "route_7", "route_8", "route_9", "route_10", "route_11", "route_12", "route_13", "route_14", "route_15", "route_16", "route_17", "route_18", "route_19", "route_20"]]}}
{"difficulty": "easy", "function_schema_python": "def get_popular_routes(limit: int) -> list[str]:\n    \"\"\"Retrieves the most popular flight routes from the database.\n\n    :param limit: Number of routes to retrieve (e.g., 20 for top 20).\n    :return: List of route identifiers.\n    :raises ValueError: If limit is not between 1 and 100.\"\"\"\n    pass\ndef cache_route_data(route_id: str, price: float, availability: int) -> bool:\n    \"\"\"Caches flight route data in Redis.\n\n    :param route_id: Unique identifier for the route.\n    :param price: Current price for the route.\n    :param availability: Number of available seats.\n    :return: True if successfully cached, False otherwise.\n    :raises ValueError: If price is negative or availability is invalid.\"\"\"\n    pass\ndef get_flight_data(route_id: str) -> dict:\n    \"\"\"Retrieves flight data from Redis cache or PostgreSQL database.\n\n    :return: \n        dict: A dictionary with the following keys:\n            - route_id (str): The route identifier\n            - price (float): Current price\n            - availability (int): Available seats\n            - last_updated (str): Timestamp of last update\n    :raises ValueError: If route_id is invalid.\"\"\"\n    pass\ndef update_cache_ttl(route_id: str, ttl_minutes: int) -> bool:\n    \"\"\"Updates the TTL (Time To Live) for a cached route.\n\n    :param route_id: The route identifier.\n    :param ttl_minutes: Cache expiration time in minutes.\n    :return: True if TTL was successfully updated, False otherwise.\n    :raises ValueError: If ttl_minutes is not positive.\"\"\"\n    pass\n", "function_schema_json": [{"name": "get_popular_routes", "description": "Retrieves the most popular flight routes from the database.", "parameters": {"type": "object", "properties": {"limit": {"type": "integer", "description": "Number of routes to retrieve (e.g., 20 for top 20)."}}, "required": ["limit"], "additionalProperties": false}}, {"name": "cache_route_data", "description": "Caches flight route data in Redis.", "parameters": {"type": "object", "properties": {"route_id": {"type": "string", "description": "Unique identifier for the route."}, "price": {"type": "number", "description": "Current price for the route."}, "availability": {"type": "integer", "description": "Number of available seats."}}, "required": ["route_id", "price", "availability"], "additionalProperties": false}}, {"name": "get_flight_data", "description": "Retrieves flight data from Redis cache or PostgreSQL database.", "parameters": {"type": "object", "properties": {"route_id": {"type": "string", "description": "Parameter route_id"}}, "required": ["route_id"], "additionalProperties": false}}, {"name": "update_cache_ttl", "description": "Updates the TTL (Time To Live) for a cached route.", "parameters": {"type": "object", "properties": {"route_id": {"type": "string", "description": "The route identifier."}, "ttl_minutes": {"type": "integer", "description": "Cache expiration time in minutes."}}, "required": ["route_id", "ttl_minutes"], "additionalProperties": false}}], "mock_functions": "def get_popular_routes(limit: int) -> list[str]:\n    \"\"\"\n    Retrieves the most popular flight routes from the database.\n    \n    :param limit: Number of routes to retrieve (e.g., 20 for top 20).\n    :return: List of route identifiers.\n    :raises ValueError: If limit is not between 1 and 100.\n    \"\"\"\n    if not 1 <= limit <= 100:\n        raise ValueError(\"Limit must be between 1 and 100\")\n    if limit == 20:\n        return [f\"route_{i}\" for i in range(1, 21)]\n    return []\ndef cache_route_data(route_id: str, price: float, availability: int) -> bool:\n    \"\"\"\n    Caches flight route data in Redis.\n    \n    :param route_id: Unique identifier for the route.\n    :param price: Current price for the route.\n    :param availability: Number of available seats.\n    :return: True if successfully cached, False otherwise.\n    :raises ValueError: If price is negative or availability is invalid.\n    \"\"\"\n    if price < 0 or availability < 0:\n        raise ValueError(\"Price and availability must be non-negative\")\n    if route_id.startswith(\"route_\") and 0 <= price <= 10000 and 0 <= availability <= 500:\n        return True\n    return False\ndef get_flight_data(route_id: str) -> dict:\n    \"\"\"\n    Retrieves flight data from Redis cache or PostgreSQL database.\n    \n    :return: \n        dict: A dictionary with the following keys:\n            - route_id (str): The route identifier\n            - price (float): Current price\n            - availability (int): Available seats\n            - last_updated (str): Timestamp of last update\n    :raises ValueError: If route_id is invalid.\n    \"\"\"\n    if not route_id.startswith(\"route_\"):\n        raise ValueError(\"Invalid route ID format\")\n    if route_id in [f\"route_{i}\" for i in range(1, 21)]:\n        return {\n            \"route_id\": route_id,\n            \"price\": 299.99,\n            \"availability\": 45,\n            \"last_updated\": \"2024-01-20T14:30:00Z\"\n        }\n    return {}\ndef update_cache_ttl(route_id: str, ttl_minutes: int) -> bool:\n    \"\"\"\n    Updates the TTL (Time To Live) for a cached route.\n    \n    :param route_id: The route identifier.\n    :param ttl_minutes: Cache expiration time in minutes.\n    :return: True if TTL was successfully updated, False otherwise.\n    :raises ValueError: If ttl_minutes is not positive.\n    \"\"\"\n    if ttl_minutes <= 0:\n        raise ValueError(\"TTL must be positive\")\n    if route_id.startswith(\"route_\") and ttl_minutes == 30:\n        return True\n    return False", "user_query": "Can you cache data for \"route_5\" with a price of $299.99 and 45 seats available?", "checklist": {"functions": ["cache_route_data"], "values": [true]}}
{"difficulty": "easy", "function_schema_python": "def get_patient_demographics(patient_id: str) -> dict:\n    \"\"\"Retrieves patient demographic information from cache or database.\n\n    :param patient_id: Unique identifier for the patient\n    :return: Dictionary containing patient demographic information\n    :raises ValueError: If patient_id is invalid\"\"\"\n    pass\ndef cache_patient_data(patient_id: str, data: dict, ttl: int) -> bool:\n    \"\"\"Caches patient data with specified time-to-live.\n\n    :param patient_id: Unique identifier for the patient\n    :param data: Dictionary containing patient data to cache\n    :param ttl: Time-to-live in seconds (default 300 seconds/5 minutes)\n    :return: Boolean indicating success of caching operation\n    :raises ValueError: If TTL exceeds maximum allowed time\"\"\"\n    pass\ndef get_recent_visits(patient_id: str, limit: int) -> list:\n    \"\"\"Retrieves recent visit history for a patient.\n\n    :param patient_id: Unique identifier for the patient\n    :param limit: Maximum number of recent visits to return\n    :return: List of recent visit dictionaries\n    :raises ValueError: If patient_id is invalid or limit is out of range\"\"\"\n    pass\ndef verify_hipaa_compliance(data: dict) -> bool:\n    \"\"\"Verifies if the data structure meets HIPAA compliance requirements.\n\n    :param data: Dictionary containing patient data to verify\n    :return: Boolean indicating if data meets HIPAA requirements\"\"\"\n    pass\n", "function_schema_json": [{"name": "get_patient_demographics", "description": "Retrieves patient demographic information from cache or database.", "parameters": {"type": "object", "properties": {"patient_id": {"type": "string", "description": "Unique identifier for the patient"}}, "required": ["patient_id"], "additionalProperties": false}}, {"name": "cache_patient_data", "description": "Caches patient data with specified time-to-live.", "parameters": {"type": "object", "properties": {"patient_id": {"type": "string", "description": "Unique identifier for the patient"}, "data": {"type": "object", "description": "Dictionary containing patient data to cache"}, "ttl": {"type": "integer", "description": "Time-to-live in seconds (default 300 seconds/5 minutes)"}}, "required": ["patient_id", "data", "ttl"], "additionalProperties": false}}, {"name": "get_recent_visits", "description": "Retrieves recent visit history for a patient.", "parameters": {"type": "object", "properties": {"patient_id": {"type": "string", "description": "Unique identifier for the patient"}, "limit": {"type": "integer", "description": "Maximum number of recent visits to return"}}, "required": ["patient_id", "limit"], "additionalProperties": false}}, {"name": "verify_hipaa_compliance", "description": "Verifies if the data structure meets HIPAA compliance requirements.", "parameters": {"type": "object", "properties": {"data": {"type": "object", "description": "Dictionary containing patient data to verify"}}, "required": ["data"], "additionalProperties": false}}], "mock_functions": "def get_patient_demographics(patient_id: str) -> dict:\n    \"\"\"\n    Retrieves patient demographic information from cache or database.\n    \n    :param patient_id: Unique identifier for the patient\n    :return: Dictionary containing patient demographic information\n    :raises ValueError: If patient_id is invalid\n    \"\"\"\n    if not isinstance(patient_id, str) or len(patient_id) != 10:\n        raise ValueError(\"Invalid patient ID format\")\n    \n    if patient_id == \"1234567890\":\n        return {\n            \"patient_id\": \"1234567890\",\n            \"name\": \"John Doe\",\n            \"dob\": \"1980-01-01\",\n            \"address\": \"123 Main St\",\n            \"phone\": \"555-0123\"\n        }\n    raise ValueError(\"Patient not found\")\ndef cache_patient_data(patient_id: str, data: dict, ttl: int = 300) -> bool:\n    \"\"\"\n    Caches patient data with specified time-to-live.\n    \n    :param patient_id: Unique identifier for the patient\n    :param data: Dictionary containing patient data to cache\n    :param ttl: Time-to-live in seconds (default 300 seconds/5 minutes)\n    :return: Boolean indicating success of caching operation\n    :raises ValueError: If TTL exceeds maximum allowed time\n    \"\"\"\n    if not isinstance(ttl, int) or ttl > 300:\n        raise ValueError(\"TTL cannot exceed 5 minutes (300 seconds)\")\n    \n    required_keys = {\"patient_id\", \"name\", \"dob\"}\n    if not all(key in data for key in required_keys):\n        raise ValueError(\"Missing required data fields\")\n    \n    return True\ndef get_recent_visits(patient_id: str, limit: int = 5) -> list:\n    \"\"\"\n    Retrieves recent visit history for a patient.\n    \n    :param patient_id: Unique identifier for the patient\n    :param limit: Maximum number of recent visits to return\n    :return: List of recent visit dictionaries\n    :raises ValueError: If patient_id is invalid or limit is out of range\n    \"\"\"\n    if not isinstance(patient_id, str) or len(patient_id) != 10:\n        raise ValueError(\"Invalid patient ID format\")\n    if not isinstance(limit, int) or limit < 1 or limit > 10:\n        raise ValueError(\"Limit must be between 1 and 10\")\n    \n    if patient_id == \"1234567890\":\n        return [\n            {\n                \"visit_id\": \"V001\",\n                \"date\": \"2023-10-01\",\n                \"doctor\": \"Dr. Smith\",\n                \"reason\": \"Annual checkup\"\n            },\n            {\n                \"visit_id\": \"V002\",\n                \"date\": \"2023-09-15\",\n                \"doctor\": \"Dr. Johnson\",\n                \"reason\": \"Follow-up\"\n            }\n        ]\n    return []\ndef verify_hipaa_compliance(data: dict) -> bool:\n    \"\"\"\n    Verifies if the data structure meets HIPAA compliance requirements.\n    \n    :param data: Dictionary containing patient data to verify\n    :return: Boolean indicating if data meets HIPAA requirements\n    \"\"\"\n    required_security_fields = {\"encryption\", \"access_level\", \"audit_trail\"}\n    if not all(field in data for field in required_security_fields):\n        return False\n    return True", "user_query": "Can you retrieve the demographic information for patient ID 1234567890?", "checklist": {"functions": ["get_patient_demographics"], "values": [{"patient_id": "1234567890", "name": "John Doe", "dob": "1980-01-01", "address": "123 Main St", "phone": "555-0123"}]}}
{"difficulty": "easy", "function_schema_python": "def validate_schema_compatibility(old_schema: dict, new_schema: dict) -> dict:\n    \"\"\"Validates data types and constraints between old and new database schemas.\n\n    :param old_schema: Dictionary containing the old MySQL schema definitions\n    :param new_schema: Dictionary containing the new SQLite schema definitions\n    :return: Dictionary containing validation results with following keys:\n        - is_compatible (bool): Whether schemas are compatible\n        - mismatches (list): List of incompatible fields\n        - warnings (list): List of potential issues\n    :raises ValueError: If schema dictionaries are invalid\"\"\"\n    pass\ndef compare_data_integrity(source_data: dict, target_data: dict) -> dict:\n    \"\"\"Compares historical data between source and target databases.\n\n    :param source_data: Dictionary containing source database records\n    :param target_data: Dictionary containing target database records\n    :return: Dictionary containing comparison results with following keys:\n        - match_percentage (float): Percentage of matching records\n        - missing_records (list): List of missing record IDs\n        - data_differences (dict): Dictionary of differing fields\n    :raises ValueError: If data dictionaries are invalid\"\"\"\n    pass\ndef generate_migration_report(schema_validation: dict, data_comparison: dict) -> dict:\n    \"\"\"Generates a comprehensive migration validation report.\n\n    :param schema_validation: Dictionary containing schema validation results\n    :param data_comparison: Dictionary containing data comparison results\n    :return: Dictionary containing final report with following keys:\n        - success (bool): Overall migration success\n        - summary (str): Summary of migration results\n        - recommendations (list): List of recommended actions\n    :raises ValueError: If input dictionaries are invalid\"\"\"\n    pass\n", "function_schema_json": [{"name": "validate_schema_compatibility", "description": "Validates data types and constraints between old and new database schemas.", "parameters": {"type": "object", "properties": {"old_schema": {"type": "object", "description": "Dictionary containing the old MySQL schema definitions"}, "new_schema": {"type": "object", "description": "Dictionary containing the new SQLite schema definitions"}}, "required": ["old_schema", "new_schema"], "additionalProperties": false}}, {"name": "compare_data_integrity", "description": "Compares historical data between source and target databases.", "parameters": {"type": "object", "properties": {"source_data": {"type": "object", "description": "Dictionary containing source database records"}, "target_data": {"type": "object", "description": "Dictionary containing target database records"}}, "required": ["source_data", "target_data"], "additionalProperties": false}}, {"name": "generate_migration_report", "description": "Generates a comprehensive migration validation report.", "parameters": {"type": "object", "properties": {"schema_validation": {"type": "object", "description": "Dictionary containing schema validation results"}, "data_comparison": {"type": "object", "description": "Dictionary containing data comparison results"}}, "required": ["schema_validation", "data_comparison"], "additionalProperties": false}}], "mock_functions": "def validate_schema_compatibility(old_schema: dict, new_schema: dict) -> dict:\n    \"\"\"\n    Validates data types and constraints between old and new database schemas.\n    \n    :param old_schema: Dictionary containing the old MySQL schema definitions\n    :param new_schema: Dictionary containing the new SQLite schema definitions\n    :return: Dictionary containing validation results with following keys:\n        - is_compatible (bool): Whether schemas are compatible\n        - mismatches (list): List of incompatible fields\n        - warnings (list): List of potential issues\n    :raises ValueError: If schema dictionaries are invalid\n    \"\"\"\n    if not isinstance(old_schema, dict) or not isinstance(new_schema, dict):\n        raise ValueError(\"Invalid schema format\")\n    \n    if old_schema.get(\"version\") == \"1.0\" and new_schema.get(\"version\") == \"1.0\":\n        return {\n            \"is_compatible\": True,\n            \"mismatches\": [],\n            \"warnings\": [\"VARCHAR lengths might differ in SQLite\"]\n        }\n    return {\n        \"is_compatible\": False,\n        \"mismatches\": [\"Incompatible data types found\"],\n        \"warnings\": []\n    }\ndef compare_data_integrity(source_data: dict, target_data: dict) -> dict:\n    \"\"\"\n    Compares historical data between source and target databases.\n    \n    :param source_data: Dictionary containing source database records\n    :param target_data: Dictionary containing target database records\n    :return: Dictionary containing comparison results with following keys:\n        - match_percentage (float): Percentage of matching records\n        - missing_records (list): List of missing record IDs\n        - data_differences (dict): Dictionary of differing fields\n    :raises ValueError: If data dictionaries are invalid\n    \"\"\"\n    if not isinstance(source_data, dict) or not isinstance(target_data, dict):\n        raise ValueError(\"Invalid data format\")\n    \n    if source_data.get(\"checksum\") == target_data.get(\"checksum\"):\n        return {\n            \"match_percentage\": 100.0,\n            \"missing_records\": [],\n            \"data_differences\": {}\n        }\n    return {\n        \"match_percentage\": 98.5,\n        \"missing_records\": [\"PRJ_001\", \"PRJ_002\"],\n        \"data_differences\": {\"PRJ_003\": [\"last_modified_date\"]}\n    }\ndef generate_migration_report(schema_validation: dict, data_comparison: dict) -> dict:\n    \"\"\"\n    Generates a comprehensive migration validation report.\n    \n    :param schema_validation: Dictionary containing schema validation results\n    :param data_comparison: Dictionary containing data comparison results\n    :return: Dictionary containing final report with following keys:\n        - success (bool): Overall migration success\n        - summary (str): Summary of migration results\n        - recommendations (list): List of recommended actions\n    :raises ValueError: If input dictionaries are invalid\n    \"\"\"\n    if not isinstance(schema_validation, dict) or not isinstance(data_comparison, dict):\n        raise ValueError(\"Invalid input data\")\n\n    if (schema_validation.get(\"is_compatible\") and \n        data_comparison.get(\"match_percentage\", 0) > 98.0):\n        return {\n            \"success\": True,\n            \"summary\": \"Migration successful with 98.5% data accuracy\",\n            \"recommendations\": [\"Verify missing records PRJ_001, PRJ_002\"]\n        }\n    return {\n        \"success\": False,\n        \"summary\": \"Migration requires attention\",\n        \"recommendations\": [\"Review schema incompatibilities\"]\n    }", "user_query": "This is James. Can you validate the schema compatibility between my old MySQL schema (version 1.0) and the new SQLite schema (version 1.0)?", "checklist": {"functions": ["validate_schema_compatibility"], "values": [{"is_compatible": true, "mismatches": [], "warnings": ["VARCHAR lengths might differ in SQLite"]}]}}
{"difficulty": "easy", "function_schema_python": "def validate_schema_compatibility(old_schema: dict, new_schema: dict) -> dict:\n    \"\"\"Validates data types and constraints between old and new database schemas.\n\n    :param old_schema: Dictionary containing the old MySQL schema definitions\n    :param new_schema: Dictionary containing the new SQLite schema definitions\n    :return: Dictionary containing validation results with following keys:\n        - is_compatible (bool): Whether schemas are compatible\n        - mismatches (list): List of incompatible fields\n        - warnings (list): List of potential issues\n    :raises ValueError: If schema dictionaries are invalid\"\"\"\n    pass\ndef compare_data_integrity(source_data: dict, target_data: dict) -> dict:\n    \"\"\"Compares historical data between source and target databases.\n\n    :param source_data: Dictionary containing source database records\n    :param target_data: Dictionary containing target database records\n    :return: Dictionary containing comparison results with following keys:\n        - match_percentage (float): Percentage of matching records\n        - missing_records (list): List of missing record IDs\n        - data_differences (dict): Dictionary of differing fields\n    :raises ValueError: If data dictionaries are invalid\"\"\"\n    pass\ndef generate_migration_report(schema_validation: dict, data_comparison: dict) -> dict:\n    \"\"\"Generates a comprehensive migration validation report.\n\n    :param schema_validation: Dictionary containing schema validation results\n    :param data_comparison: Dictionary containing data comparison results\n    :return: Dictionary containing final report with following keys:\n        - success (bool): Overall migration success\n        - summary (str): Summary of migration results\n        - recommendations (list): List of recommended actions\n    :raises ValueError: If input dictionaries are invalid\"\"\"\n    pass\n", "function_schema_json": [{"name": "validate_schema_compatibility", "description": "Validates data types and constraints between old and new database schemas.", "parameters": {"type": "object", "properties": {"old_schema": {"type": "object", "description": "Dictionary containing the old MySQL schema definitions"}, "new_schema": {"type": "object", "description": "Dictionary containing the new SQLite schema definitions"}}, "required": ["old_schema", "new_schema"], "additionalProperties": false}}, {"name": "compare_data_integrity", "description": "Compares historical data between source and target databases.", "parameters": {"type": "object", "properties": {"source_data": {"type": "object", "description": "Dictionary containing source database records"}, "target_data": {"type": "object", "description": "Dictionary containing target database records"}}, "required": ["source_data", "target_data"], "additionalProperties": false}}, {"name": "generate_migration_report", "description": "Generates a comprehensive migration validation report.", "parameters": {"type": "object", "properties": {"schema_validation": {"type": "object", "description": "Dictionary containing schema validation results"}, "data_comparison": {"type": "object", "description": "Dictionary containing data comparison results"}}, "required": ["schema_validation", "data_comparison"], "additionalProperties": false}}], "mock_functions": "def validate_schema_compatibility(old_schema: dict, new_schema: dict) -> dict:\n    \"\"\"\n    Validates data types and constraints between old and new database schemas.\n    \n    :param old_schema: Dictionary containing the old MySQL schema definitions\n    :param new_schema: Dictionary containing the new SQLite schema definitions\n    :return: Dictionary containing validation results with following keys:\n        - is_compatible (bool): Whether schemas are compatible\n        - mismatches (list): List of incompatible fields\n        - warnings (list): List of potential issues\n    :raises ValueError: If schema dictionaries are invalid\n    \"\"\"\n    if not isinstance(old_schema, dict) or not isinstance(new_schema, dict):\n        raise ValueError(\"Invalid schema format\")\n    \n    if old_schema.get(\"version\") == \"1.0\" and new_schema.get(\"version\") == \"1.0\":\n        return {\n            \"is_compatible\": True,\n            \"mismatches\": [],\n            \"warnings\": [\"VARCHAR lengths might differ in SQLite\"]\n        }\n    return {\n        \"is_compatible\": False,\n        \"mismatches\": [\"Incompatible data types found\"],\n        \"warnings\": []\n    }\ndef compare_data_integrity(source_data: dict, target_data: dict) -> dict:\n    \"\"\"\n    Compares historical data between source and target databases.\n    \n    :param source_data: Dictionary containing source database records\n    :param target_data: Dictionary containing target database records\n    :return: Dictionary containing comparison results with following keys:\n        - match_percentage (float): Percentage of matching records\n        - missing_records (list): List of missing record IDs\n        - data_differences (dict): Dictionary of differing fields\n    :raises ValueError: If data dictionaries are invalid\n    \"\"\"\n    if not isinstance(source_data, dict) or not isinstance(target_data, dict):\n        raise ValueError(\"Invalid data format\")\n    \n    if source_data.get(\"checksum\") == target_data.get(\"checksum\"):\n        return {\n            \"match_percentage\": 100.0,\n            \"missing_records\": [],\n            \"data_differences\": {}\n        }\n    return {\n        \"match_percentage\": 98.5,\n        \"missing_records\": [\"PRJ_001\", \"PRJ_002\"],\n        \"data_differences\": {\"PRJ_003\": [\"last_modified_date\"]}\n    }\ndef generate_migration_report(schema_validation: dict, data_comparison: dict) -> dict:\n    \"\"\"\n    Generates a comprehensive migration validation report.\n    \n    :param schema_validation: Dictionary containing schema validation results\n    :param data_comparison: Dictionary containing data comparison results\n    :return: Dictionary containing final report with following keys:\n        - success (bool): Overall migration success\n        - summary (str): Summary of migration results\n        - recommendations (list): List of recommended actions\n    :raises ValueError: If input dictionaries are invalid\n    \"\"\"\n    if not isinstance(schema_validation, dict) or not isinstance(data_comparison, dict):\n        raise ValueError(\"Invalid input data\")\n\n    if (schema_validation.get(\"is_compatible\") and \n        data_comparison.get(\"match_percentage\", 0) > 98.0):\n        return {\n            \"success\": True,\n            \"summary\": \"Migration successful with 98.5% data accuracy\",\n            \"recommendations\": [\"Verify missing records PRJ_001, PRJ_002\"]\n        }\n    return {\n        \"success\": False,\n        \"summary\": \"Migration requires attention\",\n        \"recommendations\": [\"Review schema incompatibilities\"]\n    }", "user_query": "James here. I need to compare the data integrity. The source data checksum is 'abcdef123456' and the target data checksum is 'abcdef123456'. Can you check?", "checklist": {"functions": ["compare_data_integrity"], "values": [{"match_percentage": 100.0, "missing_records": [], "data_differences": {}}]}}
{"difficulty": "easy", "function_schema_python": "def get_student_exam_scores(student_id: str) -> dict:\n    \"\"\"Retrieves exam scores for a specific student from MongoDB.\n\n    :param student_id: The unique identifier for the student.\n    :return: Dictionary containing exam scores and statistics.\n    :raises ValueError: If student_id is invalid.\"\"\"\n    pass\ndef write_student_feedback(student_id: str, exam_id: str, feedback: str) -> bool:\n    \"\"\"Writes personalized feedback for a student's exam performance.\n\n    :param student_id: The unique identifier for the student.\n    :param exam_id: The unique identifier for the exam.\n    :param feedback: The feedback text to be stored.\n    :return: Boolean indicating success of the operation.\n    :raises ValueError: If parameters are invalid.\"\"\"\n    pass\ndef get_class_statistics(course_id: str) -> dict:\n    \"\"\"Generates statistical analysis of exam scores for an entire class.\n\n    :param course_id: The unique identifier for the course.\n    :return: Dictionary containing class statistics.\n    :raises ValueError: If course_id is invalid.\"\"\"\n    pass\n", "function_schema_json": [{"name": "get_student_exam_scores", "description": "Retrieves exam scores for a specific student from MongoDB.", "parameters": {"type": "object", "properties": {"student_id": {"type": "string", "description": "The unique identifier for the student."}}, "required": ["student_id"], "additionalProperties": false}}, {"name": "write_student_feedback", "description": "Writes personalized feedback for a student's exam performance.", "parameters": {"type": "object", "properties": {"student_id": {"type": "string", "description": "The unique identifier for the student."}, "exam_id": {"type": "string", "description": "The unique identifier for the exam."}, "feedback": {"type": "string", "description": "The feedback text to be stored."}}, "required": ["student_id", "exam_id", "feedback"], "additionalProperties": false}}, {"name": "get_class_statistics", "description": "Generates statistical analysis of exam scores for an entire class.", "parameters": {"type": "object", "properties": {"course_id": {"type": "string", "description": "The unique identifier for the course."}}, "required": ["course_id"], "additionalProperties": false}}], "mock_functions": "def get_student_exam_scores(student_id: str) -> dict:\n    \"\"\"\n    Retrieves exam scores for a specific student from MongoDB.\n    \n    :param student_id: The unique identifier for the student.\n    :return: Dictionary containing exam scores and statistics.\n    :raises ValueError: If student_id is invalid.\n    \"\"\"\n    if not isinstance(student_id, str) or len(student_id) != 8:\n        raise ValueError(\"Invalid student ID format\")\n    \n    if student_id == \"STU12345\":\n        return {\n            \"student_id\": \"STU12345\",\n            \"exams\": [\n                {\"course\": \"DB101\", \"score\": 85, \"date\": \"2023-10-01\"},\n                {\"course\": \"DB101\", \"score\": 92, \"date\": \"2023-11-15\"}\n            ],\n            \"average_score\": 88.5\n        }\n    return {}\ndef write_student_feedback(student_id: str, exam_id: str, feedback: str) -> bool:\n    \"\"\"\n    Writes personalized feedback for a student's exam performance.\n    \n    :param student_id: The unique identifier for the student.\n    :param exam_id: The unique identifier for the exam.\n    :param feedback: The feedback text to be stored.\n    :return: Boolean indicating success of the operation.\n    :raises ValueError: If parameters are invalid.\n    \"\"\"\n    if not isinstance(student_id, str) or len(student_id) != 8:\n        raise ValueError(\"Invalid student ID format\")\n    if not isinstance(exam_id, str) or not exam_id.startswith(\"EX\"):\n        raise ValueError(\"Invalid exam ID format\")\n    if not feedback or len(feedback) > 1000:\n        raise ValueError(\"Invalid feedback format\")\n\n    if student_id == \"STU12345\" and exam_id == \"EX001\":\n        return True\n    return False\ndef get_class_statistics(course_id: str) -> dict:\n    \"\"\"\n    Generates statistical analysis of exam scores for an entire class.\n    \n    :param course_id: The unique identifier for the course.\n    :return: Dictionary containing class statistics.\n    :raises ValueError: If course_id is invalid.\n    \"\"\"\n    if not isinstance(course_id, str) or not course_id.startswith(\"DB\"):\n        raise ValueError(\"Invalid course ID format\")\n\n    if course_id == \"DB101\":\n        return {\n            \"course_id\": \"DB101\",\n            \"total_students\": 30,\n            \"average_score\": 82.5,\n            \"median_score\": 84.0,\n            \"highest_score\": 98,\n            \"lowest_score\": 65,\n            \"score_distribution\": {\n                \"90-100\": 5,\n                \"80-89\": 15,\n                \"70-79\": 8,\n                \"60-69\": 2\n            }\n        }\n    return {}", "user_query": "Can I get the exam scores for student STU12345?", "checklist": {"functions": ["get_student_exam_scores"], "values": [{"student_id": "STU12345", "exams": [{"course": "DB101", "score": 85, "date": "2023-10-01"}, {"course": "DB101", "score": 92, "date": "2023-11-15"}], "average_score": 88.5}]}}
{"difficulty": "easy", "function_schema_python": "def get_student_exam_scores(student_id: str) -> dict:\n    \"\"\"Retrieves exam scores for a specific student from MongoDB.\n\n    :param student_id: The unique identifier for the student.\n    :return: Dictionary containing exam scores and statistics.\n    :raises ValueError: If student_id is invalid.\"\"\"\n    pass\ndef write_student_feedback(student_id: str, exam_id: str, feedback: str) -> bool:\n    \"\"\"Writes personalized feedback for a student's exam performance.\n\n    :param student_id: The unique identifier for the student.\n    :param exam_id: The unique identifier for the exam.\n    :param feedback: The feedback text to be stored.\n    :return: Boolean indicating success of the operation.\n    :raises ValueError: If parameters are invalid.\"\"\"\n    pass\ndef get_class_statistics(course_id: str) -> dict:\n    \"\"\"Generates statistical analysis of exam scores for an entire class.\n\n    :param course_id: The unique identifier for the course.\n    :return: Dictionary containing class statistics.\n    :raises ValueError: If course_id is invalid.\"\"\"\n    pass\n", "function_schema_json": [{"name": "get_student_exam_scores", "description": "Retrieves exam scores for a specific student from MongoDB.", "parameters": {"type": "object", "properties": {"student_id": {"type": "string", "description": "The unique identifier for the student."}}, "required": ["student_id"], "additionalProperties": false}}, {"name": "write_student_feedback", "description": "Writes personalized feedback for a student's exam performance.", "parameters": {"type": "object", "properties": {"student_id": {"type": "string", "description": "The unique identifier for the student."}, "exam_id": {"type": "string", "description": "The unique identifier for the exam."}, "feedback": {"type": "string", "description": "The feedback text to be stored."}}, "required": ["student_id", "exam_id", "feedback"], "additionalProperties": false}}, {"name": "get_class_statistics", "description": "Generates statistical analysis of exam scores for an entire class.", "parameters": {"type": "object", "properties": {"course_id": {"type": "string", "description": "The unique identifier for the course."}}, "required": ["course_id"], "additionalProperties": false}}], "mock_functions": "def get_student_exam_scores(student_id: str) -> dict:\n    \"\"\"\n    Retrieves exam scores for a specific student from MongoDB.\n    \n    :param student_id: The unique identifier for the student.\n    :return: Dictionary containing exam scores and statistics.\n    :raises ValueError: If student_id is invalid.\n    \"\"\"\n    if not isinstance(student_id, str) or len(student_id) != 8:\n        raise ValueError(\"Invalid student ID format\")\n    \n    if student_id == \"STU12345\":\n        return {\n            \"student_id\": \"STU12345\",\n            \"exams\": [\n                {\"course\": \"DB101\", \"score\": 85, \"date\": \"2023-10-01\"},\n                {\"course\": \"DB101\", \"score\": 92, \"date\": \"2023-11-15\"}\n            ],\n            \"average_score\": 88.5\n        }\n    return {}\ndef write_student_feedback(student_id: str, exam_id: str, feedback: str) -> bool:\n    \"\"\"\n    Writes personalized feedback for a student's exam performance.\n    \n    :param student_id: The unique identifier for the student.\n    :param exam_id: The unique identifier for the exam.\n    :param feedback: The feedback text to be stored.\n    :return: Boolean indicating success of the operation.\n    :raises ValueError: If parameters are invalid.\n    \"\"\"\n    if not isinstance(student_id, str) or len(student_id) != 8:\n        raise ValueError(\"Invalid student ID format\")\n    if not isinstance(exam_id, str) or not exam_id.startswith(\"EX\"):\n        raise ValueError(\"Invalid exam ID format\")\n    if not feedback or len(feedback) > 1000:\n        raise ValueError(\"Invalid feedback format\")\n\n    if student_id == \"STU12345\" and exam_id == \"EX001\":\n        return True\n    return False\ndef get_class_statistics(course_id: str) -> dict:\n    \"\"\"\n    Generates statistical analysis of exam scores for an entire class.\n    \n    :param course_id: The unique identifier for the course.\n    :return: Dictionary containing class statistics.\n    :raises ValueError: If course_id is invalid.\n    \"\"\"\n    if not isinstance(course_id, str) or not course_id.startswith(\"DB\"):\n        raise ValueError(\"Invalid course ID format\")\n\n    if course_id == \"DB101\":\n        return {\n            \"course_id\": \"DB101\",\n            \"total_students\": 30,\n            \"average_score\": 82.5,\n            \"median_score\": 84.0,\n            \"highest_score\": 98,\n            \"lowest_score\": 65,\n            \"score_distribution\": {\n                \"90-100\": 5,\n                \"80-89\": 15,\n                \"70-79\": 8,\n                \"60-69\": 2\n            }\n        }\n    return {}", "user_query": "Professor Kim here.  Write feedback \"Great work!\" for student STU12345's exam EX001.", "checklist": {"functions": ["write_student_feedback"], "values": [true]}}
{"difficulty": "easy", "function_schema_python": "def normalize_patient_data(patient_record: dict) -> dict:\n    \"\"\"Normalizes patient data according to standardized schema.\n\n    :param patient_record: Dictionary containing patient information\n    :return: Normalized patient data dictionary with standard keys\n    :raises ValueError: If required fields are missing\"\"\"\n    pass\ndef create_medical_history_schema() -> dict:\n    \"\"\"Creates an optimized schema for medical history records.\n\n    :return: Dictionary containing schema definition\"\"\"\n    pass\ndef verify_hipaa_compliance(data_structure: dict) -> tuple[bool, list]:\n    \"\"\"Verifies if the given data structure meets HIPAA compliance requirements.\n\n    :param data_structure: Dictionary containing database schema or data structure\n    :return: Tuple of (compliance_status, list of violations if any)\"\"\"\n    pass\ndef optimize_query_performance(query_pattern: str) -> dict:\n    \"\"\"Optimizes database query patterns for improved performance.\n\n    :param query_pattern: String representing the query pattern to optimize\n    :return: Dictionary containing optimization recommendations and indexes\n    :raises ValueError: If query pattern is invalid\"\"\"\n    pass\n", "function_schema_json": [{"name": "normalize_patient_data", "description": "Normalizes patient data according to standardized schema.", "parameters": {"type": "object", "properties": {"patient_record": {"type": "object", "description": "Dictionary containing patient information"}}, "required": ["patient_record"], "additionalProperties": false}}, {"name": "create_medical_history_schema", "description": "Creates an optimized schema for medical history records.", "parameters": {"type": "object", "properties": {}, "required": [], "additionalProperties": false}}, {"name": "verify_hipaa_compliance", "description": "Verifies if the given data structure meets HIPAA compliance requirements.", "parameters": {"type": "object", "properties": {"data_structure": {"type": "object", "description": "Dictionary containing database schema or data structure"}}, "required": ["data_structure"], "additionalProperties": false}}, {"name": "optimize_query_performance", "description": "Optimizes database query patterns for improved performance.", "parameters": {"type": "object", "properties": {"query_pattern": {"type": "string", "description": "String representing the query pattern to optimize"}}, "required": ["query_pattern"], "additionalProperties": false}}], "mock_functions": "def normalize_patient_data(patient_record: dict) -> dict:\n    \"\"\"\n    Normalizes patient data according to standardized schema.\n    \n    :param patient_record: Dictionary containing patient information\n    :return: Normalized patient data dictionary with standard keys\n    :raises ValueError: If required fields are missing\n    \"\"\"\n    required_fields = ['patient_id', 'name', 'dob']\n    if not all(field in patient_record for field in required_fields):\n        raise ValueError(\"Missing required patient information\")\n    \n    if patient_record['patient_id'] == \"P12345\":\n        return {\n            \"patient_id\": \"P12345\",\n            \"name\": \"John Doe\",\n            \"dob\": \"1980-01-01\",\n            \"contact\": {\n                \"phone\": \"555-0123\",\n                \"email\": \"john.doe@email.com\"\n            },\n            \"insurance\": {\n                \"provider\": \"HealthCare Plus\",\n                \"policy_number\": \"HC123456\"\n            }\n        }\n    return {}\ndef create_medical_history_schema() -> dict:\n    \"\"\"\n    Creates an optimized schema for medical history records.\n    \n    :return: Dictionary containing schema definition\n    \"\"\"\n    return {\n        \"table_name\": \"medical_history\",\n        \"columns\": [\n            {\"name\": \"history_id\", \"type\": \"UUID\", \"primary_key\": True},\n            {\"name\": \"patient_id\", \"type\": \"UUID\", \"foreign_key\": \"patients.id\"},\n            {\"name\": \"condition\", \"type\": \"VARCHAR(255)\"},\n            {\"name\": \"diagnosis_date\", \"type\": \"TIMESTAMP\"},\n            {\"name\": \"treating_physician\", \"type\": \"UUID\"}\n        ],\n        \"indexes\": [\"patient_id\", \"diagnosis_date\"]\n    }\ndef verify_hipaa_compliance(data_structure: dict) -> tuple[bool, list]:\n    \"\"\"\n    Verifies if the given data structure meets HIPAA compliance requirements.\n    \n    :param data_structure: Dictionary containing database schema or data structure\n    :return: Tuple of (compliance_status, list of violations if any)\n    \"\"\"\n    if \"encryption\" in data_structure and \"audit_trail\" in data_structure:\n        return (True, [])\n    return (False, [\"Missing encryption\", \"Missing audit trail\"])\ndef optimize_query_performance(query_pattern: str) -> dict:\n    \"\"\"\n    Optimizes database query patterns for improved performance.\n    \n    :param query_pattern: String representing the query pattern to optimize\n    :return: Dictionary containing optimization recommendations and indexes\n    :raises ValueError: If query pattern is invalid\n    \"\"\"\n    if not query_pattern:\n        raise ValueError(\"Query pattern cannot be empty\")\n    \n    if query_pattern == \"patient_history_lookup\":\n        return {\n            \"recommended_indexes\": [\"patient_id\", \"visit_date\"],\n            \"partitioning_strategy\": \"range_partition_by_date\",\n            \"caching_strategy\": \"patient_record_cache\",\n            \"estimated_improvement\": \"60%\"\n        }\n    return {}", "user_query": "Can you normalize this patient record? {\"patient_id\": \"P12345\", \"name\": \"John Doe\", \"dob\": \"1980-01-01\"}", "checklist": {"functions": ["normalize_patient_data"], "values": [{"patient_id": "P12345", "name": "John Doe", "dob": "1980-01-01", "contact": {"phone": "555-0123", "email": "john.doe@email.com"}, "insurance": {"provider": "HealthCare Plus", "policy_number": "HC123456"}}]}}
{"difficulty": "easy", "function_schema_python": "def create_product(product_name: str, attributes: dict, seller_id: int) -> int:\n    \"\"\"Creates a new product with specified attributes and associates it with a seller.\n\n    :param product_name: The name of the product.\n    :param attributes: A dictionary of product attributes (e.g., color, size).\n    :param seller_id: The ID of the seller who is listing the product.\n    :return: The ID of the newly created product.\n    :raises ValueError: If product_name is empty or seller_id is invalid.\"\"\"\n    pass\ndef add_product_variation(product_id: int, variation_attributes: dict) -> bool:\n    \"\"\"Adds a variation to an existing product.\n\n    :param product_id: The ID of the product to which the variation is being added.\n    :param variation_attributes: A dictionary of the variation attributes (e.g., color: \"red\", size: \"XL\").\n    :return: True if the product variation was added successfully, False otherwise.\n    :raises ValueError: If product_id is invalid or variation_attributes is empty.\"\"\"\n    pass\ndef update_inventory(product_id: int, variation_id: int, quantity: int) -> bool:\n    \"\"\"Updates the inventory level of a product variation.\n\n    :param product_id: The ID of the product.\n    :param variation_id: The ID of the product variation.\n    :param quantity: The new quantity of the product variation in stock.\n    :return: True if the inventory was updated successfully, False otherwise.\n    :raises ValueError: If product_id, variation_id, or quantity is invalid.\"\"\"\n    pass\ndef apply_pricing_rule(product_id: int, rule_description: str) -> bool:\n    \"\"\"Applies a pricing rule to a product.\n\n    :param product_id: The ID of the product.\n    :param rule_description: A description of the pricing rule to be applied.\n    :return: True if the pricing rule was applied successfully, False otherwise.\n    :raises ValueError: If product_id is invalid or rule_description is empty.\"\"\"\n    pass\ndef get_product_details(product_id: int) -> dict:\n    \"\"\"Retrieves detailed information about a product.\n\n    :param product_id: The ID of the product.\n    :return:\n        dict: A dictionary with the following keys:\n            - name (str): The name of the product.\n            - attributes (dict): A dictionary of product attributes.\n            - variations (list[dict]): A list of product variation details.\n            - inventory (dict): A dictionary of product inventory details.\n            - pricing_rules (list[str]): A list of pricing rules applied to the product.\n    :raises ValueError: If product_id is invalid.\"\"\"\n    pass\ndef list_vendors() -> list:\n    \"\"\"Lists all vendors currently on the platform.\n\n    :return: A list of dictionaries containing vendor details.\n        Each dictionary has the following keys:\n            - id (int): The ID of the vendor.\n            - name (str): The name of the vendor.\n            - products (list[int]): A list of product IDs associated with the vendor.\"\"\"\n    pass\n", "function_schema_json": [{"name": "create_product", "description": "Creates a new product with specified attributes and associates it with a seller.", "parameters": {"type": "object", "properties": {"product_name": {"type": "string", "description": "The name of the product."}, "attributes": {"type": "object", "description": "A dictionary of product attributes (e.g., color, size)."}, "seller_id": {"type": "integer", "description": "The ID of the seller who is listing the product."}}, "required": ["product_name", "attributes", "seller_id"], "additionalProperties": false}}, {"name": "add_product_variation", "description": "Adds a variation to an existing product.", "parameters": {"type": "object", "properties": {"product_id": {"type": "integer", "description": "The ID of the product to which the variation is being added."}, "variation_attributes": {"type": "object", "description": "A dictionary of the variation attributes (e.g., color: \"red\", size: \"XL\")."}}, "required": ["product_id", "variation_attributes"], "additionalProperties": false}}, {"name": "update_inventory", "description": "Updates the inventory level of a product variation.", "parameters": {"type": "object", "properties": {"product_id": {"type": "integer", "description": "The ID of the product."}, "variation_id": {"type": "integer", "description": "The ID of the product variation."}, "quantity": {"type": "integer", "description": "The new quantity of the product variation in stock."}}, "required": ["product_id", "variation_id", "quantity"], "additionalProperties": false}}, {"name": "apply_pricing_rule", "description": "Applies a pricing rule to a product.", "parameters": {"type": "object", "properties": {"product_id": {"type": "integer", "description": "The ID of the product."}, "rule_description": {"type": "string", "description": "A description of the pricing rule to be applied."}}, "required": ["product_id", "rule_description"], "additionalProperties": false}}, {"name": "get_product_details", "description": "Retrieves detailed information about a product.", "parameters": {"type": "object", "properties": {"product_id": {"type": "integer", "description": "The ID of the product."}}, "required": ["product_id"], "additionalProperties": false}}, {"name": "list_vendors", "description": "Lists all vendors currently on the platform.", "parameters": {"type": "object", "properties": {}, "required": [], "additionalProperties": false}}], "mock_functions": "def create_product(product_name: str, attributes: dict, seller_id: int) -> int:\n    \"\"\"\n    Creates a new product with specified attributes and associates it with a seller.\n\n    :param product_name: The name of the product.\n    :param attributes: A dictionary of product attributes (e.g., color, size).\n    :param seller_id: The ID of the seller who is listing the product.\n    :return: The ID of the newly created product.\n    :raises ValueError: If product_name is empty or seller_id is invalid.\n    \"\"\"\n    if not product_name:\n        raise ValueError(\"Product name must not be empty.\")\n    if not isinstance(seller_id, int) or seller_id <= 0:\n        raise ValueError(\"Seller ID must be a positive integer.\")\n    if not isinstance(attributes, dict):\n        raise ValueError(\"Attributes must be a dictionary.\")\n    return 1001  # Mock product ID\ndef add_product_variation(product_id: int, variation_attributes: dict) -> bool:\n    \"\"\"\n    Adds a variation to an existing product.\n\n    :param product_id: The ID of the product to which the variation is being added.\n    :param variation_attributes: A dictionary of the variation attributes (e.g., color: \"red\", size: \"XL\").\n    :return: True if the product variation was added successfully, False otherwise.\n    :raises ValueError: If product_id is invalid or variation_attributes is empty.\n    \"\"\"\n    if not isinstance(product_id, int) or product_id <= 0:\n        raise ValueError(\"Product ID must be a positive integer.\")\n    if not isinstance(variation_attributes, dict) or not variation_attributes:\n        raise ValueError(\"Variation attributes must be a non-empty dictionary.\")\n    return True\ndef update_inventory(product_id: int, variation_id: int, quantity: int) -> bool:\n    \"\"\"\n    Updates the inventory level of a product variation.\n\n    :param product_id: The ID of the product.\n    :param variation_id: The ID of the product variation.\n    :param quantity: The new quantity of the product variation in stock.\n    :return: True if the inventory was updated successfully, False otherwise.\n    :raises ValueError: If product_id, variation_id, or quantity is invalid.\n    \"\"\"\n    if not isinstance(product_id, int) or product_id <= 0:\n        raise ValueError(\"Product ID must be a positive integer.\")\n    if not isinstance(variation_id, int) or variation_id <= 0:\n        raise ValueError(\"Variation ID must be a positive integer.\")\n    if not isinstance(quantity, int) or quantity < 0:\n        raise ValueError(\"Quantity must be a non-negative integer.\")\n    return True\ndef apply_pricing_rule(product_id: int, rule_description: str) -> bool:\n    \"\"\"\n    Applies a pricing rule to a product.\n\n    :param product_id: The ID of the product.\n    :param rule_description: A description of the pricing rule to be applied.\n    :return: True if the pricing rule was applied successfully, False otherwise.\n    :raises ValueError: If product_id is invalid or rule_description is empty.\n    \"\"\"\n    if not isinstance(product_id, int) or product_id <= 0:\n        raise ValueError(\"Product ID must be a positive integer.\")\n    if not rule_description:\n        raise ValueError(\"Rule description must not be empty.\")\n    return True\ndef get_product_details(product_id: int) -> dict:\n    \"\"\"\n    Retrieves detailed information about a product.\n\n    :param product_id: The ID of the product.\n    :return:\n        dict: A dictionary with the following keys:\n            - name (str): The name of the product.\n            - attributes (dict): A dictionary of product attributes.\n            - variations (list[dict]): A list of product variation details.\n            - inventory (dict): A dictionary of product inventory details.\n            - pricing_rules (list[str]): A list of pricing rules applied to the product.\n    :raises ValueError: If product_id is invalid.\n    \"\"\"\n    if not isinstance(product_id, int) or product_id <= 0:\n        raise ValueError(\"Product ID must be a positive integer.\")\n    return {\n        \"name\": \"Sample Product\",\n        \"attributes\": {\"color\": \"red\", \"size\": \"XL\"},\n        \"variations\": [{\"id\": 2001, \"attributes\": {\"color\": \"red\", \"size\": \"XL\"}, \"quantity\": 50}],\n        \"inventory\": {\"total_quantity\": 50, \"variations\": [{\"id\": 2001, \"quantity\": 50}]},\n        \"pricing_rules\": [\"10% off for bulk orders\"]\n    }\ndef list_vendors() -> list:\n    \"\"\"\n    Lists all vendors currently on the platform.\n\n    :return: A list of dictionaries containing vendor details.\n        Each dictionary has the following keys:\n            - id (int): The ID of the vendor.\n            - name (str): The name of the vendor.\n            - products (list[int]): A list of product IDs associated with the vendor.\n    \"\"\"\n    return [\n        {\"id\": 1, \"name\": \"Vendor A\", \"products\": [1001, 1002]},\n        {\"id\": 2, \"name\": \"Vendor B\", \"products\": [1003, 1004]}\n    ]", "user_query": "Can you create a new product called \"Smart Running Shoes\" with attributes color and size for seller ID 2?", "checklist": {"functions": ["create_product"], "values": [1001]}}
{"difficulty": "easy", "function_schema_python": "def get_system_resources() -> dict:\n    \"\"\"Retrieves current system resource usage statistics.\n\n    :return: Dictionary containing system resource information\n        - cpu_percent (float): CPU usage percentage\n        - memory_percent (float): Memory usage percentage\n        - disk_usage (float): Disk usage percentage\n        - network_usage (dict): Network interface statistics\n    :raises RuntimeError: If unable to retrieve system statistics\"\"\"\n    pass\ndef list_resource_intensive_processes() -> list:\n    \"\"\"Lists all processes consuming significant system resources.\n\n    :return: List of dictionaries containing process information\n        - pid (int): Process ID\n        - name (str): Process name\n        - cpu_percent (float): CPU usage percentage\n        - memory_percent (float): Memory usage percentage\n    :raises RuntimeError: If unable to retrieve process list\"\"\"\n    pass\ndef terminate_process(pid: int) -> bool:\n    \"\"\"Terminates a specific process by its process ID.\n\n    :param pid: Process ID to terminate\n    :return: True if process was successfully terminated, False otherwise\n    :raises ValueError: If pid is invalid\n    :raises PermissionError: If user lacks permission to terminate the process\"\"\"\n    pass\ndef optimize_system_resources(target_cpu_percent: float) -> bool:\n    \"\"\"Automatically optimizes system resources by managing processes.\n\n    :param target_cpu_percent: Target CPU usage percentage to achieve\n    :return: True if optimization was successful, False otherwise\n    :raises ValueError: If target_cpu_percent is not between 0 and 100\"\"\"\n    pass\n", "function_schema_json": [{"name": "get_system_resources", "description": "Retrieves current system resource usage statistics.", "parameters": {"type": "object", "properties": {}, "required": [], "additionalProperties": false}}, {"name": "list_resource_intensive_processes", "description": "Lists all processes consuming significant system resources.", "parameters": {"type": "object", "properties": {}, "required": [], "additionalProperties": false}}, {"name": "terminate_process", "description": "Terminates a specific process by its process ID.", "parameters": {"type": "object", "properties": {"pid": {"type": "integer", "description": "Process ID to terminate"}}, "required": ["pid"], "additionalProperties": false}}, {"name": "optimize_system_resources", "description": "Automatically optimizes system resources by managing processes.", "parameters": {"type": "object", "properties": {"target_cpu_percent": {"type": "number", "description": "Target CPU usage percentage to achieve"}}, "required": ["target_cpu_percent"], "additionalProperties": false}}], "mock_functions": "def get_system_resources() -> dict:\n    \"\"\"\n    Retrieves current system resource usage statistics.\n    \n    :return: Dictionary containing system resource information\n        - cpu_percent (float): CPU usage percentage\n        - memory_percent (float): Memory usage percentage\n        - disk_usage (float): Disk usage percentage\n        - network_usage (dict): Network interface statistics\n    :raises RuntimeError: If unable to retrieve system statistics\n    \"\"\"\n    return {\n        \"cpu_percent\": 85.5,\n        \"memory_percent\": 92.3,\n        \"disk_usage\": 76.8,\n        \"network_usage\": {\n            \"bytes_sent\": 1024567,\n            \"bytes_received\": 2048976\n        }\n    }\ndef list_resource_intensive_processes() -> list:\n    \"\"\"\n    Lists all processes consuming significant system resources.\n    \n    :return: List of dictionaries containing process information\n        - pid (int): Process ID\n        - name (str): Process name\n        - cpu_percent (float): CPU usage percentage\n        - memory_percent (float): Memory usage percentage\n    :raises RuntimeError: If unable to retrieve process list\n    \"\"\"\n    return [\n        {\n            \"pid\": 1234,\n            \"name\": \"data_processing.py\",\n            \"cpu_percent\": 75.5,\n            \"memory_percent\": 45.2\n        },\n        {\n            \"pid\": 5678,\n            \"name\": \"chrome\",\n            \"cpu_percent\": 25.8,\n            \"memory_percent\": 32.1\n        }\n    ]\ndef terminate_process(pid: int) -> bool:\n    \"\"\"\n    Terminates a specific process by its process ID.\n    \n    :param pid: Process ID to terminate\n    :return: True if process was successfully terminated, False otherwise\n    :raises ValueError: If pid is invalid\n    :raises PermissionError: If user lacks permission to terminate the process\n    \"\"\"\n    if not isinstance(pid, int) or pid <= 0:\n        raise ValueError(\"Invalid process ID\")\n    if pid == 1234:\n        return True\n    return False\ndef optimize_system_resources(target_cpu_percent: float = 70.0) -> bool:\n    \"\"\"\n    Automatically optimizes system resources by managing processes.\n    \n    :param target_cpu_percent: Target CPU usage percentage to achieve\n    :return: True if optimization was successful, False otherwise\n    :raises ValueError: If target_cpu_percent is not between 0 and 100\n    \"\"\"\n    if not 0 <= target_cpu_percent <= 100:\n        raise ValueError(\"Target CPU percentage must be between 0 and 100\")\n    return True if target_cpu_percent == 70.0 else False", "user_query": "What are the current CPU and memory usage statistics on Alex's system?", "checklist": {"functions": ["get_system_resources"], "values": [{"cpu_percent": 85.5, "memory_percent": 92.3, "disk_usage": 76.8, "network_usage": {"bytes_sent": 1024567, "bytes_received": 2048976}}]}}
{"difficulty": "easy", "function_schema_python": "def get_system_resources() -> dict:\n    \"\"\"Retrieves current system resource usage statistics.\n\n    :return: Dictionary containing system resource information\n        - cpu_percent (float): CPU usage percentage\n        - memory_percent (float): Memory usage percentage\n        - disk_usage (float): Disk usage percentage\n        - network_usage (dict): Network interface statistics\n    :raises RuntimeError: If unable to retrieve system statistics\"\"\"\n    pass\ndef list_resource_intensive_processes() -> list:\n    \"\"\"Lists all processes consuming significant system resources.\n\n    :return: List of dictionaries containing process information\n        - pid (int): Process ID\n        - name (str): Process name\n        - cpu_percent (float): CPU usage percentage\n        - memory_percent (float): Memory usage percentage\n    :raises RuntimeError: If unable to retrieve process list\"\"\"\n    pass\ndef terminate_process(pid: int) -> bool:\n    \"\"\"Terminates a specific process by its process ID.\n\n    :param pid: Process ID to terminate\n    :return: True if process was successfully terminated, False otherwise\n    :raises ValueError: If pid is invalid\n    :raises PermissionError: If user lacks permission to terminate the process\"\"\"\n    pass\ndef optimize_system_resources(target_cpu_percent: float) -> bool:\n    \"\"\"Automatically optimizes system resources by managing processes.\n\n    :param target_cpu_percent: Target CPU usage percentage to achieve\n    :return: True if optimization was successful, False otherwise\n    :raises ValueError: If target_cpu_percent is not between 0 and 100\"\"\"\n    pass\n", "function_schema_json": [{"name": "get_system_resources", "description": "Retrieves current system resource usage statistics.", "parameters": {"type": "object", "properties": {}, "required": [], "additionalProperties": false}}, {"name": "list_resource_intensive_processes", "description": "Lists all processes consuming significant system resources.", "parameters": {"type": "object", "properties": {}, "required": [], "additionalProperties": false}}, {"name": "terminate_process", "description": "Terminates a specific process by its process ID.", "parameters": {"type": "object", "properties": {"pid": {"type": "integer", "description": "Process ID to terminate"}}, "required": ["pid"], "additionalProperties": false}}, {"name": "optimize_system_resources", "description": "Automatically optimizes system resources by managing processes.", "parameters": {"type": "object", "properties": {"target_cpu_percent": {"type": "number", "description": "Target CPU usage percentage to achieve"}}, "required": ["target_cpu_percent"], "additionalProperties": false}}], "mock_functions": "def get_system_resources() -> dict:\n    \"\"\"\n    Retrieves current system resource usage statistics.\n    \n    :return: Dictionary containing system resource information\n        - cpu_percent (float): CPU usage percentage\n        - memory_percent (float): Memory usage percentage\n        - disk_usage (float): Disk usage percentage\n        - network_usage (dict): Network interface statistics\n    :raises RuntimeError: If unable to retrieve system statistics\n    \"\"\"\n    return {\n        \"cpu_percent\": 85.5,\n        \"memory_percent\": 92.3,\n        \"disk_usage\": 76.8,\n        \"network_usage\": {\n            \"bytes_sent\": 1024567,\n            \"bytes_received\": 2048976\n        }\n    }\ndef list_resource_intensive_processes() -> list:\n    \"\"\"\n    Lists all processes consuming significant system resources.\n    \n    :return: List of dictionaries containing process information\n        - pid (int): Process ID\n        - name (str): Process name\n        - cpu_percent (float): CPU usage percentage\n        - memory_percent (float): Memory usage percentage\n    :raises RuntimeError: If unable to retrieve process list\n    \"\"\"\n    return [\n        {\n            \"pid\": 1234,\n            \"name\": \"data_processing.py\",\n            \"cpu_percent\": 75.5,\n            \"memory_percent\": 45.2\n        },\n        {\n            \"pid\": 5678,\n            \"name\": \"chrome\",\n            \"cpu_percent\": 25.8,\n            \"memory_percent\": 32.1\n        }\n    ]\ndef terminate_process(pid: int) -> bool:\n    \"\"\"\n    Terminates a specific process by its process ID.\n    \n    :param pid: Process ID to terminate\n    :return: True if process was successfully terminated, False otherwise\n    :raises ValueError: If pid is invalid\n    :raises PermissionError: If user lacks permission to terminate the process\n    \"\"\"\n    if not isinstance(pid, int) or pid <= 0:\n        raise ValueError(\"Invalid process ID\")\n    if pid == 1234:\n        return True\n    return False\ndef optimize_system_resources(target_cpu_percent: float = 70.0) -> bool:\n    \"\"\"\n    Automatically optimizes system resources by managing processes.\n    \n    :param target_cpu_percent: Target CPU usage percentage to achieve\n    :return: True if optimization was successful, False otherwise\n    :raises ValueError: If target_cpu_percent is not between 0 and 100\n    \"\"\"\n    if not 0 <= target_cpu_percent <= 100:\n        raise ValueError(\"Target CPU percentage must be between 0 and 100\")\n    return True if target_cpu_percent == 70.0 else False", "user_query": "Could you list all resource-intensive processes running on Alex's system right now?", "checklist": {"functions": ["list_resource_intensive_processes"], "values": [[{"pid": 1234, "name": "data_processing.py", "cpu_percent": 75.5, "memory_percent": 45.2}, {"pid": 5678, "name": "chrome", "cpu_percent": 25.8, "memory_percent": 32.1}]]}}
{"difficulty": "easy", "function_schema_python": "def check_user_permissions(username: str, folder_path: str) -> dict:\n    \"\"\"Checks the permissions of a specific user for a given network folder.\n\n    :param username: The username to check permissions for.\n    :param folder_path: The network folder path to check.\n    :return: Dictionary containing permission details:\n        - read (bool): Whether user has read permissions\n        - write (bool): Whether user has write permissions\n        - execute (bool): Whether user has execute permissions\n        - owner (str): Owner of the folder\n    :raises ValueError: If username or folder path is invalid.\"\"\"\n    pass\ndef modify_folder_permissions(username: str, folder_path: str, permissions: dict) -> bool:\n    \"\"\"Modifies the permissions for a specific user on a network folder.\n\n    :param username: The username to modify permissions for.\n    :param folder_path: The network folder path to modify.\n    :param permissions: Dictionary containing permission settings:\n        - read (bool): Whether to grant read permissions\n        - write (bool): Whether to grant write permissions\n        - execute (bool): Whether to grant execute permissions\n    :return: True if permissions were successfully modified, False otherwise.\n    :raises ValueError: If invalid parameters are provided.\"\"\"\n    pass\ndef verify_folder_access(username: str, folder_path: str) -> bool:\n    \"\"\"Verifies if a user can actually access a specific folder after permission changes.\n\n    :param username: The username to verify access for.\n    :param folder_path: The network folder path to verify.\n    :return: True if user can access the folder, False otherwise.\n    :raises ValueError: If username or folder path is invalid.\"\"\"\n    pass\n", "function_schema_json": [{"name": "check_user_permissions", "description": "Checks the permissions of a specific user for a given network folder.", "parameters": {"type": "object", "properties": {"username": {"type": "string", "description": "The username to check permissions for."}, "folder_path": {"type": "string", "description": "The network folder path to check."}}, "required": ["username", "folder_path"], "additionalProperties": false}}, {"name": "modify_folder_permissions", "description": "Modifies the permissions for a specific user on a network folder.", "parameters": {"type": "object", "properties": {"username": {"type": "string", "description": "The username to modify permissions for."}, "folder_path": {"type": "string", "description": "The network folder path to modify."}, "permissions": {"type": "object", "description": "Dictionary containing permission settings:"}}, "required": ["username", "folder_path", "permissions"], "additionalProperties": false}}, {"name": "verify_folder_access", "description": "Verifies if a user can actually access a specific folder after permission changes.", "parameters": {"type": "object", "properties": {"username": {"type": "string", "description": "The username to verify access for."}, "folder_path": {"type": "string", "description": "The network folder path to verify."}}, "required": ["username", "folder_path"], "additionalProperties": false}}], "mock_functions": "def check_user_permissions(username: str, folder_path: str) -> dict:\n    \"\"\"\n    Checks the permissions of a specific user for a given network folder.\n    \n    :param username: The username to check permissions for.\n    :param folder_path: The network folder path to check.\n    :return: Dictionary containing permission details:\n        - read (bool): Whether user has read permissions\n        - write (bool): Whether user has write permissions\n        - execute (bool): Whether user has execute permissions\n        - owner (str): Owner of the folder\n    :raises ValueError: If username or folder path is invalid.\n    \"\"\"\n    if not username or not folder_path:\n        raise ValueError(\"Username and folder path must be provided\")\n    \n    if username.lower() == \"alex\" and folder_path == \"\\\\\\\\server\\\\shared\\\\documents\":\n        return {\n            \"read\": False,\n            \"write\": False,\n            \"execute\": False,\n            \"owner\": \"Administrator\"\n        }\n    return {\n        \"read\": True,\n        \"write\": True,\n        \"execute\": True,\n        \"owner\": \"Administrator\"\n    }\ndef modify_folder_permissions(username: str, folder_path: str, permissions: dict) -> bool:\n    \"\"\"\n    Modifies the permissions for a specific user on a network folder.\n    \n    :param username: The username to modify permissions for.\n    :param folder_path: The network folder path to modify.\n    :param permissions: Dictionary containing permission settings:\n        - read (bool): Whether to grant read permissions\n        - write (bool): Whether to grant write permissions\n        - execute (bool): Whether to grant execute permissions\n    :return: True if permissions were successfully modified, False otherwise.\n    :raises ValueError: If invalid parameters are provided.\n    \"\"\"\n    if not username or not folder_path:\n        raise ValueError(\"Username and folder path must be provided\")\n    \n    required_keys = [\"read\", \"write\", \"execute\"]\n    if not all(key in permissions for key in required_keys):\n        raise ValueError(\"Permissions dictionary must contain read, write, and execute keys\")\n\n    if username.lower() == \"alex\" and folder_path == \"\\\\\\\\server\\\\shared\\\\documents\":\n        return True\n    return False\ndef verify_folder_access(username: str, folder_path: str) -> bool:\n    \"\"\"\n    Verifies if a user can actually access a specific folder after permission changes.\n    \n    :param username: The username to verify access for.\n    :param folder_path: The network folder path to verify.\n    :return: True if user can access the folder, False otherwise.\n    :raises ValueError: If username or folder path is invalid.\n    \"\"\"\n    if not username or not folder_path:\n        raise ValueError(\"Username and folder path must be provided\")\n    \n    if username.lower() == \"alex\" and folder_path == \"\\\\\\\\server\\\\shared\\\\documents\":\n        return True\n    return False", "user_query": "Can you check if Alex has read permissions for the folder \\\\server\\shared\\documents?", "checklist": {"functions": ["check_user_permissions"], "values": [{"read": false, "write": false, "execute": false, "owner": "Administrator"}]}}
{"difficulty": "easy", "function_schema_python": "def identify_large_files(directory: str, size_threshold_mb: int) -> list:\n    \"\"\"Identifies files larger than a specified size in a given directory.\n\n    :param directory: The directory to search.\n    :param size_threshold_mb: The size threshold in MB.\n    :return: A list of file paths exceeding the size threshold.\"\"\"\n    pass\ndef archive_old_files(directory: str, days_threshold: int) -> list:\n    \"\"\"Archives files older than a specified number of days.\n\n    :param directory: The directory to process.\n    :param days_threshold: The age threshold in days.\n    :return: A list of archived file paths.\"\"\"\n    pass\ndef generate_filesystem_report(directory: str) -> dict:\n    \"\"\"Generates a report of file system usage.\n\n    :param directory: The directory to analyze.\n    :return: A dictionary containing usage statistics.\"\"\"\n    pass\ndef remove_temp_files(directory: str, days_threshold: int) -> list:\n    \"\"\"Removes temporary files that haven't been accessed in a specified number of days.\n\n    :param directory: The directory to clean.\n    :param days_threshold: The inactivity threshold in days.\n    :return: A list of removed file paths.\"\"\"\n    pass\n", "function_schema_json": [{"name": "identify_large_files", "description": "Identifies files larger than a specified size in a given directory.", "parameters": {"type": "object", "properties": {"directory": {"type": "string", "description": "The directory to search."}, "size_threshold_mb": {"type": "integer", "description": "The size threshold in MB."}}, "required": ["directory", "size_threshold_mb"], "additionalProperties": false}}, {"name": "archive_old_files", "description": "Archives files older than a specified number of days.", "parameters": {"type": "object", "properties": {"directory": {"type": "string", "description": "The directory to process."}, "days_threshold": {"type": "integer", "description": "The age threshold in days."}}, "required": ["directory", "days_threshold"], "additionalProperties": false}}, {"name": "generate_filesystem_report", "description": "Generates a report of file system usage.", "parameters": {"type": "object", "properties": {"directory": {"type": "string", "description": "The directory to analyze."}}, "required": ["directory"], "additionalProperties": false}}, {"name": "remove_temp_files", "description": "Removes temporary files that haven't been accessed in a specified number of days.", "parameters": {"type": "object", "properties": {"directory": {"type": "string", "description": "The directory to clean."}, "days_threshold": {"type": "integer", "description": "The inactivity threshold in days."}}, "required": ["directory", "days_threshold"], "additionalProperties": false}}], "mock_functions": "def identify_large_files(directory: str, size_threshold_mb: int) -> list:\n    \"\"\"\n    Identifies files larger than a specified size in a given directory.\n\n    :param directory: The directory to search.\n    :param size_threshold_mb: The size threshold in MB.\n    :return: A list of file paths exceeding the size threshold.\n    \"\"\"\n    large_files = []\n    if not directory or size_threshold_mb <= 0:\n        return []  # or raise ValueError for stricter input validation\n\n    # Mock implementation\n    if directory == \"/dev/projects\" and size_threshold_mb >= 500:\n        large_files = [\n            \"/dev/projects/project_a/large_file_1.zip\",\n            \"/dev/projects/project_b/large_dataset.csv\"\n        ]\n\n    return large_files\ndef archive_old_files(directory: str, days_threshold: int) -> list:\n    \"\"\"\n    Archives files older than a specified number of days.\n\n    :param directory: The directory to process.\n    :param days_threshold: The age threshold in days.\n    :return: A list of archived file paths.\n    \"\"\"\n    archived_files = []\n\n    if not directory or days_threshold <= 0:\n        return [] # or raise ValueError\n\n    # Mock implementation\n    if directory == \"/dev/projects\" and days_threshold >= 180:\n        archived_files = [\n            \"/dev/projects/project_a/old_report.pdf\",\n            \"/dev/projects/project_b/archive_data.tar.gz\"\n        ]\n    return archived_files\ndef generate_filesystem_report(directory: str) -> dict:\n    \"\"\"\n    Generates a report of file system usage.\n\n    :param directory: The directory to analyze.\n    :return: A dictionary containing usage statistics.\n    \"\"\"\n    if not directory:\n        return {}\n\n    # Mock implementation\n    if directory == \"/dev/projects\":\n        return {\n            \"total_space\": \"100GB\",\n            \"used_space\": \"60GB\",\n            \"free_space\": \"40GB\"\n        }\n    return {}\ndef remove_temp_files(directory: str, days_threshold: int) -> list:\n    \"\"\"\n    Removes temporary files that haven't been accessed in a specified number of days.\n\n    :param directory: The directory to clean.\n    :param days_threshold: The inactivity threshold in days.\n    :return: A list of removed file paths.\n    \"\"\"\n    removed_files = []\n\n    if not directory or days_threshold <= 0:\n        return [] # or raise ValueError\n    \n    if directory == \"/tmp\" and days_threshold >= 30:\n        removed_files = [\n            \"/tmp/temp_file_1.txt\",\n            \"/tmp/temp_file_2.log\"\n        ]\n\n    return removed_files", "user_query": "Please archive files older than 180 days in the directory /dev/projects and let me know which files are archived.", "checklist": {"functions": ["archive_old_files"], "values": [["/dev/projects/project_a/old_report.pdf", "/dev/projects/project_b/archive_data.tar.gz"]]}}
{"difficulty": "easy", "function_schema_python": "def connect_ssh(host: str, username: str) -> bool:\n    \"\"\"Simulates connecting to a remote server via SSH.\n\n    :param host: The IP address or hostname of the remote server.\n    :param username: The username for the SSH connection.\n    :return: True if the connection is successful, False otherwise.\n    :raises ValueError: If host or username is not provided.\"\"\"\n    pass\ndef transfer_files_to_remote(host: str, local_path: str, remote_path: str) -> bool:\n    \"\"\"Simulates transferring files to a remote server using SCP.\n\n    :param host: The IP address or hostname of the remote server.\n    :param local_path: The local file path to transfer.\n    :param remote_path: The destination file path on the remote server.\n    :return: True if the transfer is successful, False otherwise.\n    :raises ValueError: If host, local_path, or remote_path is not provided.\"\"\"\n    pass\ndef verify_system_permissions(host: str) -> dict:\n    \"\"\"Simulates verifying system permissions on a remote server.\n\n    :param host: The IP address or hostname of the remote server.\n    :return: A dictionary with the following keys:\n            - has_root_access (bool): True if root access is available, False otherwise.\n            - sudo_required (bool): True if sudo is required, False otherwise.\n    :raises ValueError: If host is not provided.\"\"\"\n    pass\ndef execute_remote_command(host: str, command: str) -> str:\n    \"\"\"Simulates executing a command on a remote server.\n\n    :param host: The IP address or hostname of the remote server.\n    :param command: The command to execute on the remote server.\n    :return: The output of the command if successful, an error message otherwise.\n    :raises ValueError: If host or command is not provided.\"\"\"\n    pass\ndef check_docker_version(host: str) -> str:\n    \"\"\"Simulates checking the Docker version on a remote server.\n\n    :param host: The IP address or hostname of the remote server.\n    :return: The version of Docker installed on the server, or an error message if Docker is not installed.\n    :raises ValueError: If host is not provided.\"\"\"\n    pass\ndef scan_open_ports(host: str) -> list:\n    \"\"\"Simulates scanning for open ports on a remote server.\n\n    :param host: The IP address or hostname of the remote server.\n    :return: A list of open ports.\n    :raises ValueError: If host is not provided.\"\"\"\n    pass\ndef list_running_processes(host: str) -> list:\n    \"\"\"Simulates listing running processes on a remote server.\n\n    :param host: The IP address or hostname of the remote server.\n    :return: A list of running processes with their PIDs.\n    :raises ValueError: If host is not provided.\"\"\"\n    pass\n", "function_schema_json": [{"name": "connect_ssh", "description": "Simulates connecting to a remote server via SSH.", "parameters": {"type": "object", "properties": {"host": {"type": "string", "description": "The IP address or hostname of the remote server."}, "username": {"type": "string", "description": "The username for the SSH connection."}}, "required": ["host", "username"], "additionalProperties": false}}, {"name": "transfer_files_to_remote", "description": "Simulates transferring files to a remote server using SCP.", "parameters": {"type": "object", "properties": {"host": {"type": "string", "description": "The IP address or hostname of the remote server."}, "local_path": {"type": "string", "description": "The local file path to transfer."}, "remote_path": {"type": "string", "description": "The destination file path on the remote server."}}, "required": ["host", "local_path", "remote_path"], "additionalProperties": false}}, {"name": "verify_system_permissions", "description": "Simulates verifying system permissions on a remote server.", "parameters": {"type": "object", "properties": {"host": {"type": "string", "description": "The IP address or hostname of the remote server."}}, "required": ["host"], "additionalProperties": false}}, {"name": "execute_remote_command", "description": "Simulates executing a command on a remote server.", "parameters": {"type": "object", "properties": {"host": {"type": "string", "description": "The IP address or hostname of the remote server."}, "command": {"type": "string", "description": "The command to execute on the remote server."}}, "required": ["host", "command"], "additionalProperties": false}}, {"name": "check_docker_version", "description": "Simulates checking the Docker version on a remote server.", "parameters": {"type": "object", "properties": {"host": {"type": "string", "description": "The IP address or hostname of the remote server."}}, "required": ["host"], "additionalProperties": false}}, {"name": "scan_open_ports", "description": "Simulates scanning for open ports on a remote server.", "parameters": {"type": "object", "properties": {"host": {"type": "string", "description": "The IP address or hostname of the remote server."}}, "required": ["host"], "additionalProperties": false}}, {"name": "list_running_processes", "description": "Simulates listing running processes on a remote server.", "parameters": {"type": "object", "properties": {"host": {"type": "string", "description": "The IP address or hostname of the remote server."}}, "required": ["host"], "additionalProperties": false}}], "mock_functions": "def connect_ssh(host: str, username: str) -> bool:\n    \"\"\"\n    Simulates connecting to a remote server via SSH.\n    \n    :param host: The IP address or hostname of the remote server.\n    :param username: The username for the SSH connection.\n    :return: True if the connection is successful, False otherwise.\n    :raises ValueError: If host or username is not provided.\n    \"\"\"\n    if not host or not username:\n        raise ValueError(\"Host and username must be provided.\")\n    # Mock logic: Always return True for demonstration purposes.\n    return True\ndef transfer_files_to_remote(host: str, local_path: str, remote_path: str) -> bool:\n    \"\"\"\n    Simulates transferring files to a remote server using SCP.\n    \n    :param host: The IP address or hostname of the remote server.\n    :param local_path: The local file path to transfer.\n    :param remote_path: The destination file path on the remote server.\n    :return: True if the transfer is successful, False otherwise.\n    :raises ValueError: If host, local_path, or remote_path is not provided.\n    \"\"\"\n    if not host or not local_path or not remote_path:\n        raise ValueError(\"Host, local path, and remote path must be provided.\")\n    # Mock logic: Check if the local file exists and assume transfer is successful.\n    return os.path.exists(local_path)\ndef verify_system_permissions(host: str) -> dict:\n    \"\"\"\n    Simulates verifying system permissions on a remote server.\n    \n    :param host: The IP address or hostname of the remote server.\n    :return: A dictionary with the following keys:\n            - has_root_access (bool): True if root access is available, False otherwise.\n            - sudo_required (bool): True if sudo is required, False otherwise.\n    :raises ValueError: If host is not provided.\n    \"\"\"\n    if not host:\n        raise ValueError(\"Host must be provided.\")\n    # Mock logic: Assume root access without sudo.\n    return {\n        \"has_root_access\": True,\n        \"sudo_required\": False\n    }\ndef execute_remote_command(host: str, command: str) -> str:\n    \"\"\"\n    Simulates executing a command on a remote server.\n    \n    :param host: The IP address or hostname of the remote server.\n    :param command: The command to execute on the remote server.\n    :return: The output of the command if successful, an error message otherwise.\n    :raises ValueError: If host or command is not provided.\n    \"\"\"\n    if not host or not command:\n        raise ValueError(\"Host and command must be provided.\")\n    # Mock logic: Return a mock output for demonstration purposes.\n    return \"Command executed successfully on \" + host\ndef check_docker_version(host: str) -> str:\n    \"\"\"\n    Simulates checking the Docker version on a remote server.\n    \n    :param host: The IP address or hostname of the remote server.\n    :return: The version of Docker installed on the server, or an error message if Docker is not installed.\n    :raises ValueError: If host is not provided.\n    \"\"\"\n    if not host:\n        raise ValueError(\"Host must be provided.\")\n    # Mock logic: Assume Docker is installed and return a dummy version.\n    return \"Docker version 20.10.7, build f0df350\"\ndef scan_open_ports(host: str) -> list:\n    \"\"\"\n    Simulates scanning for open ports on a remote server.\n    \n    :param host: The IP address or hostname of the remote server.\n    :return: A list of open ports.\n    :raises ValueError: If host is not provided.\n    \"\"\"\n    if not host:\n        raise ValueError(\"Host must be provided.\")\n    # Mock logic: Assume certain ports are open.\n    return [22, 80, 443]\ndef list_running_processes(host: str) -> list:\n    \"\"\"\n    Simulates listing running processes on a remote server.\n    \n    :param host: The IP address or hostname of the remote server.\n    :return: A list of running processes with their PIDs.\n    :raises ValueError: If host is not provided.\n    \"\"\"\n    if not host:\n        raise ValueError(\"Host must be provided.\")\n    # Mock logic: Return a list of dummy processes.\n    return [{\"pid\": 1, \"name\": \"systemd\"}, {\"pid\": 234, \"name\": \"sshd\"}, {\"pid\": 567, \"name\": \"nginx\"}]", "user_query": "Can you connect to the server at 192.168.1.100 using my username 'sarah_technova'?", "checklist": {"functions": ["connect_ssh"], "values": [true]}}
{"difficulty": "easy", "function_schema_python": "def scan_ssh_config(server_ip: str, port: int) -> dict:\n    \"\"\"Scans SSH configuration of a specified server.\n\n    :param server_ip: IP address of the target server\n    :param port: SSH port number (default: 22)\n    :return: Dictionary containing SSH configuration details\n    :raises ValueError: If IP address is invalid\"\"\"\n    pass\ndef verify_ssh_key_auth(server_ip: str, username: str) -> bool:\n    \"\"\"Verifies SSH key authentication for a specific user on a server.\n\n    :param server_ip: IP address of the target server\n    :param username: Username to verify\n    :return: True if key authentication is properly configured, False otherwise\n    :raises ConnectionError: If unable to connect to server\"\"\"\n    pass\ndef disable_root_login(server_ip: str, ssh_config_path: str) -> bool:\n    \"\"\"Disables root login on the specified server.\n\n    :param server_ip: IP address of the target server\n    :param ssh_config_path: Path to SSH config file\n    :return: True if root login was successfully disabled, False otherwise\n    :raises PermissionError: If insufficient privileges\"\"\"\n    pass\ndef implement_access_control(server_ip: str, allowed_users: list) -> dict:\n    \"\"\"Implements SSH access controls for specified users.\n\n    :param server_ip: IP address of the target server\n    :param allowed_users: List of usernames to allow SSH access\n    :return: Dictionary containing access control status\n    :raises ValueError: If allowed_users list is empty\"\"\"\n    pass\n", "function_schema_json": [{"name": "scan_ssh_config", "description": "Scans SSH configuration of a specified server.", "parameters": {"type": "object", "properties": {"server_ip": {"type": "string", "description": "IP address of the target server"}, "port": {"type": "integer", "description": "SSH port number (default: 22)"}}, "required": ["server_ip", "port"], "additionalProperties": false}}, {"name": "verify_ssh_key_auth", "description": "Verifies SSH key authentication for a specific user on a server.", "parameters": {"type": "object", "properties": {"server_ip": {"type": "string", "description": "IP address of the target server"}, "username": {"type": "string", "description": "Username to verify"}}, "required": ["server_ip", "username"], "additionalProperties": false}}, {"name": "disable_root_login", "description": "Disables root login on the specified server.", "parameters": {"type": "object", "properties": {"server_ip": {"type": "string", "description": "IP address of the target server"}, "ssh_config_path": {"type": "string", "description": "Path to SSH config file"}}, "required": ["server_ip", "ssh_config_path"], "additionalProperties": false}}, {"name": "implement_access_control", "description": "Implements SSH access controls for specified users.", "parameters": {"type": "object", "properties": {"server_ip": {"type": "string", "description": "IP address of the target server"}, "allowed_users": {"type": "array", "description": "List of usernames to allow SSH access"}}, "required": ["server_ip", "allowed_users"], "additionalProperties": false}}], "mock_functions": "def scan_ssh_config(server_ip: str, port: int = 22) -> dict:\n    \"\"\"\n    Scans SSH configuration of a specified server.\n    \n    :param server_ip: IP address of the target server\n    :param port: SSH port number (default: 22)\n    :return: Dictionary containing SSH configuration details\n    :raises ValueError: If IP address is invalid\n    \"\"\"\n    if not isinstance(server_ip, str) or not 0 <= port <= 65535:\n        raise ValueError(\"Invalid IP address or port\")\n    \n    if server_ip == \"192.168.1.10\":\n        return {\n            \"permit_root_login\": True,\n            \"password_authentication\": True,\n            \"key_authentication\": True,\n            \"protocol_version\": 2,\n            \"ciphers\": [\"aes256-cbc\", \"aes128-ctr\"]\n        }\n    return {}\ndef verify_ssh_key_auth(server_ip: str, username: str) -> bool:\n    \"\"\"\n    Verifies SSH key authentication for a specific user on a server.\n    \n    :param server_ip: IP address of the target server\n    :param username: Username to verify\n    :return: True if key authentication is properly configured, False otherwise\n    :raises ConnectionError: If unable to connect to server\n    \"\"\"\n    if not server_ip or not username:\n        raise ValueError(\"Server IP and username must be provided\")\n    \n    if server_ip == \"192.168.1.10\" and username == \"admin\":\n        return True\n    return False\ndef disable_root_login(server_ip: str, ssh_config_path: str = \"/etc/ssh/sshd_config\") -> bool:\n    \"\"\"\n    Disables root login on the specified server.\n    \n    :param server_ip: IP address of the target server\n    :param ssh_config_path: Path to SSH config file\n    :return: True if root login was successfully disabled, False otherwise\n    :raises PermissionError: If insufficient privileges\n    \"\"\"\n    if not server_ip or not ssh_config_path:\n        raise ValueError(\"Server IP and config path must be provided\")\n    \n    if server_ip == \"192.168.1.10\" and ssh_config_path == \"/etc/ssh/sshd_config\":\n        return True\n    return False\ndef implement_access_control(server_ip: str, allowed_users: list) -> dict:\n    \"\"\"\n    Implements SSH access controls for specified users.\n    \n    :param server_ip: IP address of the target server\n    :param allowed_users: List of usernames to allow SSH access\n    :return: Dictionary containing access control status\n    :raises ValueError: If allowed_users list is empty\n    \"\"\"\n    if not server_ip or not allowed_users:\n        raise ValueError(\"Server IP and allowed users must be provided\")\n    \n    if server_ip == \"192.168.1.10\" and \"admin\" in allowed_users:\n        return {\n            \"status\": \"success\",\n            \"allowed_users\": allowed_users,\n            \"denied_users\": [\"root\"],\n            \"configuration_applied\": True\n        }\n    return {\"status\": \"failed\"}", "user_query": "Can you scan the SSH configuration of server 192.168.1.10?", "checklist": {"functions": ["scan_ssh_config"], "values": [{"permit_root_login": true, "password_authentication": true, "key_authentication": true, "protocol_version": 2, "ciphers": ["aes256-cbc", "aes128-ctr"]}]}}
{"difficulty": "easy", "function_schema_python": "def scan_ssh_config(server_ip: str, port: int) -> dict:\n    \"\"\"Scans SSH configuration of a specified server.\n\n    :param server_ip: IP address of the target server\n    :param port: SSH port number (default: 22)\n    :return: Dictionary containing SSH configuration details\n    :raises ValueError: If IP address is invalid\"\"\"\n    pass\ndef verify_ssh_key_auth(server_ip: str, username: str) -> bool:\n    \"\"\"Verifies SSH key authentication for a specific user on a server.\n\n    :param server_ip: IP address of the target server\n    :param username: Username to verify\n    :return: True if key authentication is properly configured, False otherwise\n    :raises ConnectionError: If unable to connect to server\"\"\"\n    pass\ndef disable_root_login(server_ip: str, ssh_config_path: str) -> bool:\n    \"\"\"Disables root login on the specified server.\n\n    :param server_ip: IP address of the target server\n    :param ssh_config_path: Path to SSH config file\n    :return: True if root login was successfully disabled, False otherwise\n    :raises PermissionError: If insufficient privileges\"\"\"\n    pass\ndef implement_access_control(server_ip: str, allowed_users: list) -> dict:\n    \"\"\"Implements SSH access controls for specified users.\n\n    :param server_ip: IP address of the target server\n    :param allowed_users: List of usernames to allow SSH access\n    :return: Dictionary containing access control status\n    :raises ValueError: If allowed_users list is empty\"\"\"\n    pass\n", "function_schema_json": [{"name": "scan_ssh_config", "description": "Scans SSH configuration of a specified server.", "parameters": {"type": "object", "properties": {"server_ip": {"type": "string", "description": "IP address of the target server"}, "port": {"type": "integer", "description": "SSH port number (default: 22)"}}, "required": ["server_ip", "port"], "additionalProperties": false}}, {"name": "verify_ssh_key_auth", "description": "Verifies SSH key authentication for a specific user on a server.", "parameters": {"type": "object", "properties": {"server_ip": {"type": "string", "description": "IP address of the target server"}, "username": {"type": "string", "description": "Username to verify"}}, "required": ["server_ip", "username"], "additionalProperties": false}}, {"name": "disable_root_login", "description": "Disables root login on the specified server.", "parameters": {"type": "object", "properties": {"server_ip": {"type": "string", "description": "IP address of the target server"}, "ssh_config_path": {"type": "string", "description": "Path to SSH config file"}}, "required": ["server_ip", "ssh_config_path"], "additionalProperties": false}}, {"name": "implement_access_control", "description": "Implements SSH access controls for specified users.", "parameters": {"type": "object", "properties": {"server_ip": {"type": "string", "description": "IP address of the target server"}, "allowed_users": {"type": "array", "description": "List of usernames to allow SSH access"}}, "required": ["server_ip", "allowed_users"], "additionalProperties": false}}], "mock_functions": "def scan_ssh_config(server_ip: str, port: int = 22) -> dict:\n    \"\"\"\n    Scans SSH configuration of a specified server.\n    \n    :param server_ip: IP address of the target server\n    :param port: SSH port number (default: 22)\n    :return: Dictionary containing SSH configuration details\n    :raises ValueError: If IP address is invalid\n    \"\"\"\n    if not isinstance(server_ip, str) or not 0 <= port <= 65535:\n        raise ValueError(\"Invalid IP address or port\")\n    \n    if server_ip == \"192.168.1.10\":\n        return {\n            \"permit_root_login\": True,\n            \"password_authentication\": True,\n            \"key_authentication\": True,\n            \"protocol_version\": 2,\n            \"ciphers\": [\"aes256-cbc\", \"aes128-ctr\"]\n        }\n    return {}\ndef verify_ssh_key_auth(server_ip: str, username: str) -> bool:\n    \"\"\"\n    Verifies SSH key authentication for a specific user on a server.\n    \n    :param server_ip: IP address of the target server\n    :param username: Username to verify\n    :return: True if key authentication is properly configured, False otherwise\n    :raises ConnectionError: If unable to connect to server\n    \"\"\"\n    if not server_ip or not username:\n        raise ValueError(\"Server IP and username must be provided\")\n    \n    if server_ip == \"192.168.1.10\" and username == \"admin\":\n        return True\n    return False\ndef disable_root_login(server_ip: str, ssh_config_path: str = \"/etc/ssh/sshd_config\") -> bool:\n    \"\"\"\n    Disables root login on the specified server.\n    \n    :param server_ip: IP address of the target server\n    :param ssh_config_path: Path to SSH config file\n    :return: True if root login was successfully disabled, False otherwise\n    :raises PermissionError: If insufficient privileges\n    \"\"\"\n    if not server_ip or not ssh_config_path:\n        raise ValueError(\"Server IP and config path must be provided\")\n    \n    if server_ip == \"192.168.1.10\" and ssh_config_path == \"/etc/ssh/sshd_config\":\n        return True\n    return False\ndef implement_access_control(server_ip: str, allowed_users: list) -> dict:\n    \"\"\"\n    Implements SSH access controls for specified users.\n    \n    :param server_ip: IP address of the target server\n    :param allowed_users: List of usernames to allow SSH access\n    :return: Dictionary containing access control status\n    :raises ValueError: If allowed_users list is empty\n    \"\"\"\n    if not server_ip or not allowed_users:\n        raise ValueError(\"Server IP and allowed users must be provided\")\n    \n    if server_ip == \"192.168.1.10\" and \"admin\" in allowed_users:\n        return {\n            \"status\": \"success\",\n            \"allowed_users\": allowed_users,\n            \"denied_users\": [\"root\"],\n            \"configuration_applied\": True\n        }\n    return {\"status\": \"failed\"}", "user_query": "Marcus Rodriguez needs to verify SSH key authentication for user 'admin' on server 192.168.1.10.", "checklist": {"functions": ["verify_ssh_key_auth"], "values": [true]}}
{"difficulty": "easy", "function_schema_python": "def monitor_cpu_usage(server_id: str) -> float:\n    \"\"\"Simulates monitoring the CPU usage of a specified server.\n\n    :param server_id: The ID or name of the server to monitor.\n    :return: A float representing the CPU usage percentage.\n    :raises ValueError: If the server_id is invalid.\"\"\"\n    pass\ndef monitor_memory_usage(server_id: str) -> Dict[str, float]:\n    \"\"\"Simulates monitoring the memory usage of a specified server.\n\n    :param server_id: The ID or name of the server to monitor.\n    :return:\n        dict: A dictionary with the following keys:\n            - total (float): The total memory in GB.\n            - used (float): The used memory in GB.\n            - free (float): The free memory in GB.\n    :raises ValueError: If the server_id is invalid.\"\"\"\n    pass\ndef monitor_disk_io(server_id: str) -> List[Dict[str, float]]:\n    \"\"\"Simulates monitoring the disk I/O operations of a specified server.\n\n    :param server_id: The ID or name of the server to monitor.\n    :return:\n        list[dict]: A list of dictionaries, each representing a disk with the following keys:\n            - device (str): The device identifier.\n            - read (float): The number of blocks read per second.\n            - write (float): The number of blocks written per second.\n    :raises ValueError: If the server_id is invalid.\"\"\"\n    pass\ndef sniff_network_traffic(interface: str) -> List[Dict[str, str]]:\n    \"\"\"Simulates sniffing network traffic using Scapy on a specified network interface.\n\n    :param interface: The network interface to use for sniffing (e.g., \"eth0\").\n    :return:\n        list[dict]: A list of dictionaries, each representing a network packet with the following keys:\n            - src (str): The source IP address.\n            - dst (str): The destination IP address.\n            - protocol (str): The protocol used.\n            - length (str): The length of the packet in bytes.\n    :raises ValueError: If the interface is invalid.\"\"\"\n    pass\ndef start_docker_container(container_name: str) -> bool:\n    \"\"\"Simulates starting a Docker container.\n\n    :param container_name: The name of the Docker container to start.\n    :return: True if the container is successfully started, False otherwise.\n    :raises ValueError: If the container_name is invalid.\"\"\"\n    pass\ndef get_disk_usage(server_id: str) -> Dict[str, float]:\n    \"\"\"Simulates getting the disk usage statistics of a specified server's disk partitions.\n\n    :param server_id: The ID or name of the server to check.\n    :return:\n        dict: A dictionary where keys are disk partitions and values are their usage percentages.\n    :raises ValueError: If the server_id is invalid.\"\"\"\n    pass\ndef generate_alert(message: str, alert_level: str) -> bool:\n    \"\"\"Simulates generating an alert message.\n\n    :param message: The message to include in the alert.\n    :param alert_level: The level of the alert (e.g., \"critical\", \"warning\").\n    :return: True if the alert is successfully generated, False otherwise.\n    :raises ValueError: If the message or alert_level is invalid.\"\"\"\n    pass\n", "function_schema_json": [{"name": "monitor_cpu_usage", "description": "Simulates monitoring the CPU usage of a specified server.", "parameters": {"type": "object", "properties": {"server_id": {"type": "string", "description": "The ID or name of the server to monitor."}}, "required": ["server_id"], "additionalProperties": false}}, {"name": "monitor_memory_usage", "description": "Simulates monitoring the memory usage of a specified server.", "parameters": {"type": "object", "properties": {"server_id": {"type": "string", "description": "The ID or name of the server to monitor."}}, "required": ["server_id"], "additionalProperties": false}}, {"name": "monitor_disk_io", "description": "Simulates monitoring the disk I/O operations of a specified server.", "parameters": {"type": "object", "properties": {"server_id": {"type": "string", "description": "The ID or name of the server to monitor."}}, "required": ["server_id"], "additionalProperties": false}}, {"name": "sniff_network_traffic", "description": "Simulates sniffing network traffic using Scapy on a specified network interface.", "parameters": {"type": "object", "properties": {"interface": {"type": "string", "description": "The network interface to use for sniffing (e.g., \"eth0\")."}}, "required": ["interface"], "additionalProperties": false}}, {"name": "start_docker_container", "description": "Simulates starting a Docker container.", "parameters": {"type": "object", "properties": {"container_name": {"type": "string", "description": "The name of the Docker container to start."}}, "required": ["container_name"], "additionalProperties": false}}, {"name": "get_disk_usage", "description": "Simulates getting the disk usage statistics of a specified server's disk partitions.", "parameters": {"type": "object", "properties": {"server_id": {"type": "string", "description": "The ID or name of the server to check."}}, "required": ["server_id"], "additionalProperties": false}}, {"name": "generate_alert", "description": "Simulates generating an alert message.", "parameters": {"type": "object", "properties": {"message": {"type": "string", "description": "The message to include in the alert."}, "alert_level": {"type": "string", "description": "The level of the alert (e.g., \"critical\", \"warning\")."}}, "required": ["message", "alert_level"], "additionalProperties": false}}], "mock_functions": "def monitor_cpu_usage(server_id: str) -> float:\n    \"\"\"\n    Simulates monitoring the CPU usage of a specified server.\n    \n    :param server_id: The ID or name of the server to monitor.\n    :return: A float representing the CPU usage percentage.\n    :raises ValueError: If the server_id is invalid.\n    \"\"\"\n    if not server_id:\n        raise ValueError(\"Server ID must be provided.\")\n    # Mock logic: Return a simulated CPU usage percentage based on the server_id\n    if server_id == \"TechCorp-Server1\":\n        return 45.0\n    elif server_id == \"TechCorp-Server2\":\n        return 70.5\n    else:\n        return 50.0  # Default CPU usage for any other server\ndef monitor_memory_usage(server_id: str) -> Dict[str, float]:\n    \"\"\"\n    Simulates monitoring the memory usage of a specified server.\n    \n    :param server_id: The ID or name of the server to monitor.\n    :return:\n        dict: A dictionary with the following keys:\n            - total (float): The total memory in GB.\n            - used (float): The used memory in GB.\n            - free (float): The free memory in GB.\n    :raises ValueError: If the server_id is invalid.\n    \"\"\"\n    if not server_id:\n        raise ValueError(\"Server ID must be provided.\")\n    # Mock logic: Return a simulated memory usage stats based on the server_id\n    if server_id == \"TechCorp-Server1\":\n        return {\"total\": 16.0, \"used\": 8.5, \"free\": 7.5}\n    elif server_id == \"TechCorp-Server2\":\n        return {\"total\": 32.0, \"used\": 25.0, \"free\": 7.0}\n    else:\n        return {\"total\": 8.0, \"used\": 5.0, \"free\": 3.0}  # Default memory usage for any other server\ndef monitor_disk_io(server_id: str) -> List[Dict[str, float]]:\n    \"\"\"\n    Simulates monitoring the disk I/O operations of a specified server.\n    \n    :param server_id: The ID or name of the server to monitor.\n    :return:\n        list[dict]: A list of dictionaries, each representing a disk with the following keys:\n            - device (str): The device identifier.\n            - read (float): The number of blocks read per second.\n            - write (float): The number of blocks written per second.\n    :raises ValueError: If the server_id is invalid.\n    \"\"\"\n    if not server_id:\n        raise ValueError(\"Server ID must be provided.\")\n    # Mock logic: Return a simulated disk I/O stats based on the server_id\n    if server_id == \"TechCorp-Server1\":\n        return [\n            {\"device\": \"sda1\", \"read\": 1024.5, \"write\": 768.3},\n            {\"device\": \"sda2\", \"read\": 512.2, \"write\": 256.1}\n        ]\n    elif server_id == \"TechCorp-Server2\":\n        return [\n            {\"device\": \"sdb1\", \"read\": 2048.8, \"write\": 1536.6},\n            {\"device\": \"sdb2\", \"read\": 1024.4, \"write\": 512.3}\n        ]\n    else:\n        return [\n            {\"device\": \"sd01\", \"read\": 512.1, \"write\": 256.05}  # Default disk I/O stats for any other server\n        ]\ndef sniff_network_traffic(interface: str) -> List[Dict[str, str]]:\n    \"\"\"\n    Simulates sniffing network traffic using Scapy on a specified network interface.\n    \n    :param interface: The network interface to use for sniffing (e.g., \"eth0\").\n    :return:\n        list[dict]: A list of dictionaries, each representing a network packet with the following keys:\n            - src (str): The source IP address.\n            - dst (str): The destination IP address.\n            - protocol (str): The protocol used.\n            - length (str): The length of the packet in bytes.\n    :raises ValueError: If the interface is invalid.\n    \"\"\"\n    if not interface:\n        raise ValueError(\"Interface must be provided.\")\n    # Mock logic: Return a simulated network traffic packet data based on the interface\n    if interface == \"eth0\":\n        return [\n            {\"src\": \"192.168.1.1\", \"dst\": \"192.168.1.254\", \"protocol\": \"TCP\", \"length\": \"1280\"},\n            {\"src\": \"192.168.1.2\", \"dst\": \"8.8.8.8\", \"protocol\": \"UDP\", \"length\": \"512\"}\n        ]\n    elif interface == \"wlan0\":\n        return [\n            {\"src\": \"172.16.0.1\", \"dst\": \"172.16.1.50\", \"protocol\": \"ICMP\", \"length\": \"256\"},\n            {\"src\": \"172.16.0.57\", \"dst\": \"172.16.1.255\", \"protocol\": \"DHCP\", \"length\": \"1024\"}\n        ]\n    else:\n        return [\n            {\"src\": \"0.0.0.0\", \"dst\": \"0.0.0.0\", \"protocol\": \"\u672a\u77e5\", \"length\": \"0\"}  # Default traffic for unsupported interface\n        ]\ndef start_docker_container(container_name: str) -> bool:\n    \"\"\"\n    Simulates starting a Docker container.\n    \n    :param container_name: The name of the Docker container to start.\n    :return: True if the container is successfully started, False otherwise.\n    :raises ValueError: If the container_name is invalid.\n    \"\"\"\n    if not container_name:\n        raise ValueError(\"Container name must be provided.\")\n    # Mock logic: Simulate a successful start for a container named \"TechCorp-Database\"\n    if container_name == \"TechCorp-Database\":\n        return True\n    return False\ndef get_disk_usage(server_id: str) -> Dict[str, float]:\n    \"\"\"\n    Simulates getting the disk usage statistics of a specified server's disk partitions.\n    \n    :param server_id: The ID or name of the server to check.\n    :return:\n        dict: A dictionary where keys are disk partitions and values are their usage percentages.\n    :raises ValueError: If the server_id is invalid.\n    \"\"\"\n    if not server_id:\n        raise ValueError(\"Server ID must be provided.\")\n    # Mock logic: Return a simulated disk usage stats on a server\n    if server_id == \"TechCorp-Server1\":\n        return {\"/dev/sda1\": 45.0, \"/dev/sda2\": 30.0}\n    elif server_id == \"TechCorp-Server2\":\n        return {\"/dev/sdb1\": 70.0, \"/dev/sdb2\": 50.0}\n    else:\n        return {\"/dev/sd01\": 55.0}  # Default disk usage for any other server\ndef generate_alert(message: str, alert_level: str) -> bool:\n    \"\"\"\n    Simulates generating an alert message.\n    \n    :param message: The message to include in the alert.\n    :param alert_level: The level of the alert (e.g., \"critical\", \"warning\").\n    :return: True if the alert is successfully generated, False otherwise.\n    :raises ValueError: If the message or alert_level is invalid.\n    \"\"\"\n    if not message or not alert_level:\n        raise ValueError(\"Message and alert level must be provided.\")\n    # Mock logic: Simulate alert generation for any given alert_level and message\n    return True", "user_query": "What is the CPU usage of TechCorp-Server1?", "checklist": {"functions": ["monitor_cpu_usage"], "values": [45.0]}}
{"difficulty": "easy", "function_schema_python": "def analyze_campaign_performance(campaign_id: str, date_range: tuple) -> dict:\n    \"\"\"Analyzes the performance metrics of a specific ad campaign.\n\n    :param campaign_id: Unique identifier for the campaign\n    :param date_range: Tuple of (start_date, end_date) in ISO format\n    :return: Dictionary containing performance metrics\n    :raises ValueError: If campaign_id is invalid or date_range is incorrect\"\"\"\n    pass\ndef identify_top_performing_creatives(campaign_id: str, limit: int) -> list:\n    \"\"\"Identifies the best performing ad creatives for a campaign.\n\n    :param campaign_id: Unique identifier for the campaign\n    :param limit: Number of top creatives to return\n    :return: List of dictionaries containing creative performance data\n    :raises ValueError: If campaign_id is invalid or limit is less than 1\"\"\"\n    pass\ndef get_audience_insights(app_name: str) -> dict:\n    \"\"\"Retrieves audience insights for the fitness app.\n\n    :param app_name: Name of the application\n    :return: Dictionary containing audience demographic and behavior data\n    :raises ValueError: If app_name is invalid\"\"\"\n    pass\n", "function_schema_json": [{"name": "analyze_campaign_performance", "description": "Analyzes the performance metrics of a specific ad campaign.", "parameters": {"type": "object", "properties": {"campaign_id": {"type": "string", "description": "Unique identifier for the campaign"}, "date_range": {"type": "string", "description": "Tuple of (start_date, end_date) in ISO format"}}, "required": ["campaign_id", "date_range"], "additionalProperties": false}}, {"name": "identify_top_performing_creatives", "description": "Identifies the best performing ad creatives for a campaign.", "parameters": {"type": "object", "properties": {"campaign_id": {"type": "string", "description": "Unique identifier for the campaign"}, "limit": {"type": "integer", "description": "Number of top creatives to return"}}, "required": ["campaign_id", "limit"], "additionalProperties": false}}, {"name": "get_audience_insights", "description": "Retrieves audience insights for the fitness app.", "parameters": {"type": "object", "properties": {"app_name": {"type": "string", "description": "Name of the application"}}, "required": ["app_name"], "additionalProperties": false}}], "mock_functions": "def analyze_campaign_performance(campaign_id: str, date_range: tuple) -> dict:\n    \"\"\"\n    Analyzes the performance metrics of a specific ad campaign.\n    \n    :param campaign_id: Unique identifier for the campaign\n    :param date_range: Tuple of (start_date, end_date) in ISO format\n    :return: Dictionary containing performance metrics\n    :raises ValueError: If campaign_id is invalid or date_range is incorrect\n    \"\"\"\n    if not campaign_id or not isinstance(date_range, tuple):\n        raise ValueError(\"Invalid parameters\")\n    \n    if campaign_id == \"FIT123\" and date_range == (\"2023-01-01\", \"2023-01-31\"):\n        return {\n            \"impressions\": 150000,\n            \"clicks\": 7500,\n            \"conversions\": 450,\n            \"ctr\": 0.05,\n            \"cost_per_conversion\": 12.50,\n            \"total_spend\": 5625.00\n        }\n    return {}\ndef identify_top_performing_creatives(campaign_id: str, limit: int = 5) -> list:\n    \"\"\"\n    Identifies the best performing ad creatives for a campaign.\n    \n    :param campaign_id: Unique identifier for the campaign\n    :param limit: Number of top creatives to return\n    :return: List of dictionaries containing creative performance data\n    :raises ValueError: If campaign_id is invalid or limit is less than 1\n    \"\"\"\n    if not campaign_id or limit < 1:\n        raise ValueError(\"Invalid parameters\")\n    \n    if campaign_id == \"FIT123\":\n        return [\n            {\"creative_id\": \"C1\", \"engagement_rate\": 0.15, \"conversion_rate\": 0.08},\n            {\"creative_id\": \"C2\", \"engagement_rate\": 0.12, \"conversion_rate\": 0.06}\n        ][:limit]\n    return []\ndef get_audience_insights(app_name: str) -> dict:\n    \"\"\"\n    Retrieves audience insights for the fitness app.\n    \n    :param app_name: Name of the application\n    :return: Dictionary containing audience demographic and behavior data\n    :raises ValueError: If app_name is invalid\n    \"\"\"\n    if not app_name or not isinstance(app_name, str):\n        raise ValueError(\"Invalid app name\")\n    \n    if app_name.lower() == \"fitfast\":\n        return {\n            \"age_groups\": {\"18-24\": 0.25, \"25-34\": 0.45, \"35-44\": 0.20},\n            \"interests\": [\"fitness\", \"health\", \"nutrition\"],\n            \"peak_usage_times\": [\"6AM-9AM\", \"5PM-8PM\"],\n            \"user_retention\": 0.75\n        }\n    return {}", "user_query": "What is the performance of ad campaign FIT123 between 2023-01-01 and 2023-01-31?", "checklist": {"functions": ["analyze_campaign_performance"], "values": [{"impressions": 150000, "clicks": 7500, "conversions": 450, "ctr": 0.05, "cost_per_conversion": 12.5, "total_spend": 5625.0}]}}
{"difficulty": "easy", "function_schema_python": "def create_ad_campaign(game_name: str, budget: float, target_demographics: dict) -> dict:\n    \"\"\"Creates a new ad campaign for a mobile game.\n\n    :param game_name: Name of the game to advertise\n    :param budget: Total budget for the campaign in USD\n    :param target_demographics: Dictionary containing demographic targeting parameters\n    :return: Dictionary containing campaign details and initial metrics\n    :raises ValueError: If budget is negative or game_name is empty\"\"\"\n    pass\ndef analyze_user_demographics(campaign_id: str) -> dict:\n    \"\"\"Analyzes user demographics for a specific campaign.\n\n    :param campaign_id: The unique identifier for the campaign\n    :return: Dictionary containing demographic analysis results\n    :raises ValueError: If campaign_id is invalid\"\"\"\n    pass\ndef optimize_ad_placements(campaign_id: str, performance_data: dict) -> dict:\n    \"\"\"Optimizes ad placements based on performance data.\n\n    :param campaign_id: The unique identifier for the campaign\n    :param performance_data: Dictionary containing current performance metrics\n    :return: Dictionary containing optimized placement recommendations\n    :raises ValueError: If performance_data is incomplete\"\"\"\n    pass\n", "function_schema_json": [{"name": "create_ad_campaign", "description": "Creates a new ad campaign for a mobile game.", "parameters": {"type": "object", "properties": {"game_name": {"type": "string", "description": "Name of the game to advertise"}, "budget": {"type": "number", "description": "Total budget for the campaign in USD"}, "target_demographics": {"type": "object", "description": "Dictionary containing demographic targeting parameters"}}, "required": ["game_name", "budget", "target_demographics"], "additionalProperties": false}}, {"name": "analyze_user_demographics", "description": "Analyzes user demographics for a specific campaign.", "parameters": {"type": "object", "properties": {"campaign_id": {"type": "string", "description": "The unique identifier for the campaign"}}, "required": ["campaign_id"], "additionalProperties": false}}, {"name": "optimize_ad_placements", "description": "Optimizes ad placements based on performance data.", "parameters": {"type": "object", "properties": {"campaign_id": {"type": "string", "description": "The unique identifier for the campaign"}, "performance_data": {"type": "object", "description": "Dictionary containing current performance metrics"}}, "required": ["campaign_id", "performance_data"], "additionalProperties": false}}], "mock_functions": "def create_ad_campaign(game_name: str, budget: float, target_demographics: dict) -> dict:\n    \"\"\"\n    Creates a new ad campaign for a mobile game.\n    \n    :param game_name: Name of the game to advertise\n    :param budget: Total budget for the campaign in USD\n    :param target_demographics: Dictionary containing demographic targeting parameters\n    :return: Dictionary containing campaign details and initial metrics\n    :raises ValueError: If budget is negative or game_name is empty\n    \"\"\"\n    if not game_name or budget <= 0:\n        raise ValueError(\"Invalid game name or budget\")\n    \n    if game_name.lower() == \"galaxy quest\" and budget >= 10000:\n        return {\n            \"campaign_id\": \"GQ2023001\",\n            \"status\": \"active\",\n            \"projected_reach\": 500000,\n            \"target_platforms\": [\"iOS\", \"Android\"],\n            \"daily_budget\": budget / 30\n        }\n    return {}\ndef analyze_user_demographics(campaign_id: str) -> dict:\n    \"\"\"\n    Analyzes user demographics for a specific campaign.\n    \n    :param campaign_id: The unique identifier for the campaign\n    :return: Dictionary containing demographic analysis results\n    :raises ValueError: If campaign_id is invalid\n    \"\"\"\n    if campaign_id == \"GQ2023001\":\n        return {\n            \"age_groups\": {\n                \"13-17\": 0.15,\n                \"18-24\": 0.45,\n                \"25-34\": 0.30,\n                \"35+\": 0.10\n            },\n            \"gender_distribution\": {\n                \"male\": 0.65,\n                \"female\": 0.32,\n                \"other\": 0.03\n            },\n            \"top_regions\": [\"North America\", \"Europe\", \"Asia Pacific\"]\n        }\n    raise ValueError(\"Invalid campaign ID\")\ndef optimize_ad_placements(campaign_id: str, performance_data: dict) -> dict:\n    \"\"\"\n    Optimizes ad placements based on performance data.\n    \n    :param campaign_id: The unique identifier for the campaign\n    :param performance_data: Dictionary containing current performance metrics\n    :return: Dictionary containing optimized placement recommendations\n    :raises ValueError: If performance_data is incomplete\n    \"\"\"\n    required_metrics = [\"click_through_rate\", \"conversion_rate\", \"cost_per_install\"]\n    if not all(metric in performance_data for metric in required_metrics):\n        raise ValueError(\"Incomplete performance data\")\n        \n    if campaign_id == \"GQ2023001\":\n        return {\n            \"recommended_platforms\": [\"Instagram\", \"TikTok\", \"Unity Ads\"],\n            \"budget_allocation\": {\n                \"Instagram\": 0.4,\n                \"TikTok\": 0.35,\n                \"Unity Ads\": 0.25\n            },\n            \"best_performing_creatives\": [\"space_adventure_15s\", \"character_showcase_30s\"],\n            \"estimated_improvement\": \"25%\"\n        }\n    return {}", "user_query": "This is Ethan from GameSphere. Please optimize ad placements for campaign GQ2023001 using these metrics: {\"click_through_rate\": 2.5, \"conversion_rate\": 3.1, \"cost_per_install\": 0.85} and show me the recommended platforms and budget allocation.", "checklist": {"functions": ["optimize_ad_placements"], "values": [{"recommended_platforms": ["Instagram", "TikTok", "Unity Ads"], "budget_allocation": {"Instagram": 0.4, "TikTok": 0.35, "Unity Ads": 0.25}, "best_performing_creatives": ["space_adventure_15s", "character_showcase_30s"], "estimated_improvement": "25%"}]}}
{"difficulty": "easy", "function_schema_python": "def analyze_facebook_ad_campaign(campaign_id: str, platform: str) -> Dict[str, Any]:\n    \"\"\"Analyzes Facebook ad campaign data and provides insights into conversion rates.\n\n    :param campaign_id: The ID of the Facebook ad campaign (e.g., \"FB12345\").\n    :param platform: The platform of the ad campaign. Currently only supports \"facebook\".\n    :return: A dictionary containing analysis results, including click-through rate (CTR), \n             conversion rate (CR), and potential reasons for low conversion rates.\n    :raises ValueError: If the campaign ID is invalid or the platform is not supported.\"\"\"\n    pass\ndef get_conversion_tracking_data(campaign_id: str, system: str) -> Dict[str, int]:\n    \"\"\"Retrieves conversion tracking data from a specified system.\n\n    :param campaign_id: The ID of the campaign for which to retrieve data.\n    :param system: The conversion tracking system (e.g., \"shopify\").\n    :return: A dictionary containing conversion data.\n             Keys include 'clicks', 'confirmed_purchases', 'coupon_uses'.\n    :raises ValueError: If the campaign ID or system is invalid.\"\"\"\n    pass\n", "function_schema_json": [{"name": "analyze_facebook_ad_campaign", "description": "Analyzes Facebook ad campaign data and provides insights into conversion rates.", "parameters": {"type": "object", "properties": {"campaign_id": {"type": "string", "description": "The ID of the Facebook ad campaign (e.g., \"FB12345\")."}, "platform": {"type": "string", "description": "The platform of the ad campaign. Currently only supports \"facebook\"."}}, "required": ["campaign_id", "platform"], "additionalProperties": false}}, {"name": "get_conversion_tracking_data", "description": "Retrieves conversion tracking data from a specified system.", "parameters": {"type": "object", "properties": {"campaign_id": {"type": "string", "description": "The ID of the campaign for which to retrieve data."}, "system": {"type": "string", "description": "The conversion tracking system (e.g., \"shopify\")."}}, "required": ["campaign_id", "system"], "additionalProperties": false}}], "mock_functions": "def analyze_facebook_ad_campaign(campaign_id: str, platform: str = \"facebook\") -> Dict[str, Any]:\n    \"\"\"\n    Analyzes Facebook ad campaign data and provides insights into conversion rates.\n\n    :param campaign_id: The ID of the Facebook ad campaign (e.g., \"FB12345\").\n    :param platform: The platform of the ad campaign. Currently only supports \"facebook\".\n    :return: A dictionary containing analysis results, including click-through rate (CTR), \n             conversion rate (CR), and potential reasons for low conversion rates.\n    :raises ValueError: If the campaign ID is invalid or the platform is not supported.\n    \"\"\"\n    if not campaign_id:\n        raise ValueError(\"Campaign ID cannot be empty.\")\n    if platform.lower() != \"facebook\":\n        raise ValueError(\"Only Facebook ad campaigns are currently supported.\")\n\n    if campaign_id == \"FB12345\":\n        return {\n            \"clicks\": 12500,\n            \"purchases\": 350,\n            \"coupon_redemptions\": 100,\n            \"ctr\": 0.028,  # Clicks / Impressions (assuming 12500 clicks from 450000 impressions)\n            \"cr\": 0.0028, # Purchases / Clicks\n            \"coupon_cr\": 0.0008, # Coupon / Clicks\n            \"potential_reasons\": [\n                \"Poor targeting: Ads may not be reaching the right audience.\",\n                \"Website issues: Technical problems or slow loading times on the website.\",\n                \"Complex checkout process:  A long or confusing checkout process can deter customers.\",\n                \"Lack of compelling offer: The ad or landing page may not offer a strong enough incentive to purchase.\"\n            ]\n        }\n    return {}\ndef get_conversion_tracking_data(campaign_id: str, system: str = \"shopify\") -> Dict[str, int]:\n    \"\"\"\n    Retrieves conversion tracking data from a specified system.\n\n    :param campaign_id: The ID of the campaign for which to retrieve data.\n    :param system: The conversion tracking system (e.g., \"shopify\").\n    :return: A dictionary containing conversion data.\n             Keys include 'clicks', 'confirmed_purchases', 'coupon_uses'.\n    :raises ValueError: If the campaign ID or system is invalid.\n    \"\"\"\n    if not campaign_id or not system:\n        raise ValueError(\"Campaign ID and system must be provided.\")\n\n    if campaign_id == \"FB12345\" and system == \"shopify\":  # Simulate data for the given scenario\n        return {\n            \"clicks\": 12500,\n            \"confirmed_purchases\": 350,\n            \"coupon_uses\": 100\n        }\n    return {}", "user_query": "This is Sarah from Happy Paws. Please get the conversion tracking data for campaign FB12345 from our Shopify system.", "checklist": {"functions": ["get_conversion_tracking_data"], "values": [{"clicks": 12500, "confirmed_purchases": 350, "coupon_uses": 100}]}}
{"difficulty": "easy", "function_schema_python": "def get_campaign_analytics(campaign_id: str) -> dict:\n    \"\"\"Retrieves analytics data for a specific marketing campaign.\n\n    :param campaign_id: The unique identifier for the campaign\n    :return: Dictionary containing campaign metrics\n    :raises ValueError: If campaign_id is invalid\"\"\"\n    pass\ndef verify_order_tracking(order_id: str, crm_id: str) -> dict:\n    \"\"\"Verifies if an order is properly tracked in the CRM system.\n\n    :param order_id: The order identifier\n    :param crm_id: The CRM system identifier\n    :return: Dictionary containing order tracking status\n    :raises ValueError: If order_id or crm_id is invalid\"\"\"\n    pass\ndef check_tracking_discrepancies(campaign_id: str, crm_id: str) -> dict:\n    \"\"\"Analyzes discrepancies between website visits and attributed conversions.\n\n    :param campaign_id: The campaign identifier\n    :param crm_id: The CRM system identifier\n    :return: Dictionary containing discrepancy analysis\n    :raises ValueError: If campaign_id or crm_id is invalid\"\"\"\n    pass\n", "function_schema_json": [{"name": "get_campaign_analytics", "description": "Retrieves analytics data for a specific marketing campaign.", "parameters": {"type": "object", "properties": {"campaign_id": {"type": "string", "description": "The unique identifier for the campaign"}}, "required": ["campaign_id"], "additionalProperties": false}}, {"name": "verify_order_tracking", "description": "Verifies if an order is properly tracked in the CRM system.", "parameters": {"type": "object", "properties": {"order_id": {"type": "string", "description": "The order identifier"}, "crm_id": {"type": "string", "description": "The CRM system identifier"}}, "required": ["order_id", "crm_id"], "additionalProperties": false}}, {"name": "check_tracking_discrepancies", "description": "Analyzes discrepancies between website visits and attributed conversions.", "parameters": {"type": "object", "properties": {"campaign_id": {"type": "string", "description": "The campaign identifier"}, "crm_id": {"type": "string", "description": "The CRM system identifier"}}, "required": ["campaign_id", "crm_id"], "additionalProperties": false}}], "mock_functions": "def get_campaign_analytics(campaign_id: str) -> dict:\n    \"\"\"\n    Retrieves analytics data for a specific marketing campaign.\n    \n    :param campaign_id: The unique identifier for the campaign\n    :return: Dictionary containing campaign metrics\n    :raises ValueError: If campaign_id is invalid\n    \"\"\"\n    if not campaign_id or not campaign_id.startswith(\"GTG-Test-\"):\n        raise ValueError(\"Invalid campaign ID format\")\n    \n    if campaign_id == \"GTG-Test-001\":\n        return {\n            \"visits\": 500,\n            \"unique_visitors\": 475,\n            \"conversion_events\": 25,\n            \"conversion_rate\": 5.0,\n            \"campaign_status\": \"active\"\n        }\n    return {}\ndef verify_order_tracking(order_id: str, crm_id: str) -> dict:\n    \"\"\"\n    Verifies if an order is properly tracked in the CRM system.\n    \n    :param order_id: The order identifier\n    :param crm_id: The CRM system identifier\n    :return: Dictionary containing order tracking status\n    :raises ValueError: If order_id or crm_id is invalid\n    \"\"\"\n    if not order_id.startswith(\"GTG-\") or not crm_id.startswith(\"GTG-\"):\n        raise ValueError(\"Invalid order ID or CRM ID format\")\n    \n    if (order_id in [f\"GTG-{str(i).zfill(3)}\" for i in range(1, 26)] \n        and crm_id == \"GTG-47\"):\n        return {\n            \"order_tracked\": True,\n            \"attribution_source\": \"GTG-Test-001\",\n            \"tracking_timestamp\": \"2023-07-20T10:30:00Z\",\n            \"conversion_verified\": True\n        }\n    return {}\ndef check_tracking_discrepancies(campaign_id: str, crm_id: str) -> dict:\n    \"\"\"\n    Analyzes discrepancies between website visits and attributed conversions.\n    \n    :param campaign_id: The campaign identifier\n    :param crm_id: The CRM system identifier\n    :return: Dictionary containing discrepancy analysis\n    :raises ValueError: If campaign_id or crm_id is invalid\n    \"\"\"\n    if not campaign_id.startswith(\"GTG-Test-\") or not crm_id.startswith(\"GTG-\"):\n        raise ValueError(\"Invalid campaign ID or CRM ID format\")\n    \n    if campaign_id == \"GTG-Test-001\" and crm_id == \"GTG-47\":\n        return {\n            \"total_visits\": 500,\n            \"tracked_conversions\": 25,\n            \"unattributed_conversions\": 0,\n            \"tracking_accuracy\": 100.0,\n            \"missing_data_points\": 0\n        }\n    return {}", "user_query": "Can you get analytics data for campaign GTG-Test-001?", "checklist": {"functions": ["get_campaign_analytics"], "values": [{"visits": 500, "unique_visitors": 475, "conversion_events": 25, "conversion_rate": 5.0, "campaign_status": "active"}]}}
{"difficulty": "easy", "function_schema_python": "def get_campaign_analytics(campaign_id: str) -> dict:\n    \"\"\"Retrieves analytics data for a specific marketing campaign.\n\n    :param campaign_id: The unique identifier for the campaign\n    :return: Dictionary containing campaign metrics\n    :raises ValueError: If campaign_id is invalid\"\"\"\n    pass\ndef verify_order_tracking(order_id: str, crm_id: str) -> dict:\n    \"\"\"Verifies if an order is properly tracked in the CRM system.\n\n    :param order_id: The order identifier\n    :param crm_id: The CRM system identifier\n    :return: Dictionary containing order tracking status\n    :raises ValueError: If order_id or crm_id is invalid\"\"\"\n    pass\ndef check_tracking_discrepancies(campaign_id: str, crm_id: str) -> dict:\n    \"\"\"Analyzes discrepancies between website visits and attributed conversions.\n\n    :param campaign_id: The campaign identifier\n    :param crm_id: The CRM system identifier\n    :return: Dictionary containing discrepancy analysis\n    :raises ValueError: If campaign_id or crm_id is invalid\"\"\"\n    pass\n", "function_schema_json": [{"name": "get_campaign_analytics", "description": "Retrieves analytics data for a specific marketing campaign.", "parameters": {"type": "object", "properties": {"campaign_id": {"type": "string", "description": "The unique identifier for the campaign"}}, "required": ["campaign_id"], "additionalProperties": false}}, {"name": "verify_order_tracking", "description": "Verifies if an order is properly tracked in the CRM system.", "parameters": {"type": "object", "properties": {"order_id": {"type": "string", "description": "The order identifier"}, "crm_id": {"type": "string", "description": "The CRM system identifier"}}, "required": ["order_id", "crm_id"], "additionalProperties": false}}, {"name": "check_tracking_discrepancies", "description": "Analyzes discrepancies between website visits and attributed conversions.", "parameters": {"type": "object", "properties": {"campaign_id": {"type": "string", "description": "The campaign identifier"}, "crm_id": {"type": "string", "description": "The CRM system identifier"}}, "required": ["campaign_id", "crm_id"], "additionalProperties": false}}], "mock_functions": "def get_campaign_analytics(campaign_id: str) -> dict:\n    \"\"\"\n    Retrieves analytics data for a specific marketing campaign.\n    \n    :param campaign_id: The unique identifier for the campaign\n    :return: Dictionary containing campaign metrics\n    :raises ValueError: If campaign_id is invalid\n    \"\"\"\n    if not campaign_id or not campaign_id.startswith(\"GTG-Test-\"):\n        raise ValueError(\"Invalid campaign ID format\")\n    \n    if campaign_id == \"GTG-Test-001\":\n        return {\n            \"visits\": 500,\n            \"unique_visitors\": 475,\n            \"conversion_events\": 25,\n            \"conversion_rate\": 5.0,\n            \"campaign_status\": \"active\"\n        }\n    return {}\ndef verify_order_tracking(order_id: str, crm_id: str) -> dict:\n    \"\"\"\n    Verifies if an order is properly tracked in the CRM system.\n    \n    :param order_id: The order identifier\n    :param crm_id: The CRM system identifier\n    :return: Dictionary containing order tracking status\n    :raises ValueError: If order_id or crm_id is invalid\n    \"\"\"\n    if not order_id.startswith(\"GTG-\") or not crm_id.startswith(\"GTG-\"):\n        raise ValueError(\"Invalid order ID or CRM ID format\")\n    \n    if (order_id in [f\"GTG-{str(i).zfill(3)}\" for i in range(1, 26)] \n        and crm_id == \"GTG-47\"):\n        return {\n            \"order_tracked\": True,\n            \"attribution_source\": \"GTG-Test-001\",\n            \"tracking_timestamp\": \"2023-07-20T10:30:00Z\",\n            \"conversion_verified\": True\n        }\n    return {}\ndef check_tracking_discrepancies(campaign_id: str, crm_id: str) -> dict:\n    \"\"\"\n    Analyzes discrepancies between website visits and attributed conversions.\n    \n    :param campaign_id: The campaign identifier\n    :param crm_id: The CRM system identifier\n    :return: Dictionary containing discrepancy analysis\n    :raises ValueError: If campaign_id or crm_id is invalid\n    \"\"\"\n    if not campaign_id.startswith(\"GTG-Test-\") or not crm_id.startswith(\"GTG-\"):\n        raise ValueError(\"Invalid campaign ID or CRM ID format\")\n    \n    if campaign_id == \"GTG-Test-001\" and crm_id == \"GTG-47\":\n        return {\n            \"total_visits\": 500,\n            \"tracked_conversions\": 25,\n            \"unattributed_conversions\": 0,\n            \"tracking_accuracy\": 100.0,\n            \"missing_data_points\": 0\n        }\n    return {}", "user_query": "This is John. Could you verify if order GTG-015 is properly tracked in CRM system GTG-47?", "checklist": {"functions": ["verify_order_tracking"], "values": [{"order_tracked": true, "attribution_source": "GTG-Test-001", "tracking_timestamp": "2023-07-20T10:30:00Z", "conversion_verified": true}]}}
{"difficulty": "easy", "function_schema_python": "def get_subscription_status(user_id: str, game_id: str) -> dict:\n    \"\"\"Retrieves the subscription status for a specific user and game.\n\n    :param user_id: The unique identifier for the user.\n    :param game_id: The unique identifier for the game.\n    :return: A dictionary containing subscription details:\n        - status (str): Current subscription status\n        - expiry_date (str): Subscription expiry date\n        - renewal_attempts (int): Number of failed renewal attempts\n        - last_renewal_error (str): Last error message if any\n    :raises ValueError: If user_id or game_id is invalid\"\"\"\n    pass\ndef process_subscription_renewal(user_id: str, game_id: str, payment_provider: str) -> dict:\n    \"\"\"Processes a subscription renewal request.\n\n    :param user_id: The unique identifier for the user.\n    :param game_id: The unique identifier for the game.\n    :param payment_provider: The payment provider to use (stripe/klarna).\n    :return: A dictionary containing renewal result:\n        - success (bool): Whether renewal was successful\n        - new_expiry_date (str): New expiration date if successful\n        - transaction_id (str): Unique transaction identifier\n        - error_message (str): Error message if unsuccessful\n    :raises ValueError: If parameters are invalid\"\"\"\n    pass\ndef create_customer_retention_case(user_id: str, issue_type: str, priority: int) -> dict:\n    \"\"\"Creates a customer retention case for follow-up.\n\n    :param user_id: The unique identifier for the user.\n    :param issue_type: Type of issue (subscription/technical/billing).\n    :param priority: Priority level (1-5, 1 being highest).\n    :return: A dictionary containing case details:\n        - case_id (str): Unique case identifier\n        - assigned_agent (str): Name of assigned agent\n        - status (str): Current case status\n        - estimated_response_time (str): Estimated response time\n    :raises ValueError: If parameters are invalid\"\"\"\n    pass\n", "function_schema_json": [{"name": "get_subscription_status", "description": "Retrieves the subscription status for a specific user and game.", "parameters": {"type": "object", "properties": {"user_id": {"type": "string", "description": "The unique identifier for the user."}, "game_id": {"type": "string", "description": "The unique identifier for the game."}}, "required": ["user_id", "game_id"], "additionalProperties": false}}, {"name": "process_subscription_renewal", "description": "Processes a subscription renewal request.", "parameters": {"type": "object", "properties": {"user_id": {"type": "string", "description": "The unique identifier for the user."}, "game_id": {"type": "string", "description": "The unique identifier for the game."}, "payment_provider": {"type": "string", "description": "The payment provider to use (stripe/klarna)."}}, "required": ["user_id", "game_id", "payment_provider"], "additionalProperties": false}}, {"name": "create_customer_retention_case", "description": "Creates a customer retention case for follow-up.", "parameters": {"type": "object", "properties": {"user_id": {"type": "string", "description": "The unique identifier for the user."}, "issue_type": {"type": "string", "description": "Type of issue (subscription/technical/billing)."}, "priority": {"type": "integer", "description": "Priority level (1-5, 1 being highest)."}}, "required": ["user_id", "issue_type", "priority"], "additionalProperties": false}}], "mock_functions": "def get_subscription_status(user_id: str, game_id: str) -> dict:\n    \"\"\"\n    Retrieves the subscription status for a specific user and game.\n    \n    :param user_id: The unique identifier for the user.\n    :param game_id: The unique identifier for the game.\n    :return: A dictionary containing subscription details:\n        - status (str): Current subscription status\n        - expiry_date (str): Subscription expiry date\n        - renewal_attempts (int): Number of failed renewal attempts\n        - last_renewal_error (str): Last error message if any\n    :raises ValueError: If user_id or game_id is invalid\n    \"\"\"\n    if not user_id or not game_id:\n        raise ValueError(\"User ID and Game ID must be provided\")\n    \n    if user_id == \"emily123\" and game_id == \"galactic_conquerors\":\n        return {\n            \"status\": \"expiring_soon\",\n            \"expiry_date\": \"2024-02-15\",\n            \"renewal_attempts\": 2,\n            \"last_renewal_error\": \"payment_processing_failed\"\n        }\n    return {}\ndef process_subscription_renewal(user_id: str, game_id: str, payment_provider: str) -> dict:\n    \"\"\"\n    Processes a subscription renewal request.\n    \n    :param user_id: The unique identifier for the user.\n    :param game_id: The unique identifier for the game.\n    :param payment_provider: The payment provider to use (stripe/klarna).\n    :return: A dictionary containing renewal result:\n        - success (bool): Whether renewal was successful\n        - new_expiry_date (str): New expiration date if successful\n        - transaction_id (str): Unique transaction identifier\n        - error_message (str): Error message if unsuccessful\n    :raises ValueError: If parameters are invalid\n    \"\"\"\n    if not user_id or not game_id or payment_provider not in ['stripe', 'klarna']:\n        raise ValueError(\"Invalid parameters provided\")\n    \n    if user_id == \"emily123\" and game_id == \"galactic_conquerors\" and payment_provider == \"stripe\":\n        return {\n            \"success\": True,\n            \"new_expiry_date\": \"2025-02-15\",\n            \"transaction_id\": \"txn_123456\",\n            \"error_message\": None\n        }\n    return {\"success\": False, \"error_message\": \"Invalid transaction\"}\ndef create_customer_retention_case(user_id: str, issue_type: str, priority: int) -> dict:\n    \"\"\"\n    Creates a customer retention case for follow-up.\n    \n    :param user_id: The unique identifier for the user.\n    :param issue_type: Type of issue (subscription/technical/billing).\n    :param priority: Priority level (1-5, 1 being highest).\n    :return: A dictionary containing case details:\n        - case_id (str): Unique case identifier\n        - assigned_agent (str): Name of assigned agent\n        - status (str): Current case status\n        - estimated_response_time (str): Estimated response time\n    :raises ValueError: If parameters are invalid\n    \"\"\"\n    if not user_id or priority not in range(1, 6):\n        raise ValueError(\"Invalid parameters provided\")\n    \n    if user_id == \"emily123\" and issue_type == \"subscription\" and priority == 1:\n        return {\n            \"case_id\": \"case_789\",\n            \"assigned_agent\": \"James\",\n            \"status\": \"open\",\n            \"estimated_response_time\": \"1 hour\"\n        }\n    return {}", "user_query": "What is the subscription status for user 'emily123' for the game 'galactic_conquerors'?", "checklist": {"functions": ["get_subscription_status"], "values": [{"status": "expiring_soon", "expiry_date": "2024-02-15", "renewal_attempts": 2, "last_renewal_error": "payment_processing_failed"}]}}
{"difficulty": "easy", "function_schema_python": "def retrieve_user_feedback(app_name: str, user_name: str) -> list:\n    \"\"\"Retrieves feedback for a specific user from a given app.\n\n    :param app_name: The name of the app (e.g., \"Puzzle Paradise\").\n    :param user_name: The name of the user whose feedback is requested.\n    :return: A list of feedback strings provided by the user.\n    :raises ValueError: If either app_name or user_name is invalid.\"\"\"\n    pass\ndef send_email(recipient_email: str, subject: str, body: str) -> bool:\n    \"\"\"Simulates sending an email to a recipient.\n\n    :param recipient_email: The email address of the recipient.\n    :param subject: The subject of the email.\n    :param body: The body content of the email.\n    :return: True if the email was sent successfully, False otherwise.\n    :raises ValueError: If any parameter is invalid.\"\"\"\n    pass\ndef analyze_feedback(feedback_list: list) -> dict:\n    \"\"\"Analyzes a list of feedback to identify common pain points.\n\n    :param feedback_list: A list of feedback strings.\n    :return: A dictionary with identified pain points as keys and their occurrences as values.\n    :raises ValueError: If the feedback list is empty.\"\"\"\n    pass\ndef log_customer_interaction(user_name: str, interaction_details: str) -> bool:\n    \"\"\"Logs details of an interaction with a customer.\n\n    :param user_name: The name of the user interacting with.\n    :param interaction_details: Details of the interaction.\n    :return: True if the interaction was logged successfully, False otherwise.\n    :raises ValueError: If either user_name or interaction_details is invalid.\"\"\"\n    pass\n", "function_schema_json": [{"name": "retrieve_user_feedback", "description": "Retrieves feedback for a specific user from a given app.", "parameters": {"type": "object", "properties": {"app_name": {"type": "string", "description": "The name of the app (e.g., \"Puzzle Paradise\")."}, "user_name": {"type": "string", "description": "The name of the user whose feedback is requested."}}, "required": ["app_name", "user_name"], "additionalProperties": false}}, {"name": "send_email", "description": "Simulates sending an email to a recipient.", "parameters": {"type": "object", "properties": {"recipient_email": {"type": "string", "description": "The email address of the recipient."}, "subject": {"type": "string", "description": "The subject of the email."}, "body": {"type": "string", "description": "The body content of the email."}}, "required": ["recipient_email", "subject", "body"], "additionalProperties": false}}, {"name": "analyze_feedback", "description": "Analyzes a list of feedback to identify common pain points.", "parameters": {"type": "object", "properties": {"feedback_list": {"type": "array", "description": "A list of feedback strings."}}, "required": ["feedback_list"], "additionalProperties": false}}, {"name": "log_customer_interaction", "description": "Logs details of an interaction with a customer.", "parameters": {"type": "object", "properties": {"user_name": {"type": "string", "description": "The name of the user interacting with."}, "interaction_details": {"type": "string", "description": "Details of the interaction."}}, "required": ["user_name", "interaction_details"], "additionalProperties": false}}], "mock_functions": "def retrieve_user_feedback(app_name: str, user_name: str) -> list:\n    \"\"\"\n    Retrieves feedback for a specific user from a given app.\n    \n    :param app_name: The name of the app (e.g., \"Puzzle Paradise\").\n    :param user_name: The name of the user whose feedback is requested.\n    :return: A list of feedback strings provided by the user.\n    :raises ValueError: If either app_name or user_name is invalid.\n    \"\"\"\n    if not app_name or not user_name:\n        raise ValueError(\"App name and user name must be provided.\")\n    if app_name == \"Puzzle Paradise\" and user_name == \"Sarah\":\n        return [\n            \"I'm having trouble with in-app purchases.\",\n            \"There hasn't been any new content updates. This is disappointing.\"\n        ]\n    return []\ndef send_email(recipient_email: str, subject: str, body: str) -> bool:\n    \"\"\"\n    Simulates sending an email to a recipient.\n    \n    :param recipient_email: The email address of the recipient.\n    :param subject: The subject of the email.\n    :param body: The body content of the email.\n    :return: True if the email was sent successfully, False otherwise.\n    :raises ValueError: If any parameter is invalid.\n    \"\"\"\n    if not recipient_email or not subject or not body:\n        raise ValueError(\"Recipient email, subject, and body must be provided.\")\n    if recipient_email == \"sarah@example.com\":\n        print(f\"Email sent to {recipient_email} with subject '{subject}' and body:\\n{body}\")\n        return True\n    return False\ndef analyze_feedback(feedback_list: list) -> dict:\n    \"\"\"\n    Analyzes a list of feedback to identify common pain points.\n    \n    :param feedback_list: A list of feedback strings.\n    :return: A dictionary with identified pain points as keys and their occurrences as values.\n    :raises ValueError: If the feedback list is empty.\n    \"\"\"\n    if not feedback_list:\n        raise ValueError(\"Feedback list must not be empty.\")\n    pain_points = {}\n    for feedback in feedback_list:\n        if \"in-app purchases\" in feedback.lower():\n            pain_points[\"in-app purchases\"] = pain_points.get(\"in-app purchases\", 0) + 1\n        if \"new content updates\" in feedback.lower():\n            pain_points[\"new content updates\"] = pain_points.get(\"new content updates\", 0) + 1\n    return pain_points\ndef log_customer_interaction(user_name: str, interaction_details: str) -> bool:\n    \"\"\"\n    Logs details of an interaction with a customer.\n    \n    :param user_name: The name of the user interacting with.\n    :param interaction_details: Details of the interaction.\n    :return: True if the interaction was logged successfully, False otherwise.\n    :raises ValueError: If either user_name or interaction_details is invalid.\n    \"\"\"\n    if not user_name or not interaction_details:\n        raise ValueError(\"User name and interaction details must be provided.\")\n    if user_name == \"Sarah\":\n        print(f\"Logged interaction with {user_name}: {interaction_details}\")\n        return True\n    return False", "user_query": "What feedback has Sarah given for Puzzle Paradise?", "checklist": {"functions": ["retrieve_user_feedback"], "values": [["I'm having trouble with in-app purchases.", "There hasn't been any new content updates. This is disappointing."]]}}
{"difficulty": "easy", "function_schema_python": "def configure_mlflow(tracking_uri: str, experiment_name: str) -> bool:\n    \"\"\"Configures MLflow tracking and sets up an experiment.\n\n    :param tracking_uri: The URI of the MLflow tracking server.\n    :param experiment_name: The name of the MLflow experiment.\n    :return: True if configuration is successful, False otherwise.\"\"\"\n    pass\ndef build_docker_image(model_name: str, dependencies: List[str]) -> str:\n    \"\"\"Builds a Docker image containing the model and its dependencies.\n\n    :param model_name: The name of the recommendation model.\n    :param dependencies: A list of dependencies required by the model.\n    :return: The Docker image ID.\"\"\"\n    pass\ndef deploy_to_kubernetes(docker_image_id: str, cluster_name: str) -> bool:\n    \"\"\"Deploys the Docker image to a Kubernetes cluster.\n\n    :param docker_image_id: The ID of the Docker image to deploy.\n    :param cluster_name: The name of the Kubernetes cluster.\n    :return: True if deployment is successful, False otherwise.\"\"\"\n    pass\ndef configure_prometheus_monitoring(deployment_name: str, metrics: List[str]) -> bool:\n    \"\"\"Configures Prometheus monitoring for the deployed model.\n\n    :param deployment_name: The name of the Kubernetes deployment.\n    :param metrics: A list of metrics to monitor.\n    :return: True if monitoring setup is successful, False otherwise.\"\"\"\n    pass\ndef setup_terraform(infrastructure_config: Dict[str, Any]) -> bool:\n    \"\"\"Sets up infrastructure using Terraform.\n\n    :param infrastructure_config: A dictionary containing infrastructure configurations.\n    :return: True if Terraform setup is successful, False otherwise.\"\"\"\n    pass\ndef configure_ansible(playbook: str, inventory: str) -> bool:\n    \"\"\"Configures Ansible for automation.\n\n    :param playbook: The path to the Ansible playbook.\n    :param inventory: The path to the Ansible inventory file.\n    :return: True if Ansible configuration is successful, False otherwise.\"\"\"\n    pass\ndef setup_ci_cd_pipeline(repository_url: str, pipeline_config: Dict[str, Any]) -> bool:\n    \"\"\"Sets up a CI/CD pipeline.\n\n    :param repository_url: The URL of the Git repository.\n    :param pipeline_config: A dictionary containing the pipeline configuration.\n    :return: True if pipeline setup is successful, False otherwise.\"\"\"\n    pass\ndef test_model_serving(test_dataset: List[Any]) -> Dict[str, Any]:\n    \"\"\"Tests the deployed model with a sample dataset.\n\n    :param test_dataset: A list of test data points.\n    :return: A dictionary containing evaluation metrics.\"\"\"\n    pass\n", "function_schema_json": [{"name": "configure_mlflow", "description": "Configures MLflow tracking and sets up an experiment.", "parameters": {"type": "object", "properties": {"tracking_uri": {"type": "string", "description": "The URI of the MLflow tracking server."}, "experiment_name": {"type": "string", "description": "The name of the MLflow experiment."}}, "required": ["tracking_uri", "experiment_name"], "additionalProperties": false}}, {"name": "build_docker_image", "description": "Builds a Docker image containing the model and its dependencies.", "parameters": {"type": "object", "properties": {"model_name": {"type": "string", "description": "The name of the recommendation model."}, "dependencies": {"type": "array", "items": {"type": "string"}, "description": "A list of dependencies required by the model."}}, "required": ["model_name", "dependencies"], "additionalProperties": false}}, {"name": "deploy_to_kubernetes", "description": "Deploys the Docker image to a Kubernetes cluster.", "parameters": {"type": "object", "properties": {"docker_image_id": {"type": "string", "description": "The ID of the Docker image to deploy."}, "cluster_name": {"type": "string", "description": "The name of the Kubernetes cluster."}}, "required": ["docker_image_id", "cluster_name"], "additionalProperties": false}}, {"name": "configure_prometheus_monitoring", "description": "Configures Prometheus monitoring for the deployed model.", "parameters": {"type": "object", "properties": {"deployment_name": {"type": "string", "description": "The name of the Kubernetes deployment."}, "metrics": {"type": "array", "items": {"type": "string"}, "description": "A list of metrics to monitor."}}, "required": ["deployment_name", "metrics"], "additionalProperties": false}}, {"name": "setup_terraform", "description": "Sets up infrastructure using Terraform.", "parameters": {"type": "object", "properties": {"infrastructure_config": {"type": "object", "description": "A dictionary containing infrastructure configurations."}}, "required": ["infrastructure_config"], "additionalProperties": false}}, {"name": "configure_ansible", "description": "Configures Ansible for automation.", "parameters": {"type": "object", "properties": {"playbook": {"type": "string", "description": "The path to the Ansible playbook."}, "inventory": {"type": "string", "description": "The path to the Ansible inventory file."}}, "required": ["playbook", "inventory"], "additionalProperties": false}}, {"name": "setup_ci_cd_pipeline", "description": "Sets up a CI/CD pipeline.", "parameters": {"type": "object", "properties": {"repository_url": {"type": "string", "description": "The URL of the Git repository."}, "pipeline_config": {"type": "object", "description": "A dictionary containing the pipeline configuration."}}, "required": ["repository_url", "pipeline_config"], "additionalProperties": false}}, {"name": "test_model_serving", "description": "Tests the deployed model with a sample dataset.", "parameters": {"type": "object", "properties": {"test_dataset": {"type": "array", "items": {"type": "string"}, "description": "A list of test data points."}}, "required": ["test_dataset"], "additionalProperties": false}}], "mock_functions": "def configure_mlflow(tracking_uri: str, experiment_name: str) -> bool:\n    \"\"\"\n    Configures MLflow tracking and sets up an experiment.\n\n    :param tracking_uri: The URI of the MLflow tracking server.\n    :param experiment_name: The name of the MLflow experiment.\n    :return: True if configuration is successful, False otherwise.\n    \"\"\"\n    if tracking_uri and experiment_name:\n        return True  # Mock successful configuration\n    return False\ndef build_docker_image(model_name: str, dependencies: List[str]) -> str:\n    \"\"\"\n    Builds a Docker image containing the model and its dependencies.\n\n    :param model_name: The name of the recommendation model.\n    :param dependencies: A list of dependencies required by the model.\n    :return: The Docker image ID.\n    \"\"\"\n    if model_name and dependencies:\n        return \"mock_docker_image_id\"\n    return \"\"\ndef deploy_to_kubernetes(docker_image_id: str, cluster_name: str) -> bool:\n    \"\"\"\n    Deploys the Docker image to a Kubernetes cluster.\n\n    :param docker_image_id: The ID of the Docker image to deploy.\n    :param cluster_name: The name of the Kubernetes cluster.\n    :return: True if deployment is successful, False otherwise.\n    \"\"\"\n    if docker_image_id and cluster_name:\n        return True\n    return False\ndef configure_prometheus_monitoring(deployment_name: str, metrics: List[str]) -> bool:\n    \"\"\"\n    Configures Prometheus monitoring for the deployed model.\n\n    :param deployment_name: The name of the Kubernetes deployment.\n    :param metrics: A list of metrics to monitor.\n    :return: True if monitoring setup is successful, False otherwise.\n    \"\"\"\n    if deployment_name and metrics:\n        return True\n    return False\ndef setup_terraform(infrastructure_config: Dict[str, Any]) -> bool:\n    \"\"\"\n    Sets up infrastructure using Terraform.\n\n    :param infrastructure_config: A dictionary containing infrastructure configurations.\n    :return: True if Terraform setup is successful, False otherwise.\n    \"\"\"\n    if infrastructure_config:\n        return True\n    return False\ndef configure_ansible(playbook: str, inventory: str) -> bool:\n    \"\"\"\n    Configures Ansible for automation.\n\n    :param playbook: The path to the Ansible playbook.\n    :param inventory: The path to the Ansible inventory file.\n    :return: True if Ansible configuration is successful, False otherwise.\n    \"\"\"\n    if playbook and inventory:\n        return True\n    return False\ndef setup_ci_cd_pipeline(repository_url: str, pipeline_config: Dict[str, Any]) -> bool:\n    \"\"\"\n    Sets up a CI/CD pipeline.\n\n    :param repository_url: The URL of the Git repository.\n    :param pipeline_config: A dictionary containing the pipeline configuration.\n    :return: True if pipeline setup is successful, False otherwise.\n    \"\"\"\n    if repository_url and pipeline_config:\n        return True\n    return False\ndef test_model_serving(test_dataset: List[Any]) -> Dict[str, Any]:\n    \"\"\"\n    Tests the deployed model with a sample dataset.\n\n    :param test_dataset: A list of test data points.\n    :return: A dictionary containing evaluation metrics.\n    \"\"\"\n    if test_dataset:\n        return {\"accuracy\": 0.95, \"latency\": \"10ms\"}\n    return {}", "user_query": "Can you configure MLflow for tracking using the URI 'http://mlflow.tracking.url' and set up an experiment named 'RecommendationModelExperiment' for RobustTech?", "checklist": {"functions": ["configure_mlflow"], "values": [true]}}
{"difficulty": "easy", "function_schema_python": "def configure_mlflow(tracking_uri: str, experiment_name: str) -> bool:\n    \"\"\"Configures MLflow tracking and sets up an experiment.\n\n    :param tracking_uri: The URI of the MLflow tracking server.\n    :param experiment_name: The name of the MLflow experiment.\n    :return: True if configuration is successful, False otherwise.\"\"\"\n    pass\ndef build_docker_image(model_name: str, dependencies: List[str]) -> str:\n    \"\"\"Builds a Docker image containing the model and its dependencies.\n\n    :param model_name: The name of the recommendation model.\n    :param dependencies: A list of dependencies required by the model.\n    :return: The Docker image ID.\"\"\"\n    pass\ndef deploy_to_kubernetes(docker_image_id: str, cluster_name: str) -> bool:\n    \"\"\"Deploys the Docker image to a Kubernetes cluster.\n\n    :param docker_image_id: The ID of the Docker image to deploy.\n    :param cluster_name: The name of the Kubernetes cluster.\n    :return: True if deployment is successful, False otherwise.\"\"\"\n    pass\ndef configure_prometheus_monitoring(deployment_name: str, metrics: List[str]) -> bool:\n    \"\"\"Configures Prometheus monitoring for the deployed model.\n\n    :param deployment_name: The name of the Kubernetes deployment.\n    :param metrics: A list of metrics to monitor.\n    :return: True if monitoring setup is successful, False otherwise.\"\"\"\n    pass\ndef setup_terraform(infrastructure_config: Dict[str, Any]) -> bool:\n    \"\"\"Sets up infrastructure using Terraform.\n\n    :param infrastructure_config: A dictionary containing infrastructure configurations.\n    :return: True if Terraform setup is successful, False otherwise.\"\"\"\n    pass\ndef configure_ansible(playbook: str, inventory: str) -> bool:\n    \"\"\"Configures Ansible for automation.\n\n    :param playbook: The path to the Ansible playbook.\n    :param inventory: The path to the Ansible inventory file.\n    :return: True if Ansible configuration is successful, False otherwise.\"\"\"\n    pass\ndef setup_ci_cd_pipeline(repository_url: str, pipeline_config: Dict[str, Any]) -> bool:\n    \"\"\"Sets up a CI/CD pipeline.\n\n    :param repository_url: The URL of the Git repository.\n    :param pipeline_config: A dictionary containing the pipeline configuration.\n    :return: True if pipeline setup is successful, False otherwise.\"\"\"\n    pass\ndef test_model_serving(test_dataset: List[Any]) -> Dict[str, Any]:\n    \"\"\"Tests the deployed model with a sample dataset.\n\n    :param test_dataset: A list of test data points.\n    :return: A dictionary containing evaluation metrics.\"\"\"\n    pass\n", "function_schema_json": [{"name": "configure_mlflow", "description": "Configures MLflow tracking and sets up an experiment.", "parameters": {"type": "object", "properties": {"tracking_uri": {"type": "string", "description": "The URI of the MLflow tracking server."}, "experiment_name": {"type": "string", "description": "The name of the MLflow experiment."}}, "required": ["tracking_uri", "experiment_name"], "additionalProperties": false}}, {"name": "build_docker_image", "description": "Builds a Docker image containing the model and its dependencies.", "parameters": {"type": "object", "properties": {"model_name": {"type": "string", "description": "The name of the recommendation model."}, "dependencies": {"type": "array", "items": {"type": "string"}, "description": "A list of dependencies required by the model."}}, "required": ["model_name", "dependencies"], "additionalProperties": false}}, {"name": "deploy_to_kubernetes", "description": "Deploys the Docker image to a Kubernetes cluster.", "parameters": {"type": "object", "properties": {"docker_image_id": {"type": "string", "description": "The ID of the Docker image to deploy."}, "cluster_name": {"type": "string", "description": "The name of the Kubernetes cluster."}}, "required": ["docker_image_id", "cluster_name"], "additionalProperties": false}}, {"name": "configure_prometheus_monitoring", "description": "Configures Prometheus monitoring for the deployed model.", "parameters": {"type": "object", "properties": {"deployment_name": {"type": "string", "description": "The name of the Kubernetes deployment."}, "metrics": {"type": "array", "items": {"type": "string"}, "description": "A list of metrics to monitor."}}, "required": ["deployment_name", "metrics"], "additionalProperties": false}}, {"name": "setup_terraform", "description": "Sets up infrastructure using Terraform.", "parameters": {"type": "object", "properties": {"infrastructure_config": {"type": "object", "description": "A dictionary containing infrastructure configurations."}}, "required": ["infrastructure_config"], "additionalProperties": false}}, {"name": "configure_ansible", "description": "Configures Ansible for automation.", "parameters": {"type": "object", "properties": {"playbook": {"type": "string", "description": "The path to the Ansible playbook."}, "inventory": {"type": "string", "description": "The path to the Ansible inventory file."}}, "required": ["playbook", "inventory"], "additionalProperties": false}}, {"name": "setup_ci_cd_pipeline", "description": "Sets up a CI/CD pipeline.", "parameters": {"type": "object", "properties": {"repository_url": {"type": "string", "description": "The URL of the Git repository."}, "pipeline_config": {"type": "object", "description": "A dictionary containing the pipeline configuration."}}, "required": ["repository_url", "pipeline_config"], "additionalProperties": false}}, {"name": "test_model_serving", "description": "Tests the deployed model with a sample dataset.", "parameters": {"type": "object", "properties": {"test_dataset": {"type": "array", "items": {"type": "string"}, "description": "A list of test data points."}}, "required": ["test_dataset"], "additionalProperties": false}}], "mock_functions": "def configure_mlflow(tracking_uri: str, experiment_name: str) -> bool:\n    \"\"\"\n    Configures MLflow tracking and sets up an experiment.\n\n    :param tracking_uri: The URI of the MLflow tracking server.\n    :param experiment_name: The name of the MLflow experiment.\n    :return: True if configuration is successful, False otherwise.\n    \"\"\"\n    if tracking_uri and experiment_name:\n        return True  # Mock successful configuration\n    return False\ndef build_docker_image(model_name: str, dependencies: List[str]) -> str:\n    \"\"\"\n    Builds a Docker image containing the model and its dependencies.\n\n    :param model_name: The name of the recommendation model.\n    :param dependencies: A list of dependencies required by the model.\n    :return: The Docker image ID.\n    \"\"\"\n    if model_name and dependencies:\n        return \"mock_docker_image_id\"\n    return \"\"\ndef deploy_to_kubernetes(docker_image_id: str, cluster_name: str) -> bool:\n    \"\"\"\n    Deploys the Docker image to a Kubernetes cluster.\n\n    :param docker_image_id: The ID of the Docker image to deploy.\n    :param cluster_name: The name of the Kubernetes cluster.\n    :return: True if deployment is successful, False otherwise.\n    \"\"\"\n    if docker_image_id and cluster_name:\n        return True\n    return False\ndef configure_prometheus_monitoring(deployment_name: str, metrics: List[str]) -> bool:\n    \"\"\"\n    Configures Prometheus monitoring for the deployed model.\n\n    :param deployment_name: The name of the Kubernetes deployment.\n    :param metrics: A list of metrics to monitor.\n    :return: True if monitoring setup is successful, False otherwise.\n    \"\"\"\n    if deployment_name and metrics:\n        return True\n    return False\ndef setup_terraform(infrastructure_config: Dict[str, Any]) -> bool:\n    \"\"\"\n    Sets up infrastructure using Terraform.\n\n    :param infrastructure_config: A dictionary containing infrastructure configurations.\n    :return: True if Terraform setup is successful, False otherwise.\n    \"\"\"\n    if infrastructure_config:\n        return True\n    return False\ndef configure_ansible(playbook: str, inventory: str) -> bool:\n    \"\"\"\n    Configures Ansible for automation.\n\n    :param playbook: The path to the Ansible playbook.\n    :param inventory: The path to the Ansible inventory file.\n    :return: True if Ansible configuration is successful, False otherwise.\n    \"\"\"\n    if playbook and inventory:\n        return True\n    return False\ndef setup_ci_cd_pipeline(repository_url: str, pipeline_config: Dict[str, Any]) -> bool:\n    \"\"\"\n    Sets up a CI/CD pipeline.\n\n    :param repository_url: The URL of the Git repository.\n    :param pipeline_config: A dictionary containing the pipeline configuration.\n    :return: True if pipeline setup is successful, False otherwise.\n    \"\"\"\n    if repository_url and pipeline_config:\n        return True\n    return False\ndef test_model_serving(test_dataset: List[Any]) -> Dict[str, Any]:\n    \"\"\"\n    Tests the deployed model with a sample dataset.\n\n    :param test_dataset: A list of test data points.\n    :return: A dictionary containing evaluation metrics.\n    \"\"\"\n    if test_dataset:\n        return {\"accuracy\": 0.95, \"latency\": \"10ms\"}\n    return {}", "user_query": "Could you build a Docker image for the 'recommendation_model' with dependencies ['tensorflow', 'numpy']?", "checklist": {"functions": ["build_docker_image"], "values": ["mock_docker_image_id"]}}
{"difficulty": "easy", "function_schema_python": "def initialize_fraud_model(model_path: str, batch_size: int) -> dict:\n    \"\"\"Initializes the fraud detection model from HuggingFace model hub.\n\n    :param model_path: Path to the model in HuggingFace hub\n    :param batch_size: Batch size for model inference\n    :return: Dictionary containing model configuration and initialization status\n    :raises ValueError: If model_path is invalid or batch_size <= 0\"\"\"\n    pass\ndef deploy_model_container(image_name: str, resource_config: dict) -> dict:\n    \"\"\"Deploys the model container to Kubernetes cluster.\n\n    :param image_name: Docker image name for the model\n    :param resource_config: Dictionary containing resource requirements\n    :return: Dictionary containing deployment status and endpoint information\n    :raises ValueError: If image_name is invalid or resource_config is incomplete\"\"\"\n    pass\ndef configure_monitoring(deployment_id: str, metrics_config: dict) -> dict:\n    \"\"\"Sets up Prometheus monitoring for the deployed model.\n\n    :param deployment_id: ID of the deployed model\n    :param metrics_config: Dictionary containing monitoring configuration\n    :return: Dictionary containing monitoring setup status and dashboard URL\n    :raises ValueError: If deployment_id is invalid or metrics_config is incomplete\"\"\"\n    pass\n", "function_schema_json": [{"name": "initialize_fraud_model", "description": "Initializes the fraud detection model from HuggingFace model hub.", "parameters": {"type": "object", "properties": {"model_path": {"type": "string", "description": "Path to the model in HuggingFace hub"}, "batch_size": {"type": "integer", "description": "Batch size for model inference"}}, "required": ["model_path", "batch_size"], "additionalProperties": false}}, {"name": "deploy_model_container", "description": "Deploys the model container to Kubernetes cluster.", "parameters": {"type": "object", "properties": {"image_name": {"type": "string", "description": "Docker image name for the model"}, "resource_config": {"type": "object", "description": "Dictionary containing resource requirements"}}, "required": ["image_name", "resource_config"], "additionalProperties": false}}, {"name": "configure_monitoring", "description": "Sets up Prometheus monitoring for the deployed model.", "parameters": {"type": "object", "properties": {"deployment_id": {"type": "string", "description": "ID of the deployed model"}, "metrics_config": {"type": "object", "description": "Dictionary containing monitoring configuration"}}, "required": ["deployment_id", "metrics_config"], "additionalProperties": false}}], "mock_functions": "def initialize_fraud_model(model_path: str, batch_size: int) -> dict:\n    \"\"\"\n    Initializes the fraud detection model from HuggingFace model hub.\n    \n    :param model_path: Path to the model in HuggingFace hub\n    :param batch_size: Batch size for model inference\n    :return: Dictionary containing model configuration and initialization status\n    :raises ValueError: If model_path is invalid or batch_size <= 0\n    \"\"\"\n    if not model_path or batch_size <= 0:\n        raise ValueError(\"Invalid model path or batch size\")\n    \n    if model_path == \"securebank/fraud-detector-v1\" and batch_size == 32:\n        return {\n            \"model_id\": \"fraud-detector-v1\",\n            \"status\": \"initialized\",\n            \"batch_size\": batch_size,\n            \"device\": \"cuda\"\n        }\n    return {\"status\": \"failed\"}\ndef deploy_model_container(image_name: str, resource_config: dict) -> dict:\n    \"\"\"\n    Deploys the model container to Kubernetes cluster.\n    \n    :param image_name: Docker image name for the model\n    :param resource_config: Dictionary containing resource requirements\n    :return: Dictionary containing deployment status and endpoint information\n    :raises ValueError: If image_name is invalid or resource_config is incomplete\n    \"\"\"\n    required_keys = [\"cpu\", \"memory\", \"replicas\"]\n    if not all(key in resource_config for key in required_keys):\n        raise ValueError(\"Missing required resource configurations\")\n\n    if (image_name == \"securebank/fraud-model:latest\" and \n        resource_config[\"cpu\"] == \"2\" and \n        resource_config[\"memory\"] == \"4Gi\" and \n        resource_config[\"replicas\"] == 3):\n        return {\n            \"deployment_id\": \"fraud-model-prod-001\",\n            \"status\": \"running\",\n            \"endpoint\": \"https://fraud-api.securebank.com\",\n            \"health_check\": \"passed\"\n        }\n    return {\"status\": \"failed\"}\ndef configure_monitoring(deployment_id: str, metrics_config: dict) -> dict:\n    \"\"\"\n    Sets up Prometheus monitoring for the deployed model.\n    \n    :param deployment_id: ID of the deployed model\n    :param metrics_config: Dictionary containing monitoring configuration\n    :return: Dictionary containing monitoring setup status and dashboard URL\n    :raises ValueError: If deployment_id is invalid or metrics_config is incomplete\n    \"\"\"\n    required_metrics = [\"latency\", \"throughput\", \"error_rate\"]\n    if not all(metric in metrics_config for metric in required_metrics):\n        raise ValueError(\"Missing required metrics configuration\")\n\n    if (deployment_id == \"fraud-model-prod-001\" and \n        metrics_config[\"latency\"] == \"p99<100ms\" and\n        metrics_config[\"throughput\"] == \"1000rps\" and\n        metrics_config[\"error_rate\"] == \"<0.1%\"):\n        return {\n            \"monitoring_id\": \"fraud-monitor-001\",\n            \"status\": \"active\",\n            \"dashboard_url\": \"https://grafana.securebank.com/fraud-model\",\n            \"alerts_configured\": True\n        }\n    return {\"status\": \"failed\"}", "user_query": "Could you initialize the fraud detection model from securebank/fraud-detector-v1 with a batch size of 32?", "checklist": {"functions": ["initialize_fraud_model"], "values": [{"model_id": "fraud-detector-v1", "status": "initialized", "batch_size": 32, "device": "cuda"}]}}
{"difficulty": "easy", "function_schema_python": "def initialize_fraud_model(model_path: str, batch_size: int) -> dict:\n    \"\"\"Initializes the fraud detection model from HuggingFace model hub.\n\n    :param model_path: Path to the model in HuggingFace hub\n    :param batch_size: Batch size for model inference\n    :return: Dictionary containing model configuration and initialization status\n    :raises ValueError: If model_path is invalid or batch_size <= 0\"\"\"\n    pass\ndef deploy_model_container(image_name: str, resource_config: dict) -> dict:\n    \"\"\"Deploys the model container to Kubernetes cluster.\n\n    :param image_name: Docker image name for the model\n    :param resource_config: Dictionary containing resource requirements\n    :return: Dictionary containing deployment status and endpoint information\n    :raises ValueError: If image_name is invalid or resource_config is incomplete\"\"\"\n    pass\ndef configure_monitoring(deployment_id: str, metrics_config: dict) -> dict:\n    \"\"\"Sets up Prometheus monitoring for the deployed model.\n\n    :param deployment_id: ID of the deployed model\n    :param metrics_config: Dictionary containing monitoring configuration\n    :return: Dictionary containing monitoring setup status and dashboard URL\n    :raises ValueError: If deployment_id is invalid or metrics_config is incomplete\"\"\"\n    pass\n", "function_schema_json": [{"name": "initialize_fraud_model", "description": "Initializes the fraud detection model from HuggingFace model hub.", "parameters": {"type": "object", "properties": {"model_path": {"type": "string", "description": "Path to the model in HuggingFace hub"}, "batch_size": {"type": "integer", "description": "Batch size for model inference"}}, "required": ["model_path", "batch_size"], "additionalProperties": false}}, {"name": "deploy_model_container", "description": "Deploys the model container to Kubernetes cluster.", "parameters": {"type": "object", "properties": {"image_name": {"type": "string", "description": "Docker image name for the model"}, "resource_config": {"type": "object", "description": "Dictionary containing resource requirements"}}, "required": ["image_name", "resource_config"], "additionalProperties": false}}, {"name": "configure_monitoring", "description": "Sets up Prometheus monitoring for the deployed model.", "parameters": {"type": "object", "properties": {"deployment_id": {"type": "string", "description": "ID of the deployed model"}, "metrics_config": {"type": "object", "description": "Dictionary containing monitoring configuration"}}, "required": ["deployment_id", "metrics_config"], "additionalProperties": false}}], "mock_functions": "def initialize_fraud_model(model_path: str, batch_size: int) -> dict:\n    \"\"\"\n    Initializes the fraud detection model from HuggingFace model hub.\n    \n    :param model_path: Path to the model in HuggingFace hub\n    :param batch_size: Batch size for model inference\n    :return: Dictionary containing model configuration and initialization status\n    :raises ValueError: If model_path is invalid or batch_size <= 0\n    \"\"\"\n    if not model_path or batch_size <= 0:\n        raise ValueError(\"Invalid model path or batch size\")\n    \n    if model_path == \"securebank/fraud-detector-v1\" and batch_size == 32:\n        return {\n            \"model_id\": \"fraud-detector-v1\",\n            \"status\": \"initialized\",\n            \"batch_size\": batch_size,\n            \"device\": \"cuda\"\n        }\n    return {\"status\": \"failed\"}\ndef deploy_model_container(image_name: str, resource_config: dict) -> dict:\n    \"\"\"\n    Deploys the model container to Kubernetes cluster.\n    \n    :param image_name: Docker image name for the model\n    :param resource_config: Dictionary containing resource requirements\n    :return: Dictionary containing deployment status and endpoint information\n    :raises ValueError: If image_name is invalid or resource_config is incomplete\n    \"\"\"\n    required_keys = [\"cpu\", \"memory\", \"replicas\"]\n    if not all(key in resource_config for key in required_keys):\n        raise ValueError(\"Missing required resource configurations\")\n\n    if (image_name == \"securebank/fraud-model:latest\" and \n        resource_config[\"cpu\"] == \"2\" and \n        resource_config[\"memory\"] == \"4Gi\" and \n        resource_config[\"replicas\"] == 3):\n        return {\n            \"deployment_id\": \"fraud-model-prod-001\",\n            \"status\": \"running\",\n            \"endpoint\": \"https://fraud-api.securebank.com\",\n            \"health_check\": \"passed\"\n        }\n    return {\"status\": \"failed\"}\ndef configure_monitoring(deployment_id: str, metrics_config: dict) -> dict:\n    \"\"\"\n    Sets up Prometheus monitoring for the deployed model.\n    \n    :param deployment_id: ID of the deployed model\n    :param metrics_config: Dictionary containing monitoring configuration\n    :return: Dictionary containing monitoring setup status and dashboard URL\n    :raises ValueError: If deployment_id is invalid or metrics_config is incomplete\n    \"\"\"\n    required_metrics = [\"latency\", \"throughput\", \"error_rate\"]\n    if not all(metric in metrics_config for metric in required_metrics):\n        raise ValueError(\"Missing required metrics configuration\")\n\n    if (deployment_id == \"fraud-model-prod-001\" and \n        metrics_config[\"latency\"] == \"p99<100ms\" and\n        metrics_config[\"throughput\"] == \"1000rps\" and\n        metrics_config[\"error_rate\"] == \"<0.1%\"):\n        return {\n            \"monitoring_id\": \"fraud-monitor-001\",\n            \"status\": \"active\",\n            \"dashboard_url\": \"https://grafana.securebank.com/fraud-model\",\n            \"alerts_configured\": True\n        }\n    return {\"status\": \"failed\"}", "user_query": "This is Raj Patel. Please deploy the fraud model using image securebank/fraud-model:latest with 2 CPUs, 4Gi memory, and 3 replicas.", "checklist": {"functions": ["deploy_model_container"], "values": [{"deployment_id": "fraud-model-prod-001", "status": "running", "endpoint": "https://fraud-api.securebank.com", "health_check": "passed"}]}}
{"difficulty": "easy", "function_schema_python": "def deploy_smart_contract(contract_code: str, network: str) -> int:\n    \"\"\"Deploys a smart contract to a specified blockchain network.\n\n    :param contract_code: The code of the smart contract to be deployed.\n    :param network: The blockchain network (e.g., \"Ethereum\", \"Binance Smart Chain\").\n    :return: An integer representing the contract address or transaction hash.\n    :raises ValueError: If the contract code or network is invalid.\"\"\"\n    pass\ndef scan_with_web3(contract_address: int, network: str) -> dict:\n    \"\"\"Scans a smart contract using web3 for vulnerabilities.\n\n    :param contract_address: The address of the smart contract to be scanned.\n    :param network: The blockchain network the contract is deployed on (e.g., \"Ethereum\").\n    :return: A dictionary with the results of the scan.\n        dict: A dictionary with the following keys:\n            - vulnerabilities (list[str]): List of identified vulnerabilities.\n            - status (str): Status of the scan (\"completed\", \"failed\").\n    :raises ValueError: If the contract address or network is invalid.\"\"\"\n    pass\ndef analyze_with_nmap(target_host: str) -> dict:\n    \"\"\"Analyzes a target host for open ports and services using nmap.\n\n    :param target_host: The IP address or domain of the target host.\n    :return: A dictionary with the results of the analysis.\n        dict: A dictionary with the following keys:\n            - open_ports (list[int]): List of open ports.\n            - services (dict): Dictionary of services running on the open ports.\n    :raises ValueError: If the target host is invalid.\"\"\"\n    pass\ndef exploit_with_metasploit(target_host: str, exploit_name: str) -> bool:\n    \"\"\"Attempts to exploit a target host using Metasploit.\n\n    :param target_host: The IP address or domain of the target host.\n    :param exploit_name: The name of the exploit to use.\n    :return: A boolean indicating whether the exploit was successful.\n    :raises ValueError: If the target host or exploit name is invalid.\"\"\"\n    pass\ndef capture_traffic_with_wireshark(interface: str) -> list:\n    \"\"\"Captures network traffic on a specified network interface using Wireshark.\n\n    :param interface: The network interface to capture traffic from (e.g., \"eth0\").\n    :return: A list of captured packets.\n    :raises ValueError: If the interface is invalid.\"\"\"\n    pass\ndef analyze_traffic_with_burp_suite(traffic_file: str) -> dict:\n    \"\"\"Analyzes captured traffic using Burp Suite.\n\n    :param traffic_file: The file path to the captured traffic.\n    :return: A dictionary with the analysis results.\n        dict: A dictionary with the following keys:\n            - issues (list[str]): List of identified security issues.\n            - summary (str): Summary of the analysis.\n    :raises ValueError: If the traffic file is invalid.\"\"\"\n    pass\n", "function_schema_json": [{"name": "deploy_smart_contract", "description": "Deploys a smart contract to a specified blockchain network.", "parameters": {"type": "object", "properties": {"contract_code": {"type": "string", "description": "The code of the smart contract to be deployed."}, "network": {"type": "string", "description": "The blockchain network (e.g., \"Ethereum\", \"Binance Smart Chain\")."}}, "required": ["contract_code", "network"], "additionalProperties": false}}, {"name": "scan_with_web3", "description": "Scans a smart contract using web3 for vulnerabilities.", "parameters": {"type": "object", "properties": {"contract_address": {"type": "integer", "description": "The address of the smart contract to be scanned."}, "network": {"type": "string", "description": "The blockchain network the contract is deployed on (e.g., \"Ethereum\")."}}, "required": ["contract_address", "network"], "additionalProperties": false}}, {"name": "analyze_with_nmap", "description": "Analyzes a target host for open ports and services using nmap.", "parameters": {"type": "object", "properties": {"target_host": {"type": "string", "description": "The IP address or domain of the target host."}}, "required": ["target_host"], "additionalProperties": false}}, {"name": "exploit_with_metasploit", "description": "Attempts to exploit a target host using Metasploit.", "parameters": {"type": "object", "properties": {"target_host": {"type": "string", "description": "The IP address or domain of the target host."}, "exploit_name": {"type": "string", "description": "The name of the exploit to use."}}, "required": ["target_host", "exploit_name"], "additionalProperties": false}}, {"name": "capture_traffic_with_wireshark", "description": "Captures network traffic on a specified network interface using Wireshark.", "parameters": {"type": "object", "properties": {"interface": {"type": "string", "description": "The network interface to capture traffic from (e.g., \"eth0\")."}}, "required": ["interface"], "additionalProperties": false}}, {"name": "analyze_traffic_with_burp_suite", "description": "Analyzes captured traffic using Burp Suite.", "parameters": {"type": "object", "properties": {"traffic_file": {"type": "string", "description": "The file path to the captured traffic."}}, "required": ["traffic_file"], "additionalProperties": false}}], "mock_functions": "def deploy_smart_contract(contract_code: str, network: str) -> int:\n    \"\"\"\n    Deploys a smart contract to a specified blockchain network.\n    \n    :param contract_code: The code of the smart contract to be deployed.\n    :param network: The blockchain network (e.g., \"Ethereum\", \"Binance Smart Chain\").\n    :return: An integer representing the contract address or transaction hash.\n    :raises ValueError: If the contract code or network is invalid.\n    \"\"\"\n    if not contract_code or not network:\n        raise ValueError(\"Contract code and network must be provided.\")\n    return 1234567890  # Mock contract address\ndef scan_with_web3(contract_address: int, network: str) -> dict:\n    \"\"\"\n    Scans a smart contract using web3 for vulnerabilities.\n    \n    :param contract_address: The address of the smart contract to be scanned.\n    :param network: The blockchain network the contract is deployed on (e.g., \"Ethereum\").\n    :return: A dictionary with the results of the scan.\n        dict: A dictionary with the following keys:\n            - vulnerabilities (list[str]): List of identified vulnerabilities.\n            - status (str): Status of the scan (\"completed\", \"failed\").\n    :raises ValueError: If the contract address or network is invalid.\n    \"\"\"\n    if not contract_address or not network:\n        raise ValueError(\"Contract address and network must be provided.\")\n    return {\n        \"vulnerabilities\": [\"Reentrancy\", \"Unchecked external calls\"],\n        \"status\": \"completed\"\n    }\ndef analyze_with_nmap(target_host: str) -> dict:\n    \"\"\"\n    Analyzes a target host for open ports and services using nmap.\n    \n    :param target_host: The IP address or domain of the target host.\n    :return: A dictionary with the results of the analysis.\n        dict: A dictionary with the following keys:\n            - open_ports (list[int]): List of open ports.\n            - services (dict): Dictionary of services running on the open ports.\n    :raises ValueError: If the target host is invalid.\n    \"\"\"\n    if not target_host:\n        raise ValueError(\"Target host must be provided.\")\n    return {\n        \"open_ports\": [80, 443, 3000],\n        \"services\": {\n            80: \"HTTP\",\n            443: \"HTTPS\",\n            3000: \"Node.js\"\n        }\n    }\ndef exploit_with_metasploit(target_host: str, exploit_name: str) -> bool:\n    \"\"\"\n    Attempts to exploit a target host using Metasploit.\n    \n    :param target_host: The IP address or domain of the target host.\n    :param exploit_name: The name of the exploit to use.\n    :return: A boolean indicating whether the exploit was successful.\n    :raises ValueError: If the target host or exploit name is invalid.\n    \"\"\"\n    if not target_host or not exploit_name:\n        raise ValueError(\"Target host and exploit name must be provided.\")\n    return False  # Mock failure\ndef capture_traffic_with_wireshark(interface: str) -> list:\n    \"\"\"\n    Captures network traffic on a specified network interface using Wireshark.\n    \n    :param interface: The network interface to capture traffic from (e.g., \"eth0\").\n    :return: A list of captured packets.\n    :raises ValueError: If the interface is invalid.\n    \"\"\"\n    if not interface:\n        raise ValueError(\"Interface must be provided.\")\n    return [\"Packet1\", \"Packet2\", \"Packet3\"]  # Mock packets\ndef analyze_traffic_with_burp_suite(traffic_file: str) -> dict:\n    \"\"\"\n    Analyzes captured traffic using Burp Suite.\n    \n    :param traffic_file: The file path to the captured traffic.\n    :return: A dictionary with the analysis results.\n        dict: A dictionary with the following keys:\n            - issues (list[str]): List of identified security issues.\n            - summary (str): Summary of the analysis.\n    :raises ValueError: If the traffic file is invalid.\n    \"\"\"\n    if not traffic_file:\n        raise ValueError(\"Traffic file must be provided.\")\n    return {\n        \"issues\": [\"Insecure transport\", \"SQL Injection\"],\n        \"summary\": \"Analysis complete with minor issues.\"\n    }", "user_query": "Can you scan this deployed smart contract on the Ethereum network with address 1234567890 for vulnerabilities?", "checklist": {"functions": ["scan_with_web3"], "values": [{"vulnerabilities": ["Reentrancy", "Unchecked external calls"], "status": "completed"}]}}
{"difficulty": "easy", "function_schema_python": "def get_inventory_alert(product_name: str) -> dict:\n    \"\"\"Retrieves inventory alerts for a given product.\n\n    :param product_name: The name of the product.\n    :return: A dictionary containing alert details.\n        dict: A dictionary with the following keys:\n            - discrepancy (int): The inventory discrepancy.\n            - expected_level (int): The expected inventory level.\n            - actual_level (int): The actual inventory level.\n    :raises ValueError: If the product name is invalid.\"\"\"\n    pass\ndef get_inventory_data(product_name: str, api_key: str) -> dict:\n    \"\"\"Retrieves inventory data for a given product using the InvTrack API.\n\n    :param product_name: The name of the product.\n    :param api_key: The API key for authentication.\n    :return: A dictionary containing inventory data.\n        dict: A dictionary with the following keys:\n            - product_id (str): The product ID.\n            - transactions (list[dict]): A list of transactions. Each transaction is a dictionary with:\n                - transaction_id (str): The transaction ID.\n                - type (str): The transaction type (e.g., \"sale\", \"shipment\").\n                - quantity (int): The quantity involved in the transaction.\n    :raises ValueError: If the product name or API key is invalid.\"\"\"\n    pass\ndef analyze_transactions(transactions: list) -> dict:\n    \"\"\"Analyzes a list of transactions to identify potential causes of discrepancies.\n\n    :param transactions: A list of transaction dictionaries.\n    :return: A dictionary containing analysis results.\n        dict: A dictionary with the following keys:\n            - total_sales (int): The total sales quantity.\n            - total_shipments (int): The total shipments quantity.\n            - potential_issues (list[str]): List of potential issues.\n    :raises TypeError: If transactions is not a list.\"\"\"\n    pass\ndef adjust_inventory(product_id: str, adjustment_quantity: int) -> bool:\n    \"\"\"Adjusts the inventory level for a given product.\n\n    :param product_id: The ID of the product.\n    :param adjustment_quantity: The quantity to adjust (positive for increase, negative for decrease).\n    :return: True if the adjustment was successful, False otherwise.\n    :raises ValueError: If the product ID or adjustment quantity is invalid.\"\"\"\n    pass\n", "function_schema_json": [{"name": "get_inventory_alert", "description": "Retrieves inventory alerts for a given product.", "parameters": {"type": "object", "properties": {"product_name": {"type": "string", "description": "The name of the product."}}, "required": ["product_name"], "additionalProperties": false}}, {"name": "get_inventory_data", "description": "Retrieves inventory data for a given product using the InvTrack API.", "parameters": {"type": "object", "properties": {"product_name": {"type": "string", "description": "The name of the product."}, "api_key": {"type": "string", "description": "The API key for authentication."}}, "required": ["product_name", "api_key"], "additionalProperties": false}}, {"name": "analyze_transactions", "description": "Analyzes a list of transactions to identify potential causes of discrepancies.", "parameters": {"type": "object", "properties": {"transactions": {"type": "array", "description": "A list of transaction dictionaries."}}, "required": ["transactions"], "additionalProperties": false}}, {"name": "adjust_inventory", "description": "Adjusts the inventory level for a given product.", "parameters": {"type": "object", "properties": {"product_id": {"type": "string", "description": "The ID of the product."}, "adjustment_quantity": {"type": "integer", "description": "The quantity to adjust (positive for increase, negative for decrease)."}}, "required": ["product_id", "adjustment_quantity"], "additionalProperties": false}}], "mock_functions": "def get_inventory_alert(product_name: str) -> dict:\n    \"\"\"\n    Retrieves inventory alerts for a given product.\n\n    :param product_name: The name of the product.\n    :return: A dictionary containing alert details.\n        dict: A dictionary with the following keys:\n            - discrepancy (int): The inventory discrepancy.\n            - expected_level (int): The expected inventory level.\n            - actual_level (int): The actual inventory level.\n    :raises ValueError: If the product name is invalid.\n    \"\"\"\n    if product_name == \"SmartWatch X1\":\n        return {\n            \"discrepancy\": -500,\n            \"expected_level\": 1500,\n            \"actual_level\": 1000\n        }\n    raise ValueError(\"Invalid product name.\")\ndef get_inventory_data(product_name: str, api_key: str) -> dict:\n    \"\"\"\n    Retrieves inventory data for a given product using the InvTrack API.\n\n    :param product_name: The name of the product.\n    :param api_key: The API key for authentication.\n    :return: A dictionary containing inventory data.\n        dict: A dictionary with the following keys:\n            - product_id (str): The product ID.\n            - transactions (list[dict]): A list of transactions. Each transaction is a dictionary with:\n                - transaction_id (str): The transaction ID.\n                - type (str): The transaction type (e.g., \"sale\", \"shipment\").\n                - quantity (int): The quantity involved in the transaction.\n    :raises ValueError: If the product name or API key is invalid.\n    \"\"\"\n    if product_name == \"SmartWatch X1\" and api_key == \"valid_api_key\":\n        return {\n            \"product_id\": \"SWX1\",\n            \"transactions\": [\n                {\"transaction_id\": \"TX1\", \"type\": \"sale\", \"quantity\": 200},\n                {\"transaction_id\": \"TX2\", \"type\": \"shipment\", \"quantity\": 500},\n                {\"transaction_id\": \"TX3\", \"type\": \"sale\", \"quantity\": 800}\n            ]\n        }\n    raise ValueError(\"Invalid product name or API key.\")\ndef analyze_transactions(transactions: list) -> dict:\n    \"\"\"\n    Analyzes a list of transactions to identify potential causes of discrepancies.\n\n    :param transactions: A list of transaction dictionaries.\n    :return: A dictionary containing analysis results.\n        dict: A dictionary with the following keys:\n            - total_sales (int): The total sales quantity.\n            - total_shipments (int): The total shipments quantity.\n            - potential_issues (list[str]): List of potential issues.\n    :raises TypeError: If transactions is not a list.\n    \"\"\"\n    if not isinstance(transactions, list):\n        raise TypeError(\"Transactions must be a list.\")\n    total_sales = sum(t[\"quantity\"] for t in transactions if t[\"type\"] == \"sale\")\n    total_shipments = sum(t[\"quantity\"] for t in transactions if t[\"type\"] == \"shipment\")\n\n    potential_issues = []\n    if total_sales > total_shipments:\n      potential_issues.append(\"More sales than shipments\")\n    return {\n        \"total_sales\": total_sales,\n        \"total_shipments\": total_shipments,\n        \"potential_issues\": potential_issues\n    }\ndef adjust_inventory(product_id: str, adjustment_quantity: int) -> bool:\n    \"\"\"\n    Adjusts the inventory level for a given product.\n\n    :param product_id: The ID of the product.\n    :param adjustment_quantity: The quantity to adjust (positive for increase, negative for decrease).\n    :return: True if the adjustment was successful, False otherwise.\n    :raises ValueError: If the product ID or adjustment quantity is invalid.\n    \"\"\"\n    if product_id == \"SWX1\":\n        # In a real system, database operations would occur here\n        return True\n    return False", "user_query": "What is the current inventory alert status for SmartWatch X1?", "checklist": {"functions": ["get_inventory_alert"], "values": [{"discrepancy": -500, "expected_level": 1500, "actual_level": 1000}]}}
{"difficulty": "easy", "function_schema_python": "def analyze_schema_performance(database_name: str, time_period: str) -> dict:\n    \"\"\"Analyzes the performance metrics of the current database schema.\n\n    :param database_name: Name of the database to analyze\n    :param time_period: Time period for analysis (e.g., '24h', '7d', '30d')\n    :return: Dictionary containing performance metrics\n    :raises ValueError: If database_name is invalid or time_period format is incorrect\"\"\"\n    pass\ndef design_schema_enhancement(current_schema: dict, requirements: list) -> dict:\n    \"\"\"Designs an enhanced database schema based on current schema and new requirements.\n\n    :param current_schema: Dictionary containing current schema structure\n    :param requirements: List of new requirements to incorporate\n    :return: Dictionary containing the new schema design\n    :raises ValueError: If current_schema is invalid or requirements list is empty\"\"\"\n    pass\ndef estimate_data_volume(customer_count: int, retention_period: int) -> dict:\n    \"\"\"Estimates required storage and performance metrics for given customer data volume.\n\n    :param customer_count: Number of customers in the system\n    :param retention_period: Data retention period in months\n    :return: Dictionary containing volume estimates and recommendations\n    :raises ValueError: If parameters are out of valid ranges\"\"\"\n    pass\n", "function_schema_json": [{"name": "analyze_schema_performance", "description": "Analyzes the performance metrics of the current database schema.", "parameters": {"type": "object", "properties": {"database_name": {"type": "string", "description": "Name of the database to analyze"}, "time_period": {"type": "string", "description": "Time period for analysis (e.g., '24h', '7d', '30d')"}}, "required": ["database_name", "time_period"], "additionalProperties": false}}, {"name": "design_schema_enhancement", "description": "Designs an enhanced database schema based on current schema and new requirements.", "parameters": {"type": "object", "properties": {"current_schema": {"type": "object", "description": "Dictionary containing current schema structure"}, "requirements": {"type": "array", "description": "List of new requirements to incorporate"}}, "required": ["current_schema", "requirements"], "additionalProperties": false}}, {"name": "estimate_data_volume", "description": "Estimates required storage and performance metrics for given customer data volume.", "parameters": {"type": "object", "properties": {"customer_count": {"type": "integer", "description": "Number of customers in the system"}, "retention_period": {"type": "integer", "description": "Data retention period in months"}}, "required": ["customer_count", "retention_period"], "additionalProperties": false}}], "mock_functions": "def analyze_schema_performance(database_name: str, time_period: str) -> dict:\n    \"\"\"\n    Analyzes the performance metrics of the current database schema.\n    \n    :param database_name: Name of the database to analyze\n    :param time_period: Time period for analysis (e.g., '24h', '7d', '30d')\n    :return: Dictionary containing performance metrics\n    :raises ValueError: If database_name is invalid or time_period format is incorrect\n    \"\"\"\n    if not database_name or not time_period:\n        raise ValueError(\"Database name and time period must be provided\")\n    \n    if database_name == \"crm_prod\" and time_period in ['24h', '7d', '30d']:\n        return {\n            \"query_performance\": 85.5,\n            \"index_efficiency\": 92.0,\n            \"storage_utilization\": 78.3,\n            \"bottlenecks\": [\"customer_transaction_history\", \"feedback_surveys\"]\n        }\n    raise ValueError(\"Invalid database name or time period\")\ndef design_schema_enhancement(current_schema: dict, requirements: list) -> dict:\n    \"\"\"\n    Designs an enhanced database schema based on current schema and new requirements.\n    \n    :param current_schema: Dictionary containing current schema structure\n    :param requirements: List of new requirements to incorporate\n    :return: Dictionary containing the new schema design\n    :raises ValueError: If current_schema is invalid or requirements list is empty\n    \"\"\"\n    if not current_schema or not requirements:\n        raise ValueError(\"Current schema and requirements must be provided\")\n    \n    valid_requirements = [\"real-time analytics\", \"customer feedback\", \"transaction history\"]\n    if all(req in valid_requirements for req in requirements):\n        return {\n            \"tables\": [\"customers\", \"transactions\", \"feedback\", \"analytics\"],\n            \"relationships\": [\"customer_transactions\", \"customer_feedback\"],\n            \"indexes\": [\"customer_id_idx\", \"transaction_date_idx\"],\n            \"partitioning_strategy\": \"time-based\"\n        }\n    raise ValueError(\"Invalid requirements provided\")\ndef estimate_data_volume(customer_count: int, retention_period: int) -> dict:\n    \"\"\"\n    Estimates required storage and performance metrics for given customer data volume.\n    \n    :param customer_count: Number of customers in the system\n    :param retention_period: Data retention period in months\n    :return: Dictionary containing volume estimates and recommendations\n    :raises ValueError: If parameters are out of valid ranges\n    \"\"\"\n    if not (1000 <= customer_count <= 1000000) or not (1 <= retention_period <= 84):\n        raise ValueError(\"Invalid customer count or retention period\")\n    \n    return {\n        \"storage_required_gb\": customer_count * retention_period * 0.05,\n        \"estimated_query_time_ms\": 100 + (customer_count * 0.001),\n        \"recommended_partitions\": max(1, customer_count // 100000),\n        \"backup_storage_gb\": (customer_count * retention_period * 0.05) * 1.5\n    }", "user_query": "Analyze the performance of the `crm_prod` database over the last 24 hours.", "checklist": {"functions": ["analyze_schema_performance"], "values": [{"query_performance": 85.5, "index_efficiency": 92.0, "storage_utilization": 78.3, "bottlenecks": ["customer_transaction_history", "feedback_surveys"]}]}}
{"difficulty": "easy", "function_schema_python": "def design_crm_schema(entities: list, focus_areas: list) -> dict:\n    \"\"\"Designs a CRM schema based on a list of entities and focus areas.\n\n    :param entities: A list of entities involved in the CRM system.\n    :param focus_areas: A list of focus areas such as marketing campaigns and customer segmentation.\n    :return: A dictionary representing the CRM schema design.\n    :raises ValueError: If entities or focus_areas is empty.\"\"\"\n    pass\ndef integrate_social_media_data(source: str, data_type: str) -> dict:\n    \"\"\"Integrates social media data into the CRM system.\n\n    :param source: The source of the social media data (e.g., \"Twitter\").\n    :param data_type: The type of data to integrate (e.g., \"posts\", \"followers\").\n    :return: A dictionary representing the integrated data.\n    :raises ValueError: If source or data_type is empty.\"\"\"\n    pass\ndef fetch_market_trends(region: str, period: str) -> dict:\n    \"\"\"Fetches third-party market trends data.\n\n    :param region: The region for which to fetch trends (e.g., \"North America\").\n    :param period: The period for which to fetch trends (e.g., \"Q1 2023\").\n    :return: A dictionary representing the market trends data.\n    :raises ValueError: If region or period is empty.\"\"\"\n    pass\ndef optimize_data_retrieval(query: str, data_source: str) -> dict:\n    \"\"\"Optimizes data retrieval for reporting and personalized customer experiences.\n\n    :param query: The query string for data retrieval (e.g., \"customer purchase patterns\").\n    :param data_source: The data source to query (e.g., \"CRM database\").\n    :return: A dictionary representing the optimized data retrieval result.\n    :raises ValueError: If query or data_source is empty.\"\"\"\n    pass\ndef update_customer_engagement(customer_id: int, interaction_type: str) -> bool:\n    \"\"\"Updates the engagement level of a customer in the CRM system.\n\n    :param customer_id: The ID of the customer.\n    :param interaction_type: The type of interaction (e.g., \"email\", \"phone call\").\n    :return: True if the engagement level was successfully updated, False otherwise.\n    :raises ValueError: If customer_id or interaction_type is invalid.\"\"\"\n    pass\n", "function_schema_json": [{"name": "design_crm_schema", "description": "Designs a CRM schema based on a list of entities and focus areas.", "parameters": {"type": "object", "properties": {"entities": {"type": "array", "description": "A list of entities involved in the CRM system."}, "focus_areas": {"type": "array", "description": "A list of focus areas such as marketing campaigns and customer segmentation."}}, "required": ["entities", "focus_areas"], "additionalProperties": false}}, {"name": "integrate_social_media_data", "description": "Integrates social media data into the CRM system.", "parameters": {"type": "object", "properties": {"source": {"type": "string", "description": "The source of the social media data (e.g., \"Twitter\")."}, "data_type": {"type": "string", "description": "The type of data to integrate (e.g., \"posts\", \"followers\")."}}, "required": ["source", "data_type"], "additionalProperties": false}}, {"name": "fetch_market_trends", "description": "Fetches third-party market trends data.", "parameters": {"type": "object", "properties": {"region": {"type": "string", "description": "The region for which to fetch trends (e.g., \"North America\")."}, "period": {"type": "string", "description": "The period for which to fetch trends (e.g., \"Q1 2023\")."}}, "required": ["region", "period"], "additionalProperties": false}}, {"name": "optimize_data_retrieval", "description": "Optimizes data retrieval for reporting and personalized customer experiences.", "parameters": {"type": "object", "properties": {"query": {"type": "string", "description": "The query string for data retrieval (e.g., \"customer purchase patterns\")."}, "data_source": {"type": "string", "description": "The data source to query (e.g., \"CRM database\")."}}, "required": ["query", "data_source"], "additionalProperties": false}}, {"name": "update_customer_engagement", "description": "Updates the engagement level of a customer in the CRM system.", "parameters": {"type": "object", "properties": {"customer_id": {"type": "integer", "description": "The ID of the customer."}, "interaction_type": {"type": "string", "description": "The type of interaction (e.g., \"email\", \"phone call\")."}}, "required": ["customer_id", "interaction_type"], "additionalProperties": false}}], "mock_functions": "def design_crm_schema(entities: list, focus_areas: list) -> dict:\n    \"\"\"\n    Designs a CRM schema based on a list of entities and focus areas.\n    \n    :param entities: A list of entities involved in the CRM system.\n    :param focus_areas: A list of focus areas such as marketing campaigns and customer segmentation.\n    :return: A dictionary representing the CRM schema design.\n    :raises ValueError: If entities or focus_areas is empty.\n    \"\"\"\n    if not entities or not focus_areas:\n        raise ValueError(\"Entities and focus areas must be provided.\")\n    \n    # Mock logic: Return a basic schema design for demonstration\n    if entities and focus_areas:\n        schema = {\n            \"entities\": entities,\n            \"focus_areas\": focus_areas,\n            \"tables\": {\n                \"customers\": [\"customer_id\", \"name\", \"email\", \"purchase_history\", \"preferences\"],\n                \"campaigns\": [\"campaign_id\", \"name\", \"target_segment\", \"metrics\"],\n                \"engagement\": [\"engagement_id\", \"customer_id\", \"interaction_type\", \"timestamp\"]\n            }\n        }\n        return schema\n    return {}\ndef integrate_social_media_data(source: str, data_type: str) -> dict:\n    \"\"\"\n    Integrates social media data into the CRM system.\n    \n    :param source: The source of the social media data (e.g., \"Twitter\").\n    :param data_type: The type of data to integrate (e.g., \"posts\", \"followers\").\n    :return: A dictionary representing the integrated data.\n    :raises ValueError: If source or data_type is empty.\n    \"\"\"\n    if not source or not data_type:\n        raise ValueError(\"Source and data type must be provided.\")\n    \n    # Mock logic: Return a basic integration result for demonstration\n    if source and data_type:\n        integrated_data = {\n            \"source\": source,\n            \"data_type\": data_type,\n            \"data_samples\": [\n                {\"id\": 1, \"content\": \"Sample post from \" + source},\n                {\"id\": 2, \"content\": \"Another sample post from \" + source}\n            ]\n        }\n        return integrated_data\n    return {}\ndef fetch_market_trends(region: str, period: str) -> dict:\n    \"\"\"\n    Fetches third-party market trends data.\n    \n    :param region: The region for which to fetch trends (e.g., \"North America\").\n    :param period: The period for which to fetch trends (e.g., \"Q1 2023\").\n    :return: A dictionary representing the market trends data.\n    :raises ValueError: If region or period is empty.\n    \"\"\"\n    if not region or not period:\n        raise ValueError(\"Region and period must be provided.\")\n    \n    # Mock logic: Return a basic market trends data for demonstration\n    if region and period:\n        trends_data = {\n            \"region\": region,\n            \"period\": period,\n            \"trends\": [\n                {\"topic\": \"E-commerce\", \"growth\": \"10%\"},\n                {\"topic\": \"Sustainability\", \"growth\": \"8%\"}\n            ]\n        }\n        return trends_data\n    return {}\ndef optimize_data_retrieval(query: str, data_source: str) -> dict:\n    \"\"\"\n    Optimizes data retrieval for reporting and personalized customer experiences.\n    \n    :param query: The query string for data retrieval (e.g., \"customer purchase patterns\").\n    :param data_source: The data source to query (e.g., \"CRM database\").\n    :return: A dictionary representing the optimized data retrieval result.\n    :raises ValueError: If query or data_source is empty.\n    \"\"\"\n    if not query or not data_source:\n        raise ValueError(\"Query and data source must be provided.\")\n    \n    # Mock logic: Return a basic optimized data retrieval result for demonstration\n    if query and data_source:\n        retrieval_result = {\n            \"query\": query,\n            \"data_source\": data_source,\n            \"results\": [\n                {\"customer_id\": 1, \"pattern\": \"Frequency buyer\"},\n                {\"customer_id\": 2, \"pattern\": \"Occasional buyer\"}\n            ]\n        }\n        return retrieval_result\n    return {}\ndef update_customer_engagement(customer_id: int, interaction_type: str) -> bool:\n    \"\"\"\n    Updates the engagement level of a customer in the CRM system.\n    \n    :param customer_id: The ID of the customer.\n    :param interaction_type: The type of interaction (e.g., \"email\", \"phone call\").\n    :return: True if the engagement level was successfully updated, False otherwise.\n    :raises ValueError: If customer_id or interaction_type is invalid.\n    \"\"\"\n    if not isinstance(customer_id, int) or not interaction_type:\n        raise ValueError(\"Customer ID must be an integer and interaction type must be provided.\")\n    \n    # Mock logic: Simulate a successful update\n    if isinstance(customer_id, int) and interaction_type:\n        return True\n    return False", "user_query": "Can you design a CRM schema with entities [\"customers\", \"products\", \"campaigns\"] and focus areas [\"marketing\", \"customer_segmentation\"]?", "checklist": {"functions": ["design_crm_schema"], "values": [{"entities": ["customers", "products", "campaigns"], "focus_areas": ["marketing", "customer_segmentation"], "tables": {"customers": ["customer_id", "name", "email", "purchase_history", "preferences"], "campaigns": ["campaign_id", "name", "target_segment", "metrics"], "engagement": ["engagement_id", "customer_id", "interaction_type", "timestamp"]}}]}}
{"difficulty": "easy", "function_schema_python": "def check_memory_utilization(server_names: list) -> dict:\n    \"\"\"Checks the memory utilization for a list of servers.\n\n    :param server_names: List of server names to check memory utilization for.\n    :return:\n        dict: A dictionary with server names as keys and their memory utilization percentages as values.\n        Keys:\n            - server_name (str): Memory utilization percentage (int).\n    :raises ValueError: If no server names are provided.\"\"\"\n    pass\ndef get_response_times(server_names: list) -> dict:\n    \"\"\"Retrieves the response times for a list of servers.\n\n    :param server_names: List of server names to check response times for.\n    :return:\n        dict: A dictionary with server names as keys and their response times in milliseconds as values.\n        Keys:\n            - server_name (str): Response time in milliseconds (float).\n    :raises ValueError: If no server names are provided.\"\"\"\n    pass\ndef fetch_recent_deployment_logs(service_name: str, version: str) -> list:\n    \"\"\"Fetches recent deployment logs for a specific service and version.\n\n    :param service_name: The name of the service to fetch logs for.\n    :param version: The version of the service to fetch logs for.\n    :return:\n        list: A list of log entries for the specified service and version.\n        Each log entry is a string.\n    :raises ValueError: If service_name or version is empty.\"\"\"\n    pass\ndef analyze_system_metrics(server_names: list) -> dict:\n    \"\"\"Analyzes system metrics for a list of servers to determine if the current spike is related to a recent change.\n\n    :param server_names: List of server names to analyze.\n    :return:\n        dict: A dictionary with server names as keys and analysis results as values.\n        Keys:\n            - server_name (str): Analysis result (str).\n    :raises ValueError: If no server names are provided.\"\"\"\n    pass\n", "function_schema_json": [{"name": "check_memory_utilization", "description": "Checks the memory utilization for a list of servers.", "parameters": {"type": "object", "properties": {"server_names": {"type": "array", "description": "List of server names to check memory utilization for."}}, "required": ["server_names"], "additionalProperties": false}}, {"name": "get_response_times", "description": "Retrieves the response times for a list of servers.", "parameters": {"type": "object", "properties": {"server_names": {"type": "array", "description": "List of server names to check response times for."}}, "required": ["server_names"], "additionalProperties": false}}, {"name": "fetch_recent_deployment_logs", "description": "Fetches recent deployment logs for a specific service and version.", "parameters": {"type": "object", "properties": {"service_name": {"type": "string", "description": "The name of the service to fetch logs for."}, "version": {"type": "string", "description": "The version of the service to fetch logs for."}}, "required": ["service_name", "version"], "additionalProperties": false}}, {"name": "analyze_system_metrics", "description": "Analyzes system metrics for a list of servers to determine if the current spike is related to a recent change.", "parameters": {"type": "object", "properties": {"server_names": {"type": "array", "description": "List of server names to analyze."}}, "required": ["server_names"], "additionalProperties": false}}], "mock_functions": "def check_memory_utilization(server_names: list) -> dict:\n    \"\"\"\n    Checks the memory utilization for a list of servers.\n    \n    :param server_names: List of server names to check memory utilization for.\n    :return:\n        dict: A dictionary with server names as keys and their memory utilization percentages as values.\n        Keys:\n            - server_name (str): Memory utilization percentage (int).\n    :raises ValueError: If no server names are provided.\n    \"\"\"\n    if not server_names:\n        raise ValueError(\"Server names must be provided.\")\n    \n    # Mock logic: Simulate memory utilization for the specified servers.\n    memory_utilization = {\n        \"APP-101\": 92,\n        \"APP-102\": 92,\n        \"APP-103\": 92,\n        \"OTHER-SERVER\": 60  # Example of another server with normal utilization\n    }\n    \n    # Only return the memory utilization for the specified servers.\n    return {server: memory_utilization.get(server, 0) for server in server_names}\ndef get_response_times(server_names: list) -> dict:\n    \"\"\"\n    Retrieves the response times for a list of servers.\n    \n    :param server_names: List of server names to check response times for.\n    :return:\n        dict: A dictionary with server names as keys and their response times in milliseconds as values.\n        Keys:\n            - server_name (str): Response time in milliseconds (float).\n    :raises ValueError: If no server names are provided.\n    \"\"\"\n    if not server_names:\n        raise ValueError(\"Server names must be provided.\")\n    \n    # Mock logic: Simulate response times for the specified servers.\n    response_times = {\n        \"APP-101\": 1200.0,\n        \"APP-102\": 1250.0,\n        \"APP-103\": 1300.0,\n        \"OTHER-SERVER\": 200.0  # Example of another server with normal response times\n    }\n    \n    # Only return the response times for the specified servers.\n    return {server: response_times.get(server, 0.0) for server in server_names}\ndef fetch_recent_deployment_logs(service_name: str, version: str) -> list:\n    \"\"\"\n    Fetches recent deployment logs for a specific service and version.\n    \n    :param service_name: The name of the service to fetch logs for.\n    :param version: The version of the service to fetch logs for.\n    :return:\n        list: A list of log entries for the specified service and version.\n        Each log entry is a string.\n    :raises ValueError: If service_name or version is empty.\n    \"\"\"\n    if not service_name or not version:\n        raise ValueError(\"Service name and version must be provided.\")\n    \n    # Mock logic: Simulate logs for the specified service and version.\n    mock_logs = [\n        \"Deployed version 2.4.1 of the payment processing service.\",\n        \"Deployment process completed successfully.\",\n        \"No issues reported during deployment.\",\n        \"Rolling out version 2.4.1 to all primary application servers.\",\n        \"APP-101, APP-102, and APP-103 have been updated.\"\n    ]\n    \n    return mock_logs if service_name.lower() == \"payment processing service\" and version == \"2.4.1\" else []\ndef analyze_system_metrics(server_names: list) -> dict:\n    \"\"\"\n    Analyzes system metrics for a list of servers to determine if the current spike is related to a recent change.\n    \n    :param server_names: List of server names to analyze.\n    :return:\n        dict: A dictionary with server names as keys and analysis results as values.\n        Keys:\n            - server_name (str): Analysis result (str).\n    :raises ValueError: If no server names are provided.\n    \"\"\"\n    if not server_names:\n        raise ValueError(\"Server names must be provided.\")\n    \n    # Mock logic: Simulate analysis based on system metrics.\n    analysis_results = {\n        \"APP-101\": \"Memory spike detected. Related to recent deployment of version 2.4.1 of payment processing service.\",\n        \"APP-102\": \"Memory spike detected. Related to recent deployment of version 2.4.1 of payment processing service.\",\n        \"APP-103\": \"Memory spike detected. Related to recent deployment of version 2.4.1 of payment processing service.\",\n        \"OTHER-SERVER\": \"No significant changes detected.\"\n    }\n    \n    # Only return the analysis results for the specified servers.\n    return {server: analysis_results.get(server, \"No data available for this server.\") for server in server_names}", "user_query": "What is the current memory utilization for servers APP-101, APP-102, and APP-103?", "checklist": {"functions": ["check_memory_utilization"], "values": [{"APP-101": 92, "APP-102": 92, "APP-103": 92}]}}
{"difficulty": "easy", "function_schema_python": "def check_network_latency(data_center: str, load_balancer: str) -> dict:\n    \"\"\"Checks the network latency between a load balancer and the database cluster in a specific data center.\n\n    :param data_center: The data center identifier (e.g., \"DC-EAST\", \"DC-WEST\").\n    :param load_balancer: The load balancer identifier (e.g., \"LB-01\", \"LB-02\").\n    :return: A dictionary with the following keys:\n        - latency (int): The current network latency in milliseconds.\n        - normal_latency (int): The normal network latency in milliseconds.\n    :raises ValueError: If the data center or load balancer is invalid.\"\"\"\n    pass\ndef get_load_balancer_status(data_center: str, load_balancer: str) -> dict:\n    \"\"\"Retrieves the status of a load balancer in a specific data center.\n\n    :param data_center: The data center identifier (e.g., \"DC-EAST\", \"DC-WEST\").\n    :param load_balancer: The load balancer identifier (e.g., \"LB-01\", \"LB-02\").\n    :return: A dictionary with the following keys:\n        - status (str): The status of the load balancer (e.g., \"UP\", \"DOWN\").\n        - last_check_time (str): The last time the status was checked.\n    :raises ValueError: If the data center or load balancer is invalid.\"\"\"\n    pass\ndef check_database_cluster_health(data_center: str) -> dict:\n    \"\"\"Checks the health of the database cluster in a specific data center.\n\n    :param data_center: The data center identifier (e.g., \"DC-EAST\", \"DC-WEST\").\n    :return: A dictionary with the following keys:\n        - health (str): The health status of the database cluster (e.g., \"OK\", \"DEGRADED\").\n        - last_check_time (str): The last time the health was checked.\n    :raises ValueError: If the data center is invalid.\"\"\"\n    pass\ndef get_scheduled_maintenance_history(data_center: str) -> list:\n    \"\"\"Retrieves the scheduled maintenance history for network switches in a specific data center.\n\n    :param data_center: The data center identifier (e.g., \"DC-EAST\", \"DC-WEST\").\n    :return: A list of maintenance events with the following keys:\n        - event_time (str): The time of the scheduled maintenance.\n        - event_description (str): A description of the scheduled maintenance.\n        - affected_assets (list[str]): A list of assets affected by the maintenance.\n    :raises ValueError: If the data center is invalid.\"\"\"\n    pass\n", "function_schema_json": [{"name": "check_network_latency", "description": "Checks the network latency between a load balancer and the database cluster in a specific data center.", "parameters": {"type": "object", "properties": {"data_center": {"type": "string", "description": "The data center identifier (e.g., \"DC-EAST\", \"DC-WEST\")."}, "load_balancer": {"type": "string", "description": "The load balancer identifier (e.g., \"LB-01\", \"LB-02\")."}}, "required": ["data_center", "load_balancer"], "additionalProperties": false}}, {"name": "get_load_balancer_status", "description": "Retrieves the status of a load balancer in a specific data center.", "parameters": {"type": "object", "properties": {"data_center": {"type": "string", "description": "The data center identifier (e.g., \"DC-EAST\", \"DC-WEST\")."}, "load_balancer": {"type": "string", "description": "The load balancer identifier (e.g., \"LB-01\", \"LB-02\")."}}, "required": ["data_center", "load_balancer"], "additionalProperties": false}}, {"name": "check_database_cluster_health", "description": "Checks the health of the database cluster in a specific data center.", "parameters": {"type": "object", "properties": {"data_center": {"type": "string", "description": "The data center identifier (e.g., \"DC-EAST\", \"DC-WEST\")."}}, "required": ["data_center"], "additionalProperties": false}}, {"name": "get_scheduled_maintenance_history", "description": "Retrieves the scheduled maintenance history for network switches in a specific data center.", "parameters": {"type": "object", "properties": {"data_center": {"type": "string", "description": "The data center identifier (e.g., \"DC-EAST\", \"DC-WEST\")."}}, "required": ["data_center"], "additionalProperties": false}}], "mock_functions": "def check_network_latency(data_center: str, load_balancer: str) -> dict:\n    \"\"\"\n    Checks the network latency between a load balancer and the database cluster in a specific data center.\n    \n    :param data_center: The data center identifier (e.g., \"DC-EAST\", \"DC-WEST\").\n    :param load_balancer: The load balancer identifier (e.g., \"LB-01\", \"LB-02\").\n    :return: A dictionary with the following keys:\n        - latency (int): The current network latency in milliseconds.\n        - normal_latency (int): The normal network latency in milliseconds.\n    :raises ValueError: If the data center or load balancer is invalid.\n    \"\"\"\n    if data_center not in [\"DC-EAST\", \"DC-WEST\"]:\n        raise ValueError(\"Invalid data center identifier.\")\n    if load_balancer not in [\"LB-01\", \"LB-02\"]:\n        raise ValueError(\"Invalid load balancer identifier.\")\n    \n    # Mock logic: Simulate increased latency for load balancers after maintenance.\n    normal_latency = 5\n    if load_balancer in [\"LB-01\", \"LB-02\"]:\n        latency = 75\n    else:\n        latency = normal_latency\n    \n    return {\n        \"latency\": latency,\n        \"normal_latency\": normal_latency\n    }\ndef get_load_balancer_status(data_center: str, load_balancer: str) -> dict:\n    \"\"\"\n    Retrieves the status of a load balancer in a specific data center.\n    \n    :param data_center: The data center identifier (e.g., \"DC-EAST\", \"DC-WEST\").\n    :param load_balancer: The load balancer identifier (e.g., \"LB-01\", \"LB-02\").\n    :return: A dictionary with the following keys:\n        - status (str): The status of the load balancer (e.g., \"UP\", \"DOWN\").\n        - last_check_time (str): The last time the status was checked.\n    :raises ValueError: If the data center or load balancer is invalid.\n    \"\"\"\n    if data_center not in [\"DC-EAST\", \"DC-WEST\"]:\n        raise ValueError(\"Invalid data center identifier.\")\n    if load_balancer not in [\"LB-01\", \"LB-02\"]:\n        raise ValueError(\"Invalid load balancer identifier.\")\n    \n    # Mock logic: Simulate load balancer status.\n    if load_balancer in [\"LB-01\", \"LB-02\"]:\n        status = \"UP\"\n        last_check_time = \"2023-10-05 07:45:00 PST\"\n    else:\n        status = \"UNKNOWN\"\n        last_check_time = \"2023-10-05 07:45:00 PST\"\n    \n    return {\n        \"status\": status,\n        \"last_check_time\": last_check_time\n    }\ndef check_database_cluster_health(data_center: str) -> dict:\n    \"\"\"\n    Checks the health of the database cluster in a specific data center.\n    \n    :param data_center: The data center identifier (e.g., \"DC-EAST\", \"DC-WEST\").\n    :return: A dictionary with the following keys:\n        - health (str): The health status of the database cluster (e.g., \"OK\", \"DEGRADED\").\n        - last_check_time (str): The last time the health was checked.\n    :raises ValueError: If the data center is invalid.\n    \"\"\"\n    if data_center not in [\"DC-EAST\", \"DC-WEST\"]:\n        raise ValueError(\"Invalid data center identifier.\")\n    \n    # Mock logic: Simulate database cluster health.\n    health = \"OK\"\n    last_check_time = \"2023-10-05 07:45:00 PST\"\n    \n    return {\n        \"health\": health,\n        \"last_check_time\": last_check_time\n    }\ndef get_scheduled_maintenance_history(data_center: str) -> list:\n    \"\"\"\n    Retrieves the scheduled maintenance history for network switches in a specific data center.\n    \n    :param data_center: The data center identifier (e.g., \"DC-EAST\", \"DC-WEST\").\n    :return: A list of maintenance events with the following keys:\n        - event_time (str): The time of the scheduled maintenance.\n        - event_description (str): A description of the scheduled maintenance.\n        - affected_assets (list[str]): A list of assets affected by the maintenance.\n    :raises ValueError: If the data center is invalid.\n    \"\"\"\n    if data_center not in [\"DC-EAST\", \"DC-WEST\"]:\n        raise ValueError(\"Invalid data center identifier.\")\n    \n    # Mock logic: Simulate a maintenance history.\n    maintenance_history = [\n        {\n            \"event_time\": \"2023-10-05 03:45:00 PST\",\n            \"event_description\": \"Scheduled maintenance on network switches.\",\n            \"affected_assets\": [\"Switch-01\", \"Switch-02\", \"Switch-03\"]\n        },\n        {\n            \"event_time\": \"2023-09-27 03:45:00 PST\",\n            \"event_description\": \"Quarterly maintenance on network switches.\",\n            \"affected_assets\": [\"Switch-04\", \"Switch-05\", \"Switch-06\"]\n        }\n    ]\n    \n    return maintenance_history", "user_query": "What's the network latency between LB-01 and DB-CLUSTER-A in DC-EAST?", "checklist": {"functions": ["check_network_latency"], "values": [{"latency": 75, "normal_latency": 5}]}}
{"difficulty": "easy", "function_schema_python": "def load_transaction_data(file_path: str, start_date: str, end_date: str) -> dict:\n    \"\"\"Loads e-commerce transaction data from a specified source.\n\n    :param file_path: Path to the transaction data file\n    :param start_date: Start date for data filtering (YYYY-MM-DD)\n    :param end_date: End date for data filtering (YYYY-MM-DD)\n    :return: Dictionary containing transaction data with keys:\n        - purchase_amounts (list[float]): List of purchase amounts\n        - purchase_intervals (list[int]): List of days between purchases\n        - cs_interactions (list[int]): List of customer service interaction counts\n    :raises ValueError: If file path is invalid or dates are incorrectly formatted\"\"\"\n    pass\ndef normalize_features(data: dict, method: str) -> dict:\n    \"\"\"Normalizes the transaction features using specified method.\n\n    :param data: Dictionary containing transaction features\n    :param method: Normalization method ('minmax' or 'zscore')\n    :return: Dictionary containing normalized features with keys:\n        - normalized_amounts (list[float]): Normalized purchase amounts\n        - normalized_intervals (list[float]): Normalized purchase intervals\n        - normalized_cs (list[float]): Normalized customer service interactions\n    :raises ValueError: If invalid method or data format\"\"\"\n    pass\ndef calculate_behavior_metrics(normalized_data: dict) -> dict:\n    \"\"\"Calculates advanced behavioral metrics from normalized features.\n\n    :param normalized_data: Dictionary containing normalized transaction features\n    :return: Dictionary containing behavior metrics with keys:\n        - purchase_frequency_score (float): Score between 0-1\n        - spending_volatility (float): Volatility measure between 0-1\n        - cs_engagement_level (float): Engagement score between 0-1\n    :raises ValueError: If normalized data is invalid\"\"\"\n    pass\n", "function_schema_json": [{"name": "load_transaction_data", "description": "Loads e-commerce transaction data from a specified source.", "parameters": {"type": "object", "properties": {"file_path": {"type": "string", "description": "Path to the transaction data file"}, "start_date": {"type": "string", "description": "Start date for data filtering (YYYY-MM-DD)"}, "end_date": {"type": "string", "description": "End date for data filtering (YYYY-MM-DD)"}}, "required": ["file_path", "start_date", "end_date"], "additionalProperties": false}}, {"name": "normalize_features", "description": "Normalizes the transaction features using specified method.", "parameters": {"type": "object", "properties": {"data": {"type": "object", "description": "Dictionary containing transaction features"}, "method": {"type": "string", "description": "Normalization method ('minmax' or 'zscore')"}}, "required": ["data", "method"], "additionalProperties": false}}, {"name": "calculate_behavior_metrics", "description": "Calculates advanced behavioral metrics from normalized features.", "parameters": {"type": "object", "properties": {"normalized_data": {"type": "object", "description": "Dictionary containing normalized transaction features"}}, "required": ["normalized_data"], "additionalProperties": false}}], "mock_functions": "def load_transaction_data(file_path: str, start_date: str, end_date: str) -> dict:\n    \"\"\"\n    Loads e-commerce transaction data from a specified source.\n    \n    :param file_path: Path to the transaction data file\n    :param start_date: Start date for data filtering (YYYY-MM-DD)\n    :param end_date: End date for data filtering (YYYY-MM-DD)\n    :return: Dictionary containing transaction data with keys:\n        - purchase_amounts (list[float]): List of purchase amounts\n        - purchase_intervals (list[int]): List of days between purchases\n        - cs_interactions (list[int]): List of customer service interaction counts\n    :raises ValueError: If file path is invalid or dates are incorrectly formatted\n    \"\"\"\n    if not file_path.endswith('.csv') or not start_date or not end_date:\n        raise ValueError(\"Invalid file path or date format\")\n    \n    return {\n        \"purchase_amounts\": [250.0, 1200.0, 45.0, 3500.0],\n        \"purchase_intervals\": [15, 45, 120, 200],\n        \"cs_interactions\": [2, 5, 0, 12]\n    }\ndef normalize_features(data: dict, method: str = 'minmax') -> dict:\n    \"\"\"\n    Normalizes the transaction features using specified method.\n    \n    :param data: Dictionary containing transaction features\n    :param method: Normalization method ('minmax' or 'zscore')\n    :return: Dictionary containing normalized features with keys:\n        - normalized_amounts (list[float]): Normalized purchase amounts\n        - normalized_intervals (list[float]): Normalized purchase intervals\n        - normalized_cs (list[float]): Normalized customer service interactions\n    :raises ValueError: If invalid method or data format\n    \"\"\"\n    if method not in ['minmax', 'zscore']:\n        raise ValueError(\"Invalid normalization method\")\n    \n    return {\n        \"normalized_amounts\": [0.15, 0.45, 0.02, 1.0],\n        \"normalized_intervals\": [0.1, 0.3, 0.8, 1.0],\n        \"normalized_cs\": [0.2, 0.4, 0.0, 0.8]\n    }\ndef calculate_behavior_metrics(normalized_data: dict) -> dict:\n    \"\"\"\n    Calculates advanced behavioral metrics from normalized features.\n    \n    :param normalized_data: Dictionary containing normalized transaction features\n    :return: Dictionary containing behavior metrics with keys:\n        - purchase_frequency_score (float): Score between 0-1\n        - spending_volatility (float): Volatility measure between 0-1\n        - cs_engagement_level (float): Engagement score between 0-1\n    :raises ValueError: If normalized data is invalid\n    \"\"\"\n    if not all(key in normalized_data for key in ['normalized_amounts', 'normalized_intervals', 'normalized_cs']):\n        raise ValueError(\"Missing required normalized features\")\n    \n    return {\n        \"purchase_frequency_score\": 0.75,\n        \"spending_volatility\": 0.45,\n        \"cs_engagement_level\": 0.32\n    }", "user_query": "Can you load the transaction data from 'data/shopwise_transactions.csv' for the period from 2023-01-01 to 2023-12-31?", "checklist": {"functions": ["load_transaction_data"], "values": [{"purchase_amounts": [250.0, 1200.0, 45.0, 3500.0], "purchase_intervals": [15, 45, 120, 200], "cs_interactions": [2, 5, 0, 12]}]}}
{"difficulty": "easy", "function_schema_python": "def initialize_cart(user_id: str, items: list) -> dict:\n    \"\"\"Initializes the shopping cart with the specified items for the given user.\n\n    :param user_id: The unique identifier for the user.\n    :param items: A list of item names to be added to the cart.\n    :return: A dictionary representing the cart with user_id and items.\n    :raises ValueError: If user_id is empty or items is not a list.\"\"\"\n    pass\ndef proceed_to_checkout(cart: dict) -> bool:\n    \"\"\"Simulates the process of proceeding to checkout with the given cart.\n\n    :param cart: A dictionary representing the cart with user_id and items.\n    :return: True if checkout was successful, False otherwise.\n    :raises ValueError: If cart is invalid.\"\"\"\n    pass\ndef select_payment_method(payment_method: str) -> str:\n    \"\"\"Selects the payment method for the checkout process.\n\n    :param payment_method: The name of the payment method (e.g., 'stripe', 'klarna').\n    :return: A confirmation message indicating the selected payment method.\n    :raises ValueError: If payment_method is not supported.\"\"\"\n    pass\ndef verify_payment_security(payment_method: str) -> bool:\n    \"\"\"Verifies the security of the selected payment method.\n\n    :param payment_method: The name of the payment method.\n    :return: True if the payment method is secure, False otherwise.\n    :raises ValueError: If payment_method is not supported.\"\"\"\n    pass\ndef finalize_purchase(payment_details: dict) -> dict:\n    \"\"\"Finalizes the purchase with the given payment details.\n\n    :param payment_details: A dictionary containing payment information.\n    :return:\n        dict: A dictionary with the following keys:\n            - message (str): A confirmation message.\n            - order_id (str): The unique identifier for the order.\n    :raises ValueError: If payment_details are invalid.\"\"\"\n    pass\n", "function_schema_json": [{"name": "initialize_cart", "description": "Initializes the shopping cart with the specified items for the given user.", "parameters": {"type": "object", "properties": {"user_id": {"type": "string", "description": "The unique identifier for the user."}, "items": {"type": "array", "description": "A list of item names to be added to the cart."}}, "required": ["user_id", "items"], "additionalProperties": false}}, {"name": "proceed_to_checkout", "description": "Simulates the process of proceeding to checkout with the given cart.", "parameters": {"type": "object", "properties": {"cart": {"type": "object", "description": "A dictionary representing the cart with user_id and items."}}, "required": ["cart"], "additionalProperties": false}}, {"name": "select_payment_method", "description": "Selects the payment method for the checkout process.", "parameters": {"type": "object", "properties": {"payment_method": {"type": "string", "description": "The name of the payment method (e.g., 'stripe', 'klarna')."}}, "required": ["payment_method"], "additionalProperties": false}}, {"name": "verify_payment_security", "description": "Verifies the security of the selected payment method.", "parameters": {"type": "object", "properties": {"payment_method": {"type": "string", "description": "The name of the payment method."}}, "required": ["payment_method"], "additionalProperties": false}}, {"name": "finalize_purchase", "description": "Finalizes the purchase with the given payment details.", "parameters": {"type": "object", "properties": {"payment_details": {"type": "object", "description": "A dictionary containing payment information."}}, "required": ["payment_details"], "additionalProperties": false}}], "mock_functions": "def initialize_cart(user_id: str, items: list) -> dict:\n    \"\"\"\n    Initializes the shopping cart with the specified items for the given user.\n\n    :param user_id: The unique identifier for the user.\n    :param items: A list of item names to be added to the cart.\n    :return: A dictionary representing the cart with user_id and items.\n    :raises ValueError: If user_id is empty or items is not a list.\n    \"\"\"\n    if not user_id or not isinstance(items, list):\n        raise ValueError(\"User ID must not be empty and items must be a list.\")\n    return {\n        \"user_id\": user_id,\n        \"items\": items\n    }\ndef proceed_to_checkout(cart: dict) -> bool:\n    \"\"\"\n    Simulates the process of proceeding to checkout with the given cart.\n\n    :param cart: A dictionary representing the cart with user_id and items.\n    :return: True if checkout was successful, False otherwise.\n    :raises ValueError: If cart is invalid.\n    \"\"\"\n    if not cart or \"user_id\" not in cart or \"items\" not in cart:\n        raise ValueError(\"Invalid cart provided.\")\n    return True\ndef select_payment_method(payment_method: str) -> str:\n    \"\"\"\n    Selects the payment method for the checkout process.\n\n    :param payment_method: The name of the payment method (e.g., 'stripe', 'klarna').\n    :return: A confirmation message indicating the selected payment method.\n    :raises ValueError: If payment_method is not supported.\n    \"\"\"\n    supported_methods = {'stripe', 'klarna', 'paypal-sdk', 'openbanking', 'plaid'}\n    if payment_method.lower() not in supported_methods:\n        raise ValueError(\"Unsupported payment method.\")\n    return f\"Payment method '{payment_method}' selected.\"\ndef verify_payment_security(payment_method: str) -> bool:\n    \"\"\"\n    Verifies the security of the selected payment method.\n\n    :param payment_method: The name of the payment method.\n    :return: True if the payment method is secure, False otherwise.\n    :raises ValueError: If payment_method is not supported.\n    \"\"\"\n    secure_methods = {'stripe', 'klarna', 'paypal-sdk', 'openbanking', 'plaid'}\n    if payment_method.lower() not in secure_methods:\n        raise ValueError(\"Unsupported payment method.\")\n    return True\ndef finalize_purchase(payment_details: dict) -> dict:\n    \"\"\"\n    Finalizes the purchase with the given payment details.\n\n    :param payment_details: A dictionary containing payment information.\n    :return:\n        dict: A dictionary with the following keys:\n            - message (str): A confirmation message.\n            - order_id (str): The unique identifier for the order.\n    :raises ValueError: If payment_details are invalid.\n    \"\"\"\n    required_keys = {'card_number', 'expiry_date', 'cvv'}\n    if not payment_details or not required_keys.issubset(payment_details.keys()):\n        raise ValueError(\"Invalid payment details provided.\")\n    return {\n        \"message\": \"Payment processed successfully.\",\n        \"order_id\": \"ORD123456789\"\n    }", "user_query": "Could you please initialize my cart with items named \"wireless earphone\" and \"smartwatch\" for user ID \"USER_SARAH01\"?", "checklist": {"functions": ["initialize_cart"], "values": [{"user_id": "USER_SARAH01", "items": ["wireless earphone", "smartwatch"]}]}}
{"difficulty": "easy", "function_schema_python": "def verify_payment_gateway_integrity(shop_name: str, payment_gateway: str) -> bool:\n    \"\"\"Verifies the integrity of the payment gateway used by a given shop.\n\n    :param shop_name: The name of the shop (e.g., \"BookLovers Paradise\").\n    :param payment_gateway: The name of the payment gateway (e.g., \"stripe\", \"klarna\").\n    :return: True if the payment gateway is reliable, False otherwise.\n    :raises ValueError: If shop_name or payment_gateway is invalid.\"\"\"\n    pass\ndef get_supported_payment_methods(shop_name: str) -> list:\n    \"\"\"Retrieves the list of supported payment methods for a given shop.\n\n    :param shop_name: The name of the shop (e.g., \"BookLovers Paradise\").\n    :return: A list of supported payment methods (e.g., [\"credit card\", \"debit card\", \"paypal\"]).\n    :raises ValueError: If shop_name is invalid.\"\"\"\n    pass\ndef guide_checkout_process(user_name: str, shop_name: str, items_in_cart: list) -> dict:\n    \"\"\"Guides the checkout process for a user at a given shop.\n\n    :param user_name: The name of the user (e.g., \"Michael\").\n    :param shop_name: The name of the shop (e.g., \"BookLovers Paradise\").\n    :param items_in_cart: A list of items in the user's cart (e.g., [\"Novel1\", \"Novel2\"]).\n    :return:\n        dict: A dictionary with the following keys:\n            - user: The name of the user.\n            - shop: The name of the shop.\n            - items: The list of items in the cart.\n            - payment_options: The list of supported payment methods.\n    :raises ValueError: If user_name, shop_name, or items_in_cart is invalid.\"\"\"\n    pass\n", "function_schema_json": [{"name": "verify_payment_gateway_integrity", "description": "Verifies the integrity of the payment gateway used by a given shop.", "parameters": {"type": "object", "properties": {"shop_name": {"type": "string", "description": "The name of the shop (e.g., \"BookLovers Paradise\")."}, "payment_gateway": {"type": "string", "description": "The name of the payment gateway (e.g., \"stripe\", \"klarna\")."}}, "required": ["shop_name", "payment_gateway"], "additionalProperties": false}}, {"name": "get_supported_payment_methods", "description": "Retrieves the list of supported payment methods for a given shop.", "parameters": {"type": "object", "properties": {"shop_name": {"type": "string", "description": "The name of the shop (e.g., \"BookLovers Paradise\")."}}, "required": ["shop_name"], "additionalProperties": false}}, {"name": "guide_checkout_process", "description": "Guides the checkout process for a user at a given shop.", "parameters": {"type": "object", "properties": {"user_name": {"type": "string", "description": "The name of the user (e.g., \"Michael\")."}, "shop_name": {"type": "string", "description": "The name of the shop (e.g., \"BookLovers Paradise\")."}, "items_in_cart": {"type": "array", "description": "A list of items in the user's cart (e.g., [\"Novel1\", \"Novel2\"])."}}, "required": ["user_name", "shop_name", "items_in_cart"], "additionalProperties": false}}], "mock_functions": "def verify_payment_gateway_integrity(shop_name: str, payment_gateway: str) -> bool:\n    \"\"\"\n    Verifies the integrity of the payment gateway used by a given shop.\n    \n    :param shop_name: The name of the shop (e.g., \"BookLovers Paradise\").\n    :param payment_gateway: The name of the payment gateway (e.g., \"stripe\", \"klarna\").\n    :return: True if the payment gateway is reliable, False otherwise.\n    :raises ValueError: If shop_name or payment_gateway is invalid.\n    \"\"\"\n    if not shop_name or not payment_gateway:\n        raise ValueError(\"Shop name and payment gateway must be provided.\")\n    \n    # Mock logic: Only \"stripe\", \"klarna\", and \"paypal-sdk\" are considered reliable payment gateways.\n    reliable_gateways = {\"stripe\", \"klarna\", \"paypal-sdk\"}\n    if shop_name.lower() == \"booklovers paradise\" and payment_gateway.lower() in reliable_gateways:\n        return True\n    return False\ndef get_supported_payment_methods(shop_name: str) -> list:\n    \"\"\"\n    Retrieves the list of supported payment methods for a given shop.\n    \n    :param shop_name: The name of the shop (e.g., \"BookLovers Paradise\").\n    :return: A list of supported payment methods (e.g., [\"credit card\", \"debit card\", \"paypal\"]).\n    :raises ValueError: If shop_name is invalid.\n    \"\"\"\n    if not shop_name:\n        raise ValueError(\"Shop name must be provided.\")\n    \n    # Mock logic: \"BookLovers Paradise\" supports several payment methods via \"stripe\", \"klarna\", and \"paypal-sdk\".\n    if shop_name.lower() == \"booklovers paradise\":\n        return [\"credit card\", \"debit card\", \"paypal\", \"apple pay\", \"google pay\"]\n    return []\ndef guide_checkout_process(user_name: str, shop_name: str, items_in_cart: list) -> dict:\n    \"\"\"\n    Guides the checkout process for a user at a given shop.\n    \n    :param user_name: The name of the user (e.g., \"Michael\").\n    :param shop_name: The name of the shop (e.g., \"BookLovers Paradise\").\n    :param items_in_cart: A list of items in the user's cart (e.g., [\"Novel1\", \"Novel2\"]).\n    :return:\n        dict: A dictionary with the following keys:\n            - user: The name of the user.\n            - shop: The name of the shop.\n            - items: The list of items in the cart.\n            - payment_options: The list of supported payment methods.\n    :raises ValueError: If user_name, shop_name, or items_in_cart is invalid.\n    \"\"\"\n    if not user_name or not shop_name or not items_in_cart:\n        raise ValueError(\"User name, shop name, and items in cart must be provided.\")\n    \n    # Mock logic: Guide checkout process for \"Michael\" at \"BookLovers Paradise\".\n    if user_name.lower() == \"michael\" and shop_name.lower() == \"booklovers paradise\":\n        return {\n            \"user\": user_name,\n            \"shop\": shop_name,\n            \"items\": items_in_cart,\n            \"payment_options\": get_supported_payment_methods(shop_name)\n        }\n    return {}\n", "user_query": "What payment methods are supported at BookLovers Paradise?", "checklist": {"functions": ["get_supported_payment_methods"], "values": [["credit card", "debit card", "paypal", "apple pay", "google pay"]]}}
{"difficulty": "easy", "function_schema_python": "def verify_payment_gateway_integrity(shop_name: str, payment_gateway: str) -> bool:\n    \"\"\"Verifies the integrity of the payment gateway used by a given shop.\n\n    :param shop_name: The name of the shop (e.g., \"BookLovers Paradise\").\n    :param payment_gateway: The name of the payment gateway (e.g., \"stripe\", \"klarna\").\n    :return: True if the payment gateway is reliable, False otherwise.\n    :raises ValueError: If shop_name or payment_gateway is invalid.\"\"\"\n    pass\ndef get_supported_payment_methods(shop_name: str) -> list:\n    \"\"\"Retrieves the list of supported payment methods for a given shop.\n\n    :param shop_name: The name of the shop (e.g., \"BookLovers Paradise\").\n    :return: A list of supported payment methods (e.g., [\"credit card\", \"debit card\", \"paypal\"]).\n    :raises ValueError: If shop_name is invalid.\"\"\"\n    pass\ndef guide_checkout_process(user_name: str, shop_name: str, items_in_cart: list) -> dict:\n    \"\"\"Guides the checkout process for a user at a given shop.\n\n    :param user_name: The name of the user (e.g., \"Michael\").\n    :param shop_name: The name of the shop (e.g., \"BookLovers Paradise\").\n    :param items_in_cart: A list of items in the user's cart (e.g., [\"Novel1\", \"Novel2\"]).\n    :return:\n        dict: A dictionary with the following keys:\n            - user: The name of the user.\n            - shop: The name of the shop.\n            - items: The list of items in the cart.\n            - payment_options: The list of supported payment methods.\n    :raises ValueError: If user_name, shop_name, or items_in_cart is invalid.\"\"\"\n    pass\n", "function_schema_json": [{"name": "verify_payment_gateway_integrity", "description": "Verifies the integrity of the payment gateway used by a given shop.", "parameters": {"type": "object", "properties": {"shop_name": {"type": "string", "description": "The name of the shop (e.g., \"BookLovers Paradise\")."}, "payment_gateway": {"type": "string", "description": "The name of the payment gateway (e.g., \"stripe\", \"klarna\")."}}, "required": ["shop_name", "payment_gateway"], "additionalProperties": false}}, {"name": "get_supported_payment_methods", "description": "Retrieves the list of supported payment methods for a given shop.", "parameters": {"type": "object", "properties": {"shop_name": {"type": "string", "description": "The name of the shop (e.g., \"BookLovers Paradise\")."}}, "required": ["shop_name"], "additionalProperties": false}}, {"name": "guide_checkout_process", "description": "Guides the checkout process for a user at a given shop.", "parameters": {"type": "object", "properties": {"user_name": {"type": "string", "description": "The name of the user (e.g., \"Michael\")."}, "shop_name": {"type": "string", "description": "The name of the shop (e.g., \"BookLovers Paradise\")."}, "items_in_cart": {"type": "array", "description": "A list of items in the user's cart (e.g., [\"Novel1\", \"Novel2\"])."}}, "required": ["user_name", "shop_name", "items_in_cart"], "additionalProperties": false}}], "mock_functions": "def verify_payment_gateway_integrity(shop_name: str, payment_gateway: str) -> bool:\n    \"\"\"\n    Verifies the integrity of the payment gateway used by a given shop.\n    \n    :param shop_name: The name of the shop (e.g., \"BookLovers Paradise\").\n    :param payment_gateway: The name of the payment gateway (e.g., \"stripe\", \"klarna\").\n    :return: True if the payment gateway is reliable, False otherwise.\n    :raises ValueError: If shop_name or payment_gateway is invalid.\n    \"\"\"\n    if not shop_name or not payment_gateway:\n        raise ValueError(\"Shop name and payment gateway must be provided.\")\n    \n    # Mock logic: Only \"stripe\", \"klarna\", and \"paypal-sdk\" are considered reliable payment gateways.\n    reliable_gateways = {\"stripe\", \"klarna\", \"paypal-sdk\"}\n    if shop_name.lower() == \"booklovers paradise\" and payment_gateway.lower() in reliable_gateways:\n        return True\n    return False\ndef get_supported_payment_methods(shop_name: str) -> list:\n    \"\"\"\n    Retrieves the list of supported payment methods for a given shop.\n    \n    :param shop_name: The name of the shop (e.g., \"BookLovers Paradise\").\n    :return: A list of supported payment methods (e.g., [\"credit card\", \"debit card\", \"paypal\"]).\n    :raises ValueError: If shop_name is invalid.\n    \"\"\"\n    if not shop_name:\n        raise ValueError(\"Shop name must be provided.\")\n    \n    # Mock logic: \"BookLovers Paradise\" supports several payment methods via \"stripe\", \"klarna\", and \"paypal-sdk\".\n    if shop_name.lower() == \"booklovers paradise\":\n        return [\"credit card\", \"debit card\", \"paypal\", \"apple pay\", \"google pay\"]\n    return []\ndef guide_checkout_process(user_name: str, shop_name: str, items_in_cart: list) -> dict:\n    \"\"\"\n    Guides the checkout process for a user at a given shop.\n    \n    :param user_name: The name of the user (e.g., \"Michael\").\n    :param shop_name: The name of the shop (e.g., \"BookLovers Paradise\").\n    :param items_in_cart: A list of items in the user's cart (e.g., [\"Novel1\", \"Novel2\"]).\n    :return:\n        dict: A dictionary with the following keys:\n            - user: The name of the user.\n            - shop: The name of the shop.\n            - items: The list of items in the cart.\n            - payment_options: The list of supported payment methods.\n    :raises ValueError: If user_name, shop_name, or items_in_cart is invalid.\n    \"\"\"\n    if not user_name or not shop_name or not items_in_cart:\n        raise ValueError(\"User name, shop name, and items in cart must be provided.\")\n    \n    # Mock logic: Guide checkout process for \"Michael\" at \"BookLovers Paradise\".\n    if user_name.lower() == \"michael\" and shop_name.lower() == \"booklovers paradise\":\n        return {\n            \"user\": user_name,\n            \"shop\": shop_name,\n            \"items\": items_in_cart,\n            \"payment_options\": get_supported_payment_methods(shop_name)\n        }\n    return {}\n", "user_query": "Is the Stripe payment gateway reliable for BookLovers Paradise?", "checklist": {"functions": ["verify_payment_gateway_integrity"], "values": [true]}}
{"difficulty": "easy", "function_schema_python": "def verify_payment_gateway_integrity(shop_name: str, payment_gateway: str) -> bool:\n    \"\"\"Verifies the integrity of the payment gateway used by a given shop.\n\n    :param shop_name: The name of the shop (e.g., \"BookLovers Paradise\").\n    :param payment_gateway: The name of the payment gateway (e.g., \"stripe\", \"klarna\").\n    :return: True if the payment gateway is reliable, False otherwise.\n    :raises ValueError: If shop_name or payment_gateway is invalid.\"\"\"\n    pass\ndef get_supported_payment_methods(shop_name: str) -> list:\n    \"\"\"Retrieves the list of supported payment methods for a given shop.\n\n    :param shop_name: The name of the shop (e.g., \"BookLovers Paradise\").\n    :return: A list of supported payment methods (e.g., [\"credit card\", \"debit card\", \"paypal\"]).\n    :raises ValueError: If shop_name is invalid.\"\"\"\n    pass\ndef guide_checkout_process(user_name: str, shop_name: str, items_in_cart: list) -> dict:\n    \"\"\"Guides the checkout process for a user at a given shop.\n\n    :param user_name: The name of the user (e.g., \"Michael\").\n    :param shop_name: The name of the shop (e.g., \"BookLovers Paradise\").\n    :param items_in_cart: A list of items in the user's cart (e.g., [\"Novel1\", \"Novel2\"]).\n    :return:\n        dict: A dictionary with the following keys:\n            - user: The name of the user.\n            - shop: The name of the shop.\n            - items: The list of items in the cart.\n            - payment_options: The list of supported payment methods.\n    :raises ValueError: If user_name, shop_name, or items_in_cart is invalid.\"\"\"\n    pass\n", "function_schema_json": [{"name": "verify_payment_gateway_integrity", "description": "Verifies the integrity of the payment gateway used by a given shop.", "parameters": {"type": "object", "properties": {"shop_name": {"type": "string", "description": "The name of the shop (e.g., \"BookLovers Paradise\")."}, "payment_gateway": {"type": "string", "description": "The name of the payment gateway (e.g., \"stripe\", \"klarna\")."}}, "required": ["shop_name", "payment_gateway"], "additionalProperties": false}}, {"name": "get_supported_payment_methods", "description": "Retrieves the list of supported payment methods for a given shop.", "parameters": {"type": "object", "properties": {"shop_name": {"type": "string", "description": "The name of the shop (e.g., \"BookLovers Paradise\")."}}, "required": ["shop_name"], "additionalProperties": false}}, {"name": "guide_checkout_process", "description": "Guides the checkout process for a user at a given shop.", "parameters": {"type": "object", "properties": {"user_name": {"type": "string", "description": "The name of the user (e.g., \"Michael\")."}, "shop_name": {"type": "string", "description": "The name of the shop (e.g., \"BookLovers Paradise\")."}, "items_in_cart": {"type": "array", "description": "A list of items in the user's cart (e.g., [\"Novel1\", \"Novel2\"])."}}, "required": ["user_name", "shop_name", "items_in_cart"], "additionalProperties": false}}], "mock_functions": "def verify_payment_gateway_integrity(shop_name: str, payment_gateway: str) -> bool:\n    \"\"\"\n    Verifies the integrity of the payment gateway used by a given shop.\n    \n    :param shop_name: The name of the shop (e.g., \"BookLovers Paradise\").\n    :param payment_gateway: The name of the payment gateway (e.g., \"stripe\", \"klarna\").\n    :return: True if the payment gateway is reliable, False otherwise.\n    :raises ValueError: If shop_name or payment_gateway is invalid.\n    \"\"\"\n    if not shop_name or not payment_gateway:\n        raise ValueError(\"Shop name and payment gateway must be provided.\")\n    \n    # Mock logic: Only \"stripe\", \"klarna\", and \"paypal-sdk\" are considered reliable payment gateways.\n    reliable_gateways = {\"stripe\", \"klarna\", \"paypal-sdk\"}\n    if shop_name.lower() == \"booklovers paradise\" and payment_gateway.lower() in reliable_gateways:\n        return True\n    return False\ndef get_supported_payment_methods(shop_name: str) -> list:\n    \"\"\"\n    Retrieves the list of supported payment methods for a given shop.\n    \n    :param shop_name: The name of the shop (e.g., \"BookLovers Paradise\").\n    :return: A list of supported payment methods (e.g., [\"credit card\", \"debit card\", \"paypal\"]).\n    :raises ValueError: If shop_name is invalid.\n    \"\"\"\n    if not shop_name:\n        raise ValueError(\"Shop name must be provided.\")\n    \n    # Mock logic: \"BookLovers Paradise\" supports several payment methods via \"stripe\", \"klarna\", and \"paypal-sdk\".\n    if shop_name.lower() == \"booklovers paradise\":\n        return [\"credit card\", \"debit card\", \"paypal\", \"apple pay\", \"google pay\"]\n    return []\ndef guide_checkout_process(user_name: str, shop_name: str, items_in_cart: list) -> dict:\n    \"\"\"\n    Guides the checkout process for a user at a given shop.\n    \n    :param user_name: The name of the user (e.g., \"Michael\").\n    :param shop_name: The name of the shop (e.g., \"BookLovers Paradise\").\n    :param items_in_cart: A list of items in the user's cart (e.g., [\"Novel1\", \"Novel2\"]).\n    :return:\n        dict: A dictionary with the following keys:\n            - user: The name of the user.\n            - shop: The name of the shop.\n            - items: The list of items in the cart.\n            - payment_options: The list of supported payment methods.\n    :raises ValueError: If user_name, shop_name, or items_in_cart is invalid.\n    \"\"\"\n    if not user_name or not shop_name or not items_in_cart:\n        raise ValueError(\"User name, shop name, and items in cart must be provided.\")\n    \n    # Mock logic: Guide checkout process for \"Michael\" at \"BookLovers Paradise\".\n    if user_name.lower() == \"michael\" and shop_name.lower() == \"booklovers paradise\":\n        return {\n            \"user\": user_name,\n            \"shop\": shop_name,\n            \"items\": items_in_cart,\n            \"payment_options\": get_supported_payment_methods(shop_name)\n        }\n    return {}\n", "user_query": "This is Michael. Please guide me through the checkout process at BookLovers Paradise with my items [\"The Lost Manuscript\", \"Ancient Poems\", \"Rare Chronicles\"].", "checklist": {"functions": ["guide_checkout_process"], "values": [{"user": "Michael", "shop": "BookLovers Paradise", "items": ["The Lost Manuscript", "Ancient Poems", "Rare Chronicles"], "payment_options": ["credit card", "debit card", "paypal", "apple pay", "google pay"]}]}}
{"difficulty": "easy", "function_schema_python": "def create_api_endpoints(api_name: str, endpoints: list[str]) -> dict:\n    \"\"\"Creates API endpoints for the specified API name.\n\n    :param api_name: Name of the API to be created\n    :param endpoints: List of endpoint paths to be created\n    :return: Dictionary containing API configuration details\n    :raises ValueError: If API name is empty or endpoints list is empty\"\"\"\n    pass\ndef configure_database(db_type: str, storage_size: int) -> dict:\n    \"\"\"Configures database with specified parameters.\n\n    :param db_type: Type of database (e.g., MySQL, PostgreSQL)\n    :param storage_size: Storage size in GB\n    :return: Dictionary containing database configuration details\n    :raises ValueError: If storage size is less than 5GB\"\"\"\n    pass\ndef deploy_web_application(app_name: str, instance_type: str, db_config: dict) -> dict:\n    \"\"\"Deploys web application with specified configuration.\n\n    :param app_name: Name of the web application\n    :param instance_type: AWS instance type\n    :param db_config: Database configuration dictionary\n    :return: Dictionary containing deployment details\n    :raises ValueError: If any required parameter is missing\"\"\"\n    pass\n", "function_schema_json": [{"name": "create_api_endpoints", "description": "Creates API endpoints for the specified API name.", "parameters": {"type": "object", "properties": {"api_name": {"type": "string", "description": "Name of the API to be created"}, "endpoints": {"type": "array", "items": {"type": "string"}, "description": "List of endpoint paths to be created"}}, "required": ["api_name", "endpoints"], "additionalProperties": false}}, {"name": "configure_database", "description": "Configures database with specified parameters.", "parameters": {"type": "object", "properties": {"db_type": {"type": "string", "description": "Type of database (e.g., MySQL, PostgreSQL)"}, "storage_size": {"type": "integer", "description": "Storage size in GB"}}, "required": ["db_type", "storage_size"], "additionalProperties": false}}, {"name": "deploy_web_application", "description": "Deploys web application with specified configuration.", "parameters": {"type": "object", "properties": {"app_name": {"type": "string", "description": "Name of the web application"}, "instance_type": {"type": "string", "description": "AWS instance type"}, "db_config": {"type": "object", "description": "Database configuration dictionary"}}, "required": ["app_name", "instance_type", "db_config"], "additionalProperties": false}}], "mock_functions": "def create_api_endpoints(api_name: str, endpoints: list[str]) -> dict:\n    \"\"\"\n    Creates API endpoints for the specified API name.\n    \n    :param api_name: Name of the API to be created\n    :param endpoints: List of endpoint paths to be created\n    :return: Dictionary containing API configuration details\n    :raises ValueError: If API name is empty or endpoints list is empty\n    \"\"\"\n    if not api_name or not endpoints:\n        raise ValueError(\"API name and endpoints must be provided\")\n    \n    if api_name == \"PaymentProcessingAPI\" and set(endpoints) == {\"/pay\", \"/refund\"}:\n        return {\n            \"api_id\": \"pay-123\",\n            \"name\": api_name,\n            \"endpoints\": endpoints,\n            \"status\": \"created\"\n        }\n    return {\"status\": \"failed\"}\ndef configure_database(db_type: str, storage_size: int) -> dict:\n    \"\"\"\n    Configures database with specified parameters.\n    \n    :param db_type: Type of database (e.g., MySQL, PostgreSQL)\n    :param storage_size: Storage size in GB\n    :return: Dictionary containing database configuration details\n    :raises ValueError: If storage size is less than 5GB\n    \"\"\"\n    if storage_size < 5:\n        raise ValueError(\"Storage size must be at least 5GB\")\n    \n    if db_type.lower() == \"mysql\" and storage_size == 10:\n        return {\n            \"db_id\": \"db-456\",\n            \"type\": db_type,\n            \"storage\": storage_size,\n            \"connection_string\": \"mysql://username:password@hostname:3306/db\",\n            \"status\": \"configured\"\n        }\n    return {\"status\": \"failed\"}\ndef deploy_web_application(app_name: str, instance_type: str, db_config: dict) -> dict:\n    \"\"\"\n    Deploys web application with specified configuration.\n    \n    :param app_name: Name of the web application\n    :param instance_type: AWS instance type\n    :param db_config: Database configuration dictionary\n    :return: Dictionary containing deployment details\n    :raises ValueError: If any required parameter is missing\n    \"\"\"\n    if not app_name or not instance_type or not db_config:\n        raise ValueError(\"All parameters must be provided\")\n    \n    if (app_name == \"ECommerceWebApp\" and \n        instance_type == \"t2.medium\" and \n        db_config.get(\"status\") == \"configured\"):\n        return {\n            \"deployment_id\": \"dep-789\",\n            \"app_name\": app_name,\n            \"instance_type\": instance_type,\n            \"status\": \"deployed\",\n            \"url\": \"https://ecommerce-webapp.example.com\"\n        }\n    return {\"status\": \"failed\"}", "user_query": "Create API endpoints for PaymentProcessingAPI with \"/pay\" and \"/refund\" endpoints.", "checklist": {"functions": ["create_api_endpoints"], "values": [{"api_id": "pay-123", "name": "PaymentProcessingAPI", "endpoints": ["/pay", "/refund"], "status": "created"}]}}
{"difficulty": "easy", "function_schema_python": "def create_api(api_name: str, endpoints: list) -> dict:\n    \"\"\"Creates a new API with specified endpoints.\n\n    :param api_name: The name of the API to be created.\n    :param endpoints: A list of endpoint paths for the API.\n    :return: A dictionary representing the created API with the following keys:\n        - name (str): The name of the API.\n        - endpoints (list[str]): The list of endpoints.\n    :raises ValueError: If the API name is empty or endpoints are not provided.\"\"\"\n    pass\ndef deploy_web_application(app_name: str) -> str:\n    \"\"\"Deploys a web application with a load balancer.\n\n    :param app_name: The name of the web application to be deployed.\n    :return: A string confirming the deployment.\n    :raises ValueError: If the application name is empty.\"\"\"\n    pass\ndef configure_load_balancer(ssl_termination: bool) -> str:\n    \"\"\"Configures the load balancer with HTTP and SSL termination.\n\n    :param ssl_termination: Boolean indicating if SSL termination should be enabled.\n    :return: A string confirming the load balancer configuration.\"\"\"\n    pass\ndef launch_ec2_instance(instance_type: str) -> dict:\n    \"\"\"Launches an EC2 instance with a specified instance type.\n\n    :param instance_type: The type of EC2 instance to launch.\n    :return: A dictionary with instance details including the following keys:\n        - instance_type (str): The type of the instance.\n        - status (str): The status of the instance launch (\"running\" or \"failed\").\"\"\"\n    pass\n", "function_schema_json": [{"name": "create_api", "description": "Creates a new API with specified endpoints.", "parameters": {"type": "object", "properties": {"api_name": {"type": "string", "description": "The name of the API to be created."}, "endpoints": {"type": "array", "description": "A list of endpoint paths for the API."}}, "required": ["api_name", "endpoints"], "additionalProperties": false}}, {"name": "deploy_web_application", "description": "Deploys a web application with a load balancer.", "parameters": {"type": "object", "properties": {"app_name": {"type": "string", "description": "The name of the web application to be deployed."}}, "required": ["app_name"], "additionalProperties": false}}, {"name": "configure_load_balancer", "description": "Configures the load balancer with HTTP and SSL termination.", "parameters": {"type": "object", "properties": {"ssl_termination": {"type": "boolean", "description": "Boolean indicating if SSL termination should be enabled."}}, "required": ["ssl_termination"], "additionalProperties": false}}, {"name": "launch_ec2_instance", "description": "Launches an EC2 instance with a specified instance type.", "parameters": {"type": "object", "properties": {"instance_type": {"type": "string", "description": "The type of EC2 instance to launch."}}, "required": ["instance_type"], "additionalProperties": false}}], "mock_functions": "def create_api(api_name: str, endpoints: list) -> dict:\n    \"\"\"\n    Creates a new API with specified endpoints.\n    \n    :param api_name: The name of the API to be created.\n    :param endpoints: A list of endpoint paths for the API.\n    :return: A dictionary representing the created API with the following keys:\n        - name (str): The name of the API.\n        - endpoints (list[str]): The list of endpoints.\n    :raises ValueError: If the API name is empty or endpoints are not provided.\n    \"\"\"\n    if not api_name:\n        raise ValueError(\"API name must not be empty.\")\n    if not endpoints:\n        raise ValueError(\"Endpoints must be provided.\")\n    return {\n        \"name\": api_name,\n        \"endpoints\": endpoints\n    }\ndef deploy_web_application(app_name: str) -> str:\n    \"\"\"\n    Deploys a web application with a load balancer.\n    \n    :param app_name: The name of the web application to be deployed.\n    :return: A string confirming the deployment.\n    :raises ValueError: If the application name is empty.\n    \"\"\"\n    if not app_name:\n        raise ValueError(\"Application name must not be empty.\")\n    return f\"{app_name} has been deployed with a load balancer.\"\ndef configure_load_balancer(ssl_termination: bool) -> str:\n    \"\"\"\n    Configures the load balancer with HTTP and SSL termination.\n    \n    :param ssl_termination: Boolean indicating if SSL termination should be enabled.\n    :return: A string confirming the load balancer configuration.\n    \"\"\"\n    return f\"Load balancer configured with SSL termination: {ssl_termination}\"\ndef launch_ec2_instance(instance_type: str) -> dict:\n    \"\"\"\n    Launches an EC2 instance with a specified instance type.\n    \n    :param instance_type: The type of EC2 instance to launch.\n    :return: A dictionary with instance details including the following keys:\n        - instance_type (str): The type of the instance.\n        - status (str): The status of the instance launch (\"running\" or \"failed\").\n    \"\"\"\n    valid_instance_types = [\"c5.large\", \"m5.large\", \"t2.micro\"]\n    if instance_type not in valid_instance_types:\n        return {\n            \"instance_type\": instance_type,\n            \"status\": \"failed\"\n        }\n    return {\n        \"instance_type\": instance_type,\n        \"status\": \"running\"\n    }", "user_query": "Can you create an API named 'ClientAnalyticsAPI' with endpoints [\"/clients\", \"/data\"]?", "checklist": {"functions": ["create_api"], "values": [{"name": "ClientAnalyticsAPI", "endpoints": ["/clients", "/data"]}]}}
{"difficulty": "easy", "function_schema_python": "def create_ssh_key_pair(username: str, key_type: str) -> dict:\n    \"\"\"Creates a new SSH key pair for a developer.\n\n    :param username: The username of the developer\n    :param key_type: The type of SSH key (rsa, ed25519)\n    :return: Dictionary containing public and private key\n    :raises ValueError: If username is invalid or key_type is not supported\"\"\"\n    pass\ndef assign_instance_access(developer_id: str, instance_ids: list[str]) -> dict:\n    \"\"\"Assigns EC2 instance access permissions to a developer.\n\n    :param developer_id: The unique identifier of the developer\n    :param instance_ids: List of EC2 instance IDs to grant access\n    :return: Dictionary containing access status and details\n    :raises ValueError: If developer_id is invalid or instance_ids is empty\"\"\"\n    pass\ndef rotate_ssh_keys(instance_id: str, old_key_fingerprint: str) -> dict:\n    \"\"\"Rotates SSH keys for a specific EC2 instance.\n\n    :param instance_id: The EC2 instance ID\n    :param old_key_fingerprint: Fingerprint of the key to be rotated\n    :return: Dictionary containing rotation status and new key details\n    :raises RuntimeError: If rotation fails\"\"\"\n    pass\ndef verify_compliance_status(instance_id: str) -> dict:\n    \"\"\"Verifies SOC2 compliance status for SSH access on an instance.\n\n    :param instance_id: The EC2 instance ID\n    :return: Dictionary containing compliance status details\n    :raises ValueError: If instance_id is invalid\"\"\"\n    pass\n", "function_schema_json": [{"name": "create_ssh_key_pair", "description": "Creates a new SSH key pair for a developer.", "parameters": {"type": "object", "properties": {"username": {"type": "string", "description": "The username of the developer"}, "key_type": {"type": "string", "description": "The type of SSH key (rsa, ed25519)"}}, "required": ["username", "key_type"], "additionalProperties": false}}, {"name": "assign_instance_access", "description": "Assigns EC2 instance access permissions to a developer.", "parameters": {"type": "object", "properties": {"developer_id": {"type": "string", "description": "The unique identifier of the developer"}, "instance_ids": {"type": "array", "items": {"type": "string"}, "description": "List of EC2 instance IDs to grant access"}}, "required": ["developer_id", "instance_ids"], "additionalProperties": false}}, {"name": "rotate_ssh_keys", "description": "Rotates SSH keys for a specific EC2 instance.", "parameters": {"type": "object", "properties": {"instance_id": {"type": "string", "description": "The EC2 instance ID"}, "old_key_fingerprint": {"type": "string", "description": "Fingerprint of the key to be rotated"}}, "required": ["instance_id", "old_key_fingerprint"], "additionalProperties": false}}, {"name": "verify_compliance_status", "description": "Verifies SOC2 compliance status for SSH access on an instance.", "parameters": {"type": "object", "properties": {"instance_id": {"type": "string", "description": "The EC2 instance ID"}}, "required": ["instance_id"], "additionalProperties": false}}], "mock_functions": "def create_ssh_key_pair(username: str, key_type: str = \"rsa\") -> dict:\n    \"\"\"\n    Creates a new SSH key pair for a developer.\n    \n    :param username: The username of the developer\n    :param key_type: The type of SSH key (rsa, ed25519)\n    :return: Dictionary containing public and private key\n    :raises ValueError: If username is invalid or key_type is not supported\n    \"\"\"\n    if not username or not isinstance(username, str):\n        raise ValueError(\"Invalid username\")\n    if key_type not in [\"rsa\", \"ed25519\"]:\n        raise ValueError(\"Unsupported key type\")\n    \n    return {\n        \"public_key\": f\"ssh-{key_type} AAAAB3NzaC1yc2EA... {username}@techcloud.com\",\n        \"private_key\": \"-----BEGIN OPENSSH PRIVATE KEY-----\\nxxx\\n-----END OPENSSH PRIVATE KEY-----\"\n    }\ndef assign_instance_access(developer_id: str, instance_ids: list[str]) -> dict:\n    \"\"\"\n    Assigns EC2 instance access permissions to a developer.\n    \n    :param developer_id: The unique identifier of the developer\n    :param instance_ids: List of EC2 instance IDs to grant access\n    :return: Dictionary containing access status and details\n    :raises ValueError: If developer_id is invalid or instance_ids is empty\n    \"\"\"\n    if not developer_id or len(instance_ids) == 0:\n        raise ValueError(\"Invalid developer_id or empty instance_ids\")\n    \n    return {\n        \"status\": \"success\",\n        \"developer\": developer_id,\n        \"granted_instances\": instance_ids,\n        \"access_expiry\": \"2024-02-14T00:00:00Z\"\n    }\ndef rotate_ssh_keys(instance_id: str, old_key_fingerprint: str) -> dict:\n    \"\"\"\n    Rotates SSH keys for a specific EC2 instance.\n    \n    :param instance_id: The EC2 instance ID\n    :param old_key_fingerprint: Fingerprint of the key to be rotated\n    :return: Dictionary containing rotation status and new key details\n    :raises RuntimeError: If rotation fails\n    \"\"\"\n    if not instance_id.startswith('i-'):\n        raise ValueError(\"Invalid instance ID format\")\n    if len(old_key_fingerprint) != 47:  # Standard SSH key fingerprint length\n        raise ValueError(\"Invalid key fingerprint\")\n    \n    return {\n        \"status\": \"success\",\n        \"instance_id\": instance_id,\n        \"new_key_fingerprint\": \"SHA256:newfingerprint...\",\n        \"rotation_timestamp\": \"2024-01-15T10:30:00Z\",\n        \"next_rotation_due\": \"2024-02-14T10:30:00Z\"\n    }\ndef verify_compliance_status(instance_id: str) -> dict:\n    \"\"\"\n    Verifies SOC2 compliance status for SSH access on an instance.\n    \n    :param instance_id: The EC2 instance ID\n    :return: Dictionary containing compliance status details\n    :raises ValueError: If instance_id is invalid\n    \"\"\"\n    if not instance_id.startswith('i-'):\n        raise ValueError(\"Invalid instance ID format\")\n    \n    return {\n        \"compliant\": True,\n        \"instance_id\": instance_id,\n        \"last_key_rotation\": \"2024-01-15T10:30:00Z\",\n        \"access_logging_enabled\": True,\n        \"mfa_enabled\": True,\n        \"findings\": []\n    }", "user_query": "Can you create an SSH key pair for the developer with username \u201calex_jones\u201d using the rsa key type?", "checklist": {"functions": ["create_ssh_key_pair"], "values": [{"public_key": "ssh-rsa AAAAB3NzaC1yc2EA... alex_jones@techcloud.com", "private_key": "-----BEGIN OPENSSH PRIVATE KEY-----\nxxx\n-----END OPENSSH PRIVATE KEY-----"}]}}
{"difficulty": "easy", "function_schema_python": "def create_ssh_key_pair(username: str, key_type: str) -> dict:\n    \"\"\"Creates a new SSH key pair for a developer.\n\n    :param username: The username of the developer\n    :param key_type: The type of SSH key (rsa, ed25519)\n    :return: Dictionary containing public and private key\n    :raises ValueError: If username is invalid or key_type is not supported\"\"\"\n    pass\ndef assign_instance_access(developer_id: str, instance_ids: list[str]) -> dict:\n    \"\"\"Assigns EC2 instance access permissions to a developer.\n\n    :param developer_id: The unique identifier of the developer\n    :param instance_ids: List of EC2 instance IDs to grant access\n    :return: Dictionary containing access status and details\n    :raises ValueError: If developer_id is invalid or instance_ids is empty\"\"\"\n    pass\ndef rotate_ssh_keys(instance_id: str, old_key_fingerprint: str) -> dict:\n    \"\"\"Rotates SSH keys for a specific EC2 instance.\n\n    :param instance_id: The EC2 instance ID\n    :param old_key_fingerprint: Fingerprint of the key to be rotated\n    :return: Dictionary containing rotation status and new key details\n    :raises RuntimeError: If rotation fails\"\"\"\n    pass\ndef verify_compliance_status(instance_id: str) -> dict:\n    \"\"\"Verifies SOC2 compliance status for SSH access on an instance.\n\n    :param instance_id: The EC2 instance ID\n    :return: Dictionary containing compliance status details\n    :raises ValueError: If instance_id is invalid\"\"\"\n    pass\n", "function_schema_json": [{"name": "create_ssh_key_pair", "description": "Creates a new SSH key pair for a developer.", "parameters": {"type": "object", "properties": {"username": {"type": "string", "description": "The username of the developer"}, "key_type": {"type": "string", "description": "The type of SSH key (rsa, ed25519)"}}, "required": ["username", "key_type"], "additionalProperties": false}}, {"name": "assign_instance_access", "description": "Assigns EC2 instance access permissions to a developer.", "parameters": {"type": "object", "properties": {"developer_id": {"type": "string", "description": "The unique identifier of the developer"}, "instance_ids": {"type": "array", "items": {"type": "string"}, "description": "List of EC2 instance IDs to grant access"}}, "required": ["developer_id", "instance_ids"], "additionalProperties": false}}, {"name": "rotate_ssh_keys", "description": "Rotates SSH keys for a specific EC2 instance.", "parameters": {"type": "object", "properties": {"instance_id": {"type": "string", "description": "The EC2 instance ID"}, "old_key_fingerprint": {"type": "string", "description": "Fingerprint of the key to be rotated"}}, "required": ["instance_id", "old_key_fingerprint"], "additionalProperties": false}}, {"name": "verify_compliance_status", "description": "Verifies SOC2 compliance status for SSH access on an instance.", "parameters": {"type": "object", "properties": {"instance_id": {"type": "string", "description": "The EC2 instance ID"}}, "required": ["instance_id"], "additionalProperties": false}}], "mock_functions": "def create_ssh_key_pair(username: str, key_type: str = \"rsa\") -> dict:\n    \"\"\"\n    Creates a new SSH key pair for a developer.\n    \n    :param username: The username of the developer\n    :param key_type: The type of SSH key (rsa, ed25519)\n    :return: Dictionary containing public and private key\n    :raises ValueError: If username is invalid or key_type is not supported\n    \"\"\"\n    if not username or not isinstance(username, str):\n        raise ValueError(\"Invalid username\")\n    if key_type not in [\"rsa\", \"ed25519\"]:\n        raise ValueError(\"Unsupported key type\")\n    \n    return {\n        \"public_key\": f\"ssh-{key_type} AAAAB3NzaC1yc2EA... {username}@techcloud.com\",\n        \"private_key\": \"-----BEGIN OPENSSH PRIVATE KEY-----\\nxxx\\n-----END OPENSSH PRIVATE KEY-----\"\n    }\ndef assign_instance_access(developer_id: str, instance_ids: list[str]) -> dict:\n    \"\"\"\n    Assigns EC2 instance access permissions to a developer.\n    \n    :param developer_id: The unique identifier of the developer\n    :param instance_ids: List of EC2 instance IDs to grant access\n    :return: Dictionary containing access status and details\n    :raises ValueError: If developer_id is invalid or instance_ids is empty\n    \"\"\"\n    if not developer_id or len(instance_ids) == 0:\n        raise ValueError(\"Invalid developer_id or empty instance_ids\")\n    \n    return {\n        \"status\": \"success\",\n        \"developer\": developer_id,\n        \"granted_instances\": instance_ids,\n        \"access_expiry\": \"2024-02-14T00:00:00Z\"\n    }\ndef rotate_ssh_keys(instance_id: str, old_key_fingerprint: str) -> dict:\n    \"\"\"\n    Rotates SSH keys for a specific EC2 instance.\n    \n    :param instance_id: The EC2 instance ID\n    :param old_key_fingerprint: Fingerprint of the key to be rotated\n    :return: Dictionary containing rotation status and new key details\n    :raises RuntimeError: If rotation fails\n    \"\"\"\n    if not instance_id.startswith('i-'):\n        raise ValueError(\"Invalid instance ID format\")\n    if len(old_key_fingerprint) != 47:  # Standard SSH key fingerprint length\n        raise ValueError(\"Invalid key fingerprint\")\n    \n    return {\n        \"status\": \"success\",\n        \"instance_id\": instance_id,\n        \"new_key_fingerprint\": \"SHA256:newfingerprint...\",\n        \"rotation_timestamp\": \"2024-01-15T10:30:00Z\",\n        \"next_rotation_due\": \"2024-02-14T10:30:00Z\"\n    }\ndef verify_compliance_status(instance_id: str) -> dict:\n    \"\"\"\n    Verifies SOC2 compliance status for SSH access on an instance.\n    \n    :param instance_id: The EC2 instance ID\n    :return: Dictionary containing compliance status details\n    :raises ValueError: If instance_id is invalid\n    \"\"\"\n    if not instance_id.startswith('i-'):\n        raise ValueError(\"Invalid instance ID format\")\n    \n    return {\n        \"compliant\": True,\n        \"instance_id\": instance_id,\n        \"last_key_rotation\": \"2024-01-15T10:30:00Z\",\n        \"access_logging_enabled\": True,\n        \"mfa_enabled\": True,\n        \"findings\": []\n    }", "user_query": "This is Sarah. Assign EC2 instance access to the developer ID \u201cdev_456\u201d for instances [\u201ci-01234abcd\u201d, \u201ci-05678efgh\u201d, \u201ci-07890ijkl\u201d].", "checklist": {"functions": ["assign_instance_access"], "values": [{"status": "success", "developer": "dev_456", "granted_instances": ["i-01234abcd", "i-05678efgh", "i-07890ijkl"], "access_expiry": "2024-02-14T00:00:00Z"}]}}
{"difficulty": "easy", "function_schema_python": "def create_bastion_host(instance_type: str, region: str) -> dict:\n    \"\"\"Creates a new SSH bastion host in the specified AWS region.\n\n    :param instance_type: AWS instance type (e.g., 't3.large', 't3.xlarge')\n    :param region: AWS region (e.g., 'us-east-1')\n    :return: Dictionary containing instance details\n    :raises ValueError: If instance type or region is invalid\"\"\"\n    pass\ndef configure_session_manager(instance_id: str, max_sessions: int) -> dict:\n    \"\"\"Configures AWS Systems Manager Session Manager for the bastion host.\n\n    :param instance_id: AWS EC2 instance ID\n    :param max_sessions: Maximum number of concurrent SSH sessions\n    :return: Dictionary containing configuration status\n    :raises ValueError: If instance_id is invalid or max_sessions is out of range\"\"\"\n    pass\ndef setup_audit_logging(instance_id: str, log_retention_days: int) -> dict:\n    \"\"\"Sets up CloudWatch logging for SSH session auditing.\n\n    :param instance_id: AWS EC2 instance ID\n    :param log_retention_days: Number of days to retain audit logs\n    :return: Dictionary containing logging configuration details\n    :raises ValueError: If parameters are invalid\"\"\"\n    pass\n", "function_schema_json": [{"name": "create_bastion_host", "description": "Creates a new SSH bastion host in the specified AWS region.", "parameters": {"type": "object", "properties": {"instance_type": {"type": "string", "description": "AWS instance type (e.g., 't3.large', 't3.xlarge')"}, "region": {"type": "string", "description": "AWS region (e.g., 'us-east-1')"}}, "required": ["instance_type", "region"], "additionalProperties": false}}, {"name": "configure_session_manager", "description": "Configures AWS Systems Manager Session Manager for the bastion host.", "parameters": {"type": "object", "properties": {"instance_id": {"type": "string", "description": "AWS EC2 instance ID"}, "max_sessions": {"type": "integer", "description": "Maximum number of concurrent SSH sessions"}}, "required": ["instance_id", "max_sessions"], "additionalProperties": false}}, {"name": "setup_audit_logging", "description": "Sets up CloudWatch logging for SSH session auditing.", "parameters": {"type": "object", "properties": {"instance_id": {"type": "string", "description": "AWS EC2 instance ID"}, "log_retention_days": {"type": "integer", "description": "Number of days to retain audit logs"}}, "required": ["instance_id", "log_retention_days"], "additionalProperties": false}}], "mock_functions": "def create_bastion_host(instance_type: str, region: str) -> dict:\n    \"\"\"\n    Creates a new SSH bastion host in the specified AWS region.\n    \n    :param instance_type: AWS instance type (e.g., 't3.large', 't3.xlarge')\n    :param region: AWS region (e.g., 'us-east-1')\n    :return: Dictionary containing instance details\n    :raises ValueError: If instance type or region is invalid\n    \"\"\"\n    valid_instances = ['t3.large', 't3.xlarge', 't3.2xlarge']\n    valid_regions = ['us-east-1', 'us-west-2', 'eu-west-1']\n    \n    if instance_type not in valid_instances or region not in valid_regions:\n        raise ValueError(\"Invalid instance type or region\")\n    \n    return {\n        \"instance_id\": \"i-0123456789abcdef0\",\n        \"public_ip\": \"54.123.456.789\",\n        \"max_connections\": 100,\n        \"status\": \"running\"\n    }\ndef configure_session_manager(instance_id: str, max_sessions: int) -> dict:\n    \"\"\"\n    Configures AWS Systems Manager Session Manager for the bastion host.\n    \n    :param instance_id: AWS EC2 instance ID\n    :param max_sessions: Maximum number of concurrent SSH sessions\n    :return: Dictionary containing configuration status\n    :raises ValueError: If instance_id is invalid or max_sessions is out of range\n    \"\"\"\n    if not instance_id.startswith('i-') or len(instance_id) != 19:\n        raise ValueError(\"Invalid instance ID format\")\n    \n    if not 25 <= max_sessions <= 100:\n        raise ValueError(\"Max sessions must be between 25 and 100\")\n    \n    return {\n        \"status\": \"configured\",\n        \"max_sessions\": max_sessions,\n        \"audit_logging\": \"enabled\",\n        \"connection_timeout\": 3600\n    }\ndef setup_audit_logging(instance_id: str, log_retention_days: int) -> dict:\n    \"\"\"\n    Sets up CloudWatch logging for SSH session auditing.\n    \n    :param instance_id: AWS EC2 instance ID\n    :param log_retention_days: Number of days to retain audit logs\n    :return: Dictionary containing logging configuration details\n    :raises ValueError: If parameters are invalid\n    \"\"\"\n    if not instance_id.startswith('i-') or len(instance_id) != 19:\n        raise ValueError(\"Invalid instance ID\")\n    \n    if not 1 <= log_retention_days <= 365:\n        raise ValueError(\"Log retention must be between 1 and 365 days\")\n    \n    return {\n        \"log_group\": f\"/aws/ssh/{instance_id}\",\n        \"retention_days\": log_retention_days,\n        \"status\": \"enabled\",\n        \"streaming\": \"active\"\n    }", "user_query": "Can you create a new bastion host in us-east-1 region using t3.xlarge instance type?", "checklist": {"functions": ["create_bastion_host"], "values": [{"instance_id": "i-0123456789abcdef0", "public_ip": "54.123.456.789", "max_connections": 100, "status": "running"}]}}
{"difficulty": "easy", "function_schema_python": "def setup_cloud_infrastructure(project_name: str, cloud_providers: List[str], num_vms: int, budget: float) -> bool:\n    \"\"\"Sets up cloud infrastructure for a given project.\n\n    :param project_name: The name of the project (e.g., \"EagleEye\").\n    :param cloud_providers: A list of cloud providers (e.g., [\"AWS\", \"Google Cloud\", \"Azure\"]).\n    :param num_vms: The number of virtual machines to provision.\n    :param budget: The allocated budget for cloud services.\n    :return: True if the setup was successful, False otherwise.\"\"\"\n    pass\ndef initiate_hyperparameter_tuning(project_name: str, initial_parameters: Dict[str, Any]) -> str:\n    \"\"\"Initiates the hyperparameter tuning process.\n\n    :param project_name: The name of the project.\n    :param initial_parameters: A dictionary of initial hyperparameters.\n    :return: A string representing the tuning process ID.\"\"\"\n    pass\ndef scale_resources(project_name: str, scaling_factor: int) -> bool:\n    \"\"\"Scales resources for a given project.\n\n    :param project_name: The name of the project.\n    :param scaling_factor: An integer representing the scaling factor. Positive values scale up, negative values scale down.\n    :return: True if scaling was successful, False otherwise.\"\"\"\n    pass\ndef monitor_performance(project_name: str) -> Dict[str, float]:\n    \"\"\"Monitors the performance of a project.\n\n    :param project_name: The name of the project.\n    :return: A dictionary containing performance metrics (e.g., accuracy, latency).\"\"\"\n    pass\ndef adjust_hyperparameters(project_name: str, new_parameters: Dict[str, Any]) -> bool:\n    \"\"\"Adjusts the hyperparameters of a project.\n\n    :param project_name: The name of the project.\n    :param new_parameters: A dictionary containing the new hyperparameters.\n    :return: True if the adjustment was successful, False otherwise.\"\"\"\n    pass\n", "function_schema_json": [{"name": "setup_cloud_infrastructure", "description": "Sets up cloud infrastructure for a given project.", "parameters": {"type": "object", "properties": {"project_name": {"type": "string", "description": "The name of the project (e.g., \"EagleEye\")."}, "cloud_providers": {"type": "array", "items": {"type": "string"}, "description": "A list of cloud providers (e.g., [\"AWS\", \"Google Cloud\", \"Azure\"])."}, "num_vms": {"type": "integer", "description": "The number of virtual machines to provision."}, "budget": {"type": "number", "description": "The allocated budget for cloud services."}}, "required": ["project_name", "cloud_providers", "num_vms", "budget"], "additionalProperties": false}}, {"name": "initiate_hyperparameter_tuning", "description": "Initiates the hyperparameter tuning process.", "parameters": {"type": "object", "properties": {"project_name": {"type": "string", "description": "The name of the project."}, "initial_parameters": {"type": "object", "description": "A dictionary of initial hyperparameters."}}, "required": ["project_name", "initial_parameters"], "additionalProperties": false}}, {"name": "scale_resources", "description": "Scales resources for a given project.", "parameters": {"type": "object", "properties": {"project_name": {"type": "string", "description": "The name of the project."}, "scaling_factor": {"type": "integer", "description": "An integer representing the scaling factor. Positive values scale up, negative values scale down."}}, "required": ["project_name", "scaling_factor"], "additionalProperties": false}}, {"name": "monitor_performance", "description": "Monitors the performance of a project.", "parameters": {"type": "object", "properties": {"project_name": {"type": "string", "description": "The name of the project."}}, "required": ["project_name"], "additionalProperties": false}}, {"name": "adjust_hyperparameters", "description": "Adjusts the hyperparameters of a project.", "parameters": {"type": "object", "properties": {"project_name": {"type": "string", "description": "The name of the project."}, "new_parameters": {"type": "object", "description": "A dictionary containing the new hyperparameters."}}, "required": ["project_name", "new_parameters"], "additionalProperties": false}}], "mock_functions": "def setup_cloud_infrastructure(project_name: str, cloud_providers: List[str], num_vms: int, budget: float) -> bool:\n    \"\"\"\n    Sets up cloud infrastructure for a given project.\n\n    :param project_name: The name of the project (e.g., \"EagleEye\").\n    :param cloud_providers: A list of cloud providers (e.g., [\"AWS\", \"Google Cloud\", \"Azure\"]).\n    :param num_vms: The number of virtual machines to provision.\n    :param budget: The allocated budget for cloud services.\n    :return: True if the setup was successful, False otherwise.\n    \"\"\"\n    if project_name == \"EagleEye\" and cloud_providers == [\"AWS\", \"Google Cloud\", \"Azure\"] and num_vms == 10 and budget == 10000.0:\n        return True\n    return False\ndef initiate_hyperparameter_tuning(project_name: str, initial_parameters: Dict[str, Any]) -> str:\n    \"\"\"\n    Initiates the hyperparameter tuning process.\n\n    :param project_name: The name of the project.\n    :param initial_parameters: A dictionary of initial hyperparameters.\n    :return: A string representing the tuning process ID.\n    \"\"\"\n    if project_name == \"EagleEye\" and isinstance(initial_parameters, dict):\n        return \"tuning_process_123\"\n    return \"\"\ndef scale_resources(project_name: str, scaling_factor: int) -> bool:\n  \"\"\"Scales resources for a given project.\n\n  :param project_name: The name of the project.\n  :param scaling_factor: An integer representing the scaling factor. Positive values scale up, negative values scale down.\n  :return: True if scaling was successful, False otherwise.\n  \"\"\"\n  pass # Not used in the current query.\ndef monitor_performance(project_name: str) -> Dict[str, float]:\n  \"\"\"Monitors the performance of a project.\n\n  :param project_name: The name of the project.\n  :return: A dictionary containing performance metrics (e.g., accuracy, latency).\n  \"\"\"\n  pass # Not used in the current query.\ndef adjust_hyperparameters(project_name: str, new_parameters: Dict[str, Any]) -> bool:\n  \"\"\"Adjusts the hyperparameters of a project.\n\n  :param project_name: The name of the project.\n  :param new_parameters: A dictionary containing the new hyperparameters.\n  :return: True if the adjustment was successful, False otherwise.\n  \"\"\"\n  pass # Not used in the current query.", "user_query": "Could you setup cloud infrastructure for EagleEye project using AWS, Google Cloud, and Azure with 10 VMs and a $10,000 budget?", "checklist": {"functions": ["setup_cloud_infrastructure"], "values": [true]}}
{"difficulty": "easy", "function_schema_python": "def configure_cloud_setup(cloud_provider: str, project_name: str) -> dict:\n    \"\"\"Configures the cloud setup for a given project.\n\n    :param cloud_provider: The cloud provider (e.g., \"aws\", \"azure\").\n    :param project_name: The name of the project.\n    :return: \n        dict: A dictionary containing the configuration details.\n            - setup_status (str): Status of the setup (\"Completed\" or \"Failed\").\n            - resources_allocated (list[str]): List of resources allocated.\n    :raises ValueError: If invalid cloud provider or project name is provided.\"\"\"\n    pass\ndef initiate_hyperparameter_tuning(dataset_size: int, target_precision: float, algorithms: list) -> dict:\n    \"\"\"Initiates the hyperparameter tuning process.\n\n    :param dataset_size: The size of the dataset.\n    :param target_precision: The target precision.\n    :param algorithms: The list of algorithms to use.\n    :return: \n        dict: A dictionary containing tuning information.\n            - status (str): Status of the tuning process (\"Started\" or \"Failed\").\n            - initial_hyperparameters (dict): Initial hyperparameters used.\n    :raises ValueError: If invalid parameters are provided.\"\"\"\n    pass\n", "function_schema_json": [{"name": "configure_cloud_setup", "description": "Configures the cloud setup for a given project.", "parameters": {"type": "object", "properties": {"cloud_provider": {"type": "string", "description": "The cloud provider (e.g., \"aws\", \"azure\")."}, "project_name": {"type": "string", "description": "The name of the project."}}, "required": ["cloud_provider", "project_name"], "additionalProperties": false}}, {"name": "initiate_hyperparameter_tuning", "description": "Initiates the hyperparameter tuning process.", "parameters": {"type": "object", "properties": {"dataset_size": {"type": "integer", "description": "The size of the dataset."}, "target_precision": {"type": "number", "description": "The target precision."}, "algorithms": {"type": "array", "description": "The list of algorithms to use."}}, "required": ["dataset_size", "target_precision", "algorithms"], "additionalProperties": false}}], "mock_functions": "def configure_cloud_setup(cloud_provider: str, project_name: str) -> dict:\n    \"\"\"\n    Configures the cloud setup for a given project.\n\n    :param cloud_provider: The cloud provider (e.g., \"aws\", \"azure\").\n    :param project_name: The name of the project.\n    :return: \n        dict: A dictionary containing the configuration details.\n            - setup_status (str): Status of the setup (\"Completed\" or \"Failed\").\n            - resources_allocated (list[str]): List of resources allocated.\n    :raises ValueError: If invalid cloud provider or project name is provided.\n    \"\"\"\n    if not cloud_provider or not project_name:\n        raise ValueError(\"Cloud provider and project name must be provided.\")\n    if project_name == \"RecommendX\":\n        return {\n            \"setup_status\": \"Completed\",\n            \"resources_allocated\": [\"EC2 instances\", \"S3 storage\", \"Azure VMs\", \"Azure Blob Storage\"]\n        }\n    return {\"setup_status\": \"Failed\", \"resources_allocated\": []}\ndef initiate_hyperparameter_tuning(dataset_size: int, target_precision: float, algorithms: list) -> dict:\n    \"\"\"\n    Initiates the hyperparameter tuning process.\n\n    :param dataset_size: The size of the dataset.\n    :param target_precision: The target precision.\n    :param algorithms: The list of algorithms to use.\n    :return: \n        dict: A dictionary containing tuning information.\n            - status (str): Status of the tuning process (\"Started\" or \"Failed\").\n            - initial_hyperparameters (dict): Initial hyperparameters used.\n    :raises ValueError: If invalid parameters are provided.\n    \"\"\"\n    if dataset_size <= 0 or target_precision <= 0 or not algorithms:\n        raise ValueError(\"Invalid dataset size, target precision, or algorithms.\")\n    if dataset_size == 100000 and target_precision == 0.85 and \"recommendation_algorithm\" in algorithms:\n        return {\n            \"status\": \"Started\",\n            \"initial_hyperparameters\": {\"learning_rate\": 0.01, \"regularization\": 0.1}\n        }\n    return {\"status\": \"Failed\", \"initial_hyperparameters\": {}}", "user_query": "Could you set up the cloud infrastructure for \"RecommendX\" using AWS?", "checklist": {"functions": ["configure_cloud_setup"], "values": [{"setup_status": "Completed", "resources_allocated": ["EC2 instances", "S3 storage", "Azure VMs", "Azure Blob Storage"]}]}}
{"difficulty": "easy", "function_schema_python": "def configure_cloud_setup(cloud_provider: str, project_name: str) -> dict:\n    \"\"\"Configures the cloud setup for a given project.\n\n    :param cloud_provider: The cloud provider (e.g., \"aws\", \"azure\").\n    :param project_name: The name of the project.\n    :return: \n        dict: A dictionary containing the configuration details.\n            - setup_status (str): Status of the setup (\"Completed\" or \"Failed\").\n            - resources_allocated (list[str]): List of resources allocated.\n    :raises ValueError: If invalid cloud provider or project name is provided.\"\"\"\n    pass\ndef initiate_hyperparameter_tuning(dataset_size: int, target_precision: float, algorithms: list) -> dict:\n    \"\"\"Initiates the hyperparameter tuning process.\n\n    :param dataset_size: The size of the dataset.\n    :param target_precision: The target precision.\n    :param algorithms: The list of algorithms to use.\n    :return: \n        dict: A dictionary containing tuning information.\n            - status (str): Status of the tuning process (\"Started\" or \"Failed\").\n            - initial_hyperparameters (dict): Initial hyperparameters used.\n    :raises ValueError: If invalid parameters are provided.\"\"\"\n    pass\n", "function_schema_json": [{"name": "configure_cloud_setup", "description": "Configures the cloud setup for a given project.", "parameters": {"type": "object", "properties": {"cloud_provider": {"type": "string", "description": "The cloud provider (e.g., \"aws\", \"azure\")."}, "project_name": {"type": "string", "description": "The name of the project."}}, "required": ["cloud_provider", "project_name"], "additionalProperties": false}}, {"name": "initiate_hyperparameter_tuning", "description": "Initiates the hyperparameter tuning process.", "parameters": {"type": "object", "properties": {"dataset_size": {"type": "integer", "description": "The size of the dataset."}, "target_precision": {"type": "number", "description": "The target precision."}, "algorithms": {"type": "array", "description": "The list of algorithms to use."}}, "required": ["dataset_size", "target_precision", "algorithms"], "additionalProperties": false}}], "mock_functions": "def configure_cloud_setup(cloud_provider: str, project_name: str) -> dict:\n    \"\"\"\n    Configures the cloud setup for a given project.\n\n    :param cloud_provider: The cloud provider (e.g., \"aws\", \"azure\").\n    :param project_name: The name of the project.\n    :return: \n        dict: A dictionary containing the configuration details.\n            - setup_status (str): Status of the setup (\"Completed\" or \"Failed\").\n            - resources_allocated (list[str]): List of resources allocated.\n    :raises ValueError: If invalid cloud provider or project name is provided.\n    \"\"\"\n    if not cloud_provider or not project_name:\n        raise ValueError(\"Cloud provider and project name must be provided.\")\n    if project_name == \"RecommendX\":\n        return {\n            \"setup_status\": \"Completed\",\n            \"resources_allocated\": [\"EC2 instances\", \"S3 storage\", \"Azure VMs\", \"Azure Blob Storage\"]\n        }\n    return {\"setup_status\": \"Failed\", \"resources_allocated\": []}\ndef initiate_hyperparameter_tuning(dataset_size: int, target_precision: float, algorithms: list) -> dict:\n    \"\"\"\n    Initiates the hyperparameter tuning process.\n\n    :param dataset_size: The size of the dataset.\n    :param target_precision: The target precision.\n    :param algorithms: The list of algorithms to use.\n    :return: \n        dict: A dictionary containing tuning information.\n            - status (str): Status of the tuning process (\"Started\" or \"Failed\").\n            - initial_hyperparameters (dict): Initial hyperparameters used.\n    :raises ValueError: If invalid parameters are provided.\n    \"\"\"\n    if dataset_size <= 0 or target_precision <= 0 or not algorithms:\n        raise ValueError(\"Invalid dataset size, target precision, or algorithms.\")\n    if dataset_size == 100000 and target_precision == 0.85 and \"recommendation_algorithm\" in algorithms:\n        return {\n            \"status\": \"Started\",\n            \"initial_hyperparameters\": {\"learning_rate\": 0.01, \"regularization\": 0.1}\n        }\n    return {\"status\": \"Failed\", \"initial_hyperparameters\": {}}", "user_query": "This is Mr. Liam Chen. Can you initiate hyperparameter tuning on our dataset of 100,000 customers with a target precision of 0.85, using \"recommendation_algorithm\"?", "checklist": {"functions": ["initiate_hyperparameter_tuning"], "values": [{"status": "Started", "initial_hyperparameters": {"learning_rate": 0.01, "regularization": 0.1}}]}}
{"difficulty": "easy", "function_schema_python": "def trace_token_transfers(start_date: str, end_date: str, threshold: int) -> list:\n    \"\"\"Traces token transfers between a given date range for amounts greater than a specified threshold.\n\n    :param start_date: The start date of the range in \"YYYY-MM-DD\" format.\n    :param end_date: The end date of the range in \"YYYY-MM-DD\" format.\n    :param threshold: The minimum transfer amount to include in the results.\n    :return: A list of dictionaries, each representing a token transfer with the following keys:\n        - sender (str): The address of the sender.\n        - receiver (str): The address of the receiver.\n        - amount (int): The amount of tokens transferred.\n        - timestamp (str): The timestamp of the transfer in \"YYYY-MM-DD HH:MM:SS\" format.\n    :raises ValueError: If the date range is invalid or if the threshold is not positive.\"\"\"\n    pass\ndef summarize_top_token_holders(limit: int) -> dict:\n    \"\"\"Summarizes the token balances for the top token holders.\n\n    :param limit: The number of top holders to include in the summary.\n    :return: A dictionary with the following keys:\n        - holders (list[dict]): A list of dictionaries for the top holders, each with the following keys:\n            - address (str): The address of the token holder.\n            - balance (int): The number of tokens held by the holder.\n    :raises ValueError: If the limit is not positive.\"\"\"\n    pass\n", "function_schema_json": [{"name": "trace_token_transfers", "description": "Traces token transfers between a given date range for amounts greater than a specified threshold.", "parameters": {"type": "object", "properties": {"start_date": {"type": "string", "description": "The start date of the range in \"YYYY-MM-DD\" format."}, "end_date": {"type": "string", "description": "The end date of the range in \"YYYY-MM-DD\" format."}, "threshold": {"type": "integer", "description": "The minimum transfer amount to include in the results."}}, "required": ["start_date", "end_date", "threshold"], "additionalProperties": false}}, {"name": "summarize_top_token_holders", "description": "Summarizes the token balances for the top token holders.", "parameters": {"type": "object", "properties": {"limit": {"type": "integer", "description": "The number of top holders to include in the summary."}}, "required": ["limit"], "additionalProperties": false}}], "mock_functions": "def trace_token_transfers(start_date: str, end_date: str, threshold: int) -> list:\n    \"\"\"\n    Traces token transfers between a given date range for amounts greater than a specified threshold.\n    \n    :param start_date: The start date of the range in \"YYYY-MM-DD\" format.\n    :param end_date: The end date of the range in \"YYYY-MM-DD\" format.\n    :param threshold: The minimum transfer amount to include in the results.\n    :return: A list of dictionaries, each representing a token transfer with the following keys:\n        - sender (str): The address of the sender.\n        - receiver (str): The address of the receiver.\n        - amount (int): The amount of tokens transferred.\n        - timestamp (str): The timestamp of the transfer in \"YYYY-MM-DD HH:MM:SS\" format.\n    :raises ValueError: If the date range is invalid or if the threshold is not positive.\n    \"\"\"\n    if start_date > end_date:\n        raise ValueError(\"Start date must be before or the same as end date.\")\n    if threshold <= 0:\n        raise ValueError(\"Threshold must be greater than zero.\")\n    \n    # Mock logic: Return a list of mock transfers\n    return [\n        {\"sender\": \"0x123\", \"receiver\": \"0x456\", \"amount\": 1500, \"timestamp\": \"2024-05-15 10:30:00\"},\n        {\"sender\": \"0x456\", \"receiver\": \"0x789\", \"amount\": 2000, \"timestamp\": \"2024-06-01 14:45:00\"},\n        {\"sender\": \"0x789\", \"receiver\": \"0x123\", \"amount\": 1200, \"timestamp\": \"2024-06-15 09:00:00\"}\n    ]\ndef summarize_top_token_holders(limit: int) -> dict:\n    \"\"\"\n    Summarizes the token balances for the top token holders.\n    \n    :param limit: The number of top holders to include in the summary.\n    :return: A dictionary with the following keys:\n        - holders (list[dict]): A list of dictionaries for the top holders, each with the following keys:\n            - address (str): The address of the token holder.\n            - balance (int): The number of tokens held by the holder.\n    :raises ValueError: If the limit is not positive.\n    \"\"\"\n    if limit <= 0:\n        raise ValueError(\"Limit must be greater than zero.\")\n    \n    # Mock logic: Return a summary of the top 10 token holders\n    return {\n        \"holders\": [\n            {\"address\": \"0x123\", \"balance\": 150000},\n            {\"address\": \"0x456\", \"balance\": 120000},\n            {\"address\": \"0x789\", \"balance\": 90000},\n            {\"address\": \"0x321\", \"balance\": 85000},\n            {\"address\": \"0x654\", \"balance\": 70000},\n            {\"address\": \"0x987\", \"balance\": 65000},\n            {\"address\": \"0x213\", \"balance\": 60000},\n            {\"address\": \"0x546\", \"balance\": 55000},\n            {\"address\": \"0x879\", \"balance\": 50000},\n            {\"address\": \"0x312\", \"balance\": 45000}\n        ]\n    }\n", "user_query": "Can you trace token transfers between 2024-05-01 and 2024-06-30 with amounts over 1000 SFCT?", "checklist": {"functions": ["trace_token_transfers"], "values": [[{"sender": "0x123", "receiver": "0x456", "amount": 1500, "timestamp": "2024-05-15 10:30:00"}, {"sender": "0x456", "receiver": "0x789", "amount": 2000, "timestamp": "2024-06-01 14:45:00"}, {"sender": "0x789", "receiver": "0x123", "amount": 1200, "timestamp": "2024-06-15 09:00:00"}]]}}
{"difficulty": "easy", "function_schema_python": "def get_token_transfers(token_symbol: str, start_date: str, end_date: str) -> dict:\n    \"\"\"Retrieves token transfer activity for a specified period.\n\n    :param token_symbol: The token symbol (e.g., 'GTS')\n    :param start_date: Start date in 'YYYY-MM-DD' format\n    :param end_date: End date in 'YYYY-MM-DD' format\n    :return: Dictionary containing transfer activities:\n        - purchases (list[dict]): List of purchase transactions\n        - sales (list[dict]): List of sale transactions\n        - transfers (list[dict]): List of transfer transactions\n        Each transaction contains:\n            - date (str): Transaction date\n            - amount (float): Token amount\n            - from_address (str): Sender address\n            - to_address (str): Receiver address\n    :raises ValueError: If dates are invalid or token symbol doesn't exist\"\"\"\n    pass\ndef get_top_token_holders(token_symbol: str, as_of_date: str, limit: int) -> dict:\n    \"\"\"Retrieves top token holders for a specific token as of a given date.\n\n    :param token_symbol: The token symbol (e.g., 'GTS')\n    :param as_of_date: Date in 'YYYY-MM-DD' format\n    :param limit: Number of top holders to retrieve\n    :return: Dictionary containing:\n        - holders (list[dict]): List of top holders with:\n            - address (str): Wallet address\n            - balance (float): Token balance\n            - percentage (float): Percentage of total supply\n        - total_supply (int): Total token supply\n    :raises ValueError: If token symbol doesn't exist or limit is invalid\"\"\"\n    pass\n", "function_schema_json": [{"name": "get_token_transfers", "description": "Retrieves token transfer activity for a specified period.", "parameters": {"type": "object", "properties": {"token_symbol": {"type": "string", "description": "The token symbol (e.g., 'GTS')"}, "start_date": {"type": "string", "description": "Start date in 'YYYY-MM-DD' format"}, "end_date": {"type": "string", "description": "End date in 'YYYY-MM-DD' format"}}, "required": ["token_symbol", "start_date", "end_date"], "additionalProperties": false}}, {"name": "get_top_token_holders", "description": "Retrieves top token holders for a specific token as of a given date.", "parameters": {"type": "object", "properties": {"token_symbol": {"type": "string", "description": "The token symbol (e.g., 'GTS')"}, "as_of_date": {"type": "string", "description": "Date in 'YYYY-MM-DD' format"}, "limit": {"type": "integer", "description": "Number of top holders to retrieve"}}, "required": ["token_symbol", "as_of_date", "limit"], "additionalProperties": false}}], "mock_functions": "def get_token_transfers(\n    token_symbol: str, \n    start_date: str, \n    end_date: str\n) -> dict:\n    \"\"\"\n    Retrieves token transfer activity for a specified period.\n    \n    :param token_symbol: The token symbol (e.g., 'GTS')\n    :param start_date: Start date in 'YYYY-MM-DD' format\n    :param end_date: End date in 'YYYY-MM-DD' format\n    :return: Dictionary containing transfer activities:\n        - purchases (list[dict]): List of purchase transactions\n        - sales (list[dict]): List of sale transactions\n        - transfers (list[dict]): List of transfer transactions\n        Each transaction contains:\n            - date (str): Transaction date\n            - amount (float): Token amount\n            - from_address (str): Sender address\n            - to_address (str): Receiver address\n    :raises ValueError: If dates are invalid or token symbol doesn't exist\n    \"\"\"\n    if token_symbol != \"GTS\":\n        raise ValueError(\"Invalid token symbol\")\n    \n    if start_date == \"2024-07-01\" and end_date == \"2024-07-31\":\n        return {\n            \"purchases\": [\n                {\"date\": \"2024-07-15\", \"amount\": 50000, \n                 \"from_address\": \"0x123\", \"to_address\": \"0x456\"},\n            ],\n            \"sales\": [\n                {\"date\": \"2024-07-20\", \"amount\": 25000, \n                 \"from_address\": \"0x789\", \"to_address\": \"0xabc\"},\n            ],\n            \"transfers\": [\n                {\"date\": \"2024-07-25\", \"amount\": 75000, \n                 \"from_address\": \"0xdef\", \"to_address\": \"0xghi\"},\n            ]\n        }\n    return {}\ndef get_top_token_holders(\n    token_symbol: str, \n    as_of_date: str, \n    limit: int\n) -> dict:\n    \"\"\"\n    Retrieves top token holders for a specific token as of a given date.\n    \n    :param token_symbol: The token symbol (e.g., 'GTS')\n    :param as_of_date: Date in 'YYYY-MM-DD' format\n    :param limit: Number of top holders to retrieve\n    :return: Dictionary containing:\n        - holders (list[dict]): List of top holders with:\n            - address (str): Wallet address\n            - balance (float): Token balance\n            - percentage (float): Percentage of total supply\n        - total_supply (int): Total token supply\n    :raises ValueError: If token symbol doesn't exist or limit is invalid\n    \"\"\"\n    if token_symbol != \"GTS\" or limit <= 0:\n        raise ValueError(\"Invalid parameters\")\n    \n    if as_of_date == \"2024-07-31\" and limit == 20:\n        return {\n            \"holders\": [\n                {\"address\": \"0x123\", \"balance\": 1000000, \"percentage\": 20.0},\n                {\"address\": \"0x456\", \"balance\": 750000, \"percentage\": 15.0}\n            ],\n            \"total_supply\": 5000000\n        }\n    return {}", "user_query": "What were the GTS token transfers between 2024-07-01 and 2024-07-31?", "checklist": {"functions": ["get_token_transfers"], "values": [{"purchases": [{"date": "2024-07-15", "amount": 50000, "from_address": "0x123", "to_address": "0x456"}], "sales": [{"date": "2024-07-20", "amount": 25000, "from_address": "0x789", "to_address": "0xabc"}], "transfers": [{"date": "2024-07-25", "amount": 75000, "from_address": "0xdef", "to_address": "0xghi"}]}]}}
{"difficulty": "easy", "function_schema_python": "def get_token_transfers(token_symbol: str, start_date: str, end_date: str) -> dict:\n    \"\"\"Retrieves token transfer activity for a specified period.\n\n    :param token_symbol: The token symbol (e.g., 'GTS')\n    :param start_date: Start date in 'YYYY-MM-DD' format\n    :param end_date: End date in 'YYYY-MM-DD' format\n    :return: Dictionary containing transfer activities:\n        - purchases (list[dict]): List of purchase transactions\n        - sales (list[dict]): List of sale transactions\n        - transfers (list[dict]): List of transfer transactions\n        Each transaction contains:\n            - date (str): Transaction date\n            - amount (float): Token amount\n            - from_address (str): Sender address\n            - to_address (str): Receiver address\n    :raises ValueError: If dates are invalid or token symbol doesn't exist\"\"\"\n    pass\ndef get_top_token_holders(token_symbol: str, as_of_date: str, limit: int) -> dict:\n    \"\"\"Retrieves top token holders for a specific token as of a given date.\n\n    :param token_symbol: The token symbol (e.g., 'GTS')\n    :param as_of_date: Date in 'YYYY-MM-DD' format\n    :param limit: Number of top holders to retrieve\n    :return: Dictionary containing:\n        - holders (list[dict]): List of top holders with:\n            - address (str): Wallet address\n            - balance (float): Token balance\n            - percentage (float): Percentage of total supply\n        - total_supply (int): Total token supply\n    :raises ValueError: If token symbol doesn't exist or limit is invalid\"\"\"\n    pass\n", "function_schema_json": [{"name": "get_token_transfers", "description": "Retrieves token transfer activity for a specified period.", "parameters": {"type": "object", "properties": {"token_symbol": {"type": "string", "description": "The token symbol (e.g., 'GTS')"}, "start_date": {"type": "string", "description": "Start date in 'YYYY-MM-DD' format"}, "end_date": {"type": "string", "description": "End date in 'YYYY-MM-DD' format"}}, "required": ["token_symbol", "start_date", "end_date"], "additionalProperties": false}}, {"name": "get_top_token_holders", "description": "Retrieves top token holders for a specific token as of a given date.", "parameters": {"type": "object", "properties": {"token_symbol": {"type": "string", "description": "The token symbol (e.g., 'GTS')"}, "as_of_date": {"type": "string", "description": "Date in 'YYYY-MM-DD' format"}, "limit": {"type": "integer", "description": "Number of top holders to retrieve"}}, "required": ["token_symbol", "as_of_date", "limit"], "additionalProperties": false}}], "mock_functions": "def get_token_transfers(\n    token_symbol: str, \n    start_date: str, \n    end_date: str\n) -> dict:\n    \"\"\"\n    Retrieves token transfer activity for a specified period.\n    \n    :param token_symbol: The token symbol (e.g., 'GTS')\n    :param start_date: Start date in 'YYYY-MM-DD' format\n    :param end_date: End date in 'YYYY-MM-DD' format\n    :return: Dictionary containing transfer activities:\n        - purchases (list[dict]): List of purchase transactions\n        - sales (list[dict]): List of sale transactions\n        - transfers (list[dict]): List of transfer transactions\n        Each transaction contains:\n            - date (str): Transaction date\n            - amount (float): Token amount\n            - from_address (str): Sender address\n            - to_address (str): Receiver address\n    :raises ValueError: If dates are invalid or token symbol doesn't exist\n    \"\"\"\n    if token_symbol != \"GTS\":\n        raise ValueError(\"Invalid token symbol\")\n    \n    if start_date == \"2024-07-01\" and end_date == \"2024-07-31\":\n        return {\n            \"purchases\": [\n                {\"date\": \"2024-07-15\", \"amount\": 50000, \n                 \"from_address\": \"0x123\", \"to_address\": \"0x456\"},\n            ],\n            \"sales\": [\n                {\"date\": \"2024-07-20\", \"amount\": 25000, \n                 \"from_address\": \"0x789\", \"to_address\": \"0xabc\"},\n            ],\n            \"transfers\": [\n                {\"date\": \"2024-07-25\", \"amount\": 75000, \n                 \"from_address\": \"0xdef\", \"to_address\": \"0xghi\"},\n            ]\n        }\n    return {}\ndef get_top_token_holders(\n    token_symbol: str, \n    as_of_date: str, \n    limit: int\n) -> dict:\n    \"\"\"\n    Retrieves top token holders for a specific token as of a given date.\n    \n    :param token_symbol: The token symbol (e.g., 'GTS')\n    :param as_of_date: Date in 'YYYY-MM-DD' format\n    :param limit: Number of top holders to retrieve\n    :return: Dictionary containing:\n        - holders (list[dict]): List of top holders with:\n            - address (str): Wallet address\n            - balance (float): Token balance\n            - percentage (float): Percentage of total supply\n        - total_supply (int): Total token supply\n    :raises ValueError: If token symbol doesn't exist or limit is invalid\n    \"\"\"\n    if token_symbol != \"GTS\" or limit <= 0:\n        raise ValueError(\"Invalid parameters\")\n    \n    if as_of_date == \"2024-07-31\" and limit == 20:\n        return {\n            \"holders\": [\n                {\"address\": \"0x123\", \"balance\": 1000000, \"percentage\": 20.0},\n                {\"address\": \"0x456\", \"balance\": 750000, \"percentage\": 15.0}\n            ],\n            \"total_supply\": 5000000\n        }\n    return {}", "user_query": "Bob from BlockChain Investments needs top 20 GTS token holders as of 2024-07-31.", "checklist": {"functions": ["get_top_token_holders"], "values": [{"holders": [{"address": "0x123", "balance": 1000000, "percentage": 20.0}, {"address": "0x456", "balance": 750000, "percentage": 15.0}], "total_supply": 5000000}]}}
{"difficulty": "easy", "function_schema_python": "def fine_tune_model(model_name: str, data_path: str) -> dict:\n    \"\"\"Fine-tunes a machine learning model using the provided data.\n\n    :param model_name: The name of the model to fine-tune (e.g., \"BankGuard\").\n    :param data_path: The file path to the data used for fine-tuning.\n    :return:\n        dict: A dictionary with the following keys:\n            - success (bool): Flag indicating if the fine-tuning was successful.\n            - message (str): A status message.\n    :raises ValueError: If model_name or data_path is empty.\"\"\"\n    pass\ndef integrate_model_with_pentest(model_name: str, pen_test_tools: list) -> dict:\n    \"\"\"Integrates a machine learning model with traditional pentesting tools.\n\n    :param model_name: The name of the model to integrate (e.g., \"BankGuard\").\n    :param pen_test_tools: A list of traditional pentesting tools to integrate with.\n    :return:\n        dict: A dictionary with the following keys:\n            - success (bool): Flag indicating if the integration was successful.\n            - message (str): A status message.\n    :raises ValueError: If model_name is empty or pen_test_tools is not a list or is empty.\"\"\"\n    pass\ndef validate_model(model_name: str, test_data_path: str) -> dict:\n    \"\"\"Validates the accuracy of a machine learning model using test data.\n\n    :param model_name: The name of the model to validate (e.g., \"BankGuard\").\n    :param test_data_path: The file path to the test data.\n    :return:\n        dict: A dictionary with the following keys:\n            - success (bool): Flag indicating if the validation was successful.\n            - accuracy (float): The accuracy of the model (0.0 to 1.0).\n            - message (str): A status message.\n    :raises ValueError: If model_name or test_data_path is empty.\"\"\"\n    pass\ndef generate_attack_vectors(tool_name: str, target_url: str) -> list:\n    \"\"\"Generates attack vectors for a target using a specified pentesting tool.\n\n    :param tool_name: The name of the pentesting tool to use (e.g., \"nmap\").\n    :param target_url: The URL of the target to generate attack vectors for.\n    :return:\n        list: A list of generated attack vectors.\n    :raises ValueError: If tool_name or target_url is empty.\"\"\"\n    pass\ndef log_results_to_mlflow(model_name: str, results: dict) -> bool:\n    \"\"\"Logs the results of a machine learning model to MLflow.\n\n    :param model_name: The name of the model whose results are being logged.\n    :param results: A dictionary containing the results to log.\n    :return: True if the logging was successful, False otherwise.\n    :raises ValueError: If model_name is empty or results is not a dictionary.\"\"\"\n    pass\n", "function_schema_json": [{"name": "fine_tune_model", "description": "Fine-tunes a machine learning model using the provided data.", "parameters": {"type": "object", "properties": {"model_name": {"type": "string", "description": "The name of the model to fine-tune (e.g., \"BankGuard\")."}, "data_path": {"type": "string", "description": "The file path to the data used for fine-tuning."}}, "required": ["model_name", "data_path"], "additionalProperties": false}}, {"name": "integrate_model_with_pentest", "description": "Integrates a machine learning model with traditional pentesting tools.", "parameters": {"type": "object", "properties": {"model_name": {"type": "string", "description": "The name of the model to integrate (e.g., \"BankGuard\")."}, "pen_test_tools": {"type": "array", "description": "A list of traditional pentesting tools to integrate with."}}, "required": ["model_name", "pen_test_tools"], "additionalProperties": false}}, {"name": "validate_model", "description": "Validates the accuracy of a machine learning model using test data.", "parameters": {"type": "object", "properties": {"model_name": {"type": "string", "description": "The name of the model to validate (e.g., \"BankGuard\")."}, "test_data_path": {"type": "string", "description": "The file path to the test data."}}, "required": ["model_name", "test_data_path"], "additionalProperties": false}}, {"name": "generate_attack_vectors", "description": "Generates attack vectors for a target using a specified pentesting tool.", "parameters": {"type": "object", "properties": {"tool_name": {"type": "string", "description": "The name of the pentesting tool to use (e.g., \"nmap\")."}, "target_url": {"type": "string", "description": "The URL of the target to generate attack vectors for."}}, "required": ["tool_name", "target_url"], "additionalProperties": false}}, {"name": "log_results_to_mlflow", "description": "Logs the results of a machine learning model to MLflow.", "parameters": {"type": "object", "properties": {"model_name": {"type": "string", "description": "The name of the model whose results are being logged."}, "results": {"type": "object", "description": "A dictionary containing the results to log."}}, "required": ["model_name", "results"], "additionalProperties": false}}], "mock_functions": "def fine_tune_model(model_name: str, data_path: str) -> dict:\n    \"\"\"\n    Fine-tunes a machine learning model using the provided data.\n    \n    :param model_name: The name of the model to fine-tune (e.g., \"BankGuard\").\n    :param data_path: The file path to the data used for fine-tuning.\n    :return:\n        dict: A dictionary with the following keys:\n            - success (bool): Flag indicating if the fine-tuning was successful.\n            - message (str): A status message.\n    :raises ValueError: If model_name or data_path is empty.\n    \"\"\"\n    if not model_name or not data_path:\n        raise ValueError(\"Model name and data path must be provided.\")\n    if model_name.lower() == \"bankguard\" and data_path.lower() == \"path/to/data.csv\":\n        return {\n            \"success\": True,\n            \"message\": \"Model BankGuard fine-tuned successfully.\"\n        }\n    return {\n        \"success\": False,\n        \"message\": \"Failed to fine-tune model.\"\n    }\ndef integrate_model_with_pentest(model_name: str, pen_test_tools: list) -> dict:\n    \"\"\"\n    Integrates a machine learning model with traditional pentesting tools.\n    \n    :param model_name: The name of the model to integrate (e.g., \"BankGuard\").\n    :param pen_test_tools: A list of traditional pentesting tools to integrate with.\n    :return:\n        dict: A dictionary with the following keys:\n            - success (bool): Flag indicating if the integration was successful.\n            - message (str): A status message.\n    :raises ValueError: If model_name is empty or pen_test_tools is not a list or is empty.\n    \"\"\"\n    if not model_name:\n        raise ValueError(\"Model name must be provided.\")\n    if not isinstance(pen_test_tools, list) or not pen_test_tools:\n        raise ValueError(\"Pentesting tools must be provided in a non-empty list.\")\n    if model_name.lower() == \"bankguard\" and pen_test_tools == [\"nmap\", \"metasploit\"]:\n        return {\n            \"success\": True,\n            \"message\": \"Model BankGuard integrated with nmap and metasploit successfully.\"\n        }\n    return {\n        \"success\": False,\n        \"message\": \"Failed to integrate model.\"\n    }\ndef validate_model(model_name: str, test_data_path: str) -> dict:\n    \"\"\"\n    Validates the accuracy of a machine learning model using test data.\n    \n    :param model_name: The name of the model to validate (e.g., \"BankGuard\").\n    :param test_data_path: The file path to the test data.\n    :return:\n        dict: A dictionary with the following keys:\n            - success (bool): Flag indicating if the validation was successful.\n            - accuracy (float): The accuracy of the model (0.0 to 1.0).\n            - message (str): A status message.\n    :raises ValueError: If model_name or test_data_path is empty.\n    \"\"\"\n    if not model_name or not test_data_path:\n        raise ValueError(\"Model name and test data path must be provided.\")\n    if model_name.lower() == \"bankguard\" and test_data_path.lower() == \"path/to/test_data.csv\":\n        return {\n            \"success\": True,\n            \"accuracy\": 0.92,\n            \"message\": \"Model BankGuard validated successfully with 92% accuracy.\"\n        }\n    return {\n        \"success\": False,\n        \"accuracy\": 0.0,\n        \"message\": \"Failed to validate model.\"\n    }\ndef generate_attack_vectors(tool_name: str, target_url: str) -> list:\n    \"\"\"\n    Generates attack vectors for a target using a specified pentesting tool.\n    \n    :param tool_name: The name of the pentesting tool to use (e.g., \"nmap\").\n    :param target_url: The URL of the target to generate attack vectors for.\n    :return:\n        list: A list of generated attack vectors.\n    :raises ValueError: If tool_name or target_url is empty.\n    \"\"\"\n    if not tool_name or not target_url:\n        raise ValueError(\"Tool name and target URL must be provided.\")\n    if tool_name.lower() == \"nmap\" and target_url.lower() == \"https://onlinebanking.banksafe.com\":\n        return [\n            \"Nmap scan of HTTPS service on https://onlinebanking.banksafe.com\",\n            \"Detected open port 443 (HTTPS)\",\n            \"Service version: Apache/2.4.41 (Ubuntu)\"\n        ]\n    return []\ndef log_results_to_mlflow(model_name: str, results: dict) -> bool:\n    \"\"\"\n    Logs the results of a machine learning model to MLflow.\n    \n    :param model_name: The name of the model whose results are being logged.\n    :param results: A dictionary containing the results to log.\n    :return: True if the logging was successful, False otherwise.\n    :raises ValueError: If model_name is empty or results is not a dictionary.\n    \"\"\"\n    if not model_name:\n        raise ValueError(\"Model name must be provided.\")\n    if not isinstance(results, dict):\n        raise ValueError(\"Results must be provided in a dictionary.\")\n    if model_name.lower() == \"bankguard\" and isinstance(results, dict):\n        return True\n    return False", "user_query": "Can you validate the BankGuard model using test data from path/to/test_data.csv?", "checklist": {"functions": ["validate_model"], "values": [{"success": true, "accuracy": 0.92, "message": "Model BankGuard validated successfully with 92% accuracy."}]}}
{"difficulty": "easy", "function_schema_python": "def get_pending_orders(system: str) -> int:\n    \"\"\"Retrieves the number of pending orders from the specified system.\n\n    :param system: The name of the order management system (e.g., \"Order Fulfillment Orchestrator\").\n    :return: The number of pending orders.\n    :raises ValueError: If the system name is invalid.\"\"\"\n    pass\ndef get_fulfillment_center_capacity(center_id: str) -> float:\n    \"\"\"Retrieves the current operating capacity of a fulfillment center.\n\n    :param center_id: The ID of the fulfillment center (e.g., \"FC-West\").\n    :return: The operating capacity as a percentage (e.g., 0.85 for 85%).\n    :raises ValueError: If the center ID is invalid.\"\"\"\n    pass\ndef get_inventory_levels(product_id: str, fulfillment_center_id: str) -> int:\n    \"\"\"Retrieves the inventory level of a specific product at a given fulfillment center.\n\n    :param product_id: The ID of the product.\n    :param fulfillment_center_id: The ID of the fulfillment center.\n    :return: The current inventory level.\n    :raises ValueError: If the product ID or fulfillment center ID is invalid.\"\"\"\n    pass\ndef optimize_order_distribution(orders: int, fulfillment_centers: List[str], inventory_levels: Dict[str, int], capacities: Dict[str, float]) -> Dict[str, int]:\n    \"\"\"Optimizes the distribution of orders across fulfillment centers.\n\n    :param orders: The total number of orders to distribute.\n    :param fulfillment_centers: A list of fulfillment center IDs.\n    :param inventory_levels: A dictionary mapping fulfillment center IDs to inventory levels.\n    :param capacities: A dictionary mapping fulfillment center IDs to operating capacities.\n    :return: A dictionary mapping fulfillment center IDs to the number of orders assigned to each.\"\"\"\n    pass\n", "function_schema_json": [{"name": "get_pending_orders", "description": "Retrieves the number of pending orders from the specified system.", "parameters": {"type": "object", "properties": {"system": {"type": "string", "description": "The name of the order management system (e.g., \"Order Fulfillment Orchestrator\")."}}, "required": ["system"], "additionalProperties": false}}, {"name": "get_fulfillment_center_capacity", "description": "Retrieves the current operating capacity of a fulfillment center.", "parameters": {"type": "object", "properties": {"center_id": {"type": "string", "description": "The ID of the fulfillment center (e.g., \"FC-West\")."}}, "required": ["center_id"], "additionalProperties": false}}, {"name": "get_inventory_levels", "description": "Retrieves the inventory level of a specific product at a given fulfillment center.", "parameters": {"type": "object", "properties": {"product_id": {"type": "string", "description": "The ID of the product."}, "fulfillment_center_id": {"type": "string", "description": "The ID of the fulfillment center."}}, "required": ["product_id", "fulfillment_center_id"], "additionalProperties": false}}, {"name": "optimize_order_distribution", "description": "Optimizes the distribution of orders across fulfillment centers.", "parameters": {"type": "object", "properties": {"orders": {"type": "integer", "description": "The total number of orders to distribute."}, "fulfillment_centers": {"type": "array", "items": {"type": "string"}, "description": "A list of fulfillment center IDs."}, "inventory_levels": {"type": "object", "description": "A dictionary mapping fulfillment center IDs to inventory levels."}, "capacities": {"type": "object", "description": "A dictionary mapping fulfillment center IDs to operating capacities."}}, "required": ["orders", "fulfillment_centers", "inventory_levels", "capacities"], "additionalProperties": false}}], "mock_functions": "def get_pending_orders(system: str) -> int:\n    \"\"\"\n    Retrieves the number of pending orders from the specified system.\n\n    :param system: The name of the order management system (e.g., \"Order Fulfillment Orchestrator\").\n    :return: The number of pending orders.\n    :raises ValueError: If the system name is invalid.\n    \"\"\"\n    if system == \"Order Fulfillment Orchestrator\":\n        return 2500\n    raise ValueError(\"Invalid system name.\")\ndef get_fulfillment_center_capacity(center_id: str) -> float:\n    \"\"\"\n    Retrieves the current operating capacity of a fulfillment center.\n\n    :param center_id: The ID of the fulfillment center (e.g., \"FC-West\").\n    :return: The operating capacity as a percentage (e.g., 0.85 for 85%).\n    :raises ValueError: If the center ID is invalid.\n    \"\"\"\n    capacities = {\n        \"FC-West\": 0.85,\n        \"FC-Central\": 0.60,\n        \"FC-East\": 0.75,\n    }\n    if center_id in capacities:\n        return capacities[center_id]\n    raise ValueError(\"Invalid fulfillment center ID.\")\ndef get_inventory_levels(product_id: str, fulfillment_center_id: str) -> int:\n    \"\"\"\n    Retrieves the inventory level of a specific product at a given fulfillment center.\n\n    :param product_id: The ID of the product.\n    :param fulfillment_center_id: The ID of the fulfillment center.\n    :return: The current inventory level.\n    :raises ValueError: If the product ID or fulfillment center ID is invalid.\n    \"\"\"\n    if product_id == \"GT-500\" and fulfillment_center_id in [\"FC-West\", \"FC-Central\", \"FC-East\"]:\n        # Mock inventory levels\n        inventory = {\n            \"FC-West\": 500,\n            \"FC-Central\": 1200,\n            \"FC-East\": 800,\n        }\n        return inventory[fulfillment_center_id]\n    raise ValueError(\"Invalid product or fulfillment center ID.\")\ndef optimize_order_distribution(orders: int, fulfillment_centers: List[str], inventory_levels: Dict[str, int], capacities: Dict[str, float]) -> Dict[str, int]:\n    \"\"\"\n    Optimizes the distribution of orders across fulfillment centers.\n\n    :param orders: The total number of orders to distribute.\n    :param fulfillment_centers: A list of fulfillment center IDs.\n    :param inventory_levels: A dictionary mapping fulfillment center IDs to inventory levels.\n    :param capacities: A dictionary mapping fulfillment center IDs to operating capacities.\n    :return: A dictionary mapping fulfillment center IDs to the number of orders assigned to each.\n    \"\"\"\n    if orders == 2500 and fulfillment_centers == [\"FC-West\", \"FC-Central\", \"FC-East\"] and isinstance(inventory_levels, dict) and isinstance(capacities, dict) :\n        return {\n            \"FC-West\": 700,\n            \"FC-Central\": 1000,\n            \"FC-East\": 800,\n        }\n    return {}", "user_query": "How many pending orders are there in the Order Fulfillment Orchestrator system?", "checklist": {"functions": ["get_pending_orders"], "values": [2500]}}
{"difficulty": "easy", "function_schema_python": "def get_pending_orders(system: str) -> int:\n    \"\"\"Retrieves the number of pending orders from the specified system.\n\n    :param system: The name of the order management system (e.g., \"Order Fulfillment Orchestrator\").\n    :return: The number of pending orders.\n    :raises ValueError: If the system name is invalid.\"\"\"\n    pass\ndef get_fulfillment_center_capacity(center_id: str) -> float:\n    \"\"\"Retrieves the current operating capacity of a fulfillment center.\n\n    :param center_id: The ID of the fulfillment center (e.g., \"FC-West\").\n    :return: The operating capacity as a percentage (e.g., 0.85 for 85%).\n    :raises ValueError: If the center ID is invalid.\"\"\"\n    pass\ndef get_inventory_levels(product_id: str, fulfillment_center_id: str) -> int:\n    \"\"\"Retrieves the inventory level of a specific product at a given fulfillment center.\n\n    :param product_id: The ID of the product.\n    :param fulfillment_center_id: The ID of the fulfillment center.\n    :return: The current inventory level.\n    :raises ValueError: If the product ID or fulfillment center ID is invalid.\"\"\"\n    pass\ndef optimize_order_distribution(orders: int, fulfillment_centers: List[str], inventory_levels: Dict[str, int], capacities: Dict[str, float]) -> Dict[str, int]:\n    \"\"\"Optimizes the distribution of orders across fulfillment centers.\n\n    :param orders: The total number of orders to distribute.\n    :param fulfillment_centers: A list of fulfillment center IDs.\n    :param inventory_levels: A dictionary mapping fulfillment center IDs to inventory levels.\n    :param capacities: A dictionary mapping fulfillment center IDs to operating capacities.\n    :return: A dictionary mapping fulfillment center IDs to the number of orders assigned to each.\"\"\"\n    pass\n", "function_schema_json": [{"name": "get_pending_orders", "description": "Retrieves the number of pending orders from the specified system.", "parameters": {"type": "object", "properties": {"system": {"type": "string", "description": "The name of the order management system (e.g., \"Order Fulfillment Orchestrator\")."}}, "required": ["system"], "additionalProperties": false}}, {"name": "get_fulfillment_center_capacity", "description": "Retrieves the current operating capacity of a fulfillment center.", "parameters": {"type": "object", "properties": {"center_id": {"type": "string", "description": "The ID of the fulfillment center (e.g., \"FC-West\")."}}, "required": ["center_id"], "additionalProperties": false}}, {"name": "get_inventory_levels", "description": "Retrieves the inventory level of a specific product at a given fulfillment center.", "parameters": {"type": "object", "properties": {"product_id": {"type": "string", "description": "The ID of the product."}, "fulfillment_center_id": {"type": "string", "description": "The ID of the fulfillment center."}}, "required": ["product_id", "fulfillment_center_id"], "additionalProperties": false}}, {"name": "optimize_order_distribution", "description": "Optimizes the distribution of orders across fulfillment centers.", "parameters": {"type": "object", "properties": {"orders": {"type": "integer", "description": "The total number of orders to distribute."}, "fulfillment_centers": {"type": "array", "items": {"type": "string"}, "description": "A list of fulfillment center IDs."}, "inventory_levels": {"type": "object", "description": "A dictionary mapping fulfillment center IDs to inventory levels."}, "capacities": {"type": "object", "description": "A dictionary mapping fulfillment center IDs to operating capacities."}}, "required": ["orders", "fulfillment_centers", "inventory_levels", "capacities"], "additionalProperties": false}}], "mock_functions": "def get_pending_orders(system: str) -> int:\n    \"\"\"\n    Retrieves the number of pending orders from the specified system.\n\n    :param system: The name of the order management system (e.g., \"Order Fulfillment Orchestrator\").\n    :return: The number of pending orders.\n    :raises ValueError: If the system name is invalid.\n    \"\"\"\n    if system == \"Order Fulfillment Orchestrator\":\n        return 2500\n    raise ValueError(\"Invalid system name.\")\ndef get_fulfillment_center_capacity(center_id: str) -> float:\n    \"\"\"\n    Retrieves the current operating capacity of a fulfillment center.\n\n    :param center_id: The ID of the fulfillment center (e.g., \"FC-West\").\n    :return: The operating capacity as a percentage (e.g., 0.85 for 85%).\n    :raises ValueError: If the center ID is invalid.\n    \"\"\"\n    capacities = {\n        \"FC-West\": 0.85,\n        \"FC-Central\": 0.60,\n        \"FC-East\": 0.75,\n    }\n    if center_id in capacities:\n        return capacities[center_id]\n    raise ValueError(\"Invalid fulfillment center ID.\")\ndef get_inventory_levels(product_id: str, fulfillment_center_id: str) -> int:\n    \"\"\"\n    Retrieves the inventory level of a specific product at a given fulfillment center.\n\n    :param product_id: The ID of the product.\n    :param fulfillment_center_id: The ID of the fulfillment center.\n    :return: The current inventory level.\n    :raises ValueError: If the product ID or fulfillment center ID is invalid.\n    \"\"\"\n    if product_id == \"GT-500\" and fulfillment_center_id in [\"FC-West\", \"FC-Central\", \"FC-East\"]:\n        # Mock inventory levels\n        inventory = {\n            \"FC-West\": 500,\n            \"FC-Central\": 1200,\n            \"FC-East\": 800,\n        }\n        return inventory[fulfillment_center_id]\n    raise ValueError(\"Invalid product or fulfillment center ID.\")\ndef optimize_order_distribution(orders: int, fulfillment_centers: List[str], inventory_levels: Dict[str, int], capacities: Dict[str, float]) -> Dict[str, int]:\n    \"\"\"\n    Optimizes the distribution of orders across fulfillment centers.\n\n    :param orders: The total number of orders to distribute.\n    :param fulfillment_centers: A list of fulfillment center IDs.\n    :param inventory_levels: A dictionary mapping fulfillment center IDs to inventory levels.\n    :param capacities: A dictionary mapping fulfillment center IDs to operating capacities.\n    :return: A dictionary mapping fulfillment center IDs to the number of orders assigned to each.\n    \"\"\"\n    if orders == 2500 and fulfillment_centers == [\"FC-West\", \"FC-Central\", \"FC-East\"] and isinstance(inventory_levels, dict) and isinstance(capacities, dict) :\n        return {\n            \"FC-West\": 700,\n            \"FC-Central\": 1000,\n            \"FC-East\": 800,\n        }\n    return {}", "user_query": "Can you retrieve the current inventory levels of the GT-500 model in the FC-Central fulfillment center?", "checklist": {"functions": ["get_inventory_levels"], "values": [1200]}}
{"difficulty": "easy", "function_schema_python": "def check_distribution_center_capacity(dc_id: str) -> dict:\n    \"\"\"Checks the current capacity and status of a distribution center.\n\n    :param dc_id: Distribution center ID (e.g., 'DC-101')\n    :return: Dictionary containing capacity info and location\n    :raises ValueError: If invalid DC ID is provided\"\"\"\n    pass\ndef verify_temperature_compliance(current_temp: float) -> bool:\n    \"\"\"Verifies if the current temperature meets the required range (34-38\u00b0F).\n\n    :param current_temp: Current temperature in Fahrenheit\n    :return: Boolean indicating if temperature is within acceptable range\"\"\"\n    pass\ndef calculate_order_reallocation(orders: int, dc_capacities: dict) -> dict:\n    \"\"\"Calculates optimal order reallocation between available distribution centers.\n\n    :param orders: Number of orders to reallocate\n    :param dc_capacities: Dictionary containing DC capacities\n    :return: Dictionary with allocation distribution\n    :raises ValueError: If total capacity is insufficient\"\"\"\n    pass\ndef estimate_delivery_time(dc_id: str, destination_zip: str) -> dict:\n    \"\"\"Estimates delivery time from distribution center to destination.\n\n    :param dc_id: Distribution center ID\n    :param destination_zip: Destination ZIP code\n    :return: Dictionary containing delivery estimates\n    :raises ValueError: If invalid DC ID or ZIP code\"\"\"\n    pass\n", "function_schema_json": [{"name": "check_distribution_center_capacity", "description": "Checks the current capacity and status of a distribution center.", "parameters": {"type": "object", "properties": {"dc_id": {"type": "string", "description": "Distribution center ID (e.g., 'DC-101')"}}, "required": ["dc_id"], "additionalProperties": false}}, {"name": "verify_temperature_compliance", "description": "Verifies if the current temperature meets the required range (34-38\u00b0F).", "parameters": {"type": "object", "properties": {"current_temp": {"type": "number", "description": "Current temperature in Fahrenheit"}}, "required": ["current_temp"], "additionalProperties": false}}, {"name": "calculate_order_reallocation", "description": "Calculates optimal order reallocation between available distribution centers.", "parameters": {"type": "object", "properties": {"orders": {"type": "integer", "description": "Number of orders to reallocate"}, "dc_capacities": {"type": "object", "description": "Dictionary containing DC capacities"}}, "required": ["orders", "dc_capacities"], "additionalProperties": false}}, {"name": "estimate_delivery_time", "description": "Estimates delivery time from distribution center to destination.", "parameters": {"type": "object", "properties": {"dc_id": {"type": "string", "description": "Distribution center ID"}, "destination_zip": {"type": "string", "description": "Destination ZIP code"}}, "required": ["dc_id", "destination_zip"], "additionalProperties": false}}], "mock_functions": "def check_distribution_center_capacity(dc_id: str) -> dict:\n    \"\"\"\n    Checks the current capacity and status of a distribution center.\n    \n    :param dc_id: Distribution center ID (e.g., 'DC-101')\n    :return: Dictionary containing capacity info and location\n    :raises ValueError: If invalid DC ID is provided\n    \"\"\"\n    dc_data = {\n        \"DC-101\": {\"available_capacity\": 0.40, \"location\": \"Phoenix\", \"status\": \"operational\"},\n        \"DC-102\": {\"available_capacity\": 0.25, \"location\": \"Dallas\", \"status\": \"operational\"},\n        \"DC-103\": {\"available_capacity\": 0.00, \"location\": \"Houston\", \"status\": \"failure\"}\n    }\n    if dc_id not in dc_data:\n        raise ValueError(\"Invalid distribution center ID\")\n    return dc_data[dc_id]\ndef verify_temperature_compliance(current_temp: float) -> bool:\n    \"\"\"\n    Verifies if the current temperature meets the required range (34-38\u00b0F).\n    \n    :param current_temp: Current temperature in Fahrenheit\n    :return: Boolean indicating if temperature is within acceptable range\n    \"\"\"\n    return 34.0 <= current_temp <= 38.0\ndef calculate_order_reallocation(orders: int, dc_capacities: dict) -> dict:\n    \"\"\"\n    Calculates optimal order reallocation between available distribution centers.\n    \n    :param orders: Number of orders to reallocate\n    :param dc_capacities: Dictionary containing DC capacities\n    :return: Dictionary with allocation distribution\n    :raises ValueError: If total capacity is insufficient\n    \"\"\"\n    if not isinstance(orders, int) or orders <= 0:\n        raise ValueError(\"Invalid order count\")\n    \n    # Mock calculation based on capacity ratios\n    total_capacity = dc_capacities[\"DC-101\"][\"available_capacity\"] + dc_capacities[\"DC-102\"][\"available_capacity\"]\n    if total_capacity < 0.50:  # Minimum required capacity\n        raise ValueError(\"Insufficient capacity for reallocation\")\n        \n    return {\n        \"DC-101\": int(orders * 0.60),  # 60% to Phoenix due to higher capacity\n        \"DC-102\": int(orders * 0.40)   # 40% to Dallas\n    }\ndef estimate_delivery_time(dc_id: str, destination_zip: str) -> dict:\n    \"\"\"\n    Estimates delivery time from distribution center to destination.\n    \n    :param dc_id: Distribution center ID\n    :param destination_zip: Destination ZIP code\n    :return: Dictionary containing delivery estimates\n    :raises ValueError: If invalid DC ID or ZIP code\n    \"\"\"\n    if not dc_id.startswith(\"DC-\") or not destination_zip.isdigit():\n        raise ValueError(\"Invalid DC ID or ZIP code\")\n    \n    # Mock delivery time estimates\n    delivery_times = {\n        \"DC-101\": {\"estimated_hours\": 3.5, \"route_status\": \"optimal\"},\n        \"DC-102\": {\"estimated_hours\": 2.8, \"route_status\": \"optimal\"}\n    }\n    \n    if dc_id not in delivery_times:\n        raise ValueError(\"Invalid distribution center\")\n    return delivery_times[dc_id]", "user_query": "Can you check the current capacity for distribution centers DC-101 and DC-102?", "checklist": {"functions": ["check_distribution_center_capacity"], "values": [{"available_capacity": 0.4, "location": "Phoenix", "status": "operational"}, {"available_capacity": 0.25, "location": "Dallas", "status": "operational"}]}}
{"difficulty": "easy", "function_schema_python": "def check_docker_container_status(container_name: str) -> dict:\n    \"\"\"Checks the status of a Docker container.\n\n    :param container_name: Name of the Docker container to check.\n    :return: Dictionary containing container status information.\n        Keys:\n        - status (str): Current status of container ('running', 'stopped', 'error')\n        - uptime (str): Container uptime\n        - env_vars (dict): Current environment variables\n    :raises ValueError: If container name is invalid or empty.\"\"\"\n    pass\ndef update_container_env_vars(container_name: str, env_vars: dict) -> bool:\n    \"\"\"Updates environment variables for a specified Docker container.\n\n    :param container_name: Name of the Docker container.\n    :param env_vars: Dictionary of environment variables to update.\n    :return: True if update successful, False otherwise.\n    :raises ValueError: If container name is invalid or env_vars is empty.\"\"\"\n    pass\ndef restart_kubernetes_service(service_name: str, namespace: str) -> dict:\n    \"\"\"Restarts a Kubernetes service and verifies its status.\n\n    :param service_name: Name of the Kubernetes service.\n    :param namespace: Kubernetes namespace where the service is deployed.\n    :return: Dictionary containing restart operation status.\n        Keys:\n        - success (bool): Whether restart was successful\n        - message (str): Status message\n        - pod_status (str): Current pod status\n    :raises ValueError: If service name is invalid.\"\"\"\n    pass\n", "function_schema_json": [{"name": "check_docker_container_status", "description": "Checks the status of a Docker container.", "parameters": {"type": "object", "properties": {"container_name": {"type": "string", "description": "Name of the Docker container to check."}}, "required": ["container_name"], "additionalProperties": false}}, {"name": "update_container_env_vars", "description": "Updates environment variables for a specified Docker container.", "parameters": {"type": "object", "properties": {"container_name": {"type": "string", "description": "Name of the Docker container."}, "env_vars": {"type": "object", "description": "Dictionary of environment variables to update."}}, "required": ["container_name", "env_vars"], "additionalProperties": false}}, {"name": "restart_kubernetes_service", "description": "Restarts a Kubernetes service and verifies its status.", "parameters": {"type": "object", "properties": {"service_name": {"type": "string", "description": "Name of the Kubernetes service."}, "namespace": {"type": "string", "description": "Kubernetes namespace where the service is deployed."}}, "required": ["service_name", "namespace"], "additionalProperties": false}}], "mock_functions": "def check_docker_container_status(container_name: str) -> dict:\n    \"\"\"\n    Checks the status of a Docker container.\n    \n    :param container_name: Name of the Docker container to check.\n    :return: Dictionary containing container status information.\n        Keys:\n        - status (str): Current status of container ('running', 'stopped', 'error')\n        - uptime (str): Container uptime\n        - env_vars (dict): Current environment variables\n    :raises ValueError: If container name is invalid or empty.\n    \"\"\"\n    if not container_name:\n        raise ValueError(\"Container name must not be empty\")\n    if container_name == \"blog-web-app\":\n        return {\n            \"status\": \"running\",\n            \"uptime\": \"2d 3h 45m\",\n            \"env_vars\": {\n                \"DB_HOST\": \"postgres-db\",\n                \"DB_PORT\": \"5432\",\n                \"API_KEY\": \"missing\"\n            }\n        }\n    return {\"status\": \"not found\", \"uptime\": \"0\", \"env_vars\": {}}\ndef update_container_env_vars(container_name: str, env_vars: dict) -> bool:\n    \"\"\"\n    Updates environment variables for a specified Docker container.\n    \n    :param container_name: Name of the Docker container.\n    :param env_vars: Dictionary of environment variables to update.\n    :return: True if update successful, False otherwise.\n    :raises ValueError: If container name is invalid or env_vars is empty.\n    \"\"\"\n    if not container_name or not env_vars:\n        raise ValueError(\"Container name and environment variables must be provided\")\n    if container_name == \"blog-web-app\" and \"API_KEY\" in env_vars:\n        return True\n    return False\ndef restart_kubernetes_service(service_name: str, namespace: str = \"default\") -> dict:\n    \"\"\"\n    Restarts a Kubernetes service and verifies its status.\n    \n    :param service_name: Name of the Kubernetes service.\n    :param namespace: Kubernetes namespace where the service is deployed.\n    :return: Dictionary containing restart operation status.\n        Keys:\n        - success (bool): Whether restart was successful\n        - message (str): Status message\n        - pod_status (str): Current pod status\n    :raises ValueError: If service name is invalid.\n    \"\"\"\n    if not service_name:\n        raise ValueError(\"Service name must not be empty\")\n    if service_name == \"blog-service\" and namespace == \"default\":\n        return {\n            \"success\": True,\n            \"message\": \"Service restarted successfully\",\n            \"pod_status\": \"Running\"\n        }\n    return {\n        \"success\": False,\n        \"message\": \"Service restart failed\",\n        \"pod_status\": \"Unknown\"\n    }", "user_query": "Can you check the status of my 'blog-web-app' Docker container?", "checklist": {"functions": ["check_docker_container_status"], "values": [{"status": "running", "uptime": "2d 3h 45m", "env_vars": {"DB_HOST": "postgres-db", "DB_PORT": "5432", "API_KEY": "missing"}}]}}
{"difficulty": "easy", "function_schema_python": "def load_firewall_logs(start_date: str, end_date: str, num_firewalls: int) -> dict:\n    \"\"\"Loads firewall logs for the specified date range and number of firewalls.\n\n    :param start_date: Start date in 'YYYY-MM-DD' format\n    :param end_date: End date in 'YYYY-MM-DD' format\n    :param num_firewalls: Number of firewalls to collect logs from\n    :return: Dictionary containing parsed log data\n        - timestamps (list): List of timestamp strings\n        - ip_addresses (list): List of IP addresses\n        - ports (list): List of port numbers\n        - threat_scores (list): List of threat scores (1-10)\n    :raises ValueError: If date format is invalid or num_firewalls <= 0\"\"\"\n    pass\ndef train_threat_prediction_model(log_data: dict, test_size: float) -> dict:\n    \"\"\"Trains a regression model to predict threat scores based on historical data.\n\n    :param log_data: Dictionary containing firewall log data\n    :param test_size: Proportion of data to use for testing (default: 0.2)\n    :return: Dictionary containing model performance metrics\n        - accuracy (float): Model accuracy score\n        - mse (float): Mean squared error\n        - important_features (list): List of important features\n    :raises ValueError: If log_data is empty or test_size is invalid\"\"\"\n    pass\ndef identify_high_risk_patterns(threat_scores: list, threshold: float) -> dict:\n    \"\"\"Identifies patterns in high-risk threats based on threat scores.\n\n    :param threat_scores: List of threat scores (1-10)\n    :param threshold: Threshold for high-risk classification (default: 7.0)\n    :return: Dictionary containing risk analysis\n        - high_risk_count (int): Number of high-risk entries\n        - risk_percentage (float): Percentage of high-risk entries\n        - alert_status (str): Current alert status\n    :raises ValueError: If threat_scores is empty or threshold is invalid\"\"\"\n    pass\n", "function_schema_json": [{"name": "load_firewall_logs", "description": "Loads firewall logs for the specified date range and number of firewalls.", "parameters": {"type": "object", "properties": {"start_date": {"type": "string", "description": "Start date in 'YYYY-MM-DD' format"}, "end_date": {"type": "string", "description": "End date in 'YYYY-MM-DD' format"}, "num_firewalls": {"type": "integer", "description": "Number of firewalls to collect logs from"}}, "required": ["start_date", "end_date", "num_firewalls"], "additionalProperties": false}}, {"name": "train_threat_prediction_model", "description": "Trains a regression model to predict threat scores based on historical data.", "parameters": {"type": "object", "properties": {"log_data": {"type": "object", "description": "Dictionary containing firewall log data"}, "test_size": {"type": "number", "description": "Proportion of data to use for testing (default: 0.2)"}}, "required": ["log_data", "test_size"], "additionalProperties": false}}, {"name": "identify_high_risk_patterns", "description": "Identifies patterns in high-risk threats based on threat scores.", "parameters": {"type": "object", "properties": {"threat_scores": {"type": "array", "description": "List of threat scores (1-10)"}, "threshold": {"type": "number", "description": "Threshold for high-risk classification (default: 7.0)"}}, "required": ["threat_scores", "threshold"], "additionalProperties": false}}], "mock_functions": "def load_firewall_logs(start_date: str, end_date: str, num_firewalls: int) -> dict:\n    \"\"\"\n    Loads firewall logs for the specified date range and number of firewalls.\n    \n    :param start_date: Start date in 'YYYY-MM-DD' format\n    :param end_date: End date in 'YYYY-MM-DD' format\n    :param num_firewalls: Number of firewalls to collect logs from\n    :return: Dictionary containing parsed log data\n        - timestamps (list): List of timestamp strings\n        - ip_addresses (list): List of IP addresses\n        - ports (list): List of port numbers\n        - threat_scores (list): List of threat scores (1-10)\n    :raises ValueError: If date format is invalid or num_firewalls <= 0\n    \"\"\"\n    if num_firewalls <= 0:\n        raise ValueError(\"Number of firewalls must be positive\")\n    \n    if start_date == \"2024-01-01\" and end_date == \"2024-02-29\" and num_firewalls == 50:\n        return {\n            \"timestamps\": [\"2024-01-01 00:00:01\", \"2024-01-01 00:00:02\"],\n            \"ip_addresses\": [\"192.168.1.1\", \"10.0.0.1\"],\n            \"ports\": [80, 443],\n            \"threat_scores\": [8, 3]\n        }\n    return {}\ndef train_threat_prediction_model(log_data: dict, test_size: float = 0.2) -> dict:\n    \"\"\"\n    Trains a regression model to predict threat scores based on historical data.\n    \n    :param log_data: Dictionary containing firewall log data\n    :param test_size: Proportion of data to use for testing (default: 0.2)\n    :return: Dictionary containing model performance metrics\n        - accuracy (float): Model accuracy score\n        - mse (float): Mean squared error\n        - important_features (list): List of important features\n    :raises ValueError: If log_data is empty or test_size is invalid\n    \"\"\"\n    if not log_data or not 0 < test_size < 1:\n        raise ValueError(\"Invalid input parameters\")\n    \n    if len(log_data.get(\"threat_scores\", [])) > 0:\n        return {\n            \"accuracy\": 0.85,\n            \"mse\": 0.15,\n            \"important_features\": [\"ip_range\", \"port_combination\", \"time_of_day\"]\n        }\n    return {}\ndef identify_high_risk_patterns(threat_scores: list, threshold: float = 7.0) -> dict:\n    \"\"\"\n    Identifies patterns in high-risk threats based on threat scores.\n    \n    :param threat_scores: List of threat scores (1-10)\n    :param threshold: Threshold for high-risk classification (default: 7.0)\n    :return: Dictionary containing risk analysis\n        - high_risk_count (int): Number of high-risk entries\n        - risk_percentage (float): Percentage of high-risk entries\n        - alert_status (str): Current alert status\n    :raises ValueError: If threat_scores is empty or threshold is invalid\n    \"\"\"\n    if not threat_scores or not 1 <= threshold <= 10:\n        raise ValueError(\"Invalid input parameters\")\n    \n    if any(score >= threshold for score in threat_scores):\n        return {\n            \"high_risk_count\": 25,\n            \"risk_percentage\": 15.5,\n            \"alert_status\": \"ELEVATED\"\n        }\n    return {}", "user_query": "Load firewall logs from 2024-01-01 to 2024-02-29 for 50 firewalls.", "checklist": {"functions": ["load_firewall_logs"], "values": [{"timestamps": ["2024-01-01 00:00:01", "2024-01-01 00:00:02"], "ip_addresses": ["192.168.1.1", "10.0.0.1"], "ports": [80, 443], "threat_scores": [8, 3]}]}}
{"difficulty": "easy", "function_schema_python": "def extract_contact_info_from_emails(email_thread_ids: list[str], contact_name: str) -> dict:\n    \"\"\"Extracts updated contact information from a chain of emails.\n\n    :param email_thread_ids: List of email IDs to analyze\n    :param contact_name: Name of the contact to search for\n    :return: Dictionary containing updated contact information with keys:\n        - email (str): Updated email address\n        - phone (str): Updated phone number\n        - last_updated (str): Timestamp of the most recent update\n    :raises ValueError: If email_thread_ids is empty or contact_name is invalid\"\"\"\n    pass\ndef update_salesforce_contact(deal_id: str, contact_info: dict) -> bool:\n    \"\"\"Updates contact information in Salesforce CRM.\n\n    :param deal_id: Salesforce Deal ID\n    :param contact_info: Dictionary containing contact information to update\n    :return: True if update successful, False otherwise\n    :raises ValueError: If deal_id is invalid or contact_info is incomplete\"\"\"\n    pass\ndef validate_email_thread(email_thread_ids: list[str], deal_id: str) -> bool:\n    \"\"\"Validates if the email thread is related to the specified deal.\n\n    :param email_thread_ids: List of email IDs to validate\n    :param deal_id: Salesforce Deal ID to check against\n    :return: True if email thread is related to deal, False otherwise\n    :raises ValueError: If email_thread_ids is empty or deal_id is invalid\"\"\"\n    pass\n", "function_schema_json": [{"name": "extract_contact_info_from_emails", "description": "Extracts updated contact information from a chain of emails.", "parameters": {"type": "object", "properties": {"email_thread_ids": {"type": "array", "items": {"type": "string"}, "description": "List of email IDs to analyze"}, "contact_name": {"type": "string", "description": "Name of the contact to search for"}}, "required": ["email_thread_ids", "contact_name"], "additionalProperties": false}}, {"name": "update_salesforce_contact", "description": "Updates contact information in Salesforce CRM.", "parameters": {"type": "object", "properties": {"deal_id": {"type": "string", "description": "Salesforce Deal ID"}, "contact_info": {"type": "object", "description": "Dictionary containing contact information to update"}}, "required": ["deal_id", "contact_info"], "additionalProperties": false}}, {"name": "validate_email_thread", "description": "Validates if the email thread is related to the specified deal.", "parameters": {"type": "object", "properties": {"email_thread_ids": {"type": "array", "items": {"type": "string"}, "description": "List of email IDs to validate"}, "deal_id": {"type": "string", "description": "Salesforce Deal ID to check against"}}, "required": ["email_thread_ids", "deal_id"], "additionalProperties": false}}], "mock_functions": "def extract_contact_info_from_emails(email_thread_ids: list[str], contact_name: str) -> dict:\n    \"\"\"\n    Extracts updated contact information from a chain of emails.\n    \n    :param email_thread_ids: List of email IDs to analyze\n    :param contact_name: Name of the contact to search for\n    :return: Dictionary containing updated contact information with keys:\n        - email (str): Updated email address\n        - phone (str): Updated phone number\n        - last_updated (str): Timestamp of the most recent update\n    :raises ValueError: If email_thread_ids is empty or contact_name is invalid\n    \"\"\"\n    if not email_thread_ids or not contact_name:\n        raise ValueError(\"Email thread IDs and contact name must be provided\")\n    \n    if contact_name.lower() == \"sarah jones\" and len(email_thread_ids) == 5:\n        return {\n            \"email\": \"sarah.jones@globexinc.com\",\n            \"phone\": \"+1-555-0123\",\n            \"last_updated\": \"2023-12-01T14:30:00Z\"\n        }\n    return {}\ndef update_salesforce_contact(deal_id: str, contact_info: dict) -> bool:\n    \"\"\"\n    Updates contact information in Salesforce CRM.\n    \n    :param deal_id: Salesforce Deal ID\n    :param contact_info: Dictionary containing contact information to update\n    :return: True if update successful, False otherwise\n    :raises ValueError: If deal_id is invalid or contact_info is incomplete\n    \"\"\"\n    required_keys = [\"email\", \"phone\", \"last_updated\"]\n    if not deal_id or not all(key in contact_info for key in required_keys):\n        raise ValueError(\"Invalid deal ID or incomplete contact information\")\n    \n    if (deal_id == \"789456\" and \n        contact_info[\"email\"] == \"sarah.jones@globexinc.com\" and \n        contact_info[\"phone\"] == \"+1-555-0123\"):\n        return True\n    return False\ndef validate_email_thread(email_thread_ids: list[str], deal_id: str) -> bool:\n    \"\"\"\n    Validates if the email thread is related to the specified deal.\n    \n    :param email_thread_ids: List of email IDs to validate\n    :param deal_id: Salesforce Deal ID to check against\n    :return: True if email thread is related to deal, False otherwise\n    :raises ValueError: If email_thread_ids is empty or deal_id is invalid\n    \"\"\"\n    if not email_thread_ids or not deal_id:\n        raise ValueError(\"Email thread IDs and deal ID must be provided\")\n    \n    if deal_id == \"789456\" and len(email_thread_ids) == 5:\n        return True\n    return False", "user_query": "Are these emails related to deal 789456 with Globex Inc.? The email thread IDs are [\u2018email1\u2019, \u2018email2\u2019, \u2018email3\u2019, \u2018email4\u2019, \u2018email5\u2019].", "checklist": {"functions": ["validate_email_thread"], "values": [true]}}
{"difficulty": "easy", "function_schema_python": "def get_ride_data(location: str, radius: float, date: str, start_time: str, end_time: str) -> dict:\n    \"\"\"Retrieves ride data for a specific location within a radius and time period.\n\n    :param location: The central location (e.g., \"Wrigley Field\")\n    :param radius: Radius in miles to consider\n    :param date: Date in format 'YYYY-MM-DD'\n    :param start_time: Start time in 24-hour format (HH:MM)\n    :param end_time: End time in 24-hour format (HH:MM)\n    :return: Dictionary containing ride statistics\n    :raises ValueError: If parameters are invalid\"\"\"\n    pass\ndef calculate_metrics_difference(data1: dict, data2: dict) -> dict:\n    \"\"\"Calculates the percentage difference between two sets of ride metrics.\n\n    :param data1: First set of ride metrics\n    :param data2: Second set of ride metrics\n    :return: Dictionary containing percentage changes\n    :raises ValueError: If input dictionaries are invalid\"\"\"\n    pass\n", "function_schema_json": [{"name": "get_ride_data", "description": "Retrieves ride data for a specific location within a radius and time period.", "parameters": {"type": "object", "properties": {"location": {"type": "string", "description": "The central location (e.g., \"Wrigley Field\")"}, "radius": {"type": "number", "description": "Radius in miles to consider"}, "date": {"type": "string", "description": "Date in format 'YYYY-MM-DD'"}, "start_time": {"type": "string", "description": "Start time in 24-hour format (HH:MM)"}, "end_time": {"type": "string", "description": "End time in 24-hour format (HH:MM)"}}, "required": ["location", "radius", "date", "start_time", "end_time"], "additionalProperties": false}}, {"name": "calculate_metrics_difference", "description": "Calculates the percentage difference between two sets of ride metrics.", "parameters": {"type": "object", "properties": {"data1": {"type": "object", "description": "First set of ride metrics"}, "data2": {"type": "object", "description": "Second set of ride metrics"}}, "required": ["data1", "data2"], "additionalProperties": false}}], "mock_functions": "def get_ride_data(location: str, radius: float, date: str, start_time: str, end_time: str) -> dict:\n    \"\"\"\n    Retrieves ride data for a specific location within a radius and time period.\n    \n    :param location: The central location (e.g., \"Wrigley Field\")\n    :param radius: Radius in miles to consider\n    :param date: Date in format 'YYYY-MM-DD'\n    :param start_time: Start time in 24-hour format (HH:MM)\n    :param end_time: End time in 24-hour format (HH:MM)\n    :return: Dictionary containing ride statistics\n    :raises ValueError: If parameters are invalid\n    \"\"\"\n    if not all([location, radius, date, start_time, end_time]):\n        raise ValueError(\"All parameters must be provided\")\n    \n    if location == \"Wrigley Field\" and radius == 1.0:\n        if date == \"2023-07-15\":  # game day\n            return {\n                \"avg_duration\": 35.5,  # minutes\n                \"avg_fare\": 28.75,     # dollars\n                \"total_requests\": 450\n            }\n        elif date == \"2023-07-08\":  # non-game day\n            return {\n                \"avg_duration\": 22.3,\n                \"avg_fare\": 18.50,\n                \"total_requests\": 180\n            }\n    return {}\ndef calculate_metrics_difference(data1: dict, data2: dict) -> dict:\n    \"\"\"\n    Calculates the percentage difference between two sets of ride metrics.\n    \n    :param data1: First set of ride metrics\n    :param data2: Second set of ride metrics\n    :return: Dictionary containing percentage changes\n    :raises ValueError: If input dictionaries are invalid\n    \"\"\"\n    if not isinstance(data1, dict) or not isinstance(data2, dict):\n        raise ValueError(\"Both inputs must be dictionaries\")\n    \n    return {\n        \"duration_change\": ((data1[\"avg_duration\"] - data2[\"avg_duration\"]) / data2[\"avg_duration\"]) * 100,\n        \"fare_change\": ((data1[\"avg_fare\"] - data2[\"avg_fare\"]) / data2[\"avg_fare\"]) * 100,\n        \"requests_change\": ((data1[\"total_requests\"] - data2[\"total_requests\"]) / data2[\"total_requests\"]) * 100\n    }", "user_query": "Could you get the ride data for Wrigley Field within 1 mile radius on 2023-07-15 between 16:00 and 20:00?", "checklist": {"functions": ["get_ride_data"], "values": [{"avg_duration": 35.5, "avg_fare": 28.75, "total_requests": 450}]}}
{"difficulty": "easy", "function_schema_python": "def estimate_load_test_duration(ad_requests_per_hour: int) -> float:\n    \"\"\"Estimates the duration to complete a load test based on the number of ad requests per hour.\n\n    :param ad_requests_per_hour: The number of ad requests the system will handle per hour during the test.\n    :return: The estimated duration in hours required to complete the load test.\n    :raises ValueError: If the number of ad requests per hour is negative or zero.\"\"\"\n    pass\ndef analyze_ad_campaign_performance(load_test_results: dict) -> dict:\n    \"\"\"Analyzes the performance of ad campaigns under a given load test scenario.\n\n    :param load_test_results: A dictionary containing the load test results with the following keys:\n        - requests_handled (int): Total number of requests handled.\n        - response_time_avg (float): Average response time in milliseconds.\n        - error_rate (float): Error rate as a percentage.\n        - throughput (int): Throughput in requests per second.\n    :return:\n        dict: A dictionary with the following keys:\n            - performance_status (str): A brief performance status.\n            - optimized_campaigns (list[str]): List of campaigns that can be optimized.\n    :raises ValueError: If the load_test_results dictionary is incomplete or invalid.\"\"\"\n    pass\ndef simulate_ad_requests(ad_requests_per_hour: int) -> dict:\n    \"\"\"Simulates ad requests at a given rate to evaluate system load capacity.\n\n    :param ad_requests_per_hour: The number of ad requests to simulate per hour.\n    :return:\n        dict: A dictionary with the following keys:\n            - requests_handled (int): Total number of requests handled.\n            - response_time_avg (float): Average response time in milliseconds.\n            - error_rate (float): Error rate as a percentage.\n            - throughput (int): Throughput in requests per second.\n    :raises ValueError: If the number of ad requests is negative or exceeds a reasonable maximum.\"\"\"\n    pass\ndef calculate_load_capacity(error_threshold: float, performance_data: dict) -> int:\n    \"\"\"Calculates the maximum number of ad requests the system can handle without exceeding the specified error threshold.\n\n    :param error_threshold: The maximum allowable error rate as a percentage.\n    :param performance_data: A dictionary containing performance data with keys:\n        - requests_handled (int): Total number of requests handled.\n        - response_time_avg (float): Average response time in milliseconds.\n        - error_rate (float): Error rate as a percentage.\n        - throughput (int): Throughput in requests per second.\n    :return: The maximum number of ad requests per hour the system can handle without exceeding the error threshold.\n    :raises ValueError: If performance_data is incomplete or the error_threshold is negative.\"\"\"\n    pass\ndef answer_query(query: str) -> str:\n    \"\"\"Provides an answer based on the user's query about the load testing scenario.\n\n    :param query: The user's query as a string.\n    :return: A string containing the answer to the user's query.\n    :raises ValueError: If the query is not recognized.\"\"\"\n    pass\n", "function_schema_json": [{"name": "estimate_load_test_duration", "description": "Estimates the duration to complete a load test based on the number of ad requests per hour.", "parameters": {"type": "object", "properties": {"ad_requests_per_hour": {"type": "integer", "description": "The number of ad requests the system will handle per hour during the test."}}, "required": ["ad_requests_per_hour"], "additionalProperties": false}}, {"name": "analyze_ad_campaign_performance", "description": "Analyzes the performance of ad campaigns under a given load test scenario.", "parameters": {"type": "object", "properties": {"load_test_results": {"type": "object", "description": "A dictionary containing the load test results with the following keys:"}}, "required": ["load_test_results"], "additionalProperties": false}}, {"name": "simulate_ad_requests", "description": "Simulates ad requests at a given rate to evaluate system load capacity.", "parameters": {"type": "object", "properties": {"ad_requests_per_hour": {"type": "integer", "description": "The number of ad requests to simulate per hour."}}, "required": ["ad_requests_per_hour"], "additionalProperties": false}}, {"name": "calculate_load_capacity", "description": "Calculates the maximum number of ad requests the system can handle without exceeding the specified error threshold.", "parameters": {"type": "object", "properties": {"error_threshold": {"type": "number", "description": "The maximum allowable error rate as a percentage."}, "performance_data": {"type": "object", "description": "A dictionary containing performance data with keys:"}}, "required": ["error_threshold", "performance_data"], "additionalProperties": false}}, {"name": "answer_query", "description": "Provides an answer based on the user's query about the load testing scenario.", "parameters": {"type": "object", "properties": {"query": {"type": "string", "description": "The user's query as a string."}}, "required": ["query"], "additionalProperties": false}}], "mock_functions": "def estimate_load_test_duration(ad_requests_per_hour: int) -> float:\n    \"\"\"\n    Estimates the duration to complete a load test based on the number of ad requests per hour.\n    \n    :param ad_requests_per_hour: The number of ad requests the system will handle per hour during the test.\n    :return: The estimated duration in hours required to complete the load test.\n    :raises ValueError: If the number of ad requests per hour is negative or zero.\n    \"\"\"\n    if ad_requests_per_hour <= 0:\n        raise ValueError(\"Ad requests per hour must be a positive number.\")\n    # Mock logic: Assume 10,000 requests/hour takes 1 hour to test.\n    return (ad_requests_per_hour / 10000)\ndef analyze_ad_campaign_performance(load_test_results: dict) -> dict:\n    \"\"\"\n    Analyzes the performance of ad campaigns under a given load test scenario.\n    \n    :param load_test_results: A dictionary containing the load test results with the following keys:\n        - requests_handled (int): Total number of requests handled.\n        - response_time_avg (float): Average response time in milliseconds.\n        - error_rate (float): Error rate as a percentage.\n        - throughput (int): Throughput in requests per second.\n    :return:\n        dict: A dictionary with the following keys:\n            - performance_status (str): A brief performance status.\n            - optimized_campaigns (list[str]): List of campaigns that can be optimized.\n    :raises ValueError: If the load_test_results dictionary is incomplete or invalid.\n    \"\"\"\n    required_keys = {'requests_handled', 'response_time_avg', 'error_rate', 'throughput'}\n    if not (required_keys.issubset(load_test_results.keys())):\n        raise ValueError(f\"Load test results must include keys: {required_keys}.\")\n    \n    # Mock logic: Assessing based on fictitious thresholds.\n    performance_status = 'Optimal'\n    optimized_campaigns = []\n    if load_test_results['response_time_avg'] > 200:\n        performance_status = 'Suboptimal'\n        optimized_campaigns = ['campaign_1', 'campaign_3']  # Placeholder for optimization recommendations\n    return {\n        \"performance_status\": performance_status,\n        \"optimized_campaigns\": optimized_campaigns\n    }\ndef simulate_ad_requests(ad_requests_per_hour: int) -> dict:\n    \"\"\"\n    Simulates ad requests at a given rate to evaluate system load capacity.\n    \n    :param ad_requests_per_hour: The number of ad requests to simulate per hour.\n    :return:\n        dict: A dictionary with the following keys:\n            - requests_handled (int): Total number of requests handled.\n            - response_time_avg (float): Average response time in milliseconds.\n            - error_rate (float): Error rate as a percentage.\n            - throughput (int): Throughput in requests per second.\n    :raises ValueError: If the number of ad requests is negative or exceeds a reasonable maximum.\n    \"\"\"\n    if ad_requests_per_hour <= 0 or ad_requests_per_hour > 1000000:\n        raise ValueError(\"Ad requests per hour must be between 1 and 1,000,000.\")\n    \n    # Mock logic: Simulate a response based on the number of requests.\n    response_time_base = 0.5 + (ad_requests_per_hour / 100000)  # Simulated response time in seconds\n    return {\n        \"requests_handled\": ad_requests_per_hour,\n        \"response_time_avg\": response_time_base * 1000,  # Convert to milliseconds\n        \"error_rate\": ((ad_requests_per_hour / 10000) % 1) * 100,  # Simulated error rate\n        \"throughput\": ad_requests_per_hour / 3600  # Calculate requests per second\n    }\ndef calculate_load_capacity(error_threshold: float, performance_data: dict) -> int:\n    \"\"\"\n    Calculates the maximum number of ad requests the system can handle without exceeding the specified error threshold.\n    \n    :param error_threshold: The maximum allowable error rate as a percentage.\n    :param performance_data: A dictionary containing performance data with keys:\n        - requests_handled (int): Total number of requests handled.\n        - response_time_avg (float): Average response time in milliseconds.\n        - error_rate (float): Error rate as a percentage.\n        - throughput (int): Throughput in requests per second.\n    :return: The maximum number of ad requests per hour the system can handle without exceeding the error threshold.\n    :raises ValueError: If performance_data is incomplete or the error_threshold is negative.\n    \"\"\"\n    required_keys = {'requests_handled', 'response_time_avg', 'error_rate', 'throughput'}\n    if not (required_keys.issubset(performance_data.keys())):\n        raise ValueError(f\"Performance data must include keys: {required_keys}.\")\n    if error_threshold < 0:\n        raise ValueError(\"Error threshold must be a non-negative number.\")\n    \n    # Mock logic: If error rate is within threshold, suggest requests_handled is max capacity.\n    return performance_data['requests_handled'] if performance_data['error_rate'] <= error_threshold else 0\ndef answer_query(query: str) -> str:\n    \"\"\"\n    Provides an answer based on the user's query about the load testing scenario.\n    \n    :param query: The user's query as a string.\n    :return: A string containing the answer to the user's query.\n    :raises ValueError: If the query is not recognized.\n    \"\"\"\n    if \"estimated time to complete the load test\" in query.lower():\n        simulated_results = simulate_ad_requests(ad_requests_per_hour=200000)\n        estimated_duration = estimate_load_test_duration(200000)\n        return f\"The estimated time to complete the load test is approximately {estimated_duration:.2f} hours.\"\n    elif \"ad requests per hour can the platform handle\" in query.lower():\n        simulated_results = simulate_ad_requests(ad_requests_per_hour=200000)\n        max_capacity = calculate_load_capacity(error_threshold=2.0, performance_data=simulated_results)\n        return f\"The platform can handle up to approximately {max_capacity} ad requests per hour without a significant decrease in performance.\"\n    else:\n        raise ValueError(\"Unrecognized query. Please provide a relevant question about the load testing scenario.\")", "user_query": "What is the estimated time to complete a load test for 200,000 ad requests per hour?", "checklist": {"functions": ["estimate_load_test_duration"], "values": [20.0]}}
{"difficulty": "easy", "function_schema_python": "def analyze_access_patterns(excel_file: str, sheet_name: str) -> dict:\n    \"\"\"Analyzes access patterns from an Excel file.\n\n    :param excel_file: Path to the Excel file.\n    :param sheet_name: Name of the sheet to analyze.\n    :return: \n        dict: A dictionary containing analysis results with the following keys:\n            - most_common_access_level (str): The most frequent access level.\n            - average_access_duration (float): The average access duration.\n    :raises FileNotFoundError: If the Excel file is not found.\n    :raises ValueError: If the sheet name is invalid.\"\"\"\n    pass\ndef modify_employee_permissions(excel_file: str, employee_id: int, new_access_level: str) -> bool:\n    \"\"\"Modifies employee permissions in the Excel file.\n\n    :param excel_file: Path to the Excel file.\n    :param employee_id: The ID of the employee.\n    :param new_access_level: The new access level for the employee.\n    :return: True if the modification was successful, False otherwise.\n    :raises FileNotFoundError: If the Excel file is not found.\n    :raises ValueError: If the employee ID or access level is invalid.\"\"\"\n    pass\ndef maintain_security_protocols(excel_file: str) -> bool:\n    \"\"\"Maintains security protocols by validating data integrity.\n\n    :param excel_file: Path to the Excel file.\n    :return: True if security protocols are maintained, False otherwise.\"\"\"\n    pass\ndef ensure_compliance(policy_document: str) -> bool:\n    \"\"\"Ensures compliance with company policies.\n\n    :param policy_document: The name of the policy document.\n    :return: True if compliant, False otherwise.\"\"\"\n    pass\n", "function_schema_json": [{"name": "analyze_access_patterns", "description": "Analyzes access patterns from an Excel file.", "parameters": {"type": "object", "properties": {"excel_file": {"type": "string", "description": "Path to the Excel file."}, "sheet_name": {"type": "string", "description": "Name of the sheet to analyze."}}, "required": ["excel_file", "sheet_name"], "additionalProperties": false}}, {"name": "modify_employee_permissions", "description": "Modifies employee permissions in the Excel file.", "parameters": {"type": "object", "properties": {"excel_file": {"type": "string", "description": "Path to the Excel file."}, "employee_id": {"type": "integer", "description": "The ID of the employee."}, "new_access_level": {"type": "string", "description": "The new access level for the employee."}}, "required": ["excel_file", "employee_id", "new_access_level"], "additionalProperties": false}}, {"name": "maintain_security_protocols", "description": "Maintains security protocols by validating data integrity.", "parameters": {"type": "object", "properties": {"excel_file": {"type": "string", "description": "Path to the Excel file."}}, "required": ["excel_file"], "additionalProperties": false}}, {"name": "ensure_compliance", "description": "Ensures compliance with company policies.", "parameters": {"type": "object", "properties": {"policy_document": {"type": "string", "description": "The name of the policy document."}}, "required": ["policy_document"], "additionalProperties": false}}], "mock_functions": "def analyze_access_patterns(excel_file: str, sheet_name: str) -> dict:\n    \"\"\"\n    Analyzes access patterns from an Excel file.\n\n    :param excel_file: Path to the Excel file.\n    :param sheet_name: Name of the sheet to analyze.\n    :return: \n        dict: A dictionary containing analysis results with the following keys:\n            - most_common_access_level (str): The most frequent access level.\n            - average_access_duration (float): The average access duration.\n    :raises FileNotFoundError: If the Excel file is not found.\n    :raises ValueError: If the sheet name is invalid.\n    \"\"\"\n    if excel_file == \"employee_access_2023.xlsx\":\n        if sheet_name == \"Access_Levels\":\n            return {\n                \"most_common_access_level\": \"Level 2\",\n                \"average_access_duration\": 3.5\n            }\n        else:\n            raise ValueError(\"Invalid sheet name.\")\n    else:\n        raise FileNotFoundError(\"Excel file not found.\")\ndef modify_employee_permissions(excel_file: str, employee_id: int, new_access_level: str) -> bool:\n    \"\"\"\n    Modifies employee permissions in the Excel file.\n\n    :param excel_file: Path to the Excel file.\n    :param employee_id: The ID of the employee.\n    :param new_access_level: The new access level for the employee.\n    :return: True if the modification was successful, False otherwise.\n    :raises FileNotFoundError: If the Excel file is not found.\n    :raises ValueError: If the employee ID or access level is invalid.\n    \"\"\"\n    if excel_file == \"employee_access_2023.xlsx\":\n        if 1 <= employee_id <= 250:\n            if new_access_level in [\"Level 1\", \"Level 2\", \"Level 3\"]:\n                return True\n            else:\n                raise ValueError(\"Invalid access level.\")\n        else:\n            raise ValueError(\"Invalid employee ID.\")\n    else:\n        raise FileNotFoundError(\"Excel file not found.\")\ndef maintain_security_protocols(excel_file: str) -> bool:\n    \"\"\"\n    Maintains security protocols by validating data integrity.\n\n    :param excel_file: Path to the Excel file.\n    :return: True if security protocols are maintained, False otherwise.\n    \"\"\"\n    if excel_file == \"employee_access_2023.xlsx\":\n        return True\n    return False\ndef ensure_compliance(policy_document: str) -> bool:\n    \"\"\"\n    Ensures compliance with company policies.\n\n    :param policy_document: The name of the policy document.\n    :return: True if compliant, False otherwise.\n    \"\"\"\n    # Mock logic: Always compliant for this scenario.\n    return True", "user_query": "Can you analyze the access patterns in the \"Access_Levels\" sheet of the employee_access_2023.xlsx file?", "checklist": {"functions": ["analyze_access_patterns"], "values": [{"most_common_access_level": "Level 2", "average_access_duration": 3.5}]}}
{"difficulty": "easy", "function_schema_python": "def load_excel_sheet(file_path: str, sheet_name: str) -> list:\n    \"\"\"Loads a specific sheet from an Excel file and returns its data as a list of lists.\n\n    :param file_path: The path to the Excel file.\n    :param sheet_name: The name of the sheet to load.\n    :return: A list of lists, where each inner list represents a row from the sheet.\n    :raises FileNotFoundError: If the file does not exist.\n    :raises KeyError: If the sheet name does not exist in the file.\"\"\"\n    pass\ndef analyze_access_patterns(data: list) -> dict:\n    \"\"\"Analyzes access patterns from the provided data to identify anomalies.\n\n    :param data: The data to analyze, typically from a loaded Excel sheet.\n    :return:\n        dict: A dictionary with the following keys:\n            - anomalies (list[dict]): A list of dictionaries, each representing an anomaly with details.\"\"\"\n    pass\ndef update_access_matrix(file_path: str, updates: list) -> bool:\n    \"\"\"Updates the access matrix Excel file with the provided updates.\n\n    :param file_path: The path to the Excel file to update.\n    :param updates: A list of updates to apply to the file.\n    :return: True if the updates were successfully applied, False otherwise.\n    :raises FileNotFoundError: If the file does not exist.\"\"\"\n    pass\ndef generate_audit_report(anomalies: list, report_path: str) -> bool:\n    \"\"\"Generates an audit report based on detected anomalies and saves it to the specified path.\n\n    :param anomalies: A list of anomalies detected.\n    :param report_path: The path where the audit report should be saved.\n    :return: True if the report was successfully generated, False otherwise.\n    :raises ValueError: If the report path is not provided.\"\"\"\n    pass\ndef get_employee_details(employee_id: str) -> dict:\n    \"\"\"Retrieves details for a specific employee based on their ID.\n\n    :param employee_id: The ID of the employee.\n    :return:\n        dict: A dictionary with the following keys:\n            - name (str): The employee's name.\n            - branch_id (str): The ID of the branch the employee belongs to.\n            - department (str): The department the employee works in.\n            - clearance_level (str): The security clearance level of the employee.\n    :raises ValueError: If the employee ID is empty.\"\"\"\n    pass\ndef validate_access_changes(updates: list) -> list:\n    \"\"\"Validates the proposed access changes against banking regulations.\n\n    :param updates: A list of access changes to validate.\n    :return: A list of updates that are valid according to regulations.\n    :raises ValueError: If the input is not a list.\"\"\"\n    pass\n", "function_schema_json": [{"name": "load_excel_sheet", "description": "Loads a specific sheet from an Excel file and returns its data as a list of lists.", "parameters": {"type": "object", "properties": {"file_path": {"type": "string", "description": "The path to the Excel file."}, "sheet_name": {"type": "string", "description": "The name of the sheet to load."}}, "required": ["file_path", "sheet_name"], "additionalProperties": false}}, {"name": "analyze_access_patterns", "description": "Analyzes access patterns from the provided data to identify anomalies.", "parameters": {"type": "object", "properties": {"data": {"type": "array", "description": "The data to analyze, typically from a loaded Excel sheet."}}, "required": ["data"], "additionalProperties": false}}, {"name": "update_access_matrix", "description": "Updates the access matrix Excel file with the provided updates.", "parameters": {"type": "object", "properties": {"file_path": {"type": "string", "description": "The path to the Excel file to update."}, "updates": {"type": "array", "description": "A list of updates to apply to the file."}}, "required": ["file_path", "updates"], "additionalProperties": false}}, {"name": "generate_audit_report", "description": "Generates an audit report based on detected anomalies and saves it to the specified path.", "parameters": {"type": "object", "properties": {"anomalies": {"type": "array", "description": "A list of anomalies detected."}, "report_path": {"type": "string", "description": "The path where the audit report should be saved."}}, "required": ["anomalies", "report_path"], "additionalProperties": false}}, {"name": "get_employee_details", "description": "Retrieves details for a specific employee based on their ID.", "parameters": {"type": "object", "properties": {"employee_id": {"type": "string", "description": "The ID of the employee."}}, "required": ["employee_id"], "additionalProperties": false}}, {"name": "validate_access_changes", "description": "Validates the proposed access changes against banking regulations.", "parameters": {"type": "object", "properties": {"updates": {"type": "array", "description": "A list of access changes to validate."}}, "required": ["updates"], "additionalProperties": false}}], "mock_functions": "def load_excel_sheet(file_path: str, sheet_name: str) -> list:\n    \"\"\"\n    Loads a specific sheet from an Excel file and returns its data as a list of lists.\n    \n    :param file_path: The path to the Excel file.\n    :param sheet_name: The name of the sheet to load.\n    :return: A list of lists, where each inner list represents a row from the sheet.\n    :raises FileNotFoundError: If the file does not exist.\n    :raises KeyError: If the sheet name does not exist in the file.\n    \"\"\"\n    # Mock logic: return mock data based on sheet name\n    mock_data = {\n        \"Clearance_Levels\": [[\"Employee_ID\", \"Name\", \"Branch_ID\", \"Clearance_Level\", \"Access_Type\", \"Department\", \"Supervisor_Name\", \"Date_Hired\"]],\n        \"Vault_Access\": [[\"Employee_ID\", \"Branch_ID\", \"Vault_ID\", \"Access_Type\", \"Last_Access_Date\"]],\n        \"Special_Permissions\": [[\"Employee_ID\", \"Permission_Type\", \"Last_Updated\", \"Description\"]]\n    }\n    if not file_path:\n        raise FileNotFoundError(\"File path must be provided.\")\n    if sheet_name in mock_data:\n        return mock_data[sheet_name]\n    else:\n        raise KeyError(f\"Sheet '{sheet_name}' does not exist in the file.\")\ndef analyze_access_patterns(data: list) -> dict:\n    \"\"\"\n    Analyzes access patterns from the provided data to identify anomalies.\n    \n    :param data: The data to analyze, typically from a loaded Excel sheet.\n    :return:\n        dict: A dictionary with the following keys:\n            - anomalies (list[dict]): A list of dictionaries, each representing an anomaly with details.\n    \"\"\"\n    # Mock logic: return mock anomalies\n    anomalies = [\n        {\"employee_id\": \"E123\", \"description\": \"Unusual access frequency to Vault Access sheet\"},\n        {\"employee_id\": \"E456\", \"description\": \"Accessed Vault Access sheet during non-working hours\"}\n    ]\n    return {\"anomalies\": anomalies}\ndef update_access_matrix(file_path: str, updates: list) -> bool:\n    \"\"\"\n    Updates the access matrix Excel file with the provided updates.\n    \n    :param file_path: The path to the Excel file to update.\n    :param updates: A list of updates to apply to the file.\n    :return: True if the updates were successfully applied, False otherwise.\n    :raises FileNotFoundError: If the file does not exist.\n    \"\"\"\n    # Mock logic: always return True\n    if not file_path:\n        raise FileNotFoundError(\"File path must be provided.\")\n    return True\ndef generate_audit_report(anomalies: list, report_path: str) -> bool:\n    \"\"\"\n    Generates an audit report based on detected anomalies and saves it to the specified path.\n    \n    :param anomalies: A list of anomalies detected.\n    :param report_path: The path where the audit report should be saved.\n    :return: True if the report was successfully generated, False otherwise.\n    :raises ValueError: If the report path is not provided.\n    \"\"\"\n    # Mock logic: always return True\n    if not report_path:\n        raise ValueError(\"Report path must be provided.\")\n    return True\ndef get_employee_details(employee_id: str) -> dict:\n    \"\"\"\n    Retrieves details for a specific employee based on their ID.\n    \n    :param employee_id: The ID of the employee.\n    :return:\n        dict: A dictionary with the following keys:\n            - name (str): The employee's name.\n            - branch_id (str): The ID of the branch the employee belongs to.\n            - department (str): The department the employee works in.\n            - clearance_level (str): The security clearance level of the employee.\n    :raises ValueError: If the employee ID is empty.\n    \"\"\"\n    # Mock logic: return mock data\n    if not employee_id:\n        raise ValueError(\"Employee ID must be provided.\")\n    mock_details = {\n        \"E123\": {\"name\": \"John Doe\", \"branch_id\": \"B01\", \"department\": \"IT\", \"clearance_level\": \"Level 4\"},\n        \"E456\": {\"name\": \"Jane Smith\", \"branch_id\": \"B02\", \"department\": \"Finance\", \"clearance_level\": \"Level 3\"}\n    }\n    return mock_details.get(employee_id, {})\ndef validate_access_changes(updates: list) -> list:\n    \"\"\"\n    Validates the proposed access changes against banking regulations.\n    \n    :param updates: A list of access changes to validate.\n    :return: A list of updates that are valid according to regulations.\n    :raises ValueError: If the input is not a list.\n    \"\"\"\n    # Mock logic: always return the original updates for simplicity\n    if not isinstance(updates, list):\n        raise ValueError(\"Updates must be provided as a list.\")\n    return updates", "user_query": "Can you load the Clearance_Levels sheet from branch_security_matrix.xlsx?", "checklist": {"functions": ["load_excel_sheet"], "values": [[["Employee_ID", "Name", "Branch_ID", "Clearance_Level", "Access_Type", "Department", "Supervisor_Name", "Date_Hired"]]]}}
{"difficulty": "easy", "function_schema_python": "def analyze_traffic_csv(file_path: str, threshold_percentile: float) -> list[dict]:\n    \"\"\"Analyzes website traffic data to identify days with unusually low traffic.\n\n    :param file_path: Path to the CSV file containing traffic data\n    :param threshold_percentile: Percentile threshold for identifying low traffic (default: 10)\n    :return: List of dictionaries containing dates and traffic metrics for low-traffic days\n    :raises FileNotFoundError: If the CSV file doesn't exist\"\"\"\n    pass\ndef build_graphql_query(date: str) -> str:\n    \"\"\"Builds a GraphQL query for retrieving detailed analytics for a specific date.\n\n    :param date: Date in YYYY-MM-DD format\n    :return: GraphQL query string\n    :raises ValueError: If date format is invalid\"\"\"\n    pass\ndef fetch_analytics_data(query: str, endpoint: str) -> dict:\n    \"\"\"Fetches analytics data from the GraphQL endpoint.\n\n    :param query: GraphQL query string\n    :param endpoint: GraphQL endpoint URL\n    :return: Dictionary containing analytics data with keys:\n        - pageViews (int): Number of page views\n        - timeOnPage (float): Average time spent on page in minutes\n        - clickThroughRate (float): Click-through rate as decimal\n        - userInteractions (list): List of interaction events\n    :raises ConnectionError: If unable to connect to the endpoint\"\"\"\n    pass\n", "function_schema_json": [{"name": "analyze_traffic_csv", "description": "Analyzes website traffic data to identify days with unusually low traffic.", "parameters": {"type": "object", "properties": {"file_path": {"type": "string", "description": "Path to the CSV file containing traffic data"}, "threshold_percentile": {"type": "number", "description": "Percentile threshold for identifying low traffic (default: 10)"}}, "required": ["file_path", "threshold_percentile"], "additionalProperties": false}}, {"name": "build_graphql_query", "description": "Builds a GraphQL query for retrieving detailed analytics for a specific date.", "parameters": {"type": "object", "properties": {"date": {"type": "string", "description": "Date in YYYY-MM-DD format"}}, "required": ["date"], "additionalProperties": false}}, {"name": "fetch_analytics_data", "description": "Fetches analytics data from the GraphQL endpoint.", "parameters": {"type": "object", "properties": {"query": {"type": "string", "description": "GraphQL query string"}, "endpoint": {"type": "string", "description": "GraphQL endpoint URL"}}, "required": ["query", "endpoint"], "additionalProperties": false}}], "mock_functions": "def analyze_traffic_csv(file_path: str, threshold_percentile: float = 10) -> list[dict]:\n    \"\"\"\n    Analyzes website traffic data to identify days with unusually low traffic.\n    \n    :param file_path: Path to the CSV file containing traffic data\n    :param threshold_percentile: Percentile threshold for identifying low traffic (default: 10)\n    :return: List of dictionaries containing dates and traffic metrics for low-traffic days\n    :raises FileNotFoundError: If the CSV file doesn't exist\n    \"\"\"\n    if not file_path.endswith('website_traffic.csv'):\n        raise FileNotFoundError(\"Invalid file path\")\n    \n    return [\n        {\"date\": \"2024-03-15\", \"visits\": 1200, \"bounce_rate\": 0.65},\n        {\"date\": \"2024-04-20\", \"visits\": 980, \"bounce_rate\": 0.72},\n        {\"date\": \"2024-05-10\", \"visits\": 850, \"bounce_rate\": 0.68}\n    ]\ndef build_graphql_query(date: str) -> str:\n    \"\"\"\n    Builds a GraphQL query for retrieving detailed analytics for a specific date.\n    \n    :param date: Date in YYYY-MM-DD format\n    :return: GraphQL query string\n    :raises ValueError: If date format is invalid\n    \"\"\"\n    if not (len(date) == 10 and date[4] == '-' and date[7] == '-'):\n        raise ValueError(\"Invalid date format\")\n    \n    return f\"\"\"\n    query {{\n        dailyAnalytics(date: \"{date}\") {{\n            pageViews\n            timeOnPage\n            clickThroughRate\n            userInteractions\n        }}\n    }}\n    \"\"\"\ndef fetch_analytics_data(query: str, endpoint: str) -> dict:\n    \"\"\"\n    Fetches analytics data from the GraphQL endpoint.\n    \n    :param query: GraphQL query string\n    :param endpoint: GraphQL endpoint URL\n    :return: Dictionary containing analytics data with keys:\n        - pageViews (int): Number of page views\n        - timeOnPage (float): Average time spent on page in minutes\n        - clickThroughRate (float): Click-through rate as decimal\n        - userInteractions (list): List of interaction events\n    :raises ConnectionError: If unable to connect to the endpoint\n    \"\"\"\n    if not endpoint.endswith('beta_analytics.graphql'):\n        raise ConnectionError(\"Invalid endpoint\")\n    \n    # Mock response based on typical patterns\n    return {\n        \"pageViews\": 1200,\n        \"timeOnPage\": 2.5,\n        \"clickThroughRate\": 0.15,\n        \"userInteractions\": [\n            \"header_click\",\n            \"menu_navigation\",\n            \"footer_link\"\n        ]\n    }", "user_query": "Could you analyze the traffic data from website_traffic.csv to find days with unusually low traffic?", "checklist": {"functions": ["analyze_traffic_csv"], "values": [[{"date": "2024-03-15", "visits": 1200, "bounce_rate": 0.65}, {"date": "2024-04-20", "visits": 980, "bounce_rate": 0.72}, {"date": "2024-05-10", "visits": 850, "bounce_rate": 0.68}]]}}
{"difficulty": "easy", "function_schema_python": "def get_cache_metrics(cache_id: str) -> dict:\n    \"\"\"Retrieves current cache performance metrics.\n\n    :param cache_id: Unique identifier for the Redis cache instance\n    :return: Dictionary containing cache metrics\n        - hit_rate (float): Current cache hit rate percentage\n        - memory_usage (float): Current memory usage in GB\n        - queries_per_hour (int): Number of queries processed per hour\n        - avg_response_time (float): Average response time in milliseconds\n    :raises ValueError: If cache_id is invalid\"\"\"\n    pass\ndef update_cache_config(cache_id: str, size_gb: float, ttl_minutes: int, eviction_policy: str) -> bool:\n    \"\"\"Updates Redis cache configuration parameters.\n\n    :param cache_id: Unique identifier for the Redis cache instance\n    :param size_gb: Maximum cache size in gigabytes\n    :param ttl_minutes: Time-to-live in minutes\n    :param eviction_policy: Redis eviction policy (e.g., 'LRU', 'LFU', 'RANDOM')\n    :return: True if update successful, False otherwise\n    :raises ValueError: If parameters are invalid\"\"\"\n    pass\ndef analyze_traffic_patterns(timeframe_hours: int) -> dict:\n    \"\"\"Analyzes cache traffic patterns for optimization.\n\n    :param timeframe_hours: Number of hours of historical data to analyze\n    :return: Dictionary containing traffic analysis\n        - peak_hours (list[int]): List of hours with highest traffic\n        - recommended_ttl (int): Recommended TTL in minutes\n        - recommended_size (float): Recommended cache size in GB\n        - recommended_policy (str): Recommended eviction policy\n    :raises ValueError: If timeframe is invalid\"\"\"\n    pass\n", "function_schema_json": [{"name": "get_cache_metrics", "description": "Retrieves current cache performance metrics.", "parameters": {"type": "object", "properties": {"cache_id": {"type": "string", "description": "Unique identifier for the Redis cache instance"}}, "required": ["cache_id"], "additionalProperties": false}}, {"name": "update_cache_config", "description": "Updates Redis cache configuration parameters.", "parameters": {"type": "object", "properties": {"cache_id": {"type": "string", "description": "Unique identifier for the Redis cache instance"}, "size_gb": {"type": "number", "description": "Maximum cache size in gigabytes"}, "ttl_minutes": {"type": "integer", "description": "Time-to-live in minutes"}, "eviction_policy": {"type": "string", "description": "Redis eviction policy (e.g., 'LRU', 'LFU', 'RANDOM')"}}, "required": ["cache_id", "size_gb", "ttl_minutes", "eviction_policy"], "additionalProperties": false}}, {"name": "analyze_traffic_patterns", "description": "Analyzes cache traffic patterns for optimization.", "parameters": {"type": "object", "properties": {"timeframe_hours": {"type": "integer", "description": "Number of hours of historical data to analyze"}}, "required": ["timeframe_hours"], "additionalProperties": false}}], "mock_functions": "def get_cache_metrics(cache_id: str) -> dict:\n    \"\"\"\n    Retrieves current cache performance metrics.\n    \n    :param cache_id: Unique identifier for the Redis cache instance\n    :return: Dictionary containing cache metrics\n        - hit_rate (float): Current cache hit rate percentage\n        - memory_usage (float): Current memory usage in GB\n        - queries_per_hour (int): Number of queries processed per hour\n        - avg_response_time (float): Average response time in milliseconds\n    :raises ValueError: If cache_id is invalid\n    \"\"\"\n    if not cache_id or not isinstance(cache_id, str):\n        raise ValueError(\"Invalid cache ID\")\n    if cache_id == \"prod_catalog_cache\":\n        return {\n            \"hit_rate\": 62.0,\n            \"memory_usage\": 1.8,\n            \"queries_per_hour\": 50000,\n            \"avg_response_time\": 15.5\n        }\n    raise ValueError(\"Cache ID not found\")\ndef update_cache_config(cache_id: str, size_gb: float, ttl_minutes: int, eviction_policy: str) -> bool:\n    \"\"\"\n    Updates Redis cache configuration parameters.\n    \n    :param cache_id: Unique identifier for the Redis cache instance\n    :param size_gb: Maximum cache size in gigabytes\n    :param ttl_minutes: Time-to-live in minutes\n    :param eviction_policy: Redis eviction policy (e.g., 'LRU', 'LFU', 'RANDOM')\n    :return: True if update successful, False otherwise\n    :raises ValueError: If parameters are invalid\n    \"\"\"\n    valid_policies = ['LRU', 'LFU', 'RANDOM']\n    if not cache_id or size_gb <= 0 or ttl_minutes <= 0 or eviction_policy not in valid_policies:\n        raise ValueError(\"Invalid configuration parameters\")\n    if cache_id == \"prod_catalog_cache\" and 1 <= size_gb <= 10 and 5 <= ttl_minutes <= 120:\n        return True\n    return False\ndef analyze_traffic_patterns(timeframe_hours: int) -> dict:\n    \"\"\"\n    Analyzes cache traffic patterns for optimization.\n    \n    :param timeframe_hours: Number of hours of historical data to analyze\n    :return: Dictionary containing traffic analysis\n        - peak_hours (list[int]): List of hours with highest traffic\n        - recommended_ttl (int): Recommended TTL in minutes\n        - recommended_size (float): Recommended cache size in GB\n        - recommended_policy (str): Recommended eviction policy\n    :raises ValueError: If timeframe is invalid\n    \"\"\"\n    if not isinstance(timeframe_hours, int) or timeframe_hours <= 0:\n        raise ValueError(\"Invalid timeframe\")\n    if timeframe_hours == 24:\n        return {\n            \"peak_hours\": [9, 10, 11, 14, 15, 16],\n            \"recommended_ttl\": 45,\n            \"recommended_size\": 3.5,\n            \"recommended_policy\": \"LRU\"\n        }\n    return {}", "user_query": "What is the current hit rate for the prod_catalog_cache?", "checklist": {"functions": ["get_cache_metrics"], "values": [{"hit_rate": 62.0, "memory_usage": 1.8, "queries_per_hour": 50000, "avg_response_time": 15.5}]}}
{"difficulty": "easy", "function_schema_python": "def get_cache_metrics(cache_id: str) -> dict:\n    \"\"\"Retrieves current cache performance metrics.\n\n    :param cache_id: Unique identifier for the Redis cache instance\n    :return: Dictionary containing cache metrics\n        - hit_rate (float): Current cache hit rate percentage\n        - memory_usage (float): Current memory usage in GB\n        - queries_per_hour (int): Number of queries processed per hour\n        - avg_response_time (float): Average response time in milliseconds\n    :raises ValueError: If cache_id is invalid\"\"\"\n    pass\ndef update_cache_config(cache_id: str, size_gb: float, ttl_minutes: int, eviction_policy: str) -> bool:\n    \"\"\"Updates Redis cache configuration parameters.\n\n    :param cache_id: Unique identifier for the Redis cache instance\n    :param size_gb: Maximum cache size in gigabytes\n    :param ttl_minutes: Time-to-live in minutes\n    :param eviction_policy: Redis eviction policy (e.g., 'LRU', 'LFU', 'RANDOM')\n    :return: True if update successful, False otherwise\n    :raises ValueError: If parameters are invalid\"\"\"\n    pass\ndef analyze_traffic_patterns(timeframe_hours: int) -> dict:\n    \"\"\"Analyzes cache traffic patterns for optimization.\n\n    :param timeframe_hours: Number of hours of historical data to analyze\n    :return: Dictionary containing traffic analysis\n        - peak_hours (list[int]): List of hours with highest traffic\n        - recommended_ttl (int): Recommended TTL in minutes\n        - recommended_size (float): Recommended cache size in GB\n        - recommended_policy (str): Recommended eviction policy\n    :raises ValueError: If timeframe is invalid\"\"\"\n    pass\n", "function_schema_json": [{"name": "get_cache_metrics", "description": "Retrieves current cache performance metrics.", "parameters": {"type": "object", "properties": {"cache_id": {"type": "string", "description": "Unique identifier for the Redis cache instance"}}, "required": ["cache_id"], "additionalProperties": false}}, {"name": "update_cache_config", "description": "Updates Redis cache configuration parameters.", "parameters": {"type": "object", "properties": {"cache_id": {"type": "string", "description": "Unique identifier for the Redis cache instance"}, "size_gb": {"type": "number", "description": "Maximum cache size in gigabytes"}, "ttl_minutes": {"type": "integer", "description": "Time-to-live in minutes"}, "eviction_policy": {"type": "string", "description": "Redis eviction policy (e.g., 'LRU', 'LFU', 'RANDOM')"}}, "required": ["cache_id", "size_gb", "ttl_minutes", "eviction_policy"], "additionalProperties": false}}, {"name": "analyze_traffic_patterns", "description": "Analyzes cache traffic patterns for optimization.", "parameters": {"type": "object", "properties": {"timeframe_hours": {"type": "integer", "description": "Number of hours of historical data to analyze"}}, "required": ["timeframe_hours"], "additionalProperties": false}}], "mock_functions": "def get_cache_metrics(cache_id: str) -> dict:\n    \"\"\"\n    Retrieves current cache performance metrics.\n    \n    :param cache_id: Unique identifier for the Redis cache instance\n    :return: Dictionary containing cache metrics\n        - hit_rate (float): Current cache hit rate percentage\n        - memory_usage (float): Current memory usage in GB\n        - queries_per_hour (int): Number of queries processed per hour\n        - avg_response_time (float): Average response time in milliseconds\n    :raises ValueError: If cache_id is invalid\n    \"\"\"\n    if not cache_id or not isinstance(cache_id, str):\n        raise ValueError(\"Invalid cache ID\")\n    if cache_id == \"prod_catalog_cache\":\n        return {\n            \"hit_rate\": 62.0,\n            \"memory_usage\": 1.8,\n            \"queries_per_hour\": 50000,\n            \"avg_response_time\": 15.5\n        }\n    raise ValueError(\"Cache ID not found\")\ndef update_cache_config(cache_id: str, size_gb: float, ttl_minutes: int, eviction_policy: str) -> bool:\n    \"\"\"\n    Updates Redis cache configuration parameters.\n    \n    :param cache_id: Unique identifier for the Redis cache instance\n    :param size_gb: Maximum cache size in gigabytes\n    :param ttl_minutes: Time-to-live in minutes\n    :param eviction_policy: Redis eviction policy (e.g., 'LRU', 'LFU', 'RANDOM')\n    :return: True if update successful, False otherwise\n    :raises ValueError: If parameters are invalid\n    \"\"\"\n    valid_policies = ['LRU', 'LFU', 'RANDOM']\n    if not cache_id or size_gb <= 0 or ttl_minutes <= 0 or eviction_policy not in valid_policies:\n        raise ValueError(\"Invalid configuration parameters\")\n    if cache_id == \"prod_catalog_cache\" and 1 <= size_gb <= 10 and 5 <= ttl_minutes <= 120:\n        return True\n    return False\ndef analyze_traffic_patterns(timeframe_hours: int) -> dict:\n    \"\"\"\n    Analyzes cache traffic patterns for optimization.\n    \n    :param timeframe_hours: Number of hours of historical data to analyze\n    :return: Dictionary containing traffic analysis\n        - peak_hours (list[int]): List of hours with highest traffic\n        - recommended_ttl (int): Recommended TTL in minutes\n        - recommended_size (float): Recommended cache size in GB\n        - recommended_policy (str): Recommended eviction policy\n    :raises ValueError: If timeframe is invalid\n    \"\"\"\n    if not isinstance(timeframe_hours, int) or timeframe_hours <= 0:\n        raise ValueError(\"Invalid timeframe\")\n    if timeframe_hours == 24:\n        return {\n            \"peak_hours\": [9, 10, 11, 14, 15, 16],\n            \"recommended_ttl\": 45,\n            \"recommended_size\": 3.5,\n            \"recommended_policy\": \"LRU\"\n        }\n    return {}", "user_query": "This is Sarah from TechFlow Solutions.  Set the prod_catalog_cache size to 3GB, TTL to 45 minutes, and use the LRU eviction policy.", "checklist": {"functions": ["update_cache_config"], "values": [true]}}
{"difficulty": "easy", "function_schema_python": "def get_order_details(order_id: str) -> dict:\n    \"\"\"Retrieves the details of a specific order.\n\n    :param order_id: The unique identifier of the order.\n    :return: Dictionary containing order details.\n    :raises ValueError: If order_id is invalid.\"\"\"\n    pass\ndef validate_transaction(transaction_id: str, expected_amount: float) -> dict:\n    \"\"\"Validates a transaction by comparing the expected amount with the actual charged amount.\n\n    :param transaction_id: The unique identifier of the transaction.\n    :param expected_amount: The expected transaction amount.\n    :return: Dictionary containing transaction validation details.\n    :raises ValueError: If transaction_id is invalid or expected_amount is negative.\"\"\"\n    pass\ndef create_support_ticket(customer_id: str, order_id: str, issue_description: str) -> dict:\n    \"\"\"Creates a customer support ticket for order-related issues.\n\n    :param customer_id: The unique identifier of the customer.\n    :param order_id: The order ID related to the issue.\n    :param issue_description: Description of the issue.\n    :return: Dictionary containing support ticket details.\n    :raises ValueError: If any parameter is invalid.\"\"\"\n    pass\n", "function_schema_json": [{"name": "get_order_details", "description": "Retrieves the details of a specific order.", "parameters": {"type": "object", "properties": {"order_id": {"type": "string", "description": "The unique identifier of the order."}}, "required": ["order_id"], "additionalProperties": false}}, {"name": "validate_transaction", "description": "Validates a transaction by comparing the expected amount with the actual charged amount.", "parameters": {"type": "object", "properties": {"transaction_id": {"type": "string", "description": "The unique identifier of the transaction."}, "expected_amount": {"type": "number", "description": "The expected transaction amount."}}, "required": ["transaction_id", "expected_amount"], "additionalProperties": false}}, {"name": "create_support_ticket", "description": "Creates a customer support ticket for order-related issues.", "parameters": {"type": "object", "properties": {"customer_id": {"type": "string", "description": "The unique identifier of the customer."}, "order_id": {"type": "string", "description": "The order ID related to the issue."}, "issue_description": {"type": "string", "description": "Description of the issue."}}, "required": ["customer_id", "order_id", "issue_description"], "additionalProperties": false}}], "mock_functions": "def get_order_details(order_id: str) -> dict:\n    \"\"\"\n    Retrieves the details of a specific order.\n    \n    :param order_id: The unique identifier of the order.\n    :return: Dictionary containing order details.\n    :raises ValueError: If order_id is invalid.\n    \"\"\"\n    if not order_id or not isinstance(order_id, str):\n        raise ValueError(\"Invalid order ID\")\n    \n    if order_id == \"ORD123456\":\n        return {\n            \"items\": [\n                {\"name\": \"Chicken Alfredo pasta\", \"price\": 14.99},\n                {\"name\": \"Caesar salad\", \"price\": 8.50}\n            ],\n            \"subtotal\": 23.49,\n            \"tax\": 2.50,\n            \"total\": 25.99,\n            \"restaurant\": \"Alfredo's Kitchen\",\n            \"customer\": \"Emma\",\n            \"status\": \"completed\"\n        }\n    return {}\ndef validate_transaction(transaction_id: str, expected_amount: float) -> dict:\n    \"\"\"\n    Validates a transaction by comparing the expected amount with the actual charged amount.\n    \n    :param transaction_id: The unique identifier of the transaction.\n    :param expected_amount: The expected transaction amount.\n    :return: Dictionary containing transaction validation details.\n    :raises ValueError: If transaction_id is invalid or expected_amount is negative.\n    \"\"\"\n    if not transaction_id or expected_amount < 0:\n        raise ValueError(\"Invalid transaction ID or amount\")\n    \n    if transaction_id == \"TXN789012\":\n        return {\n            \"transaction_id\": \"TXN789012\",\n            \"charged_amount\": 25.99,\n            \"expected_amount\": expected_amount,\n            \"discrepancy\": True,\n            \"discrepancy_amount\": 25.99 - expected_amount,\n            \"timestamp\": \"2023-07-20T19:30:00Z\"\n        }\n    return {}\ndef create_support_ticket(customer_id: str, order_id: str, issue_description: str) -> dict:\n    \"\"\"\n    Creates a customer support ticket for order-related issues.\n    \n    :param customer_id: The unique identifier of the customer.\n    :param order_id: The order ID related to the issue.\n    :param issue_description: Description of the issue.\n    :return: Dictionary containing support ticket details.\n    :raises ValueError: If any parameter is invalid.\n    \"\"\"\n    if not all([customer_id, order_id, issue_description]):\n        raise ValueError(\"All parameters must be provided\")\n    \n    if customer_id == \"CUST456\" and order_id == \"ORD123456\":\n        return {\n            \"ticket_id\": \"TCKT101112\",\n            \"status\": \"open\",\n            \"priority\": \"high\",\n            \"customer_id\": customer_id,\n            \"order_id\": order_id,\n            \"issue_description\": issue_description,\n            \"created_at\": \"2023-07-20T20:15:00Z\"\n        }\n    return {}", "user_query": "Can you get the order details for order ID \"ORD123456\"?", "checklist": {"functions": ["get_order_details"], "values": [{"items": [{"name": "Chicken Alfredo pasta", "price": 14.99}, {"name": "Caesar salad", "price": 8.5}], "subtotal": 23.49, "tax": 2.5, "total": 25.99, "restaurant": "Alfredo's Kitchen", "customer": "Emma", "status": "completed"}]}}
{"difficulty": "easy", "function_schema_python": "def get_order_details(order_id: str) -> dict:\n    \"\"\"Retrieves the details of a specific order.\n\n    :param order_id: The unique identifier of the order.\n    :return: A dictionary containing order details with keys:\n        - items (list[dict]): List of ordered items with 'name' and 'price'\n        - total (float): Total order amount\n        - status (str): Order status\n        - timestamp (str): Order timestamp\n    :raises ValueError: If order_id is invalid or empty\"\"\"\n    pass\ndef verify_original_transaction(transaction_id: str) -> dict:\n    \"\"\"Verifies the original transaction details from payment processor.\n\n    :param transaction_id: The unique identifier of the transaction\n    :return: A dictionary containing transaction details with keys:\n        - items (list[dict]): List of items in original transaction\n        - amount (float): Transaction amount\n        - timestamp (str): Transaction timestamp\n    :raises ValueError: If transaction_id is invalid\"\"\"\n    pass\ndef correct_order_record(order_id: str, transaction_id: str) -> bool:\n    \"\"\"Corrects the order record based on the verified transaction.\n\n    :param order_id: The unique identifier of the order to correct\n    :param transaction_id: The transaction ID to reference\n    :return: True if correction was successful, False otherwise\n    :raises ValueError: If either ID is invalid\"\"\"\n    pass\ndef send_correction_confirmation(email: str, order_id: str) -> bool:\n    \"\"\"Sends a confirmation email about the order correction.\n\n    :param email: The recipient's email address\n    :param order_id: The order ID that was corrected\n    :return: True if email was sent successfully, False otherwise\n    :raises ValueError: If email is invalid or order_id is empty\"\"\"\n    pass\n", "function_schema_json": [{"name": "get_order_details", "description": "Retrieves the details of a specific order.", "parameters": {"type": "object", "properties": {"order_id": {"type": "string", "description": "The unique identifier of the order."}}, "required": ["order_id"], "additionalProperties": false}}, {"name": "verify_original_transaction", "description": "Verifies the original transaction details from payment processor.", "parameters": {"type": "object", "properties": {"transaction_id": {"type": "string", "description": "The unique identifier of the transaction"}}, "required": ["transaction_id"], "additionalProperties": false}}, {"name": "correct_order_record", "description": "Corrects the order record based on the verified transaction.", "parameters": {"type": "object", "properties": {"order_id": {"type": "string", "description": "The unique identifier of the order to correct"}, "transaction_id": {"type": "string", "description": "The transaction ID to reference"}}, "required": ["order_id", "transaction_id"], "additionalProperties": false}}, {"name": "send_correction_confirmation", "description": "Sends a confirmation email about the order correction.", "parameters": {"type": "object", "properties": {"email": {"type": "string", "description": "The recipient's email address"}, "order_id": {"type": "string", "description": "The order ID that was corrected"}}, "required": ["email", "order_id"], "additionalProperties": false}}], "mock_functions": "def get_order_details(order_id: str) -> dict:\n    \"\"\"\n    Retrieves the details of a specific order.\n    \n    :param order_id: The unique identifier of the order.\n    :return: A dictionary containing order details with keys:\n        - items (list[dict]): List of ordered items with 'name' and 'price'\n        - total (float): Total order amount\n        - status (str): Order status\n        - timestamp (str): Order timestamp\n    :raises ValueError: If order_id is invalid or empty\n    \"\"\"\n    if not order_id:\n        raise ValueError(\"Order ID cannot be empty\")\n    if order_id == \"ORDER123\":\n        return {\n            \"items\": [\n                {\"name\": \"Vegetarian Platter\", \"price\": 22.00},\n                {\"name\": \"Miso Soup\", \"price\": 5.00}\n            ],\n            \"total\": 27.00,\n            \"status\": \"Delivered\",\n            \"timestamp\": \"2023-07-20 18:30:00\"\n        }\n    raise ValueError(\"Invalid order ID\")\ndef verify_original_transaction(transaction_id: str) -> dict:\n    \"\"\"\n    Verifies the original transaction details from payment processor.\n    \n    :param transaction_id: The unique identifier of the transaction\n    :return: A dictionary containing transaction details with keys:\n        - items (list[dict]): List of items in original transaction\n        - amount (float): Transaction amount\n        - timestamp (str): Transaction timestamp\n    :raises ValueError: If transaction_id is invalid\n    \"\"\"\n    if not transaction_id:\n        raise ValueError(\"Transaction ID cannot be empty\")\n    if transaction_id == \"TXN456\":\n        return {\n            \"items\": [\n                {\"name\": \"Sushi Combo\", \"price\": 22.00},\n                {\"name\": \"Miso Soup\", \"price\": 5.00}\n            ],\n            \"amount\": 27.00,\n            \"timestamp\": \"2023-07-20 18:30:00\"\n        }\n    raise ValueError(\"Invalid transaction ID\")\ndef correct_order_record(order_id: str, transaction_id: str) -> bool:\n    \"\"\"\n    Corrects the order record based on the verified transaction.\n    \n    :param order_id: The unique identifier of the order to correct\n    :param transaction_id: The transaction ID to reference\n    :return: True if correction was successful, False otherwise\n    :raises ValueError: If either ID is invalid\n    \"\"\"\n    if not order_id or not transaction_id:\n        raise ValueError(\"Both order ID and transaction ID are required\")\n    if order_id == \"ORDER123\" and transaction_id == \"TXN456\":\n        return True\n    return False\ndef send_correction_confirmation(email: str, order_id: str) -> bool:\n    \"\"\"\n    Sends a confirmation email about the order correction.\n    \n    :param email: The recipient's email address\n    :param order_id: The order ID that was corrected\n    :return: True if email was sent successfully, False otherwise\n    :raises ValueError: If email is invalid or order_id is empty\n    \"\"\"\n    if not email or not order_id:\n        raise ValueError(\"Email and order ID are required\")\n    if email == \"mark@email.com\" and order_id == \"ORDER123\":\n        return True\n    return False", "user_query": "What are the details of order ID ORDER123?", "checklist": {"functions": ["get_order_details"], "values": [{"items": [{"name": "Vegetarian Platter", "price": 22.0}, {"name": "Miso Soup", "price": 5.0}], "total": 27.0, "status": "Delivered", "timestamp": "2023-07-20 18:30:00"}]}}
{"difficulty": "easy", "function_schema_python": "def create_calendar_event(event_name: str, date: str, attendees: list[str]) -> dict:\n    \"\"\"Creates a calendar event and sends invitations to attendees.\n\n    :param event_name: Name of the event\n    :param date: Date of the event in 'YYYY-MM-DD' format\n    :param attendees: List of email addresses for attendees\n    :return: Dictionary containing event details and status\n    :raises ValueError: If date format is incorrect or attendee list is empty\"\"\"\n    pass\ndef track_family_preferences(family_member: str, preferences: dict) -> dict:\n    \"\"\"Records preferences for a family member regarding the reunion.\n\n    :param family_member: Name of the family member\n    :param preferences: Dictionary containing dietary, activity, and accommodation preferences\n    :return: Dictionary containing processed preferences and status\n    :raises ValueError: If preferences are invalid or incomplete\"\"\"\n    pass\ndef schedule_group_activity(activity_name: str, date: str, participants: list[str]) -> dict:\n    \"\"\"Schedules a group activity during the reunion.\n\n    :param activity_name: Name of the activity\n    :param date: Date of the activity in 'YYYY-MM-DD' format\n    :param participants: List of participant names\n    :return: Dictionary containing activity details and scheduling status\"\"\"\n    pass\n", "function_schema_json": [{"name": "create_calendar_event", "description": "Creates a calendar event and sends invitations to attendees.", "parameters": {"type": "object", "properties": {"event_name": {"type": "string", "description": "Name of the event"}, "date": {"type": "string", "description": "Date of the event in 'YYYY-MM-DD' format"}, "attendees": {"type": "array", "items": {"type": "string"}, "description": "List of email addresses for attendees"}}, "required": ["event_name", "date", "attendees"], "additionalProperties": false}}, {"name": "track_family_preferences", "description": "Records preferences for a family member regarding the reunion.", "parameters": {"type": "object", "properties": {"family_member": {"type": "string", "description": "Name of the family member"}, "preferences": {"type": "object", "description": "Dictionary containing dietary, activity, and accommodation preferences"}}, "required": ["family_member", "preferences"], "additionalProperties": false}}, {"name": "schedule_group_activity", "description": "Schedules a group activity during the reunion.", "parameters": {"type": "object", "properties": {"activity_name": {"type": "string", "description": "Name of the activity"}, "date": {"type": "string", "description": "Date of the activity in 'YYYY-MM-DD' format"}, "participants": {"type": "array", "items": {"type": "string"}, "description": "List of participant names"}}, "required": ["activity_name", "date", "participants"], "additionalProperties": false}}], "mock_functions": "def create_calendar_event(event_name: str, date: str, attendees: list[str]) -> dict:\n    \"\"\"\n    Creates a calendar event and sends invitations to attendees.\n    \n    :param event_name: Name of the event\n    :param date: Date of the event in 'YYYY-MM-DD' format\n    :param attendees: List of email addresses for attendees\n    :return: Dictionary containing event details and status\n    :raises ValueError: If date format is incorrect or attendee list is empty\n    \"\"\"\n    if not event_name or not date or not attendees:\n        raise ValueError(\"All parameters must be provided\")\n    \n    if date.startswith(\"2024-08\"):\n        return {\n            \"event_id\": \"reunion2024\",\n            \"status\": \"created\",\n            \"confirmed_attendees\": 0,\n            \"pending_responses\": len(attendees)\n        }\n    raise ValueError(\"Invalid date format or date outside reunion month\")\ndef track_family_preferences(family_member: str, preferences: dict) -> dict:\n    \"\"\"\n    Records preferences for a family member regarding the reunion.\n    \n    :param family_member: Name of the family member\n    :param preferences: Dictionary containing dietary, activity, and accommodation preferences\n    :return: Dictionary containing processed preferences and status\n    :raises ValueError: If preferences are invalid or incomplete\n    \"\"\"\n    required_keys = [\"dietary\", \"activities\", \"accommodation\"]\n    if not all(key in preferences for key in required_keys):\n        raise ValueError(\"Missing required preference categories\")\n    \n    if family_member == \"Maria Rodriguez\":\n        return {\n            \"member_id\": \"MR001\",\n            \"preferences_status\": \"recorded\",\n            \"preference_conflicts\": [],\n            \"special_requirements\": preferences.get(\"dietary\", [])\n        }\n    return {}\ndef schedule_group_activity(activity_name: str, date: str, participants: list[str]) -> dict:\n    \"\"\"\n    Schedules a group activity during the reunion.\n    \n    :param activity_name: Name of the activity\n    :param date: Date of the activity in 'YYYY-MM-DD' format\n    :param participants: List of participant names\n    :return: Dictionary containing activity details and scheduling status\n    \"\"\"\n    if not activity_name or not date or not participants:\n        raise ValueError(\"All parameters must be provided\")\n\n    if date.startswith(\"2024-08\"):\n        return {\n            \"activity_id\": \"act_001\",\n            \"status\": \"scheduled\",\n            \"capacity\": len(participants),\n            \"location\": \"Main Hall\",\n            \"time_slot\": \"10:00 AM - 12:00 PM\"\n        }\n    raise ValueError(\"Invalid date or activity details\")", "user_query": "Create a calendar event named \"Rodriguez Family Reunion\" for August 10th, 2024, inviting these email addresses:  [\"maria@email.com\", \"john@email.com\", \"susan@email.com\"].", "checklist": {"functions": ["create_calendar_event"], "values": [{"event_id": "reunion2024", "status": "created", "confirmed_attendees": 0, "pending_responses": 3}]}}
{"difficulty": "easy", "function_schema_python": "def create_calendar_event(event_name: str, date: str, attendees: list[str]) -> dict:\n    \"\"\"Creates a calendar event and sends invitations to attendees.\n\n    :param event_name: Name of the event\n    :param date: Date of the event in 'YYYY-MM-DD' format\n    :param attendees: List of email addresses for attendees\n    :return: Dictionary containing event details and status\n    :raises ValueError: If date format is incorrect or attendee list is empty\"\"\"\n    pass\ndef track_family_preferences(family_member: str, preferences: dict) -> dict:\n    \"\"\"Records preferences for a family member regarding the reunion.\n\n    :param family_member: Name of the family member\n    :param preferences: Dictionary containing dietary, activity, and accommodation preferences\n    :return: Dictionary containing processed preferences and status\n    :raises ValueError: If preferences are invalid or incomplete\"\"\"\n    pass\ndef schedule_group_activity(activity_name: str, date: str, participants: list[str]) -> dict:\n    \"\"\"Schedules a group activity during the reunion.\n\n    :param activity_name: Name of the activity\n    :param date: Date of the activity in 'YYYY-MM-DD' format\n    :param participants: List of participant names\n    :return: Dictionary containing activity details and scheduling status\"\"\"\n    pass\n", "function_schema_json": [{"name": "create_calendar_event", "description": "Creates a calendar event and sends invitations to attendees.", "parameters": {"type": "object", "properties": {"event_name": {"type": "string", "description": "Name of the event"}, "date": {"type": "string", "description": "Date of the event in 'YYYY-MM-DD' format"}, "attendees": {"type": "array", "items": {"type": "string"}, "description": "List of email addresses for attendees"}}, "required": ["event_name", "date", "attendees"], "additionalProperties": false}}, {"name": "track_family_preferences", "description": "Records preferences for a family member regarding the reunion.", "parameters": {"type": "object", "properties": {"family_member": {"type": "string", "description": "Name of the family member"}, "preferences": {"type": "object", "description": "Dictionary containing dietary, activity, and accommodation preferences"}}, "required": ["family_member", "preferences"], "additionalProperties": false}}, {"name": "schedule_group_activity", "description": "Schedules a group activity during the reunion.", "parameters": {"type": "object", "properties": {"activity_name": {"type": "string", "description": "Name of the activity"}, "date": {"type": "string", "description": "Date of the activity in 'YYYY-MM-DD' format"}, "participants": {"type": "array", "items": {"type": "string"}, "description": "List of participant names"}}, "required": ["activity_name", "date", "participants"], "additionalProperties": false}}], "mock_functions": "def create_calendar_event(event_name: str, date: str, attendees: list[str]) -> dict:\n    \"\"\"\n    Creates a calendar event and sends invitations to attendees.\n    \n    :param event_name: Name of the event\n    :param date: Date of the event in 'YYYY-MM-DD' format\n    :param attendees: List of email addresses for attendees\n    :return: Dictionary containing event details and status\n    :raises ValueError: If date format is incorrect or attendee list is empty\n    \"\"\"\n    if not event_name or not date or not attendees:\n        raise ValueError(\"All parameters must be provided\")\n    \n    if date.startswith(\"2024-08\"):\n        return {\n            \"event_id\": \"reunion2024\",\n            \"status\": \"created\",\n            \"confirmed_attendees\": 0,\n            \"pending_responses\": len(attendees)\n        }\n    raise ValueError(\"Invalid date format or date outside reunion month\")\ndef track_family_preferences(family_member: str, preferences: dict) -> dict:\n    \"\"\"\n    Records preferences for a family member regarding the reunion.\n    \n    :param family_member: Name of the family member\n    :param preferences: Dictionary containing dietary, activity, and accommodation preferences\n    :return: Dictionary containing processed preferences and status\n    :raises ValueError: If preferences are invalid or incomplete\n    \"\"\"\n    required_keys = [\"dietary\", \"activities\", \"accommodation\"]\n    if not all(key in preferences for key in required_keys):\n        raise ValueError(\"Missing required preference categories\")\n    \n    if family_member == \"Maria Rodriguez\":\n        return {\n            \"member_id\": \"MR001\",\n            \"preferences_status\": \"recorded\",\n            \"preference_conflicts\": [],\n            \"special_requirements\": preferences.get(\"dietary\", [])\n        }\n    return {}\ndef schedule_group_activity(activity_name: str, date: str, participants: list[str]) -> dict:\n    \"\"\"\n    Schedules a group activity during the reunion.\n    \n    :param activity_name: Name of the activity\n    :param date: Date of the activity in 'YYYY-MM-DD' format\n    :param participants: List of participant names\n    :return: Dictionary containing activity details and scheduling status\n    \"\"\"\n    if not activity_name or not date or not participants:\n        raise ValueError(\"All parameters must be provided\")\n\n    if date.startswith(\"2024-08\"):\n        return {\n            \"activity_id\": \"act_001\",\n            \"status\": \"scheduled\",\n            \"capacity\": len(participants),\n            \"location\": \"Main Hall\",\n            \"time_slot\": \"10:00 AM - 12:00 PM\"\n        }\n    raise ValueError(\"Invalid date or activity details\")", "user_query": "Track preferences for family member \"Maria Rodriguez\": dietary restrictions: [\"vegetarian\", \"gluten-free\"], preferred activities: [\"hiking\", \"swimming\"], preferred accommodation: \"hotel with pool\".", "checklist": {"functions": ["track_family_preferences"], "values": [{"member_id": "MR001", "preferences_status": "recorded", "preference_conflicts": [], "special_requirements": ["vegetarian", "gluten-free"]}]}}
{"difficulty": "easy", "function_schema_python": "def create_calendar_event(event_name: str, date: str, attendees: list[str]) -> dict:\n    \"\"\"Creates a calendar event and sends invitations to attendees.\n\n    :param event_name: Name of the event\n    :param date: Date of the event in 'YYYY-MM-DD' format\n    :param attendees: List of email addresses for attendees\n    :return: Dictionary containing event details and status\n    :raises ValueError: If date format is incorrect or attendee list is empty\"\"\"\n    pass\ndef track_family_preferences(family_member: str, preferences: dict) -> dict:\n    \"\"\"Records preferences for a family member regarding the reunion.\n\n    :param family_member: Name of the family member\n    :param preferences: Dictionary containing dietary, activity, and accommodation preferences\n    :return: Dictionary containing processed preferences and status\n    :raises ValueError: If preferences are invalid or incomplete\"\"\"\n    pass\ndef schedule_group_activity(activity_name: str, date: str, participants: list[str]) -> dict:\n    \"\"\"Schedules a group activity during the reunion.\n\n    :param activity_name: Name of the activity\n    :param date: Date of the activity in 'YYYY-MM-DD' format\n    :param participants: List of participant names\n    :return: Dictionary containing activity details and scheduling status\"\"\"\n    pass\n", "function_schema_json": [{"name": "create_calendar_event", "description": "Creates a calendar event and sends invitations to attendees.", "parameters": {"type": "object", "properties": {"event_name": {"type": "string", "description": "Name of the event"}, "date": {"type": "string", "description": "Date of the event in 'YYYY-MM-DD' format"}, "attendees": {"type": "array", "items": {"type": "string"}, "description": "List of email addresses for attendees"}}, "required": ["event_name", "date", "attendees"], "additionalProperties": false}}, {"name": "track_family_preferences", "description": "Records preferences for a family member regarding the reunion.", "parameters": {"type": "object", "properties": {"family_member": {"type": "string", "description": "Name of the family member"}, "preferences": {"type": "object", "description": "Dictionary containing dietary, activity, and accommodation preferences"}}, "required": ["family_member", "preferences"], "additionalProperties": false}}, {"name": "schedule_group_activity", "description": "Schedules a group activity during the reunion.", "parameters": {"type": "object", "properties": {"activity_name": {"type": "string", "description": "Name of the activity"}, "date": {"type": "string", "description": "Date of the activity in 'YYYY-MM-DD' format"}, "participants": {"type": "array", "items": {"type": "string"}, "description": "List of participant names"}}, "required": ["activity_name", "date", "participants"], "additionalProperties": false}}], "mock_functions": "def create_calendar_event(event_name: str, date: str, attendees: list[str]) -> dict:\n    \"\"\"\n    Creates a calendar event and sends invitations to attendees.\n    \n    :param event_name: Name of the event\n    :param date: Date of the event in 'YYYY-MM-DD' format\n    :param attendees: List of email addresses for attendees\n    :return: Dictionary containing event details and status\n    :raises ValueError: If date format is incorrect or attendee list is empty\n    \"\"\"\n    if not event_name or not date or not attendees:\n        raise ValueError(\"All parameters must be provided\")\n    \n    if date.startswith(\"2024-08\"):\n        return {\n            \"event_id\": \"reunion2024\",\n            \"status\": \"created\",\n            \"confirmed_attendees\": 0,\n            \"pending_responses\": len(attendees)\n        }\n    raise ValueError(\"Invalid date format or date outside reunion month\")\ndef track_family_preferences(family_member: str, preferences: dict) -> dict:\n    \"\"\"\n    Records preferences for a family member regarding the reunion.\n    \n    :param family_member: Name of the family member\n    :param preferences: Dictionary containing dietary, activity, and accommodation preferences\n    :return: Dictionary containing processed preferences and status\n    :raises ValueError: If preferences are invalid or incomplete\n    \"\"\"\n    required_keys = [\"dietary\", \"activities\", \"accommodation\"]\n    if not all(key in preferences for key in required_keys):\n        raise ValueError(\"Missing required preference categories\")\n    \n    if family_member == \"Maria Rodriguez\":\n        return {\n            \"member_id\": \"MR001\",\n            \"preferences_status\": \"recorded\",\n            \"preference_conflicts\": [],\n            \"special_requirements\": preferences.get(\"dietary\", [])\n        }\n    return {}\ndef schedule_group_activity(activity_name: str, date: str, participants: list[str]) -> dict:\n    \"\"\"\n    Schedules a group activity during the reunion.\n    \n    :param activity_name: Name of the activity\n    :param date: Date of the activity in 'YYYY-MM-DD' format\n    :param participants: List of participant names\n    :return: Dictionary containing activity details and scheduling status\n    \"\"\"\n    if not activity_name or not date or not participants:\n        raise ValueError(\"All parameters must be provided\")\n\n    if date.startswith(\"2024-08\"):\n        return {\n            \"activity_id\": \"act_001\",\n            \"status\": \"scheduled\",\n            \"capacity\": len(participants),\n            \"location\": \"Main Hall\",\n            \"time_slot\": \"10:00 AM - 12:00 PM\"\n        }\n    raise ValueError(\"Invalid date or activity details\")", "user_query": "Schedule a group activity called \"Family BBQ\" for August 11th, 2024, with these participants: [\"Maria Rodriguez\", \"John Rodriguez\", \"Susan Rodriguez\", \"David Rodriguez\"].", "checklist": {"functions": ["schedule_group_activity"], "values": [{"activity_id": "act_001", "status": "scheduled", "capacity": 4, "location": "Main Hall", "time_slot": "10:00 AM - 12:00 PM"}]}}
{"difficulty": "easy", "function_schema_python": "def get_colleague_schedule(day: str) -> dict:\n    \"\"\"Retrieves the availability schedule for colleagues on a given day.\n\n    :param day: The day of the week (e.g., \"Monday\").\n    :return:\n        dict: A dictionary with the following keys:\n            - mike (bool): Availability of Mike.\n            - jennifer (bool): Availability of Jennifer.\n            - david (bool): Availability of David.\n    :raises ValueError: If day is not a valid weekday.\"\"\"\n    pass\ndef calculate_ride_cost(distance: float, cost_per_mile: float, wear_tear_per_mile: float) -> float:\n    \"\"\"Calculates the total cost of the ride based on distance and cost factors.\n\n    :param distance: The total distance of the ride in miles.\n    :param cost_per_mile: The electricity cost per mile for the ride.\n    :param wear_tear_per_mile: The wear-and-tear cost per mile for the ride.\n    :return: The total cost of the ride in dollars.\n    :raises ValueError: If any parameter is invalid.\"\"\"\n    pass\ndef create_rideshare_transaction(amount: float, recipient: str, method: str) -> str:\n    \"\"\"Creates a transaction for the rideshare service.\n\n    :param amount: The amount to be transferred.\n    :param recipient: The recipient of the transaction (e.g., \"Mike\").\n    :param method: The payment method used for the transaction (e.g., \"Stripe\").\n    :return: A confirmation message for the transaction.\n    :raises ValueError: If any parameter is invalid.\"\"\"\n    pass\ndef log_event_in_calendar(day: str, time: str, activity: str) -> bool:\n    \"\"\"Logs an event in the calendar for a specific day and time.\n\n    :param day: The day of the week (e.g., \"Monday\").\n    :param time: The time of the event (e.g., \"7 AM\").\n    :param activity: A brief description of the event (e.g., \"Carpool to Tech Park\").\n    :return: True if the event was successfully logged, False otherwise.\n    :raises ValueError: If any parameter is invalid.\"\"\"\n    pass\ndef get_directions(origin: str, destination: str) -> dict:\n    \"\"\"Retrieves directions from Google Maps.\n\n    :param origin: The starting address.\n    :param destination: The destination address.\n    :return:\n        dict: A dictionary with the following keys:\n            - steps (list[str]): The list of steps in directions.\n            - estimated_time (str): Estimated time in \"1 hour 30 minutes\" format.\n    :raises ValueError: If origin or destination is empty.\"\"\"\n    pass\n", "function_schema_json": [{"name": "get_colleague_schedule", "description": "Retrieves the availability schedule for colleagues on a given day.", "parameters": {"type": "object", "properties": {"day": {"type": "string", "description": "The day of the week (e.g., \"Monday\")."}}, "required": ["day"], "additionalProperties": false}}, {"name": "calculate_ride_cost", "description": "Calculates the total cost of the ride based on distance and cost factors.", "parameters": {"type": "object", "properties": {"distance": {"type": "number", "description": "The total distance of the ride in miles."}, "cost_per_mile": {"type": "number", "description": "The electricity cost per mile for the ride."}, "wear_tear_per_mile": {"type": "number", "description": "The wear-and-tear cost per mile for the ride."}}, "required": ["distance", "cost_per_mile", "wear_tear_per_mile"], "additionalProperties": false}}, {"name": "create_rideshare_transaction", "description": "Creates a transaction for the rideshare service.", "parameters": {"type": "object", "properties": {"amount": {"type": "number", "description": "The amount to be transferred."}, "recipient": {"type": "string", "description": "The recipient of the transaction (e.g., \"Mike\")."}, "method": {"type": "string", "description": "The payment method used for the transaction (e.g., \"Stripe\")."}}, "required": ["amount", "recipient", "method"], "additionalProperties": false}}, {"name": "log_event_in_calendar", "description": "Logs an event in the calendar for a specific day and time.", "parameters": {"type": "object", "properties": {"day": {"type": "string", "description": "The day of the week (e.g., \"Monday\")."}, "time": {"type": "string", "description": "The time of the event (e.g., \"7 AM\")."}, "activity": {"type": "string", "description": "A brief description of the event (e.g., \"Carpool to Tech Park\")."}}, "required": ["day", "time", "activity"], "additionalProperties": false}}, {"name": "get_directions", "description": "Retrieves directions from Google Maps.", "parameters": {"type": "object", "properties": {"origin": {"type": "string", "description": "The starting address."}, "destination": {"type": "string", "description": "The destination address."}}, "required": ["origin", "destination"], "additionalProperties": false}}], "mock_functions": "def get_colleague_schedule(day: str) -> dict:\n    \"\"\"\n    Retrieves the availability schedule for colleagues on a given day.\n    \n    :param day: The day of the week (e.g., \"Monday\").\n    :return:\n        dict: A dictionary with the following keys:\n            - mike (bool): Availability of Mike.\n            - jennifer (bool): Availability of Jennifer.\n            - david (bool): Availability of David.\n    :raises ValueError: If day is not a valid weekday.\n    \"\"\"\n    weekdays = [\"monday\", \"tuesday\", \"wednesday\", \"thursday\", \"friday\"]\n    if day.lower() not in weekdays:\n        raise ValueError(\"Day must be a valid weekday (Monday through Friday).\")\n    # Mock logic: All colleagues are available on weekdays.\n    return {\n        \"mike\": True,\n        \"jennifer\": True,\n        \"david\": True\n    }\ndef calculate_ride_cost(distance: float, cost_per_mile: float, wear_tear_per_mile: float) -> float:\n    \"\"\"\n    Calculates the total cost of the ride based on distance and cost factors.\n    \n    :param distance: The total distance of the ride in miles.\n    :param cost_per_mile: The electricity cost per mile for the ride.\n    :param wear_tear_per_mile: The wear-and-tear cost per mile for the ride.\n    :return: The total cost of the ride in dollars.\n    :raises ValueError: If any parameter is invalid.\n    \"\"\"\n    if distance <= 0 or cost_per_mile < 0 or wear_tear_per_mile < 0:\n        raise ValueError(\"Distance must be positive, and costs per mile must be non-negative.\")\n    return (cost_per_mile + wear_tear_per_mile) * distance\ndef create_rideshare_transaction(amount: float, recipient: str, method: str) -> str:\n    \"\"\"\n    Creates a transaction for the rideshare service.\n    \n    :param amount: The amount to be transferred.\n    :param recipient: The recipient of the transaction (e.g., \"Mike\").\n    :param method: The payment method used for the transaction (e.g., \"Stripe\").\n    :return: A confirmation message for the transaction.\n    :raises ValueError: If any parameter is invalid.\n    \"\"\"\n    valid_methods = [\"stripe\", \"klarna\", \"openbanking\", \"plaid\", \"paypal-sdk\"]\n    if amount <= 0 or recipient.lower() not in [\"mike\", \"jennifer\", \"david\"] or method.lower() not in valid_methods:\n        raise ValueError(\"Invalid parameters for the transaction.\")\n    return f\"Transaction of ${amount:.2f} to {recipient} using {method} successful.\"\ndef log_event_in_calendar(day: str, time: str, activity: str) -> bool:\n    \"\"\"\n    Logs an event in the calendar for a specific day and time.\n    \n    :param day: The day of the week (e.g., \"Monday\").\n    :param time: The time of the event (e.g., \"7 AM\").\n    :param activity: A brief description of the event (e.g., \"Carpool to Tech Park\").\n    :return: True if the event was successfully logged, False otherwise.\n    :raises ValueError: If any parameter is invalid.\n    \"\"\"\n    weekdays = [\"monday\", \"tuesday\", \"wednesday\", \"thursday\", \"friday\"]\n    if day.lower() not in weekdays or not time or not activity:\n        raise ValueError(\"Invalid day, time, or activity for the event.\")\n    return True\ndef get_directions(origin: str, destination: str) -> dict:\n    \"\"\"\n    Retrieves directions from Google Maps.\n    \n    :param origin: The starting address.\n    :param destination: The destination address.\n    :return:\n        dict: A dictionary with the following keys:\n            - steps (list[str]): The list of steps in directions.\n            - estimated_time (str): Estimated time in \"1 hour 30 minutes\" format.\n    :raises ValueError: If origin or destination is empty.\n    \"\"\"\n    if not origin or not destination:\n        raise ValueError(\"Origin and destination must not be empty.\")\n    return {\n        \"steps\": [\n            \"Head east on Grand Ave.\",\n            \"Take exit 3 to Tech Park Rd.\",\n            \"Arrive at destination: Tech Park\"\n        ],\n        \"estimated_time\": \"30 minutes\"\n    }", "user_query": "Can you check if all my colleagues (Mike, Jennifer, and David) are available for carpooling on Monday?", "checklist": {"functions": ["get_colleague_schedule"], "values": [{"mike": true, "jennifer": true, "david": true}]}}
{"difficulty": "easy", "function_schema_python": "def get_colleague_schedule(day: str) -> dict:\n    \"\"\"Retrieves the availability schedule for colleagues on a given day.\n\n    :param day: The day of the week (e.g., \"Monday\").\n    :return:\n        dict: A dictionary with the following keys:\n            - mike (bool): Availability of Mike.\n            - jennifer (bool): Availability of Jennifer.\n            - david (bool): Availability of David.\n    :raises ValueError: If day is not a valid weekday.\"\"\"\n    pass\ndef calculate_ride_cost(distance: float, cost_per_mile: float, wear_tear_per_mile: float) -> float:\n    \"\"\"Calculates the total cost of the ride based on distance and cost factors.\n\n    :param distance: The total distance of the ride in miles.\n    :param cost_per_mile: The electricity cost per mile for the ride.\n    :param wear_tear_per_mile: The wear-and-tear cost per mile for the ride.\n    :return: The total cost of the ride in dollars.\n    :raises ValueError: If any parameter is invalid.\"\"\"\n    pass\ndef create_rideshare_transaction(amount: float, recipient: str, method: str) -> str:\n    \"\"\"Creates a transaction for the rideshare service.\n\n    :param amount: The amount to be transferred.\n    :param recipient: The recipient of the transaction (e.g., \"Mike\").\n    :param method: The payment method used for the transaction (e.g., \"Stripe\").\n    :return: A confirmation message for the transaction.\n    :raises ValueError: If any parameter is invalid.\"\"\"\n    pass\ndef log_event_in_calendar(day: str, time: str, activity: str) -> bool:\n    \"\"\"Logs an event in the calendar for a specific day and time.\n\n    :param day: The day of the week (e.g., \"Monday\").\n    :param time: The time of the event (e.g., \"7 AM\").\n    :param activity: A brief description of the event (e.g., \"Carpool to Tech Park\").\n    :return: True if the event was successfully logged, False otherwise.\n    :raises ValueError: If any parameter is invalid.\"\"\"\n    pass\ndef get_directions(origin: str, destination: str) -> dict:\n    \"\"\"Retrieves directions from Google Maps.\n\n    :param origin: The starting address.\n    :param destination: The destination address.\n    :return:\n        dict: A dictionary with the following keys:\n            - steps (list[str]): The list of steps in directions.\n            - estimated_time (str): Estimated time in \"1 hour 30 minutes\" format.\n    :raises ValueError: If origin or destination is empty.\"\"\"\n    pass\n", "function_schema_json": [{"name": "get_colleague_schedule", "description": "Retrieves the availability schedule for colleagues on a given day.", "parameters": {"type": "object", "properties": {"day": {"type": "string", "description": "The day of the week (e.g., \"Monday\")."}}, "required": ["day"], "additionalProperties": false}}, {"name": "calculate_ride_cost", "description": "Calculates the total cost of the ride based on distance and cost factors.", "parameters": {"type": "object", "properties": {"distance": {"type": "number", "description": "The total distance of the ride in miles."}, "cost_per_mile": {"type": "number", "description": "The electricity cost per mile for the ride."}, "wear_tear_per_mile": {"type": "number", "description": "The wear-and-tear cost per mile for the ride."}}, "required": ["distance", "cost_per_mile", "wear_tear_per_mile"], "additionalProperties": false}}, {"name": "create_rideshare_transaction", "description": "Creates a transaction for the rideshare service.", "parameters": {"type": "object", "properties": {"amount": {"type": "number", "description": "The amount to be transferred."}, "recipient": {"type": "string", "description": "The recipient of the transaction (e.g., \"Mike\")."}, "method": {"type": "string", "description": "The payment method used for the transaction (e.g., \"Stripe\")."}}, "required": ["amount", "recipient", "method"], "additionalProperties": false}}, {"name": "log_event_in_calendar", "description": "Logs an event in the calendar for a specific day and time.", "parameters": {"type": "object", "properties": {"day": {"type": "string", "description": "The day of the week (e.g., \"Monday\")."}, "time": {"type": "string", "description": "The time of the event (e.g., \"7 AM\")."}, "activity": {"type": "string", "description": "A brief description of the event (e.g., \"Carpool to Tech Park\")."}}, "required": ["day", "time", "activity"], "additionalProperties": false}}, {"name": "get_directions", "description": "Retrieves directions from Google Maps.", "parameters": {"type": "object", "properties": {"origin": {"type": "string", "description": "The starting address."}, "destination": {"type": "string", "description": "The destination address."}}, "required": ["origin", "destination"], "additionalProperties": false}}], "mock_functions": "def get_colleague_schedule(day: str) -> dict:\n    \"\"\"\n    Retrieves the availability schedule for colleagues on a given day.\n    \n    :param day: The day of the week (e.g., \"Monday\").\n    :return:\n        dict: A dictionary with the following keys:\n            - mike (bool): Availability of Mike.\n            - jennifer (bool): Availability of Jennifer.\n            - david (bool): Availability of David.\n    :raises ValueError: If day is not a valid weekday.\n    \"\"\"\n    weekdays = [\"monday\", \"tuesday\", \"wednesday\", \"thursday\", \"friday\"]\n    if day.lower() not in weekdays:\n        raise ValueError(\"Day must be a valid weekday (Monday through Friday).\")\n    # Mock logic: All colleagues are available on weekdays.\n    return {\n        \"mike\": True,\n        \"jennifer\": True,\n        \"david\": True\n    }\ndef calculate_ride_cost(distance: float, cost_per_mile: float, wear_tear_per_mile: float) -> float:\n    \"\"\"\n    Calculates the total cost of the ride based on distance and cost factors.\n    \n    :param distance: The total distance of the ride in miles.\n    :param cost_per_mile: The electricity cost per mile for the ride.\n    :param wear_tear_per_mile: The wear-and-tear cost per mile for the ride.\n    :return: The total cost of the ride in dollars.\n    :raises ValueError: If any parameter is invalid.\n    \"\"\"\n    if distance <= 0 or cost_per_mile < 0 or wear_tear_per_mile < 0:\n        raise ValueError(\"Distance must be positive, and costs per mile must be non-negative.\")\n    return (cost_per_mile + wear_tear_per_mile) * distance\ndef create_rideshare_transaction(amount: float, recipient: str, method: str) -> str:\n    \"\"\"\n    Creates a transaction for the rideshare service.\n    \n    :param amount: The amount to be transferred.\n    :param recipient: The recipient of the transaction (e.g., \"Mike\").\n    :param method: The payment method used for the transaction (e.g., \"Stripe\").\n    :return: A confirmation message for the transaction.\n    :raises ValueError: If any parameter is invalid.\n    \"\"\"\n    valid_methods = [\"stripe\", \"klarna\", \"openbanking\", \"plaid\", \"paypal-sdk\"]\n    if amount <= 0 or recipient.lower() not in [\"mike\", \"jennifer\", \"david\"] or method.lower() not in valid_methods:\n        raise ValueError(\"Invalid parameters for the transaction.\")\n    return f\"Transaction of ${amount:.2f} to {recipient} using {method} successful.\"\ndef log_event_in_calendar(day: str, time: str, activity: str) -> bool:\n    \"\"\"\n    Logs an event in the calendar for a specific day and time.\n    \n    :param day: The day of the week (e.g., \"Monday\").\n    :param time: The time of the event (e.g., \"7 AM\").\n    :param activity: A brief description of the event (e.g., \"Carpool to Tech Park\").\n    :return: True if the event was successfully logged, False otherwise.\n    :raises ValueError: If any parameter is invalid.\n    \"\"\"\n    weekdays = [\"monday\", \"tuesday\", \"wednesday\", \"thursday\", \"friday\"]\n    if day.lower() not in weekdays or not time or not activity:\n        raise ValueError(\"Invalid day, time, or activity for the event.\")\n    return True\ndef get_directions(origin: str, destination: str) -> dict:\n    \"\"\"\n    Retrieves directions from Google Maps.\n    \n    :param origin: The starting address.\n    :param destination: The destination address.\n    :return:\n        dict: A dictionary with the following keys:\n            - steps (list[str]): The list of steps in directions.\n            - estimated_time (str): Estimated time in \"1 hour 30 minutes\" format.\n    :raises ValueError: If origin or destination is empty.\n    \"\"\"\n    if not origin or not destination:\n        raise ValueError(\"Origin and destination must not be empty.\")\n    return {\n        \"steps\": [\n            \"Head east on Grand Ave.\",\n            \"Take exit 3 to Tech Park Rd.\",\n            \"Arrive at destination: Tech Park\"\n        ],\n        \"estimated_time\": \"30 minutes\"\n    }", "user_query": "Could you calculate the total cost of our 30-mile carpool ride with electricity at $0.15/mile and wear-and-tear at $0.20/mile?", "checklist": {"functions": ["calculate_ride_cost"], "values": [10.5]}}
{"difficulty": "easy", "function_schema_python": "def calculate_gas_cost(round_trip_distance: int, mpg: float, gas_price: float) -> float:\n    \"\"\"Calculates the total gas cost for the round trip.\n\n    :param round_trip_distance: Total distance of the round trip in miles.\n    :param mpg: Vehicle's miles per gallon.\n    :param gas_price: Price of gas per gallon.\n    :return: Total cost of gas for the trip.\"\"\"\n    pass\ndef calculate_total_trip_cost(round_trip_distance: int, mpg: float, gas_price: float, parking_cost: float, toll_cost: float) -> float:\n    \"\"\"Calculates the total cost of the trip, including gas, parking, and tolls.\n\n    :param round_trip_distance: Total distance of the round trip in miles.\n    :param mpg: Vehicle's miles per gallon.\n    :param gas_price: Price of gas per gallon.\n    :param parking_cost: Cost for resort parking.\n    :param toll_cost: Cost for tolls each way.\n    :return: Total cost of the trip.\"\"\"\n    pass\ndef calculate_individual_cost(total_trip_cost: float, number_of_participants: int) -> float:\n    \"\"\"Calculates the individual cost each participant needs to pay.\n\n    :param total_trip_cost: Total cost of the trip.\n    :param number_of_participants: Number of participants sharing the cost.\n    :return: Individual cost each participant pays.\"\"\"\n    pass\ndef add_event_to_calendar(event_name: str, date: str, time: str, location: str) -> bool:\n    \"\"\"Adds an event to a calendar.\n\n    :param event_name: The name of the event (e.g., \"Carpool to Snowpeak Resort\").\n    :param date: The event date (e.g., \"next Friday\").\n    :param time: The event time (e.g., \"8 AM\").\n    :param location: The event location (e.g., \"Snowpeak Resort\").\n    :return: True if the event was successfully added, False otherwise.\n    :raises ValueError: If any parameter is invalid.\"\"\"\n    pass\ndef send_email_notification(recipient: str, subject: str, message: str) -> bool:\n    \"\"\"Sends an email notification to a recipient.\n\n    :param recipient: The email address of the recipient.\n    :param subject: The subject line of the email.\n    :param message: The body of the email.\n    :return: True if the email was successfully sent, False otherwise.\n    :raises ValueError: If any parameter is invalid.\"\"\"\n    pass\ndef book_uber_pickup(location: str, pickup_time: str, dropoff_location: str, dropoff_time: str) -> dict:\n    \"\"\"Books an Uber pickup and dropoff.\n\n    :param location: The location for the pickup.\n    :param pickup_time: Expected pickup time.\n    :param dropoff_location: The location for the dropoff.\n    :param dropoff_time: Expected dropoff time.\n    :return:\n        dict: A dictionary with the following keys:\n            - booking_id (str): Unique booking identifier.\n            - pickup_time (str): Confirmed pickup time.\n            - dropoff_time (str): Confirmed dropoff time.\n            - driver_name (str): Name of the Uber driver.\n            - driver_phone (str): Phone number of the Uber driver.\n    :raises ValueError: If any parameter is invalid.\"\"\"\n    pass\ndef validate_payment(payment_method: str, amount: float, currency: str) -> bool:\n    \"\"\"Validates a payment using the specified payment method.\n\n    :param payment_method: The payment method used (e.g., \"stripe\").\n    :param amount: The amount to be charged.\n    :param currency: The currency of the payment (e.g., \"USD\").\n    :return: True if the payment is valid, False otherwise.\n    :raises ValueError: If any parameter is invalid.\"\"\"\n    pass\ndef create_trip_report(participants: list, total_trip_cost: float, individual_costs: dict) -> dict:\n    \"\"\"Creates a trip report with detailed cost information.\n\n    :param participants: List of participants in the trip.\n    :param total_trip_cost: Total cost of the trip.\n    :param individual_costs: Dictionary mapping each participant to their individual cost.\n    :return:\n        dict: A dictionary with the following keys:\n            - participants (list[str]): List of participants.\n            - total_trip_cost (float): Total cost of the trip.\n            - individual_costs (dict[str, float]): Dictionary mapping each participant to their individual cost.\n    :raises ValueError: If any parameter is invalid.\"\"\"\n    pass\n", "function_schema_json": [{"name": "calculate_gas_cost", "description": "Calculates the total gas cost for the round trip.", "parameters": {"type": "object", "properties": {"round_trip_distance": {"type": "integer", "description": "Total distance of the round trip in miles."}, "mpg": {"type": "number", "description": "Vehicle's miles per gallon."}, "gas_price": {"type": "number", "description": "Price of gas per gallon."}}, "required": ["round_trip_distance", "mpg", "gas_price"], "additionalProperties": false}}, {"name": "calculate_total_trip_cost", "description": "Calculates the total cost of the trip, including gas, parking, and tolls.", "parameters": {"type": "object", "properties": {"round_trip_distance": {"type": "integer", "description": "Total distance of the round trip in miles."}, "mpg": {"type": "number", "description": "Vehicle's miles per gallon."}, "gas_price": {"type": "number", "description": "Price of gas per gallon."}, "parking_cost": {"type": "number", "description": "Cost for resort parking."}, "toll_cost": {"type": "number", "description": "Cost for tolls each way."}}, "required": ["round_trip_distance", "mpg", "gas_price", "parking_cost", "toll_cost"], "additionalProperties": false}}, {"name": "calculate_individual_cost", "description": "Calculates the individual cost each participant needs to pay.", "parameters": {"type": "object", "properties": {"total_trip_cost": {"type": "number", "description": "Total cost of the trip."}, "number_of_participants": {"type": "integer", "description": "Number of participants sharing the cost."}}, "required": ["total_trip_cost", "number_of_participants"], "additionalProperties": false}}, {"name": "add_event_to_calendar", "description": "Adds an event to a calendar.", "parameters": {"type": "object", "properties": {"event_name": {"type": "string", "description": "The name of the event (e.g., \"Carpool to Snowpeak Resort\")."}, "date": {"type": "string", "description": "The event date (e.g., \"next Friday\")."}, "time": {"type": "string", "description": "The event time (e.g., \"8 AM\")."}, "location": {"type": "string", "description": "The event location (e.g., \"Snowpeak Resort\")."}}, "required": ["event_name", "date", "time", "location"], "additionalProperties": false}}, {"name": "send_email_notification", "description": "Sends an email notification to a recipient.", "parameters": {"type": "object", "properties": {"recipient": {"type": "string", "description": "The email address of the recipient."}, "subject": {"type": "string", "description": "The subject line of the email."}, "message": {"type": "string", "description": "The body of the email."}}, "required": ["recipient", "subject", "message"], "additionalProperties": false}}, {"name": "book_uber_pickup", "description": "Books an Uber pickup and dropoff.", "parameters": {"type": "object", "properties": {"location": {"type": "string", "description": "The location for the pickup."}, "pickup_time": {"type": "string", "description": "Expected pickup time."}, "dropoff_location": {"type": "string", "description": "The location for the dropoff."}, "dropoff_time": {"type": "string", "description": "Expected dropoff time."}}, "required": ["location", "pickup_time", "dropoff_location", "dropoff_time"], "additionalProperties": false}}, {"name": "validate_payment", "description": "Validates a payment using the specified payment method.", "parameters": {"type": "object", "properties": {"payment_method": {"type": "string", "description": "The payment method used (e.g., \"stripe\")."}, "amount": {"type": "number", "description": "The amount to be charged."}, "currency": {"type": "string", "description": "The currency of the payment (e.g., \"USD\")."}}, "required": ["payment_method", "amount", "currency"], "additionalProperties": false}}, {"name": "create_trip_report", "description": "Creates a trip report with detailed cost information.", "parameters": {"type": "object", "properties": {"participants": {"type": "array", "description": "List of participants in the trip."}, "total_trip_cost": {"type": "number", "description": "Total cost of the trip."}, "individual_costs": {"type": "object", "description": "Dictionary mapping each participant to their individual cost."}}, "required": ["participants", "total_trip_cost", "individual_costs"], "additionalProperties": false}}], "mock_functions": "def calculate_gas_cost(round_trip_distance: int, mpg: float, gas_price: float) -> float:\n    \"\"\"\n    Calculates the total gas cost for the round trip.\n    \n    :param round_trip_distance: Total distance of the round trip in miles.\n    :param mpg: Vehicle's miles per gallon.\n    :param gas_price: Price of gas per gallon.\n    :return: Total cost of gas for the trip.\n    \"\"\"\n    gallons_needed = round_trip_distance / mpg\n    total_gas_cost = gallons_needed * gas_price\n    return total_gas_cost\ndef calculate_total_trip_cost(round_trip_distance: int, mpg: float, gas_price: float, parking_cost: float, toll_cost: float) -> float:\n    \"\"\"\n    Calculates the total cost of the trip, including gas, parking, and tolls.\n    \n    :param round_trip_distance: Total distance of the round trip in miles.\n    :param mpg: Vehicle's miles per gallon.\n    :param gas_price: Price of gas per gallon.\n    :param parking_cost: Cost for resort parking.\n    :param toll_cost: Cost for tolls each way.\n    :return: Total cost of the trip.\n    \"\"\"\n    total_gas_cost = calculate_gas_cost(round_trip_distance, mpg, gas_price)\n    total_toll_cost = toll_cost * 2\n    total_trip_cost = total_gas_cost + parking_cost + total_toll_cost\n    return total_trip_cost\ndef calculate_individual_cost(total_trip_cost: float, number_of_participants: int) -> float:\n    \"\"\"\n    Calculates the individual cost each participant needs to pay.\n    \n    :param total_trip_cost: Total cost of the trip.\n    :param number_of_participants: Number of participants sharing the cost.\n    :return: Individual cost each participant pays.\n    \"\"\"\n    individual_cost = total_trip_cost / number_of_participants\n    return individual_cost\ndef add_event_to_calendar(event_name: str, date: str, time: str, location: str) -> bool:\n    \"\"\"\n    Adds an event to a calendar.\n    \n    :param event_name: The name of the event (e.g., \"Carpool to Snowpeak Resort\").\n    :param date: The event date (e.g., \"next Friday\").\n    :param time: The event time (e.g., \"8 AM\").\n    :param location: The event location (e.g., \"Snowpeak Resort\").\n    :return: True if the event was successfully added, False otherwise.\n    :raises ValueError: If any parameter is invalid.\n    \"\"\"\n    if not event_name or not date or not time or not location:\n        raise ValueError(\"Event name, date, time, and location must be provided.\")\n    return True\ndef send_email_notification(recipient: str, subject: str, message: str) -> bool:\n    \"\"\"\n    Sends an email notification to a recipient.\n    \n    :param recipient: The email address of the recipient.\n    :param subject: The subject line of the email.\n    :param message: The body of the email.\n    :return: True if the email was successfully sent, False otherwise.\n    :raises ValueError: If any parameter is invalid.\n    \"\"\"\n    if not recipient or not subject or not message:\n        raise ValueError(\"Recipient, subject, and message must be provided.\")\n    return True\ndef book_uber_pickup(location: str, pickup_time: str, dropoff_location: str, dropoff_time: str) -> dict:\n    \"\"\"\n    Books an Uber pickup and dropoff.\n    \n    :param location: The location for the pickup.\n    :param pickup_time: Expected pickup time.\n    :param dropoff_location: The location for the dropoff.\n    :param dropoff_time: Expected dropoff time.\n    :return:\n        dict: A dictionary with the following keys:\n            - booking_id (str): Unique booking identifier.\n            - pickup_time (str): Confirmed pickup time.\n            - dropoff_time (str): Confirmed dropoff time.\n            - driver_name (str): Name of the Uber driver.\n            - driver_phone (str): Phone number of the Uber driver.\n    :raises ValueError: If any parameter is invalid.\n    \"\"\"\n    if not location or not pickup_time or not dropoff_location or not dropoff_time:\n        raise ValueError(\"Location, pickup time, dropoff location, and dropoff time must be provided.\")\n    return {\n        \"booking_id\": \"UBER12345\",\n        \"pickup_time\": pickup_time,\n        \"dropoff_time\": dropoff_time,\n        \"driver_name\": \"John Doe\",\n        \"driver_phone\": \"555-1234\"\n    }\ndef validate_payment(payment_method: str, amount: float, currency: str) -> bool:\n    \"\"\"\n    Validates a payment using the specified payment method.\n    \n    :param payment_method: The payment method used (e.g., \"stripe\").\n    :param amount: The amount to be charged.\n    :param currency: The currency of the payment (e.g., \"USD\").\n    :return: True if the payment is valid, False otherwise.\n    :raises ValueError: If any parameter is invalid.\n    \"\"\"\n    if not payment_method or not amount or not currency:\n        raise ValueError(\"Payment method, amount, and currency must be provided.\")\n    if payment_method.lower() == \"stripe\":\n        return True\n    return False\ndef create_trip_report(participants: list, total_trip_cost: float, individual_costs: dict) -> dict:\n    \"\"\"\n    Creates a trip report with detailed cost information.\n    \n    :param participants: List of participants in the trip.\n    :param total_trip_cost: Total cost of the trip.\n    :param individual_costs: Dictionary mapping each participant to their individual cost.\n    :return:\n        dict: A dictionary with the following keys:\n            - participants (list[str]): List of participants.\n            - total_trip_cost (float): Total cost of the trip.\n            - individual_costs (dict[str, float]): Dictionary mapping each participant to their individual cost.\n    :raises ValueError: If any parameter is invalid.\n    \"\"\"\n    if not participants or not total_trip_cost or not individual_costs:\n        raise ValueError(\"Participants, total trip cost, and individual costs must be provided.\")\n    return {\n        \"participants\": participants,\n        \"total_trip_cost\": total_trip_cost,\n        \"individual_costs\": individual_costs\n    }", "user_query": "What is the total gas cost for a 180-mile round trip if the SUV gets 22 miles per gallon and gas costs $3.50 per gallon?", "checklist": {"functions": ["calculate_gas_cost"], "values": [28.6363636364]}}
{"difficulty": "easy", "function_schema_python": "def parse_pdf_invoice(file_path: str, invoice_id: str) -> dict:\n    \"\"\"Parses a PDF invoice and extracts relevant information.\n\n    :param file_path: The file path to the PDF invoice.\n    :param invoice_id: The ID of the invoice to be parsed.\n    :return:\n        dict: A dictionary with the following keys:\n            - vendor_id (str): The ID of the vendor.\n            - invoice_date (str): The date of the invoice in \"YYYY-MM-DD\" format.\n            - itemized_costs (list[dict]): A list of itemized costs with keys 'description' (str) and 'amount' (float).\n            - total_amount (float): The total amount of the invoice.\n    :raises ValueError: If file_path or invoice_id is invalid.\"\"\"\n    pass\ndef record_payment_in_accounting_system(vendor_id: str, invoice_date: str, total_amount: float) -> bool:\n    \"\"\"Records a payment in the accounting system.\n\n    :param vendor_id: The ID of the vendor.\n    :param invoice_date: The date of the invoice in \"YYYY-MM-DD\" format.\n    :param total_amount: The total amount to be recorded.\n    :return: True if the payment was successfully recorded, False otherwise.\n    :raises ValueError: If any parameter is invalid.\"\"\"\n    pass\ndef generate_report_for_reconciliation(month: str, year: int) -> dict:\n    \"\"\"Generates a report for accounts payable reconciliation.\n\n    :param month: The month for reconciliation (e.g., \"February\").\n    :param year: The year for reconciliation (e.g., 2024).\n    :return:\n        dict: A dictionary with the following keys:\n            - month (str): The month of reconciliation.\n            - year (int): The year of reconciliation.\n            - total_payable (float): The total amount payable.\n            - vendor_invoices (list[dict]): A list of vendor invoices with keys 'vendor_id', 'invoice_id', 'total_amount'.\n    :raises ValueError: If month or year is invalid.\"\"\"\n    pass\n", "function_schema_json": [{"name": "parse_pdf_invoice", "description": "Parses a PDF invoice and extracts relevant information.", "parameters": {"type": "object", "properties": {"file_path": {"type": "string", "description": "The file path to the PDF invoice."}, "invoice_id": {"type": "string", "description": "The ID of the invoice to be parsed."}}, "required": ["file_path", "invoice_id"], "additionalProperties": false}}, {"name": "record_payment_in_accounting_system", "description": "Records a payment in the accounting system.", "parameters": {"type": "object", "properties": {"vendor_id": {"type": "string", "description": "The ID of the vendor."}, "invoice_date": {"type": "string", "description": "The date of the invoice in \"YYYY-MM-DD\" format."}, "total_amount": {"type": "number", "description": "The total amount to be recorded."}}, "required": ["vendor_id", "invoice_date", "total_amount"], "additionalProperties": false}}, {"name": "generate_report_for_reconciliation", "description": "Generates a report for accounts payable reconciliation.", "parameters": {"type": "object", "properties": {"month": {"type": "string", "description": "The month for reconciliation (e.g., \"February\")."}, "year": {"type": "integer", "description": "The year for reconciliation (e.g., 2024)."}}, "required": ["month", "year"], "additionalProperties": false}}], "mock_functions": "def parse_pdf_invoice(file_path: str, invoice_id: str) -> dict:\n    \"\"\"\n    Parses a PDF invoice and extracts relevant information.\n    \n    :param file_path: The file path to the PDF invoice.\n    :param invoice_id: The ID of the invoice to be parsed.\n    :return:\n        dict: A dictionary with the following keys:\n            - vendor_id (str): The ID of the vendor.\n            - invoice_date (str): The date of the invoice in \"YYYY-MM-DD\" format.\n            - itemized_costs (list[dict]): A list of itemized costs with keys 'description' (str) and 'amount' (float).\n            - total_amount (float): The total amount of the invoice.\n    :raises ValueError: If file_path or invoice_id is invalid.\n    \"\"\"\n    if not file_path or not invoice_id:\n        raise ValueError(\"File path and invoice ID must be provided.\")\n    \n    # Mock logic: If the invoice ID is correct, return a known result.\n    if invoice_id == \"GEB-2402-9876\":\n        return {\n            \"vendor_id\": \"SPS-555\",\n            \"invoice_date\": \"2024-02-15\",\n            \"itemized_costs\": [\n                {\"description\": \"Solar Panel Installation\", \"amount\": 2500.00},\n                {\"description\": \"Shipping and Handling\", \"amount\": 350.00},\n                {\"description\": \"Tax\", \"amount\": 400.00}  # Implied tax calculation\n            ],\n            \"total_amount\": 3250.00\n        }\n    return {}\ndef record_payment_in_accounting_system(vendor_id: str, invoice_date: str, total_amount: float) -> bool:\n    \"\"\"\n    Records a payment in the accounting system.\n    \n    :param vendor_id: The ID of the vendor.\n    :param invoice_date: The date of the invoice in \"YYYY-MM-DD\" format.\n    :param total_amount: The total amount to be recorded.\n    :return: True if the payment was successfully recorded, False otherwise.\n    :raises ValueError: If any parameter is invalid.\n    \"\"\"\n    if not vendor_id or not invoice_date or total_amount <= 0:\n        raise ValueError(\"Vendor ID, invoice date, and total amount must be provided and valid.\")\n    \n    # Mock logic: If all parameters are correct, return True.\n    if vendor_id == \"SPS-555\" and invoice_date == \"2024-02-15\" and total_amount == 3250.00:\n        return True\n    return False\ndef generate_report_for_reconciliation(month: str, year: int) -> dict:\n    \"\"\"\n    Generates a report for accounts payable reconciliation.\n    \n    :param month: The month for reconciliation (e.g., \"February\").\n    :param year: The year for reconciliation (e.g., 2024).\n    :return:\n        dict: A dictionary with the following keys:\n            - month (str): The month of reconciliation.\n            - year (int): The year of reconciliation.\n            - total_payable (float): The total amount payable.\n            - vendor_invoices (list[dict]): A list of vendor invoices with keys 'vendor_id', 'invoice_id', 'total_amount'.\n    :raises ValueError: If month or year is invalid.\n    \"\"\"\n    if not month or not isinstance(year, int):\n        raise ValueError(\"Month and year must be provided and valid.\")\n    \n    # Mock logic: If the month and year are correct, return a known result.\n    if month.lower() == \"february\" and year == 2024:\n        return {\n            \"month\": \"February\",\n            \"year\": 2024,\n            \"total_payable\": 12000.00,\n            \"vendor_invoices\": [\n                {\"vendor_id\": \"SPS-555\", \"invoice_id\": \"GEB-2402-9876\", \"total_amount\": 3250.00},\n                {\"vendor_id\": \"VEN-123\", \"invoice_id\": \"GEB-2402-1234\", \"total_amount\": 4500.00},\n                {\"vendor_id\": \"VEN-456\", \"invoice_id\": \"GEB-2402-5678\", \"total_amount\": 4250.00}\n            ]\n        }\n    return {}", "user_query": "Can you parse the invoice with ID GEB-2402-9876 found at file path \"/invoices/solar_invoice.pdf\"?", "checklist": {"functions": ["parse_pdf_invoice"], "values": [{"vendor_id": "SPS-555", "invoice_date": "2024-02-15", "itemized_costs": [{"description": "Solar Panel Installation", "amount": 2500.0}, {"description": "Shipping and Handling", "amount": 350.0}, {"description": "Tax", "amount": 400.0}], "total_amount": 3250.0}]}}
{"difficulty": "easy", "function_schema_python": "def filter_dietary_preferences(restrictions: list[str], prep_time_max: int) -> dict:\n    \"\"\"Filters user dietary preferences and time constraints.\n\n    :param restrictions: List of dietary restrictions (e.g., ['gluten-free', 'low-sodium'])\n    :param prep_time_max: Maximum preparation time in minutes\n    :return: Dictionary containing validated preferences\n    :raises ValueError: If restrictions list is empty or prep_time_max is negative\"\"\"\n    pass\ndef get_recommended_meals(preference_id: str, limit: int) -> dict:\n    \"\"\"Retrieves meal recommendations based on user preferences.\n\n    :param preference_id: User preference ID from filter_dietary_preferences\n    :param limit: Maximum number of recommendations to return\n    :return: Dictionary containing meal recommendations\n    :raises ValueError: If preference_id is invalid or limit is negative\"\"\"\n    pass\ndef analyze_nutritional_fit(meal_list: list[dict], restrictions: list[str]) -> dict:\n    \"\"\"Analyzes how well meals fit nutritional requirements.\n\n    :param meal_list: List of meal dictionaries with nutritional information\n    :param restrictions: List of dietary restrictions\n    :return: Dictionary containing analysis results\n    :raises ValueError: If meal_list is empty or restrictions is empty\"\"\"\n    pass\n", "function_schema_json": [{"name": "filter_dietary_preferences", "description": "Filters user dietary preferences and time constraints.", "parameters": {"type": "object", "properties": {"restrictions": {"type": "array", "items": {"type": "string"}, "description": "List of dietary restrictions (e.g., ['gluten-free', 'low-sodium'])"}, "prep_time_max": {"type": "integer", "description": "Maximum preparation time in minutes"}}, "required": ["restrictions", "prep_time_max"], "additionalProperties": false}}, {"name": "get_recommended_meals", "description": "Retrieves meal recommendations based on user preferences.", "parameters": {"type": "object", "properties": {"preference_id": {"type": "string", "description": "User preference ID from filter_dietary_preferences"}, "limit": {"type": "integer", "description": "Maximum number of recommendations to return"}}, "required": ["preference_id", "limit"], "additionalProperties": false}}, {"name": "analyze_nutritional_fit", "description": "Analyzes how well meals fit nutritional requirements.", "parameters": {"type": "object", "properties": {"meal_list": {"type": "array", "items": {"type": "object"}, "description": "List of meal dictionaries with nutritional information"}, "restrictions": {"type": "array", "items": {"type": "string"}, "description": "List of dietary restrictions"}}, "required": ["meal_list", "restrictions"], "additionalProperties": false}}], "mock_functions": "def filter_dietary_preferences(restrictions: list[str], prep_time_max: int) -> dict:\n    \"\"\"\n    Filters user dietary preferences and time constraints.\n    \n    :param restrictions: List of dietary restrictions (e.g., ['gluten-free', 'low-sodium'])\n    :param prep_time_max: Maximum preparation time in minutes\n    :return: Dictionary containing validated preferences\n    :raises ValueError: If restrictions list is empty or prep_time_max is negative\n    \"\"\"\n    if not restrictions or prep_time_max < 0:\n        raise ValueError(\"Invalid restrictions or prep time\")\n    \n    valid_restrictions = ['gluten-free', 'low-sodium', 'vegan', 'vegetarian']\n    filtered_restrictions = [r for r in restrictions if r.lower() in valid_restrictions]\n    \n    return {\n        \"dietary_restrictions\": filtered_restrictions,\n        \"max_prep_time\": prep_time_max,\n        \"preference_id\": \"PREF_001\"\n    }\ndef get_recommended_meals(preference_id: str, limit: int = 5) -> dict:\n    \"\"\"\n    Retrieves meal recommendations based on user preferences.\n    \n    :param preference_id: User preference ID from filter_dietary_preferences\n    :param limit: Maximum number of recommendations to return\n    :return: Dictionary containing meal recommendations\n    :raises ValueError: If preference_id is invalid or limit is negative\n    \"\"\"\n    if not preference_id.startswith(\"PREF_\") or limit < 1:\n        raise ValueError(\"Invalid preference ID or limit\")\n    \n    if preference_id == \"PREF_001\":\n        return {\n            \"meals\": [\n                {\n                    \"name\": \"Quinoa Bowl\",\n                    \"prep_time\": 15,\n                    \"ingredients\": [\"quinoa\", \"vegetables\", \"olive oil\"],\n                    \"nutrition\": {\"sodium\": \"50mg\", \"calories\": 350}\n                },\n                {\n                    \"name\": \"Grilled Chicken Salad\",\n                    \"prep_time\": 20,\n                    \"ingredients\": [\"chicken\", \"lettuce\", \"lemon\"],\n                    \"nutrition\": {\"sodium\": \"80mg\", \"calories\": 300}\n                }\n            ],\n            \"total_found\": 2\n        }\n    return {\"meals\": [], \"total_found\": 0}\ndef analyze_nutritional_fit(meal_list: list[dict], restrictions: list[str]) -> dict:\n    \"\"\"\n    Analyzes how well meals fit nutritional requirements.\n    \n    :param meal_list: List of meal dictionaries with nutritional information\n    :param restrictions: List of dietary restrictions\n    :return: Dictionary containing analysis results\n    :raises ValueError: If meal_list is empty or restrictions is empty\n    \"\"\"\n    if not meal_list or not restrictions:\n        raise ValueError(\"Invalid meal list or restrictions\")\n    \n    if 'low-sodium' in restrictions and 'gluten-free' in restrictions:\n        return {\n            \"compatibility_score\": 0.95,\n            \"restriction_compliance\": {\n                \"low-sodium\": True,\n                \"gluten-free\": True\n            },\n            \"recommended_substitutions\": []\n        }\n    return {\"compatibility_score\": 0.0, \"restriction_compliance\": {}}", "user_query": "This is Sarah. Please get meal recommendations based on preference id PREF_001 limited to 5 meals.", "checklist": {"functions": ["get_recommended_meals"], "values": [{"meals": [{"name": "Quinoa Bowl", "prep_time": 15, "ingredients": ["quinoa", "vegetables", "olive oil"], "nutrition": {"sodium": "50mg", "calories": 350}}, {"name": "Grilled Chicken Salad", "prep_time": 20, "ingredients": ["chicken", "lettuce", "lemon"], "nutrition": {"sodium": "80mg", "calories": 300}}], "total_found": 2}]}}
{"difficulty": "easy", "function_schema_python": "def get_nutritional_content(item: str) -> dict:\n    \"\"\"Retrieves nutritional information for a given food item.\n\n    :param item: The name of the food item.\n    :return:\n        dict: A dictionary with the following keys:\n            - calories (int): The number of calories in the item.\n            - protein (int): The amount of protein in grams.\n            - carbs (int): The amount of carbohydrates in grams.\n            - fat (int): The amount of fat in grams.\n    :raises ValueError: If the input item is empty or not recognized.\"\"\"\n    pass\ndef filter_recipes(ingredients: list, dietary_preference: str, workout_intensity: str) -> list:\n    \"\"\"Filters recipes based on given ingredients, dietary preference, and workout intensity.\n\n    :param ingredients: A list of ingredient names.\n    :param dietary_preference: The dietary preference (e.g., \"vegetarian\", \"vegan\").\n    :param workout_intensity: The intensity of the workout regimen (e.g., \"high\", \"low\").\n    :return: \n        list: A list of recipe names that match the criteria.\n    :raises ValueError: If ingredients list is empty or dietary and workout intensity are invalid.\"\"\"\n    pass\ndef estimate_grocery_costs(recipes: list) -> dict:\n    \"\"\"Estimates the cost of grocery items needed for the given recipes.\n\n    :param recipes: A list of recipe names.\n    :return: \n        dict: A dictionary with the following keys:\n            - total_cost (float): The total cost of the groceries.\n            - items (dict): A dictionary mapping each item to its cost.\n    :raises ValueError: If recipes list is empty.\"\"\"\n    pass\ndef check_grocery_availability(items: list) -> dict:\n    \"\"\"Checks the availability of grocery items.\n\n    :param items: A list of item names to check for availability.\n    :return: \n        dict: A dictionary with the following keys:\n            - available (list): List of available items.\n            - not_available (list): List of not available items.\n    :raises ValueError: If items list is empty.\"\"\"\n    pass\ndef recommend_vegetarian_recipes(preferred_nutrients: dict, price_range: tuple) -> list:\n    \"\"\"Recommends vegetarian recipes based on preferred nutritional content and price range.\n\n    :param preferred_nutrients: A dictionary indicating preferred nutritional content.\n    :param price_range: A tuple indicating the acceptable price range (min, max).\n    :return: \n        list: A list of recipe names that match the nutritional preferences and price range.\n    :raises ValueError: If preferred_nutrients or price_range are invalid.\"\"\"\n    pass\n", "function_schema_json": [{"name": "get_nutritional_content", "description": "Retrieves nutritional information for a given food item.", "parameters": {"type": "object", "properties": {"item": {"type": "string", "description": "The name of the food item."}}, "required": ["item"], "additionalProperties": false}}, {"name": "filter_recipes", "description": "Filters recipes based on given ingredients, dietary preference, and workout intensity.", "parameters": {"type": "object", "properties": {"ingredients": {"type": "array", "description": "A list of ingredient names."}, "dietary_preference": {"type": "string", "description": "The dietary preference (e.g., \"vegetarian\", \"vegan\")."}, "workout_intensity": {"type": "string", "description": "The intensity of the workout regimen (e.g., \"high\", \"low\")."}}, "required": ["ingredients", "dietary_preference", "workout_intensity"], "additionalProperties": false}}, {"name": "estimate_grocery_costs", "description": "Estimates the cost of grocery items needed for the given recipes.", "parameters": {"type": "object", "properties": {"recipes": {"type": "array", "description": "A list of recipe names."}}, "required": ["recipes"], "additionalProperties": false}}, {"name": "check_grocery_availability", "description": "Checks the availability of grocery items.", "parameters": {"type": "object", "properties": {"items": {"type": "array", "description": "A list of item names to check for availability."}}, "required": ["items"], "additionalProperties": false}}, {"name": "recommend_vegetarian_recipes", "description": "Recommends vegetarian recipes based on preferred nutritional content and price range.", "parameters": {"type": "object", "properties": {"preferred_nutrients": {"type": "object", "description": "A dictionary indicating preferred nutritional content."}, "price_range": {"type": "string", "description": "A tuple indicating the acceptable price range (min, max)."}}, "required": ["preferred_nutrients", "price_range"], "additionalProperties": false}}], "mock_functions": "def get_nutritional_content(item: str) -> dict:\n    \"\"\"\n    Retrieves nutritional information for a given food item.\n    \n    :param item: The name of the food item.\n    :return:\n        dict: A dictionary with the following keys:\n            - calories (int): The number of calories in the item.\n            - protein (int): The amount of protein in grams.\n            - carbs (int): The amount of carbohydrates in grams.\n            - fat (int): The amount of fat in grams.\n    :raises ValueError: If the input item is empty or not recognized.\n    \"\"\"\n    if not item:\n        raise ValueError(\"Item must be provided.\")\n    mock_nutrition_data = {\n        \"chicken breast\": {\"calories\": 165, \"protein\": 31, \"carbs\": 0, \"fat\": 3.6},\n        \"spinach\": {\"calories\": 7, \"protein\": 0.86, \"carbs\": 0.7, \"fat\": 0.14},\n        \"broccoli\": {\"calories\": 55, \"protein\": 3.3, \"carbs\": 11, \"fat\": 0.4},\n        \"quinoa\": {\"calories\": 120, \"protein\": 4.4, \"carbs\": 21.3, \"fat\": 1.9},\n        \"almonds\": {\"calories\": 164, \"protein\": 6, \"carbs\": 22, \"fat\": 14.9},\n        \"soba noodles\": {\"calories\": 176, \"protein\": 10, \"carbs\": 29.6, \"fat\": 0.69}\n    }\n    return mock_nutrition_data.get(item.lower(), {\"calories\": 0, \"protein\": 0, \"carbs\": 0, \"fat\": 0})\ndef filter_recipes(ingredients: list, dietary_preference: str, workout_intensity: str) -> list:\n    \"\"\"\n    Filters recipes based on given ingredients, dietary preference, and workout intensity.\n    \n    :param ingredients: A list of ingredient names.\n    :param dietary_preference: The dietary preference (e.g., \"vegetarian\", \"vegan\").\n    :param workout_intensity: The intensity of the workout regimen (e.g., \"high\", \"low\").\n    :return: \n        list: A list of recipe names that match the criteria.\n    :raises ValueError: If ingredients list is empty or dietary and workout intensity are invalid.\n    \"\"\"\n    if not ingredients:\n        raise ValueError(\"Ingredients list must not be empty.\")\n    mock_recipes = {\n        \"vegetarian\": {\n            \"high\": [\"Grilled Quinoa Salad\", \"Lentil Soup\"],\n            \"low\": [\"Vegetable Stir Fry\", \"Sweet Potato Soup\"]\n        },\n        \"vegan\": {\n            \"high\": [\"Tofu and Vegetable Stir Fry\", \"Black Bean Tacos\"],\n            \"low\": [\"Avocado and Tomato Sandwich\", \"Chickpea and Spinach Curry\"]\n        }\n    }\n    return mock_recipes.get(dietary_preference.lower(), {}).get(workout_intensity.lower(), [])\ndef estimate_grocery_costs(recipes: list) -> dict:\n    \"\"\"\n    Estimates the cost of grocery items needed for the given recipes.\n    \n    :param recipes: A list of recipe names.\n    :return: \n        dict: A dictionary with the following keys:\n            - total_cost (float): The total cost of the groceries.\n            - items (dict): A dictionary mapping each item to its cost.\n    :raises ValueError: If recipes list is empty.\n    \"\"\"\n    if not recipes:\n        raise ValueError(\"Recipes list must not be empty.\")\n    mock_price_data = {\n        \"Grilled Quinoa Salad\": {\"quinoa\": 3.00, \"spinach\": 2.00, \"almonds\": 5.00},\n        \"Lentil Soup\": {\"lentils\": 2.00, \"broccoli\": 3.00, \"chickpeas\": 4.00},\n        \"Vegetable Stir Fry\": {\"broccoli\": 3.00, \"spinach\": 2.00, \"soba noodles\": 6.00},\n        \"Sweet Potato Soup\": {\"sweet potatoes\": 4.00, \"spinach\": 2.00, \"almonds\": 5.00},\n        \"Tofu and Vegetable Stir Fry\": {\"tofu\": 6.00, \"broccoli\": 3.00, \"soba noodles\": 6.00},\n        \"Black Bean Tacos\": {\"black beans\": 4.00, \"quinoa\": 3.00, \"avocados\": 7.00},\n        \"Avocado and Tomato Sandwich\": {\"avocados\": 7.00, \"tomatoes\": 3.00, \"almonds\": 5.00},\n        \"Chickpea and Spinach Curry\": {\"chickpeas\": 4.00, \"spinach\": 2.00, \"tomatoes\": 3.00}\n    }\n    total_cost = 0\n    items = {}\n    for recipe in recipes:\n        recipe_items = mock_price_data.get(recipe, {})\n        for item, price in recipe_items.items():\n            if item in items:\n                items[item] += price\n            else:\n                items[item] = price\n            total_cost += price\n    return {\"total_cost\": total_cost, \"items\": items}\ndef check_grocery_availability(items: list) -> dict:\n    \"\"\"\n    Checks the availability of grocery items.\n    \n    :param items: A list of item names to check for availability.\n    :return: \n        dict: A dictionary with the following keys:\n            - available (list): List of available items.\n            - not_available (list): List of not available items.\n    :raises ValueError: If items list is empty.\n    \"\"\"\n    if not items:\n        raise ValueError(\"Items list must not be empty.\")\n    mock_availability = {\n        \"quinoa\": True,\n        \"spinach\": True,\n        \"almonds\": False,\n        \"lentils\": True,\n        \"broccoli\": True,\n        \"chickpeas\": False,\n        \"soba noodles\": True,\n        \"sweet potatoes\": True,\n        \"tofu\": True,\n        \"avocados\": True,\n        \"tomatoes\": True,\n        \"black beans\": True\n    }\n    available = [item for item in items if mock_availability.get(item.lower(), False)]\n    not_available = [item for item in items if not mock_availability.get(item.lower(), False)]\n    return {\"available\": available, \"not_available\": not_available}\ndef recommend_vegetarian_recipes(preferred_nutrients: dict, price_range: tuple) -> list:\n    \"\"\"\n    Recommends vegetarian recipes based on preferred nutritional content and price range.\n    \n    :param preferred_nutrients: A dictionary indicating preferred nutritional content.\n    :param price_range: A tuple indicating the acceptable price range (min, max).\n    :return: \n        list: A list of recipe names that match the nutritional preferences and price range.\n    :raises ValueError: If preferred_nutrients or price_range are invalid.\n    \"\"\"\n    if not preferred_nutrients or not isinstance(price_range, tuple) or len(price_range) != 2:\n        raise ValueError(\"Preferred nutrients must not be empty and price range must be a tuple with two elements.\")\n    mock_recipes = {\n        \"Grilled Quinoa Salad\": {\"calories\": 200, \"protein\": 35, \"carbs\": 25, \"fat\": 10},\n        \"Lentil Soup\": {\"calories\": 180, \"protein\": 28, \"carbs\": 30, \"fat\": 5},\n        \"Vegetable Stir Fry\": {\"calories\": 220, \"protein\": 15, \"carbs\": 15, \"fat\": 10},\n        \"Sweet Potato Soup\": {\"calories\": 170, \"protein\": 10, \"carbs\": 38, \"fat\": 5}\n    }\n    recommended_recipes = []\n    for recipe, nutrients in mock_recipes.items():\n        if (preferred_nutrients[\"calories\"] >= nutrients[\"calories\"] and\n            preferred_nutrients[\"protein\"] <= nutrients[\"protein\"] and\n            preferred_nutrients[\"carbs\"] <= nutrients[\"carbs\"] and\n            preferred_nutrients[\"fat\"] <= nutrients[\"fat\"]):\n            cost = estimate_grocery_costs([recipe])[\"total_cost\"]\n            if price_range[0] <= cost <= price_range[1]:\n                recommended_recipes.append(recipe)\n    return recommended_recipes", "user_query": "What's the nutritional content of quinoa?", "checklist": {"functions": ["get_nutritional_content"], "values": [{"calories": 120, "protein": 4.4, "carbs": 21.3, "fat": 1.9}]}}
{"difficulty": "easy", "function_schema_python": "def upload_csv(file_name: str) -> bool:\n    \"\"\"Simulates the process of uploading a CSV file to the smart budgeting tool.\n\n    :param file_name: The name of the CSV file to be uploaded.\n    :return: True if the file is successfully uploaded, False otherwise.\n    :raises ValueError: If the file name is not provided or the file is not a CSV.\"\"\"\n    pass\ndef categorize_transactions(file_name: str) -> dict:\n    \"\"\"Categorizes transactions from the uploaded CSV file into 'Project Income' and 'Business Expenses'.\n\n    :param file_name: The name of the CSV file containing transactions.\n    :return:\n        dict: A dictionary with the following keys:\n            - project_income (float): Total income from projects.\n            - business_expenses (float): Total expenses for business.\n    :raises ValueError: If the file name is incorrect.\"\"\"\n    pass\ndef analyze_profitability(transactions: dict) -> dict:\n    \"\"\"Analyzes the profitability of projects based on categorized transactions.\n\n    :param transactions: A dictionary containing project income and business expenses.\n    :return:\n        dict: A dictionary with the following keys:\n            - most_profitable_project (str): The name of the most profitable project.\n            - profit (float): The profit amount for the most profitable project.\n    :raises ValueError: If the transactions dictionary is not properly formatted.\"\"\"\n    pass\ndef present_analysis(transactions: dict, profitability: dict) -> None:\n    \"\"\"Presents the analysis of transactions and profitability in a readable format.\n\n    :param transactions: A dictionary containing project income and business expenses.\n    :param profitability: A dictionary containing the most profitable project and its profit.\n    :return: None\n    :raises ValueError: If the input dictionaries are not properly formatted.\"\"\"\n    pass\n", "function_schema_json": [{"name": "upload_csv", "description": "Simulates the process of uploading a CSV file to the smart budgeting tool.", "parameters": {"type": "object", "properties": {"file_name": {"type": "string", "description": "The name of the CSV file to be uploaded."}}, "required": ["file_name"], "additionalProperties": false}}, {"name": "categorize_transactions", "description": "Categorizes transactions from the uploaded CSV file into 'Project Income' and 'Business Expenses'.", "parameters": {"type": "object", "properties": {"file_name": {"type": "string", "description": "The name of the CSV file containing transactions."}}, "required": ["file_name"], "additionalProperties": false}}, {"name": "analyze_profitability", "description": "Analyzes the profitability of projects based on categorized transactions.", "parameters": {"type": "object", "properties": {"transactions": {"type": "object", "description": "A dictionary containing project income and business expenses."}}, "required": ["transactions"], "additionalProperties": false}}, {"name": "present_analysis", "description": "Presents the analysis of transactions and profitability in a readable format.", "parameters": {"type": "object", "properties": {"transactions": {"type": "object", "description": "A dictionary containing project income and business expenses."}, "profitability": {"type": "object", "description": "A dictionary containing the most profitable project and its profit."}}, "required": ["transactions", "profitability"], "additionalProperties": false}}], "mock_functions": "def upload_csv(file_name: str) -> bool:\n    \"\"\"\n    Simulates the process of uploading a CSV file to the smart budgeting tool.\n    \n    :param file_name: The name of the CSV file to be uploaded.\n    :return: True if the file is successfully uploaded, False otherwise.\n    :raises ValueError: If the file name is not provided or the file is not a CSV.\n    \"\"\"\n    if not file_name or not file_name.endswith('.csv'):\n        raise ValueError(\"Invalid file name. Please provide a valid CSV file.\")\n    if file_name == \"Q3_2024_transactions.csv\":\n        return True\n    return False\ndef categorize_transactions(file_name: str) -> dict:\n    \"\"\"\n    Categorizes transactions from the uploaded CSV file into 'Project Income' and 'Business Expenses'.\n    \n    :param file_name: The name of the CSV file containing transactions.\n    :return:\n        dict: A dictionary with the following keys:\n            - project_income (float): Total income from projects.\n            - business_expenses (float): Total expenses for business.\n    :raises ValueError: If the file name is incorrect.\n    \"\"\"\n    if file_name != \"Q3_2024_transactions.csv\":\n        raise ValueError(\"Incorrect file name. Please upload 'Q3_2024_transactions.csv'.\")\n    # Mock data for demonstration\n    return {\n        \"project_income\": 15000.00,\n        \"business_expenses\": 5000.00\n    }\ndef analyze_profitability(transactions: dict) -> dict:\n    \"\"\"\n    Analyzes the profitability of projects based on categorized transactions.\n    \n    :param transactions: A dictionary containing project income and business expenses.\n    :return:\n        dict: A dictionary with the following keys:\n            - most_profitable_project (str): The name of the most profitable project.\n            - profit (float): The profit amount for the most profitable project.\n    :raises ValueError: If the transactions dictionary is not properly formatted.\n    \"\"\"\n    required_keys = {\"project_income\", \"business_expenses\"}\n    if not set(transactions.keys()).issuperset(required_keys):\n        raise ValueError(\"Transactions dictionary must contain 'project_income' and 'business_expenses'.\")\n    # Mock data for demonstration\n    return {\n        \"most_profitable_project\": \"Project Alpha\",\n        \"profit\": 7500.00\n    }\ndef present_analysis(transactions: dict, profitability: dict) -> None:\n    \"\"\"\n    Presents the analysis of transactions and profitability in a readable format.\n    \n    :param transactions: A dictionary containing project income and business expenses.\n    :param profitability: A dictionary containing the most profitable project and its profit.\n    :return: None\n    :raises ValueError: If the input dictionaries are not properly formatted.\n    \"\"\"\n    required_transactions_keys = {\"project_income\", \"business_expenses\"}\n    required_profitability_keys = {\"most_profitable_project\", \"profit\"}\n    if not set(transactions.keys()).issuperset(required_transactions_keys):\n        raise ValueError(\"Transactions dictionary must contain 'project_income' and 'business_expenses'.\")\n    if not set(profitability.keys()).issuperset(required_profitability_keys):\n        raise ValueError(\"Profitability dictionary must contain 'most_profitable_project' and 'profit'.\")\n    # Mock presentation logic\n    print(f\"Project Income: ${transactions['project_income']}\")\n    print(f\"Business Expenses: ${transactions['business_expenses']}\")\n    print(f\"Most Profitable Project: {profitability['most_profitable_project']}\")\n    print(f\"Profit: ${profitability['profit']}\")\n", "user_query": "Can you upload my Q3_2024_transactions.csv file?", "checklist": {"functions": ["upload_csv"], "values": [true]}}
{"difficulty": "easy", "function_schema_python": "def get_product_usage_history(product_id: str, warehouse_id: int, months: int) -> dict:\n    \"\"\"Retrieves historical usage data for a specific product in a warehouse.\n\n    :param product_id: The product identifier (e.g., 'SG-2023-456')\n    :param warehouse_id: The warehouse identifier (1-3)\n    :param months: Number of months of history to retrieve\n    :return: Dictionary containing usage statistics\n    :raises ValueError: If product_id is invalid or warehouse_id is out of range\"\"\"\n    pass\ndef calculate_alert_thresholds(product_id: str, baseline_usage: int, variation_tolerance: float) -> dict:\n    \"\"\"Calculates normalized alert thresholds for inventory monitoring.\n\n    :param product_id: The product identifier\n    :param baseline_usage: Expected monthly usage\n    :param variation_tolerance: Acceptable variation as a percentage (0.0 to 1.0)\n    :return: Dictionary containing threshold values\n    :raises ValueError: If parameters are invalid\"\"\"\n    pass\ndef update_inventory_alerts(product_id: str, warehouse_id: int, thresholds: dict) -> bool:\n    \"\"\"Updates the alert thresholds for a specific product in a warehouse.\n\n    :param product_id: The product identifier\n    :param warehouse_id: The warehouse identifier (1-3)\n    :param thresholds: Dictionary containing threshold values\n    :return: True if update successful, False otherwise\n    :raises ValueError: If parameters are invalid\"\"\"\n    pass\n", "function_schema_json": [{"name": "get_product_usage_history", "description": "Retrieves historical usage data for a specific product in a warehouse.", "parameters": {"type": "object", "properties": {"product_id": {"type": "string", "description": "The product identifier (e.g., 'SG-2023-456')"}, "warehouse_id": {"type": "integer", "description": "The warehouse identifier (1-3)"}, "months": {"type": "integer", "description": "Number of months of history to retrieve"}}, "required": ["product_id", "warehouse_id", "months"], "additionalProperties": false}}, {"name": "calculate_alert_thresholds", "description": "Calculates normalized alert thresholds for inventory monitoring.", "parameters": {"type": "object", "properties": {"product_id": {"type": "string", "description": "The product identifier"}, "baseline_usage": {"type": "integer", "description": "Expected monthly usage"}, "variation_tolerance": {"type": "number", "description": "Acceptable variation as a percentage (0.0 to 1.0)"}}, "required": ["product_id", "baseline_usage", "variation_tolerance"], "additionalProperties": false}}, {"name": "update_inventory_alerts", "description": "Updates the alert thresholds for a specific product in a warehouse.", "parameters": {"type": "object", "properties": {"product_id": {"type": "string", "description": "The product identifier"}, "warehouse_id": {"type": "integer", "description": "The warehouse identifier (1-3)"}, "thresholds": {"type": "object", "description": "Dictionary containing threshold values"}}, "required": ["product_id", "warehouse_id", "thresholds"], "additionalProperties": false}}], "mock_functions": "def get_product_usage_history(product_id: str, warehouse_id: int, months: int) -> dict:\n    \"\"\"\n    Retrieves historical usage data for a specific product in a warehouse.\n    \n    :param product_id: The product identifier (e.g., 'SG-2023-456')\n    :param warehouse_id: The warehouse identifier (1-3)\n    :param months: Number of months of history to retrieve\n    :return: Dictionary containing usage statistics\n    :raises ValueError: If product_id is invalid or warehouse_id is out of range\n    \"\"\"\n    if not product_id.startswith('SG-') or warehouse_id not in [1, 2, 3] or months <= 0:\n        raise ValueError(\"Invalid parameters provided\")\n    \n    if product_id == 'SG-2023-456':\n        return {\n            \"monthly_average\": 1000,\n            \"current_month_usage\": 1200,\n            \"usage_variation\": 400,\n            \"monthly_data\": [1100, 900, 1400, 600, 1200, 800]\n        }\n    return {}\ndef calculate_alert_thresholds(product_id: str, baseline_usage: int, variation_tolerance: float) -> dict:\n    \"\"\"\n    Calculates normalized alert thresholds for inventory monitoring.\n    \n    :param product_id: The product identifier\n    :param baseline_usage: Expected monthly usage\n    :param variation_tolerance: Acceptable variation as a percentage (0.0 to 1.0)\n    :return: Dictionary containing threshold values\n    :raises ValueError: If parameters are invalid\n    \"\"\"\n    if not 0.0 <= variation_tolerance <= 1.0 or baseline_usage <= 0:\n        raise ValueError(\"Invalid parameters\")\n    \n    if product_id == 'SG-2023-456' and baseline_usage == 1000:\n        return {\n            \"lower_threshold\": int(baseline_usage * (1 - variation_tolerance)),\n            \"upper_threshold\": int(baseline_usage * (1 + variation_tolerance)),\n            \"reorder_point\": int(baseline_usage * 0.75)\n        }\n    return {}\ndef update_inventory_alerts(product_id: str, warehouse_id: int, thresholds: dict) -> bool:\n    \"\"\"\n    Updates the alert thresholds for a specific product in a warehouse.\n    \n    :param product_id: The product identifier\n    :param warehouse_id: The warehouse identifier (1-3)\n    :param thresholds: Dictionary containing threshold values\n    :return: True if update successful, False otherwise\n    :raises ValueError: If parameters are invalid\n    \"\"\"\n    required_keys = {\"lower_threshold\", \"upper_threshold\", \"reorder_point\"}\n    if not all(key in thresholds for key in required_keys):\n        raise ValueError(\"Thresholds dictionary missing required keys\")\n    \n    if (product_id == 'SG-2023-456' and \n        warehouse_id in [1, 2, 3] and \n        thresholds[\"lower_threshold\"] == 800 and \n        thresholds[\"upper_threshold\"] == 1200):\n        return True\n    return False", "user_query": "Can you retrieve the usage history for surgical gloves (SG-2023-456) for Warehouse 2 over the past 6 months?", "checklist": {"functions": ["get_product_usage_history"], "values": [{"monthly_average": 1000, "current_month_usage": 1200, "usage_variation": 400, "monthly_data": [1100, 900, 1400, 600, 1200, 800]}]}}
{"difficulty": "easy", "function_schema_python": "def get_product_usage_history(product_id: str, warehouse_id: int, months: int) -> dict:\n    \"\"\"Retrieves historical usage data for a specific product in a warehouse.\n\n    :param product_id: The product identifier (e.g., 'SG-2023-456')\n    :param warehouse_id: The warehouse identifier (1-3)\n    :param months: Number of months of history to retrieve\n    :return: Dictionary containing usage statistics\n    :raises ValueError: If product_id is invalid or warehouse_id is out of range\"\"\"\n    pass\ndef calculate_alert_thresholds(product_id: str, baseline_usage: int, variation_tolerance: float) -> dict:\n    \"\"\"Calculates normalized alert thresholds for inventory monitoring.\n\n    :param product_id: The product identifier\n    :param baseline_usage: Expected monthly usage\n    :param variation_tolerance: Acceptable variation as a percentage (0.0 to 1.0)\n    :return: Dictionary containing threshold values\n    :raises ValueError: If parameters are invalid\"\"\"\n    pass\ndef update_inventory_alerts(product_id: str, warehouse_id: int, thresholds: dict) -> bool:\n    \"\"\"Updates the alert thresholds for a specific product in a warehouse.\n\n    :param product_id: The product identifier\n    :param warehouse_id: The warehouse identifier (1-3)\n    :param thresholds: Dictionary containing threshold values\n    :return: True if update successful, False otherwise\n    :raises ValueError: If parameters are invalid\"\"\"\n    pass\n", "function_schema_json": [{"name": "get_product_usage_history", "description": "Retrieves historical usage data for a specific product in a warehouse.", "parameters": {"type": "object", "properties": {"product_id": {"type": "string", "description": "The product identifier (e.g., 'SG-2023-456')"}, "warehouse_id": {"type": "integer", "description": "The warehouse identifier (1-3)"}, "months": {"type": "integer", "description": "Number of months of history to retrieve"}}, "required": ["product_id", "warehouse_id", "months"], "additionalProperties": false}}, {"name": "calculate_alert_thresholds", "description": "Calculates normalized alert thresholds for inventory monitoring.", "parameters": {"type": "object", "properties": {"product_id": {"type": "string", "description": "The product identifier"}, "baseline_usage": {"type": "integer", "description": "Expected monthly usage"}, "variation_tolerance": {"type": "number", "description": "Acceptable variation as a percentage (0.0 to 1.0)"}}, "required": ["product_id", "baseline_usage", "variation_tolerance"], "additionalProperties": false}}, {"name": "update_inventory_alerts", "description": "Updates the alert thresholds for a specific product in a warehouse.", "parameters": {"type": "object", "properties": {"product_id": {"type": "string", "description": "The product identifier"}, "warehouse_id": {"type": "integer", "description": "The warehouse identifier (1-3)"}, "thresholds": {"type": "object", "description": "Dictionary containing threshold values"}}, "required": ["product_id", "warehouse_id", "thresholds"], "additionalProperties": false}}], "mock_functions": "def get_product_usage_history(product_id: str, warehouse_id: int, months: int) -> dict:\n    \"\"\"\n    Retrieves historical usage data for a specific product in a warehouse.\n    \n    :param product_id: The product identifier (e.g., 'SG-2023-456')\n    :param warehouse_id: The warehouse identifier (1-3)\n    :param months: Number of months of history to retrieve\n    :return: Dictionary containing usage statistics\n    :raises ValueError: If product_id is invalid or warehouse_id is out of range\n    \"\"\"\n    if not product_id.startswith('SG-') or warehouse_id not in [1, 2, 3] or months <= 0:\n        raise ValueError(\"Invalid parameters provided\")\n    \n    if product_id == 'SG-2023-456':\n        return {\n            \"monthly_average\": 1000,\n            \"current_month_usage\": 1200,\n            \"usage_variation\": 400,\n            \"monthly_data\": [1100, 900, 1400, 600, 1200, 800]\n        }\n    return {}\ndef calculate_alert_thresholds(product_id: str, baseline_usage: int, variation_tolerance: float) -> dict:\n    \"\"\"\n    Calculates normalized alert thresholds for inventory monitoring.\n    \n    :param product_id: The product identifier\n    :param baseline_usage: Expected monthly usage\n    :param variation_tolerance: Acceptable variation as a percentage (0.0 to 1.0)\n    :return: Dictionary containing threshold values\n    :raises ValueError: If parameters are invalid\n    \"\"\"\n    if not 0.0 <= variation_tolerance <= 1.0 or baseline_usage <= 0:\n        raise ValueError(\"Invalid parameters\")\n    \n    if product_id == 'SG-2023-456' and baseline_usage == 1000:\n        return {\n            \"lower_threshold\": int(baseline_usage * (1 - variation_tolerance)),\n            \"upper_threshold\": int(baseline_usage * (1 + variation_tolerance)),\n            \"reorder_point\": int(baseline_usage * 0.75)\n        }\n    return {}\ndef update_inventory_alerts(product_id: str, warehouse_id: int, thresholds: dict) -> bool:\n    \"\"\"\n    Updates the alert thresholds for a specific product in a warehouse.\n    \n    :param product_id: The product identifier\n    :param warehouse_id: The warehouse identifier (1-3)\n    :param thresholds: Dictionary containing threshold values\n    :return: True if update successful, False otherwise\n    :raises ValueError: If parameters are invalid\n    \"\"\"\n    required_keys = {\"lower_threshold\", \"upper_threshold\", \"reorder_point\"}\n    if not all(key in thresholds for key in required_keys):\n        raise ValueError(\"Thresholds dictionary missing required keys\")\n    \n    if (product_id == 'SG-2023-456' and \n        warehouse_id in [1, 2, 3] and \n        thresholds[\"lower_threshold\"] == 800 and \n        thresholds[\"upper_threshold\"] == 1200):\n        return True\n    return False", "user_query": "Please calculate alert thresholds for surgical gloves (SG-2023-456) with a baseline usage of 1000 boxes and a 20% variation tolerance.", "checklist": {"functions": ["calculate_alert_thresholds"], "values": [{"lower_threshold": 800, "upper_threshold": 1200, "reorder_point": 750}]}}
{"difficulty": "easy", "function_schema_python": "def grant_access_to_vendor(vendor_name: str, access_level: str) -> bool:\n    \"\"\"Grants access to a specific vendor for managing their product catalog.\n\n    :param vendor_name: The name of the vendor.\n    :param access_level: The level of access to grant (e.g., 'editor', 'admin').\n    :return: True if access was successfully granted, False otherwise.\n    :raises ValueError: If vendor_name or access_level is not provided.\"\"\"\n    pass\ndef setup_vendor_approval_workflow(workflow_name: str, steps: list) -> bool:\n    \"\"\"Sets up a workflow for approving vendor requests in the online ordering system.\n\n    :param workflow_name: The name of the workflow (e.g., 'Vendor Approval Workflow').\n    :param steps: A list of steps in the workflow.\n    :return: True if the workflow setup was successful, False otherwise.\n    :raises ValueError: If workflow_name or steps is not provided.\"\"\"\n    pass\ndef configure_discounts_for_loyalty_program(program_name: str, discount_rules: dict) -> bool:\n    \"\"\"Configures discounts for the store's loyalty program within the Food_Ordering module.\n\n    :param program_name: The name of the loyalty program (e.g., 'Sammy's Rewards').\n    :param discount_rules: A dictionary defining the discount rules.\n    :return: True if the discounts were configured successfully, False otherwise.\n    :raises ValueError: If program_name or discount_rules is not provided.\"\"\"\n    pass\ndef track_sales_and_preferences(analytics_module: str, tracking_mode: str) -> bool:\n    \"\"\"Configures the system's analytics module to track sales and customer preferences.\n\n    :param analytics_module: The name of the analytics module (e.g., 'Food_Ordering').\n    :param tracking_mode: The tracking mode to activate (e.g., 'sales', 'preferences').\n    :return: True if tracking was successfully enabled, False otherwise.\n    :raises ValueError: If analytics_module or tracking_mode is not provided.\"\"\"\n    pass\ndef ensure_security_protocols(system_module: str, security_feature: str) -> dict:\n    \"\"\"Ensures that the system complies with security protocols to safeguard customer information.\n\n    :param system_module: The module in the system to check and update security (e.g., 'Food_Ordering').\n    :param security_feature: The security feature to enable (e.g., 'encryption').\n    :return:\n        dict: A dictionary with the following keys:\n            - status (str): The status of the security update (\"enabled\", \"failed\").\n            - message (str): A message indicating the outcome of the update.\n    :raises ValueError: If system_module or security_feature is not provided.\"\"\"\n    pass\n", "function_schema_json": [{"name": "grant_access_to_vendor", "description": "Grants access to a specific vendor for managing their product catalog.", "parameters": {"type": "object", "properties": {"vendor_name": {"type": "string", "description": "The name of the vendor."}, "access_level": {"type": "string", "description": "The level of access to grant (e.g., 'editor', 'admin')."}}, "required": ["vendor_name", "access_level"], "additionalProperties": false}}, {"name": "setup_vendor_approval_workflow", "description": "Sets up a workflow for approving vendor requests in the online ordering system.", "parameters": {"type": "object", "properties": {"workflow_name": {"type": "string", "description": "The name of the workflow (e.g., 'Vendor Approval Workflow')."}, "steps": {"type": "array", "description": "A list of steps in the workflow."}}, "required": ["workflow_name", "steps"], "additionalProperties": false}}, {"name": "configure_discounts_for_loyalty_program", "description": "Configures discounts for the store's loyalty program within the Food_Ordering module.", "parameters": {"type": "object", "properties": {"program_name": {"type": "string", "description": "The name of the loyalty program (e.g., 'Sammy's Rewards')."}, "discount_rules": {"type": "object", "description": "A dictionary defining the discount rules."}}, "required": ["program_name", "discount_rules"], "additionalProperties": false}}, {"name": "track_sales_and_preferences", "description": "Configures the system's analytics module to track sales and customer preferences.", "parameters": {"type": "object", "properties": {"analytics_module": {"type": "string", "description": "The name of the analytics module (e.g., 'Food_Ordering')."}, "tracking_mode": {"type": "string", "description": "The tracking mode to activate (e.g., 'sales', 'preferences')."}}, "required": ["analytics_module", "tracking_mode"], "additionalProperties": false}}, {"name": "ensure_security_protocols", "description": "Ensures that the system complies with security protocols to safeguard customer information.", "parameters": {"type": "object", "properties": {"system_module": {"type": "string", "description": "The module in the system to check and update security (e.g., 'Food_Ordering')."}, "security_feature": {"type": "string", "description": "The security feature to enable (e.g., 'encryption')."}}, "required": ["system_module", "security_feature"], "additionalProperties": false}}], "mock_functions": "def grant_access_to_vendor(vendor_name: str, access_level: str) -> bool:\n    \"\"\"\n    Grants access to a specific vendor for managing their product catalog.\n    \n    :param vendor_name: The name of the vendor.\n    :param access_level: The level of access to grant (e.g., 'editor', 'admin').\n    :return: True if access was successfully granted, False otherwise.\n    :raises ValueError: If vendor_name or access_level is not provided.\n    \"\"\"\n    if not vendor_name or not access_level:\n        raise ValueError(\"Vendor name and access level must be provided.\")\n    if vendor_name == \"Emily\" and access_level in ['editor', 'admin']:\n        return True\n    return False\ndef setup_vendor_approval_workflow(workflow_name: str, steps: list) -> bool:\n    \"\"\"\n    Sets up a workflow for approving vendor requests in the online ordering system.\n    \n    :param workflow_name: The name of the workflow (e.g., 'Vendor Approval Workflow').\n    :param steps: A list of steps in the workflow.\n    :return: True if the workflow setup was successful, False otherwise.\n    :raises ValueError: If workflow_name or steps is not provided.\n    \"\"\"\n    if not workflow_name or not steps:\n        raise ValueError(\"Workflow name and steps must be provided.\")\n    if workflow_name == \"Vendor Approval Workflow\" and isinstance(steps, list) and steps:\n        return True\n    return False\ndef configure_discounts_for_loyalty_program(program_name: str, discount_rules: dict) -> bool:\n    \"\"\"\n    Configures discounts for the store's loyalty program within the Food_Ordering module.\n    \n    :param program_name: The name of the loyalty program (e.g., 'Sammy's Rewards').\n    :param discount_rules: A dictionary defining the discount rules.\n    :return: True if the discounts were configured successfully, False otherwise.\n    :raises ValueError: If program_name or discount_rules is not provided.\n    \"\"\"\n    if not program_name or not discount_rules:\n        raise ValueError(\"Program name and discount rules must be provided.\")\n    if program_name == \"Sammy's Rewards\" and isinstance(discount_rules, dict) and discount_rules:\n        return True\n    return False\ndef track_sales_and_preferences(analytics_module: str, tracking_mode: str) -> bool:\n    \"\"\"\n    Configures the system's analytics module to track sales and customer preferences.\n    \n    :param analytics_module: The name of the analytics module (e.g., 'Food_Ordering').\n    :param tracking_mode: The tracking mode to activate (e.g., 'sales', 'preferences').\n    :return: True if tracking was successfully enabled, False otherwise.\n    :raises ValueError: If analytics_module or tracking_mode is not provided.\n    \"\"\"\n    if not analytics_module or not tracking_mode:\n        raise ValueError(\"Analytics module and tracking mode must be provided.\")\n    if analytics_module == \"Food_Ordering\" and tracking_mode in ['sales', 'preferences']:\n        return True\n    return False\ndef ensure_security_protocols(system_module: str, security_feature: str) -> dict:\n    \"\"\"\n    Ensures that the system complies with security protocols to safeguard customer information.\n    \n    :param system_module: The module in the system to check and update security (e.g., 'Food_Ordering').\n    :param security_feature: The security feature to enable (e.g., 'encryption').\n    :return:\n        dict: A dictionary with the following keys:\n            - status (str): The status of the security update (\"enabled\", \"failed\").\n            - message (str): A message indicating the outcome of the update.\n    :raises ValueError: If system_module or security_feature is not provided.\n    \"\"\"\n    if not system_module or not security_feature:\n        raise ValueError(\"System module and security feature must be provided.\")\n    if system_module == \"Food_Ordering\" and security_feature == \"encryption\":\n        return {\n            \"status\": \"enabled\",\n            \"message\": \"Encryption security feature has been enabled successfully.\"\n        }\n    return {\n        \"status\": \"failed\",\n        \"message\": \"Failed to enable the specified security feature.\"\n    }", "user_query": "Grant Emily editor access to the online ordering system.", "checklist": {"functions": ["grant_access_to_vendor"], "values": [true]}}
{"difficulty": "easy", "function_schema_python": "def grant_access_to_vendor(vendor_name: str, access_level: str) -> bool:\n    \"\"\"Grants access to a specific vendor for managing their product catalog.\n\n    :param vendor_name: The name of the vendor.\n    :param access_level: The level of access to grant (e.g., 'editor', 'admin').\n    :return: True if access was successfully granted, False otherwise.\n    :raises ValueError: If vendor_name or access_level is not provided.\"\"\"\n    pass\ndef setup_vendor_approval_workflow(workflow_name: str, steps: list) -> bool:\n    \"\"\"Sets up a workflow for approving vendor requests in the online ordering system.\n\n    :param workflow_name: The name of the workflow (e.g., 'Vendor Approval Workflow').\n    :param steps: A list of steps in the workflow.\n    :return: True if the workflow setup was successful, False otherwise.\n    :raises ValueError: If workflow_name or steps is not provided.\"\"\"\n    pass\ndef configure_discounts_for_loyalty_program(program_name: str, discount_rules: dict) -> bool:\n    \"\"\"Configures discounts for the store's loyalty program within the Food_Ordering module.\n\n    :param program_name: The name of the loyalty program (e.g., 'Sammy's Rewards').\n    :param discount_rules: A dictionary defining the discount rules.\n    :return: True if the discounts were configured successfully, False otherwise.\n    :raises ValueError: If program_name or discount_rules is not provided.\"\"\"\n    pass\ndef track_sales_and_preferences(analytics_module: str, tracking_mode: str) -> bool:\n    \"\"\"Configures the system's analytics module to track sales and customer preferences.\n\n    :param analytics_module: The name of the analytics module (e.g., 'Food_Ordering').\n    :param tracking_mode: The tracking mode to activate (e.g., 'sales', 'preferences').\n    :return: True if tracking was successfully enabled, False otherwise.\n    :raises ValueError: If analytics_module or tracking_mode is not provided.\"\"\"\n    pass\ndef ensure_security_protocols(system_module: str, security_feature: str) -> dict:\n    \"\"\"Ensures that the system complies with security protocols to safeguard customer information.\n\n    :param system_module: The module in the system to check and update security (e.g., 'Food_Ordering').\n    :param security_feature: The security feature to enable (e.g., 'encryption').\n    :return:\n        dict: A dictionary with the following keys:\n            - status (str): The status of the security update (\"enabled\", \"failed\").\n            - message (str): A message indicating the outcome of the update.\n    :raises ValueError: If system_module or security_feature is not provided.\"\"\"\n    pass\n", "function_schema_json": [{"name": "grant_access_to_vendor", "description": "Grants access to a specific vendor for managing their product catalog.", "parameters": {"type": "object", "properties": {"vendor_name": {"type": "string", "description": "The name of the vendor."}, "access_level": {"type": "string", "description": "The level of access to grant (e.g., 'editor', 'admin')."}}, "required": ["vendor_name", "access_level"], "additionalProperties": false}}, {"name": "setup_vendor_approval_workflow", "description": "Sets up a workflow for approving vendor requests in the online ordering system.", "parameters": {"type": "object", "properties": {"workflow_name": {"type": "string", "description": "The name of the workflow (e.g., 'Vendor Approval Workflow')."}, "steps": {"type": "array", "description": "A list of steps in the workflow."}}, "required": ["workflow_name", "steps"], "additionalProperties": false}}, {"name": "configure_discounts_for_loyalty_program", "description": "Configures discounts for the store's loyalty program within the Food_Ordering module.", "parameters": {"type": "object", "properties": {"program_name": {"type": "string", "description": "The name of the loyalty program (e.g., 'Sammy's Rewards')."}, "discount_rules": {"type": "object", "description": "A dictionary defining the discount rules."}}, "required": ["program_name", "discount_rules"], "additionalProperties": false}}, {"name": "track_sales_and_preferences", "description": "Configures the system's analytics module to track sales and customer preferences.", "parameters": {"type": "object", "properties": {"analytics_module": {"type": "string", "description": "The name of the analytics module (e.g., 'Food_Ordering')."}, "tracking_mode": {"type": "string", "description": "The tracking mode to activate (e.g., 'sales', 'preferences')."}}, "required": ["analytics_module", "tracking_mode"], "additionalProperties": false}}, {"name": "ensure_security_protocols", "description": "Ensures that the system complies with security protocols to safeguard customer information.", "parameters": {"type": "object", "properties": {"system_module": {"type": "string", "description": "The module in the system to check and update security (e.g., 'Food_Ordering')."}, "security_feature": {"type": "string", "description": "The security feature to enable (e.g., 'encryption')."}}, "required": ["system_module", "security_feature"], "additionalProperties": false}}], "mock_functions": "def grant_access_to_vendor(vendor_name: str, access_level: str) -> bool:\n    \"\"\"\n    Grants access to a specific vendor for managing their product catalog.\n    \n    :param vendor_name: The name of the vendor.\n    :param access_level: The level of access to grant (e.g., 'editor', 'admin').\n    :return: True if access was successfully granted, False otherwise.\n    :raises ValueError: If vendor_name or access_level is not provided.\n    \"\"\"\n    if not vendor_name or not access_level:\n        raise ValueError(\"Vendor name and access level must be provided.\")\n    if vendor_name == \"Emily\" and access_level in ['editor', 'admin']:\n        return True\n    return False\ndef setup_vendor_approval_workflow(workflow_name: str, steps: list) -> bool:\n    \"\"\"\n    Sets up a workflow for approving vendor requests in the online ordering system.\n    \n    :param workflow_name: The name of the workflow (e.g., 'Vendor Approval Workflow').\n    :param steps: A list of steps in the workflow.\n    :return: True if the workflow setup was successful, False otherwise.\n    :raises ValueError: If workflow_name or steps is not provided.\n    \"\"\"\n    if not workflow_name or not steps:\n        raise ValueError(\"Workflow name and steps must be provided.\")\n    if workflow_name == \"Vendor Approval Workflow\" and isinstance(steps, list) and steps:\n        return True\n    return False\ndef configure_discounts_for_loyalty_program(program_name: str, discount_rules: dict) -> bool:\n    \"\"\"\n    Configures discounts for the store's loyalty program within the Food_Ordering module.\n    \n    :param program_name: The name of the loyalty program (e.g., 'Sammy's Rewards').\n    :param discount_rules: A dictionary defining the discount rules.\n    :return: True if the discounts were configured successfully, False otherwise.\n    :raises ValueError: If program_name or discount_rules is not provided.\n    \"\"\"\n    if not program_name or not discount_rules:\n        raise ValueError(\"Program name and discount rules must be provided.\")\n    if program_name == \"Sammy's Rewards\" and isinstance(discount_rules, dict) and discount_rules:\n        return True\n    return False\ndef track_sales_and_preferences(analytics_module: str, tracking_mode: str) -> bool:\n    \"\"\"\n    Configures the system's analytics module to track sales and customer preferences.\n    \n    :param analytics_module: The name of the analytics module (e.g., 'Food_Ordering').\n    :param tracking_mode: The tracking mode to activate (e.g., 'sales', 'preferences').\n    :return: True if tracking was successfully enabled, False otherwise.\n    :raises ValueError: If analytics_module or tracking_mode is not provided.\n    \"\"\"\n    if not analytics_module or not tracking_mode:\n        raise ValueError(\"Analytics module and tracking mode must be provided.\")\n    if analytics_module == \"Food_Ordering\" and tracking_mode in ['sales', 'preferences']:\n        return True\n    return False\ndef ensure_security_protocols(system_module: str, security_feature: str) -> dict:\n    \"\"\"\n    Ensures that the system complies with security protocols to safeguard customer information.\n    \n    :param system_module: The module in the system to check and update security (e.g., 'Food_Ordering').\n    :param security_feature: The security feature to enable (e.g., 'encryption').\n    :return:\n        dict: A dictionary with the following keys:\n            - status (str): The status of the security update (\"enabled\", \"failed\").\n            - message (str): A message indicating the outcome of the update.\n    :raises ValueError: If system_module or security_feature is not provided.\n    \"\"\"\n    if not system_module or not security_feature:\n        raise ValueError(\"System module and security feature must be provided.\")\n    if system_module == \"Food_Ordering\" and security_feature == \"encryption\":\n        return {\n            \"status\": \"enabled\",\n            \"message\": \"Encryption security feature has been enabled successfully.\"\n        }\n    return {\n        \"status\": \"failed\",\n        \"message\": \"Failed to enable the specified security feature.\"\n    }", "user_query": "Set up a 'Vendor Approval Workflow' with steps: [\u201cSubmit Request\u201d, \u201cReview Request\u201d, \u201cApprove/Reject\u201d, \u201cGrant Access\u201d].", "checklist": {"functions": ["setup_vendor_approval_workflow"], "values": [true]}}
{"difficulty": "easy", "function_schema_python": "def validate_transaction(amount: float, transaction_id: str) -> bool:\n    \"\"\"Validates a transaction based on the provided amount and transaction ID.\n\n    :param amount: The amount of the transaction.\n    :param transaction_id: The transaction ID.\n    :return: True if the transaction is valid, False otherwise.\"\"\"\n    pass\ndef check_user_permission(user_name: str, permission_type: str) -> bool:\n    \"\"\"Checks if a user has a specific type of permission.\n\n    :param user_name: The name of the user.\n    :param permission_type: The type of permission to check (e.g., \"view\", \"edit\").\n    :return: True if the user has the permission, False otherwise.\"\"\"\n    pass\ndef get_transaction_details(transaction_id: str) -> dict:\n    \"\"\"Retrieves the details of a transaction based on the transaction ID.\n\n    :param transaction_id: The transaction ID.\n    :return: A dictionary with transaction details.\n        dict: A dictionary with the following keys:\n            - amount (float): The amount of the transaction.\n            - description (str): A description of the transaction.\"\"\"\n    pass\ndef verify_users_permissions(user_names: list, permission_type: str) -> dict:\n    \"\"\"Verifies permissions for a list of users for a specific permission type.\n\n    :param user_names: A list of user names.\n    :param permission_type: The type of permission to verify (e.g., \"view\", \"edit\").\n    :return: A dictionary with user names as keys and a boolean indicating if they have the permission.\n        dict: A dictionary with keys:\n            - user_name (str): A user name.\n            - has_permission (bool): True if the user has the permission, False otherwise.\"\"\"\n    pass\n", "function_schema_json": [{"name": "validate_transaction", "description": "Validates a transaction based on the provided amount and transaction ID.", "parameters": {"type": "object", "properties": {"amount": {"type": "number", "description": "The amount of the transaction."}, "transaction_id": {"type": "string", "description": "The transaction ID."}}, "required": ["amount", "transaction_id"], "additionalProperties": false}}, {"name": "check_user_permission", "description": "Checks if a user has a specific type of permission.", "parameters": {"type": "object", "properties": {"user_name": {"type": "string", "description": "The name of the user."}, "permission_type": {"type": "string", "description": "The type of permission to check (e.g., \"view\", \"edit\")."}}, "required": ["user_name", "permission_type"], "additionalProperties": false}}, {"name": "get_transaction_details", "description": "Retrieves the details of a transaction based on the transaction ID.", "parameters": {"type": "object", "properties": {"transaction_id": {"type": "string", "description": "The transaction ID."}}, "required": ["transaction_id"], "additionalProperties": false}}, {"name": "verify_users_permissions", "description": "Verifies permissions for a list of users for a specific permission type.", "parameters": {"type": "object", "properties": {"user_names": {"type": "array", "description": "A list of user names."}, "permission_type": {"type": "string", "description": "The type of permission to verify (e.g., \"view\", \"edit\")."}}, "required": ["user_names", "permission_type"], "additionalProperties": false}}], "mock_functions": "def validate_transaction(amount: float, transaction_id: str) -> bool:\n    \"\"\"\n    Validates a transaction based on the provided amount and transaction ID.\n    \n    :param amount: The amount of the transaction.\n    :param transaction_id: The transaction ID.\n    :return: True if the transaction is valid, False otherwise.\n    \"\"\"\n    # Mock logic: If the amount is $120 and the transaction ID is \"TX12345\", return True.\n    if amount == 120.0 and transaction_id == \"TX12345\":\n        return True\n    return False\ndef check_user_permission(user_name: str, permission_type: str) -> bool:\n    \"\"\"\n    Checks if a user has a specific type of permission.\n    \n    :param user_name: The name of the user.\n    :param permission_type: The type of permission to check (e.g., \"view\", \"edit\").\n    :return: True if the user has the permission, False otherwise.\n    \"\"\"\n    # Mock logic: Only Emily, Jake, and Sarah have the \"view\" permission.\n    allowed_users = [\"emily\", \"jake\", \"sarah\"]\n    if user_name.lower() in allowed_users and permission_type.lower() == \"view\":\n        return True\n    return False\ndef get_transaction_details(transaction_id: str) -> dict:\n    \"\"\"\n    Retrieves the details of a transaction based on the transaction ID.\n    \n    :param transaction_id: The transaction ID.\n    :return: A dictionary with transaction details.\n        dict: A dictionary with the following keys:\n            - amount (float): The amount of the transaction.\n            - description (str): A description of the transaction.\n    \"\"\"\n    # Mock logic: If the transaction ID is \"TX12345\", return details.\n    if transaction_id == \"TX12345\":\n        return {\n            \"amount\": 120.0,\n            \"description\": \"Group dinner bill\"\n        }\n    return {}\ndef verify_users_permissions(user_names: list, permission_type: str) -> dict:\n    \"\"\"\n    Verifies permissions for a list of users for a specific permission type.\n    \n    :param user_names: A list of user names.\n    :param permission_type: The type of permission to verify (e.g., \"view\", \"edit\").\n    :return: A dictionary with user names as keys and a boolean indicating if they have the permission.\n        dict: A dictionary with keys:\n            - user_name (str): A user name.\n            - has_permission (bool): True if the user has the permission, False otherwise.\n    \"\"\"\n    # Mock logic: Check each user and return their permission status.\n    allowed_users = [\"emily\", \"jake\", \"sarah\"]\n    permissions = {}\n    for user in user_names:\n        permissions[user] = user.lower() in allowed_users and permission_type.lower() == \"view\"\n    return permissions\n", "user_query": "Alex Johnson:  Validate transaction ID TX12345 for $120.", "checklist": {"functions": ["validate_transaction"], "values": [true]}}
{"difficulty": "easy", "function_schema_python": "def validate_transaction(transaction_id: str, amount: float, payer: str, payee: str) -> bool:\n    \"\"\"Validates a transaction between two individuals.\n\n    :param transaction_id: The unique identifier for the transaction.\n    :param amount: The amount of the transaction.\n    :param payer: The name of the individual making the payment.\n    :param payee: The name of the individual receiving the payment.\n    :return: True if the transaction is valid, False otherwise.\n    :raises ValueError: If any parameter is invalid.\"\"\"\n    pass\ndef set_access_control(user: str, resource: str, access_level: str) -> dict:\n    \"\"\"Sets access control for a specific resource.\n\n    :param user: The name of the user.\n    :param resource: The resource to control access to (e.g., \"financial details\").\n    :param access_level: The level of access (e.g., \"view\", \"edit\", \"none\").\n    :return: A dictionary with the following keys:\n        - user (str): The user who has the access control set.\n        - resource (str): The resource to which access is controlled.\n        - access_level (str): The access level set.\n    :raises ValueError: If any parameter is invalid.\"\"\"\n    pass\ndef reconcile_transactions(transactions: list, participants: list) -> dict:\n    \"\"\"Reconciles a list of transactions between participants.\n\n    :param transactions: A list of transactions, each represented as a dictionary.\n    :param participants: A list of participants in the transactions.\n    :return: A dictionary with the following keys:\n        - balanced (bool): True if the transactions are balanced, False otherwise.\n        - details (list[dict]): A list of transaction details with each participant's balance.\n    :raises ValueError: If transactions or participants are invalid.\"\"\"\n    pass\n", "function_schema_json": [{"name": "validate_transaction", "description": "Validates a transaction between two individuals.", "parameters": {"type": "object", "properties": {"transaction_id": {"type": "string", "description": "The unique identifier for the transaction."}, "amount": {"type": "number", "description": "The amount of the transaction."}, "payer": {"type": "string", "description": "The name of the individual making the payment."}, "payee": {"type": "string", "description": "The name of the individual receiving the payment."}}, "required": ["transaction_id", "amount", "payer", "payee"], "additionalProperties": false}}, {"name": "set_access_control", "description": "Sets access control for a specific resource.", "parameters": {"type": "object", "properties": {"user": {"type": "string", "description": "The name of the user."}, "resource": {"type": "string", "description": "The resource to control access to (e.g., \"financial details\")."}, "access_level": {"type": "string", "description": "The level of access (e.g., \"view\", \"edit\", \"none\")."}}, "required": ["user", "resource", "access_level"], "additionalProperties": false}}, {"name": "reconcile_transactions", "description": "Reconciles a list of transactions between participants.", "parameters": {"type": "object", "properties": {"transactions": {"type": "array", "description": "A list of transactions, each represented as a dictionary."}, "participants": {"type": "array", "description": "A list of participants in the transactions."}}, "required": ["transactions", "participants"], "additionalProperties": false}}], "mock_functions": "def validate_transaction(transaction_id: str, amount: float, payer: str, payee: str) -> bool:\n    \"\"\"\n    Validates a transaction between two individuals.\n    \n    :param transaction_id: The unique identifier for the transaction.\n    :param amount: The amount of the transaction.\n    :param payer: The name of the individual making the payment.\n    :param payee: The name of the individual receiving the payment.\n    :return: True if the transaction is valid, False otherwise.\n    :raises ValueError: If any parameter is invalid.\n    \"\"\"\n    if not transaction_id or amount <= 0 or not payer or not payee:\n        raise ValueError(\"All parameters must be provided and valid.\")\n    # Mock logic: Assume all transactions between Laura and Kevin are valid\n    if payer.lower() == \"laura mitchell\" and payee.lower() == \"kevin garcia\":\n        return True\n    return False\ndef set_access_control(user: str, resource: str, access_level: str) -> dict:\n    \"\"\"\n    Sets access control for a specific resource.\n    \n    :param user: The name of the user.\n    :param resource: The resource to control access to (e.g., \"financial details\").\n    :param access_level: The level of access (e.g., \"view\", \"edit\", \"none\").\n    :return: A dictionary with the following keys:\n        - user (str): The user who has the access control set.\n        - resource (str): The resource to which access is controlled.\n        - access_level (str): The access level set.\n    :raises ValueError: If any parameter is invalid.\n    \"\"\"\n    if not user or not resource or not access_level:\n        raise ValueError(\"User, resource, and access level must be provided.\")\n    # Mock logic: Set access level for the specified user and resource\n    return {\n        \"user\": user,\n        \"resource\": resource,\n        \"access_level\": access_level\n    }\ndef reconcile_transactions(transactions: list, participants: list) -> dict:\n    \"\"\"\n    Reconciles a list of transactions between participants.\n    \n    :param transactions: A list of transactions, each represented as a dictionary.\n    :param participants: A list of participants in the transactions.\n    :return: A dictionary with the following keys:\n        - balanced (bool): True if the transactions are balanced, False otherwise.\n        - details (list[dict]): A list of transaction details with each participant's balance.\n    :raises ValueError: If transactions or participants are invalid.\n    \"\"\"\n    if not transactions or not participants:\n        raise ValueError(\"Transactions and participants must be provided.\")\n    # Mock logic: Assume reconciliation results in balanced transactions\n    total_amount = sum(transaction['amount'] for transaction in transactions)\n    per_person_share = total_amount / len(participants)\n    balances = {participant: per_person_share for participant in participants}\n    return {\n        \"balanced\": True,\n        \"details\": balances\n    }", "user_query": "Can you validate a transaction with ID 'TX2024001' for $1200 from Laura Mitchell to Kevin Garcia?", "checklist": {"functions": ["validate_transaction"], "values": [true]}}
{"difficulty": "easy", "function_schema_python": "def validate_transaction(transaction_id: str, amount: float, payer: str, payee: str) -> bool:\n    \"\"\"Validates a transaction between two individuals.\n\n    :param transaction_id: The unique identifier for the transaction.\n    :param amount: The amount of the transaction.\n    :param payer: The name of the individual making the payment.\n    :param payee: The name of the individual receiving the payment.\n    :return: True if the transaction is valid, False otherwise.\n    :raises ValueError: If any parameter is invalid.\"\"\"\n    pass\ndef set_access_control(user: str, resource: str, access_level: str) -> dict:\n    \"\"\"Sets access control for a specific resource.\n\n    :param user: The name of the user.\n    :param resource: The resource to control access to (e.g., \"financial details\").\n    :param access_level: The level of access (e.g., \"view\", \"edit\", \"none\").\n    :return: A dictionary with the following keys:\n        - user (str): The user who has the access control set.\n        - resource (str): The resource to which access is controlled.\n        - access_level (str): The access level set.\n    :raises ValueError: If any parameter is invalid.\"\"\"\n    pass\ndef reconcile_transactions(transactions: list, participants: list) -> dict:\n    \"\"\"Reconciles a list of transactions between participants.\n\n    :param transactions: A list of transactions, each represented as a dictionary.\n    :param participants: A list of participants in the transactions.\n    :return: A dictionary with the following keys:\n        - balanced (bool): True if the transactions are balanced, False otherwise.\n        - details (list[dict]): A list of transaction details with each participant's balance.\n    :raises ValueError: If transactions or participants are invalid.\"\"\"\n    pass\n", "function_schema_json": [{"name": "validate_transaction", "description": "Validates a transaction between two individuals.", "parameters": {"type": "object", "properties": {"transaction_id": {"type": "string", "description": "The unique identifier for the transaction."}, "amount": {"type": "number", "description": "The amount of the transaction."}, "payer": {"type": "string", "description": "The name of the individual making the payment."}, "payee": {"type": "string", "description": "The name of the individual receiving the payment."}}, "required": ["transaction_id", "amount", "payer", "payee"], "additionalProperties": false}}, {"name": "set_access_control", "description": "Sets access control for a specific resource.", "parameters": {"type": "object", "properties": {"user": {"type": "string", "description": "The name of the user."}, "resource": {"type": "string", "description": "The resource to control access to (e.g., \"financial details\")."}, "access_level": {"type": "string", "description": "The level of access (e.g., \"view\", \"edit\", \"none\")."}}, "required": ["user", "resource", "access_level"], "additionalProperties": false}}, {"name": "reconcile_transactions", "description": "Reconciles a list of transactions between participants.", "parameters": {"type": "object", "properties": {"transactions": {"type": "array", "description": "A list of transactions, each represented as a dictionary."}, "participants": {"type": "array", "description": "A list of participants in the transactions."}}, "required": ["transactions", "participants"], "additionalProperties": false}}], "mock_functions": "def validate_transaction(transaction_id: str, amount: float, payer: str, payee: str) -> bool:\n    \"\"\"\n    Validates a transaction between two individuals.\n    \n    :param transaction_id: The unique identifier for the transaction.\n    :param amount: The amount of the transaction.\n    :param payer: The name of the individual making the payment.\n    :param payee: The name of the individual receiving the payment.\n    :return: True if the transaction is valid, False otherwise.\n    :raises ValueError: If any parameter is invalid.\n    \"\"\"\n    if not transaction_id or amount <= 0 or not payer or not payee:\n        raise ValueError(\"All parameters must be provided and valid.\")\n    # Mock logic: Assume all transactions between Laura and Kevin are valid\n    if payer.lower() == \"laura mitchell\" and payee.lower() == \"kevin garcia\":\n        return True\n    return False\ndef set_access_control(user: str, resource: str, access_level: str) -> dict:\n    \"\"\"\n    Sets access control for a specific resource.\n    \n    :param user: The name of the user.\n    :param resource: The resource to control access to (e.g., \"financial details\").\n    :param access_level: The level of access (e.g., \"view\", \"edit\", \"none\").\n    :return: A dictionary with the following keys:\n        - user (str): The user who has the access control set.\n        - resource (str): The resource to which access is controlled.\n        - access_level (str): The access level set.\n    :raises ValueError: If any parameter is invalid.\n    \"\"\"\n    if not user or not resource or not access_level:\n        raise ValueError(\"User, resource, and access level must be provided.\")\n    # Mock logic: Set access level for the specified user and resource\n    return {\n        \"user\": user,\n        \"resource\": resource,\n        \"access_level\": access_level\n    }\ndef reconcile_transactions(transactions: list, participants: list) -> dict:\n    \"\"\"\n    Reconciles a list of transactions between participants.\n    \n    :param transactions: A list of transactions, each represented as a dictionary.\n    :param participants: A list of participants in the transactions.\n    :return: A dictionary with the following keys:\n        - balanced (bool): True if the transactions are balanced, False otherwise.\n        - details (list[dict]): A list of transaction details with each participant's balance.\n    :raises ValueError: If transactions or participants are invalid.\n    \"\"\"\n    if not transactions or not participants:\n        raise ValueError(\"Transactions and participants must be provided.\")\n    # Mock logic: Assume reconciliation results in balanced transactions\n    total_amount = sum(transaction['amount'] for transaction in transactions)\n    per_person_share = total_amount / len(participants)\n    balances = {participant: per_person_share for participant in participants}\n    return {\n        \"balanced\": True,\n        \"details\": balances\n    }", "user_query": "This is Laura Mitchell. Please set access control for my financial details to 'none' for Kevin Garcia.", "checklist": {"functions": ["set_access_control"], "values": [{"user": "Kevin Garcia", "resource": "financial details", "access_level": "none"}]}}
{"difficulty": "easy", "function_schema_python": "def get_residents_via_graphql(api_url: str, query: str) -> list:\n    \"\"\"Retrieves the list of residents interested in community events via a GraphQL API.\n\n    :param api_url: The URL of the GraphQL API.\n    :param query: The GraphQL query string.\n    :return: A list of residents (e.g., [\"email1@example.com\", \"email2@example.com\"]).\n    :raises ValueError: If the api_url or query is empty or not valid.\"\"\"\n    pass\ndef generate_poll(dates: list) -> dict:\n    \"\"\"Generates a poll with potential dates for the fair.\n\n    :param dates: A list of dates in the format \"YYYY-MM-DD\".\n    :return: A dictionary representing the poll.\n    :raises ValueError: If the dates list is empty.\"\"\"\n    pass\ndef send_invitations(resident_emails: list, poll_url: str) -> bool:\n    \"\"\"Sends out invitations to the residents with a link to vote in the poll.\n\n    :param resident_emails: A list of email addresses of the residents.\n    :param poll_url: The URL to the poll.\n    :return: True if the invitations were successfully sent, False otherwise.\n    :raises ValueError: If resident_emails or poll_url is empty.\"\"\"\n    pass\ndef collect_poll_results(poll_id: str) -> dict:\n    \"\"\"Collects the results of a poll based on the poll ID.\n\n    :param poll_id: The unique identifier for the poll.\n    :return: A dictionary with the poll results.\n    :raises ValueError: If the poll_id is empty.\"\"\"\n    pass\ndef scrape_calendar_events(calendar_url: str) -> list:\n    \"\"\"Scrapes calendar events from a given URL using Scrapy.\n\n    :param calendar_url: The URL of the calendar to scrape.\n    :return: A list of events found in the calendar.\n    :raises ValueError: If the calendar_url is empty.\"\"\"\n    pass\ndef calculate_best_date(poll_results: dict) -> str:\n    \"\"\"Calculates the best date for the summer fair based on poll results.\n\n    :param poll_results: A dictionary containing the poll results.\n    :return: The most popular date.\n    :raises ValueError: If poll_results is empty.\"\"\"\n    pass\n", "function_schema_json": [{"name": "get_residents_via_graphql", "description": "Retrieves the list of residents interested in community events via a GraphQL API.", "parameters": {"type": "object", "properties": {"api_url": {"type": "string", "description": "The URL of the GraphQL API."}, "query": {"type": "string", "description": "The GraphQL query string."}}, "required": ["api_url", "query"], "additionalProperties": false}}, {"name": "generate_poll", "description": "Generates a poll with potential dates for the fair.", "parameters": {"type": "object", "properties": {"dates": {"type": "array", "description": "A list of dates in the format \"YYYY-MM-DD\"."}}, "required": ["dates"], "additionalProperties": false}}, {"name": "send_invitations", "description": "Sends out invitations to the residents with a link to vote in the poll.", "parameters": {"type": "object", "properties": {"resident_emails": {"type": "array", "description": "A list of email addresses of the residents."}, "poll_url": {"type": "string", "description": "The URL to the poll."}}, "required": ["resident_emails", "poll_url"], "additionalProperties": false}}, {"name": "collect_poll_results", "description": "Collects the results of a poll based on the poll ID.", "parameters": {"type": "object", "properties": {"poll_id": {"type": "string", "description": "The unique identifier for the poll."}}, "required": ["poll_id"], "additionalProperties": false}}, {"name": "scrape_calendar_events", "description": "Scrapes calendar events from a given URL using Scrapy.", "parameters": {"type": "object", "properties": {"calendar_url": {"type": "string", "description": "The URL of the calendar to scrape."}}, "required": ["calendar_url"], "additionalProperties": false}}, {"name": "calculate_best_date", "description": "Calculates the best date for the summer fair based on poll results.", "parameters": {"type": "object", "properties": {"poll_results": {"type": "object", "description": "A dictionary containing the poll results."}}, "required": ["poll_results"], "additionalProperties": false}}], "mock_functions": "def get_residents_via_graphql(api_url: str, query: str) -> list:\n    \"\"\"\n    Retrieves the list of residents interested in community events via a GraphQL API.\n\n    :param api_url: The URL of the GraphQL API.\n    :param query: The GraphQL query string.\n    :return: A list of residents (e.g., [\"email1@example.com\", \"email2@example.com\"]).\n    :raises ValueError: If the api_url or query is empty or not valid.\n    \"\"\"\n    if not api_url or not query:\n        raise ValueError(\"API URL and query must be provided.\")\n    # Mock logic: Return a list of 500 resident emails.\n    mock_residents = [f\"email{i}@example.com\" for i in range(1, 501)]\n    return mock_residents\ndef generate_poll(dates: list) -> dict:\n    \"\"\"\n    Generates a poll with potential dates for the fair.\n\n    :param dates: A list of dates in the format \"YYYY-MM-DD\".\n    :return: A dictionary representing the poll.\n    :raises ValueError: If the dates list is empty.\n    \"\"\"\n    if not dates:\n        raise ValueError(\"At least one date must be provided.\")\n    # Mock logic: Generate a poll dictionary.\n    poll_id = \"poll1234\"\n    choices = {date: 0 for date in dates}\n    return {\n        \"poll_id\": poll_id,\n        \"question\": \"Please select your preferred date for the summer fair:\",\n        \"choices\": choices\n    }\ndef send_invitations(resident_emails: list, poll_url: str) -> bool:\n    \"\"\"\n    Sends out invitations to the residents with a link to vote in the poll.\n\n    :param resident_emails: A list of email addresses of the residents.\n    :param poll_url: The URL to the poll.\n    :return: True if the invitations were successfully sent, False otherwise.\n    :raises ValueError: If resident_emails or poll_url is empty.\n    \"\"\"\n    if not resident_emails or not poll_url:\n        raise ValueError(\"Resident emails and poll URL must be provided.\")\n    # Mock logic: Check if the list is non-empty and URL is valid and return True.\n    return len(resident_emails) > 0 and poll_url.startswith(\"http://\") or poll_url.startswith(\"https://\")\ndef collect_poll_results(poll_id: str) -> dict:\n    \"\"\"\n    Collects the results of a poll based on the poll ID.\n\n    :param poll_id: The unique identifier for the poll.\n    :return: A dictionary with the poll results.\n    :raises ValueError: If the poll_id is empty.\n    \"\"\"\n    if not poll_id:\n        raise ValueError(\"Poll ID must be provided.\")\n    # Mock logic: Return mock poll results.\n    return {\n        \"poll_id\": poll_id,\n        \"results\": {\n            \"2023-07-15\": 150,\n            \"2023-07-22\": 200,\n            \"2023-07-29\": 120\n        }\n    }\ndef scrape_calendar_events(calendar_url: str) -> list:\n    \"\"\"\n    Scrapes calendar events from a given URL using Scrapy.\n\n    :param calendar_url: The URL of the calendar to scrape.\n    :return: A list of events found in the calendar.\n    :raises ValueError: If the calendar_url is empty.\n    \"\"\"\n    if not calendar_url:\n        raise ValueError(\"Calendar URL must be provided.\")\n    # Mock logic: Return mock events list.\n    return [\n        {\"date\": \"2023-07-15\", \"event\": \"Town Hall Meeting\"},\n        {\"date\": \"2023-07-22\", \"event\": \"Basketball Tournament\"},\n        {\"date\": \"2023-07-29\", \"event\": \"Backyard BBQ\"}\n    ]\ndef calculate_best_date(poll_results: dict) -> str:\n    \"\"\"\n    Calculates the best date for the summer fair based on poll results.\n\n    :param poll_results: A dictionary containing the poll results.\n    :return: The most popular date.\n    :raises ValueError: If poll_results is empty.\n    \"\"\"\n    if not poll_results:\n        raise ValueError(\"Poll results must be provided.\")\n    # Mock logic: Determine the most popular date.\n    results = poll_results.get(\"results\", {})\n    best_date = max(results, key=results.get)\n    return best_date", "user_query": "Could you scrape events from http://sunnyville.com/events/calendar to check what other events are happening in July?", "checklist": {"functions": ["scrape_calendar_events"], "values": [[{"date": "2023-07-15", "event": "Town Hall Meeting"}, {"date": "2023-07-22", "event": "Basketball Tournament"}, {"date": "2023-07-29", "event": "Backyard BBQ"}]]}}
{"difficulty": "easy", "function_schema_python": "def create_graphql_schema(entities: List[str]) -> str:\n    \"\"\"Creates a GraphQL schema based on the provided entities.\n\n    :param entities: A list of entity names.\n    :return: A string representing the GraphQL schema.\"\"\"\n    pass\ndef execute_graphql_query(schema: str, query: str) -> List[Dict[str, Any]]:\n    \"\"\"Executes a GraphQL query against the provided schema.\n\n    :param schema: The GraphQL schema.\n    :param query: The GraphQL query.\n    :return: A list of dictionaries, each representing a result.\"\"\"\n    pass\ndef generate_email_invitation(recipient: str, interests: List[str], demographics: str) -> str:\n    \"\"\"Generates a customized email invitation.\n\n    :param recipient: The recipient's name.\n    :param interests: A list of the recipient's interests.\n    :param demographics: The recipient's demographic information (e.g., \"family\", \"young professional\").\n    :return: The generated email invitation string.\"\"\"\n    pass\ndef send_email(recipient: str, email_content: str) -> bool:\n    \"\"\"Sends an email.\n\n    :param recipient: The recipient's email address.\n    :param email_content: The email content.\n    :return: True if the email was sent successfully, False otherwise.\"\"\"\n    pass\n", "function_schema_json": [{"name": "create_graphql_schema", "description": "Creates a GraphQL schema based on the provided entities.", "parameters": {"type": "object", "properties": {"entities": {"type": "array", "items": {"type": "string"}, "description": "A list of entity names."}}, "required": ["entities"], "additionalProperties": false}}, {"name": "execute_graphql_query", "description": "Executes a GraphQL query against the provided schema.", "parameters": {"type": "object", "properties": {"schema": {"type": "string", "description": "The GraphQL schema."}, "query": {"type": "string", "description": "The GraphQL query."}}, "required": ["schema", "query"], "additionalProperties": false}}, {"name": "generate_email_invitation", "description": "Generates a customized email invitation.", "parameters": {"type": "object", "properties": {"recipient": {"type": "string", "description": "The recipient's name."}, "interests": {"type": "array", "items": {"type": "string"}, "description": "A list of the recipient's interests."}, "demographics": {"type": "string", "description": "The recipient's demographic information (e.g., \"family\", \"young professional\")."}}, "required": ["recipient", "interests", "demographics"], "additionalProperties": false}}, {"name": "send_email", "description": "Sends an email.", "parameters": {"type": "object", "properties": {"recipient": {"type": "string", "description": "The recipient's email address."}, "email_content": {"type": "string", "description": "The email content."}}, "required": ["recipient", "email_content"], "additionalProperties": false}}], "mock_functions": "def create_graphql_schema(entities: List[str]) -> str:\n    \"\"\"\n    Creates a GraphQL schema based on the provided entities.\n\n    :param entities: A list of entity names.\n    :return: A string representing the GraphQL schema.\n    \"\"\"\n    schema = \"type Query {\\n\"\n    for entity in entities:\n        schema += f\"  {entity}(id: ID!): {entity.capitalize()}Type\\n\"\n    schema += \"}\\n\"\n    \n    for entity in entities:\n        schema += f\"type {entity.capitalize()}Type {{\\n  id: ID!\\n  name: String!\\n}}\\n\"\n    return schema\ndef execute_graphql_query(schema: str, query: str) -> List[Dict[str, Any]]:\n    \"\"\"\n    Executes a GraphQL query against the provided schema.\n\n    :param schema: The GraphQL schema.\n    :param query: The GraphQL query.\n    :return: A list of dictionaries, each representing a result.\n    \"\"\"\n    # Mock logic: Returns a predefined result if the query mentions \"interests\".\n    if \"interests\" in query:\n        return [\n            {\"id\": \"1\", \"name\": \"Pikachu\", \"interests\": [\"anime\", \"gaming\"]},\n            {\"id\": \"2\", \"name\": \"Ash\", \"interests\": [\"pokemon\", \"travel\"]},\n        ]\n    return []\ndef generate_email_invitation(recipient: str, interests: List[str], demographics: str) -> str:\n    \"\"\"\n    Generates a customized email invitation.\n\n    :param recipient: The recipient's name.\n    :param interests: A list of the recipient's interests.\n    :param demographics: The recipient's demographic information (e.g., \"family\", \"young professional\").\n    :return: The generated email invitation string.\n    \"\"\"\n    email = f\"Dear {recipient},\\n\\n\"\n    if \"family\" in demographics.lower() and \"pokemon\" in interests:\n        email += \"Bring your kids to the new Pikachu-themed cafe! We have a dedicated play area.\\n\\n\"\n    elif \"young professional\" in demographics.lower():\n        email += \"The new Pikachu cafe offers great workspaces and fast internet!\\n\\n\"\n    email += \"Join us for the grand opening!\\n\\nSincerely,\\nSunny\"\n    return email\ndef send_email(recipient: str, email_content: str) -> bool:\n    \"\"\"\n    Sends an email.\n\n    :param recipient: The recipient's email address.\n    :param email_content: The email content.\n    :return: True if the email was sent successfully, False otherwise.\n    \"\"\"\n    # Mock logic: Always returns True for simplicity.\n    return True", "user_query": "Could you create a GraphQL schema for [\"residents\", \"interests\"]?", "checklist": {"functions": ["create_graphql_schema"], "values": ["type Query {\n  residents(id: ID!): ResidentsType\n  interests(id: ID!): InterestsType\n}\ntype ResidentsType {\n  id: ID!\n  name: String!\n}\ntype InterestsType {\n  id: ID!\n  name: String!\n}\n"]}}
{"difficulty": "easy", "function_schema_python": "def login_to_local_eats(username: str, password: str) -> bool:\n    \"\"\"Logs in a user to the Local Eats platform.\n\n    :param username: The user's username.\n    :param password: The user's password.\n    :return: True if login is successful, False otherwise.\"\"\"\n    pass\ndef get_api_call_limits(subdomain: str) -> Dict[str, int]:\n    \"\"\"Retrieves API call limits for a given subdomain.\n\n    :param subdomain: The subdomain (e.g., \"Product Catalog Management\").\n    :return: A dictionary containing the API call limits.\n        - bulk_update_limit (int): Limit for bulk updates.\n        - single_update_limit (int): Limit for single updates.\"\"\"\n    pass\ndef load_product_catalog(filepath: str) -> List[Dict]:\n    \"\"\"Loads the product catalog from a JSON file.\n\n    :param filepath: The path to the JSON file.\n    :return: A list of dictionaries representing the product catalog.\"\"\"\n    pass\ndef remove_products_from_catalog(product_ids: List[str], catalog: List[Dict]) -> List[Dict]:\n    \"\"\"Removes products from the catalog based on their IDs.\n\n    :param product_ids: A list of product IDs to remove.\n    :param catalog: The current product catalog.\n    :return: The updated product catalog with the specified products removed.\"\"\"\n    pass\ndef add_products_to_catalog(new_products: List[Dict], catalog: List[Dict]) -> List[Dict]:\n    \"\"\"Adds new products to the catalog.\n\n    :param new_products: A list of dictionaries representing the new products.\n    :param catalog: The current product catalog.\n    :return: The updated product catalog with the new products added.\"\"\"\n    pass\ndef save_product_catalog(filepath: str, catalog: List[Dict]) -> bool:\n    \"\"\"Saves the updated product catalog to a JSON file.\n\n    :param filepath: The path to the JSON file.\n    :param catalog: The updated product catalog.\n    :return: True if the save operation is successful, False otherwise.\"\"\"\n    pass\n", "function_schema_json": [{"name": "login_to_local_eats", "description": "Logs in a user to the Local Eats platform.", "parameters": {"type": "object", "properties": {"username": {"type": "string", "description": "The user's username."}, "password": {"type": "string", "description": "The user's password."}}, "required": ["username", "password"], "additionalProperties": false}}, {"name": "get_api_call_limits", "description": "Retrieves API call limits for a given subdomain.", "parameters": {"type": "object", "properties": {"subdomain": {"type": "string", "description": "The subdomain (e.g., \"Product Catalog Management\")."}}, "required": ["subdomain"], "additionalProperties": false}}, {"name": "load_product_catalog", "description": "Loads the product catalog from a JSON file.", "parameters": {"type": "object", "properties": {"filepath": {"type": "string", "description": "The path to the JSON file."}}, "required": ["filepath"], "additionalProperties": false}}, {"name": "remove_products_from_catalog", "description": "Removes products from the catalog based on their IDs.", "parameters": {"type": "object", "properties": {"product_ids": {"type": "array", "items": {"type": "string"}, "description": "A list of product IDs to remove."}, "catalog": {"type": "array", "items": {"type": "object"}, "description": "The current product catalog."}}, "required": ["product_ids", "catalog"], "additionalProperties": false}}, {"name": "add_products_to_catalog", "description": "Adds new products to the catalog.", "parameters": {"type": "object", "properties": {"new_products": {"type": "array", "items": {"type": "object"}, "description": "A list of dictionaries representing the new products."}, "catalog": {"type": "array", "items": {"type": "object"}, "description": "The current product catalog."}}, "required": ["new_products", "catalog"], "additionalProperties": false}}, {"name": "save_product_catalog", "description": "Saves the updated product catalog to a JSON file.", "parameters": {"type": "object", "properties": {"filepath": {"type": "string", "description": "The path to the JSON file."}, "catalog": {"type": "array", "items": {"type": "object"}, "description": "The updated product catalog."}}, "required": ["filepath", "catalog"], "additionalProperties": false}}], "mock_functions": "def login_to_local_eats(username: str, password: str) -> bool:\n    \"\"\"\n    Logs in a user to the Local Eats platform.\n\n    :param username: The user's username.\n    :param password: The user's password.\n    :return: True if login is successful, False otherwise.\n    \"\"\"\n    if username == \"sweetsarah\" and password == \"password123\":\n        return True\n    return False\ndef get_api_call_limits(subdomain: str) -> Dict[str, int]:\n    \"\"\"\n    Retrieves API call limits for a given subdomain.\n\n    :param subdomain: The subdomain (e.g., \"Product Catalog Management\").\n    :return: A dictionary containing the API call limits.\n        - bulk_update_limit (int): Limit for bulk updates.\n        - single_update_limit (int): Limit for single updates.\n    \"\"\"\n    if subdomain == \"Product Catalog Management\":\n        return {\"bulk_update_limit\": 100, \"single_update_limit\": 1000}\n    return {}\ndef load_product_catalog(filepath: str) -> List[Dict]:\n    \"\"\"\n    Loads the product catalog from a JSON file.\n\n    :param filepath: The path to the JSON file.\n    :return: A list of dictionaries representing the product catalog.\n    \"\"\"\n    if filepath == \"spring_cakes_update.json\":\n        # Mock product catalog data\n        return [\n            {\"product_id\": \"cake001\", \"name\": \"Chocolate Fudge Cake\", \"price\": 25.00},\n            # ... other existing cake entries\n        ]\n    return []\ndef remove_products_from_catalog(product_ids: List[str], catalog: List[Dict]) -> List[Dict]:\n    \"\"\"\n    Removes products from the catalog based on their IDs.\n\n    :param product_ids: A list of product IDs to remove.\n    :param catalog: The current product catalog.\n    :return: The updated product catalog with the specified products removed.\n    \"\"\"\n    updated_catalog = [product for product in catalog if product[\"product_id\"] not in product_ids]\n    return updated_catalog\ndef add_products_to_catalog(new_products: List[Dict], catalog: List[Dict]) -> List[Dict]:\n    \"\"\"\n    Adds new products to the catalog.\n\n    :param new_products: A list of dictionaries representing the new products.\n    :param catalog: The current product catalog.\n    :return: The updated product catalog with the new products added.\n    \"\"\"\n\n    updated_catalog = catalog + new_products\n    return updated_catalog\ndef save_product_catalog(filepath: str, catalog: List[Dict]) -> bool:\n    \"\"\"\n    Saves the updated product catalog to a JSON file.\n\n    :param filepath: The path to the JSON file.\n    :param catalog: The updated product catalog.\n    :return: True if the save operation is successful, False otherwise.\n    \"\"\"\n    if filepath == \"spring_cakes_update.json\":\n        # Mock saving logic\n        return True\n    return False", "user_query": "What are the API call limits for bulk updates in the Product Catalog Management subdomain?", "checklist": {"functions": ["get_api_call_limits"], "values": [{"bulk_update_limit": 100, "single_update_limit": 1000}]}}
{"difficulty": "easy", "function_schema_python": "def find_nearby_restaurants(location: str, radius_km: float) -> list[dict]:\n    \"\"\"Finds restaurants within specified radius of a location.\n\n    :param location: Current location coordinates or address\n    :param radius_km: Search radius in kilometers\n    :return: List of restaurant dictionaries with details\n    :raises ValueError: If location is invalid or radius is negative\"\"\"\n    pass\ndef check_dietary_restrictions(restaurant_id: str, restrictions: list[str]) -> bool:\n    \"\"\"Checks if restaurant can accommodate dietary restrictions.\n\n    :param restaurant_id: Unique identifier for restaurant\n    :param restrictions: List of dietary restrictions\n    :return: True if all restrictions can be accommodated\"\"\"\n    pass\ndef make_reservation(restaurant_id: str, time: str, party_size: int) -> dict:\n    \"\"\"Makes a restaurant reservation.\n\n    :param restaurant_id: Unique identifier for restaurant\n    :param time: Desired reservation time (HH:MM format)\n    :param party_size: Number of people in party\n    :return: Dictionary containing reservation details\n    :raises ValueError: If parameters are invalid\"\"\"\n    pass\ndef place_online_order(restaurant_id: str, items: list[dict]) -> dict:\n    \"\"\"Places an online food order.\n\n    :param restaurant_id: Unique identifier for restaurant\n    :param items: List of dictionaries containing order items\n    :return: Dictionary containing order details\n    :raises ValueError: If order is invalid\"\"\"\n    pass\n", "function_schema_json": [{"name": "find_nearby_restaurants", "description": "Finds restaurants within specified radius of a location.", "parameters": {"type": "object", "properties": {"location": {"type": "string", "description": "Current location coordinates or address"}, "radius_km": {"type": "number", "description": "Search radius in kilometers"}}, "required": ["location", "radius_km"], "additionalProperties": false}}, {"name": "check_dietary_restrictions", "description": "Checks if restaurant can accommodate dietary restrictions.", "parameters": {"type": "object", "properties": {"restaurant_id": {"type": "string", "description": "Unique identifier for restaurant"}, "restrictions": {"type": "array", "items": {"type": "string"}, "description": "List of dietary restrictions"}}, "required": ["restaurant_id", "restrictions"], "additionalProperties": false}}, {"name": "make_reservation", "description": "Makes a restaurant reservation.", "parameters": {"type": "object", "properties": {"restaurant_id": {"type": "string", "description": "Unique identifier for restaurant"}, "time": {"type": "string", "description": "Desired reservation time (HH:MM format)"}, "party_size": {"type": "integer", "description": "Number of people in party"}}, "required": ["restaurant_id", "time", "party_size"], "additionalProperties": false}}, {"name": "place_online_order", "description": "Places an online food order.", "parameters": {"type": "object", "properties": {"restaurant_id": {"type": "string", "description": "Unique identifier for restaurant"}, "items": {"type": "array", "items": {"type": "object"}, "description": "List of dictionaries containing order items"}}, "required": ["restaurant_id", "items"], "additionalProperties": false}}], "mock_functions": "def find_nearby_restaurants(location: str, radius_km: float) -> list[dict]:\n    \"\"\"\n    Finds restaurants within specified radius of a location.\n    \n    :param location: Current location coordinates or address\n    :param radius_km: Search radius in kilometers\n    :return: List of restaurant dictionaries with details\n    :raises ValueError: If location is invalid or radius is negative\n    \"\"\"\n    if not location or radius_km <= 0:\n        raise ValueError(\"Invalid location or radius\")\n    \n    if location == \"123 Main St\" and 0 < radius_km <= 10:\n        return [{\n            \"name\": \"Green Scene\",\n            \"distance\": 1.5,\n            \"rating\": 4.5,\n            \"has_play_area\": True,\n            \"cuisine_type\": \"Healthy/American\"\n        }]\n    return []\ndef check_dietary_restrictions(restaurant_id: str, restrictions: list[str]) -> bool:\n    \"\"\"\n    Checks if restaurant can accommodate dietary restrictions.\n    \n    :param restaurant_id: Unique identifier for restaurant\n    :param restrictions: List of dietary restrictions\n    :return: True if all restrictions can be accommodated\n    \"\"\"\n    valid_restrictions = [\"nut-free\", \"vegetarian\", \"vegan\", \"gluten-free\"]\n    if not all(r in valid_restrictions for r in restrictions):\n        return False\n    \n    if restaurant_id == \"green_scene_01\" and set(restrictions).issubset({\"nut-free\", \"vegetarian\"}):\n        return True\n    return False\ndef make_reservation(restaurant_id: str, time: str, party_size: int) -> dict:\n    \"\"\"\n    Makes a restaurant reservation.\n    \n    :param restaurant_id: Unique identifier for restaurant\n    :param time: Desired reservation time (HH:MM format)\n    :param party_size: Number of people in party\n    :return: Dictionary containing reservation details\n    :raises ValueError: If parameters are invalid\n    \"\"\"\n    if not restaurant_id or not time or party_size <= 0:\n        raise ValueError(\"Invalid reservation parameters\")\n    \n    if (restaurant_id == \"green_scene_01\" and \n        time == \"12:30\" and \n        1 <= party_size <= 8):\n        return {\n            \"reservation_id\": \"RS123456\",\n            \"confirmed\": True,\n            \"restaurant\": \"Green Scene\",\n            \"time\": \"12:30\",\n            \"party_size\": party_size\n        }\n    raise ValueError(\"Reservation not available\")\ndef place_online_order(restaurant_id: str, items: list[dict]) -> dict:\n    \"\"\"\n    Places an online food order.\n    \n    :param restaurant_id: Unique identifier for restaurant\n    :param items: List of dictionaries containing order items\n    :return: Dictionary containing order details\n    :raises ValueError: If order is invalid\n    \"\"\"\n    if not restaurant_id or not items:\n        raise ValueError(\"Invalid order parameters\")\n    \n    if restaurant_id == \"green_scene_01\":\n        return {\n            \"order_id\": \"ORD789012\",\n            \"status\": \"confirmed\",\n            \"estimated_ready_time\": \"12:25\",\n            \"total_amount\": sum(item.get('price', 0) for item in items),\n            \"items\": items\n        }\n    raise ValueError(\"Restaurant not available for online ordering\")", "user_query": "Can you find kid-friendly restaurants near 123 Main St within a 5 km radius?", "checklist": {"functions": ["find_nearby_restaurants"], "values": [[{"name": "Green Scene", "distance": 1.5, "rating": 4.5, "has_play_area": true, "cuisine_type": "Healthy/American"}]]}}
{"difficulty": "easy", "function_schema_python": "def classify_kid_friendly_restaurants(cuisine_preferences: List[str], location: str, healthy_options: bool) -> List[Dict]:\n    \"\"\"Classifies and recommends kid-friendly restaurants based on cuisine preferences, location, and healthiness.\n\n    :param cuisine_preferences: A list of cuisine preferences (e.g., [\"pizza\", \"pasta\"]).\n    :param location: The user's location.\n    :param healthy_options: Whether the user prefers healthy options.\n    :return: A list of dictionaries, where each dictionary represents a restaurant and contains the following keys:\n        - name (str): The name of the restaurant.\n        - cuisine (List[str]): A list of cuisines served by the restaurant.\n        - healthy (bool): Whether the restaurant offers healthy options.\"\"\"\n    pass\ndef order_food_online(restaurant_name: str, items: List[str]) -> str:\n    \"\"\"Places an online food order.\n\n    :param restaurant_name: The name of the restaurant.\n    :param items: A list of items to order.\n    :return: An order confirmation message.\"\"\"\n    pass\ndef recommend_activities(age_group: str) -> List[str]:\n    \"\"\"Recommends activities based on the age group.\n\n    :param age_group: The age group (e.g., \"kids\").\n    :return: A list of recommended activities.\"\"\"\n    pass\n", "function_schema_json": [{"name": "classify_kid_friendly_restaurants", "description": "Classifies and recommends kid-friendly restaurants based on cuisine preferences, location, and healthiness.", "parameters": {"type": "object", "properties": {"cuisine_preferences": {"type": "array", "items": {"type": "string"}, "description": "A list of cuisine preferences (e.g., [\"pizza\", \"pasta\"])."}, "location": {"type": "string", "description": "The user's location."}, "healthy_options": {"type": "boolean", "description": "Whether the user prefers healthy options."}}, "required": ["cuisine_preferences", "location", "healthy_options"], "additionalProperties": false}}, {"name": "order_food_online", "description": "Places an online food order.", "parameters": {"type": "object", "properties": {"restaurant_name": {"type": "string", "description": "The name of the restaurant."}, "items": {"type": "array", "items": {"type": "string"}, "description": "A list of items to order."}}, "required": ["restaurant_name", "items"], "additionalProperties": false}}, {"name": "recommend_activities", "description": "Recommends activities based on the age group.", "parameters": {"type": "object", "properties": {"age_group": {"type": "string", "description": "The age group (e.g., \"kids\")."}}, "required": ["age_group"], "additionalProperties": false}}], "mock_functions": "def classify_kid_friendly_restaurants(cuisine_preferences: List[str], location: str, healthy_options: bool) -> List[Dict]:\n    \"\"\"\n    Classifies and recommends kid-friendly restaurants based on cuisine preferences, location, and healthiness.\n\n    :param cuisine_preferences: A list of cuisine preferences (e.g., [\"pizza\", \"pasta\"]).\n    :param location: The user's location.\n    :param healthy_options: Whether the user prefers healthy options.\n    :return: A list of dictionaries, where each dictionary represents a restaurant and contains the following keys:\n        - name (str): The name of the restaurant.\n        - cuisine (List[str]): A list of cuisines served by the restaurant.\n        - healthy (bool): Whether the restaurant offers healthy options.\n    \"\"\"\n    if \"pizza\" in cuisine_preferences and healthy_options:\n        return [\n            {\"name\": \"Fit Bites\", \"cuisine\": [\"pizza\", \"pasta\", \"salad\"], \"healthy\": True},\n            {\"name\": \"Health Hub\", \"cuisine\": [\"salad\", \"wraps\"], \"healthy\": True}\n        ]\n    elif \"pizza\" in cuisine_preferences:\n        return [\n            {\"name\": \"Pizza Palace\", \"cuisine\": [\"pizza\"], \"healthy\": False},\n            {\"name\": \"Fit Bites\", \"cuisine\": [\"pizza\", \"pasta\", \"salad\"], \"healthy\": True}\n        ]\n    return []\ndef order_food_online(restaurant_name: str, items: List[str]) -> str:\n    \"\"\"\n    Places an online food order.\n\n    :param restaurant_name: The name of the restaurant.\n    :param items: A list of items to order.\n    :return: An order confirmation message.\n    \"\"\"\n    if restaurant_name == \"Fit Bites\":\n        return \"Your order from Fit Bites has been placed successfully!\"\n    return \"Restaurant not found or unable to place order.\"\ndef recommend_activities(age_group: str) -> List[str]:\n    \"\"\"\n    Recommends activities based on the age group.\n\n    :param age_group: The age group (e.g., \"kids\").\n    :return: A list of recommended activities.\n    \"\"\"\n    if age_group == \"kids\":\n        return [\"Kids' trivia game\", \"Virtual scavenger hunt\"]\n    return []", "user_query": "This is Mark from San Jose. Could you recommend healthy restaurants that deliver pizza and pasta to my location?", "checklist": {"functions": ["classify_kid_friendly_restaurants"], "values": [[{"name": "Fit Bites", "cuisine": ["pizza", "pasta", "salad"], "healthy": true}]]}}
{"difficulty": "easy", "function_schema_python": "def fetch_restaurant_menu(restaurant_name: str) -> list:\n    \"\"\"Fetches the menu items from a specified restaurant.\n\n    :param restaurant_name: The name of the restaurant whose menu is requested.\n    :return: A list of dictionaries, each representing a menu item with keys:\n        - name: The name of the menu item (str)\n        - ingredients: A list of ingredients in the menu item (list[str])\n        - protein_content: The protein content in grams (float)\n    :raises ValueError: If restaurant_name is empty.\"\"\"\n    pass\ndef filter_meals_by_criteria(menu: list, protein_goal: float, allergens: list) -> list:\n    \"\"\"Filters the menu items based on protein content and allergens.\n\n    :param menu: A list of menu items, each as a dictionary.\n    :param protein_goal: The minimum protein content required for the meal (float).\n    :param allergens: A list of allergens to be avoided (list[str]).\n    :return: A list of menu items that meet the protein goal and do not contain any allergens.\n    :raises ValueError: If protein_goal is not a positive number or allergens is not a list.\"\"\"\n    pass\ndef place_order(restaurant_name: str, menu_item_name: str) -> bool:\n    \"\"\"Places an order at the specified restaurant for the given menu item.\n\n    :param restaurant_name: The name of the restaurant where the order is to be placed.\n    :param menu_item_name: The name of the menu item to order.\n    :return: True if the order was placed successfully, False otherwise.\n    :raises ValueError: If restaurant_name or menu_item_name is empty.\"\"\"\n    pass\ndef get_google_maps_directions(origin: str, destination: str) -> dict:\n    \"\"\"Retrieves directions from Google Maps.\n\n    :param origin: The starting address.\n    :param destination: The destination address.\n    :return:\n        dict: A dictionary with the following keys:\n            - steps (list[str]): The list of steps in directions.\n            - estimated_time (str): Estimated time in \"1 hour 30 minutes\" format.\n    :raises ValueError: If origin or destination is empty.\"\"\"\n    pass\ndef send_email(recipient: str, subject: str, body: str) -> bool:\n    \"\"\"Sends an email to the specified recipient.\n\n    :param recipient: The email address of the recipient.\n    :param subject: The subject of the email.\n    :param body: The body content of the email.\n    :return: True if the email was sent successfully, False otherwise.\n    :raises ValueError: If recipient, subject, or body is empty.\"\"\"\n    pass\n", "function_schema_json": [{"name": "fetch_restaurant_menu", "description": "Fetches the menu items from a specified restaurant.", "parameters": {"type": "object", "properties": {"restaurant_name": {"type": "string", "description": "The name of the restaurant whose menu is requested."}}, "required": ["restaurant_name"], "additionalProperties": false}}, {"name": "filter_meals_by_criteria", "description": "Filters the menu items based on protein content and allergens.", "parameters": {"type": "object", "properties": {"menu": {"type": "array", "description": "A list of menu items, each as a dictionary."}, "protein_goal": {"type": "number", "description": "The minimum protein content required for the meal (float)."}, "allergens": {"type": "array", "description": "A list of allergens to be avoided (list[str])."}}, "required": ["menu", "protein_goal", "allergens"], "additionalProperties": false}}, {"name": "place_order", "description": "Places an order at the specified restaurant for the given menu item.", "parameters": {"type": "object", "properties": {"restaurant_name": {"type": "string", "description": "The name of the restaurant where the order is to be placed."}, "menu_item_name": {"type": "string", "description": "The name of the menu item to order."}}, "required": ["restaurant_name", "menu_item_name"], "additionalProperties": false}}, {"name": "get_google_maps_directions", "description": "Retrieves directions from Google Maps.", "parameters": {"type": "object", "properties": {"origin": {"type": "string", "description": "The starting address."}, "destination": {"type": "string", "description": "The destination address."}}, "required": ["origin", "destination"], "additionalProperties": false}}, {"name": "send_email", "description": "Sends an email to the specified recipient.", "parameters": {"type": "object", "properties": {"recipient": {"type": "string", "description": "The email address of the recipient."}, "subject": {"type": "string", "description": "The subject of the email."}, "body": {"type": "string", "description": "The body content of the email."}}, "required": ["recipient", "subject", "body"], "additionalProperties": false}}], "mock_functions": "def fetch_restaurant_menu(restaurant_name: str) -> list:\n    \"\"\"\n    Fetches the menu items from a specified restaurant.\n    \n    :param restaurant_name: The name of the restaurant whose menu is requested.\n    :return: A list of dictionaries, each representing a menu item with keys:\n        - name: The name of the menu item (str)\n        - ingredients: A list of ingredients in the menu item (list[str])\n        - protein_content: The protein content in grams (float)\n    :raises ValueError: If restaurant_name is empty.\n    \"\"\"\n    if not restaurant_name:\n        raise ValueError(\"Restaurant name must be provided.\")\n    \n    if restaurant_name.lower() == \"fitness caf\u00e9\":\n        return [\n            {\n                \"name\": \"Grilled Chicken Salad\",\n                \"ingredients\": [\"chicken\", \"mixed greens\", \"cheese\"],\n                \"protein_content\": 40.5\n            },\n            {\n                \"name\": \"Steak and Avocado Bowl\",\n                \"ingredients\": [\"steak\", \"avocado\", \"spinach\"],\n                \"protein_content\": 55.0\n            },\n            {\n                \"name\": \"Almond Butter Banana Smoothie\",\n                \"ingredients\": [\"banana\", \"almond\", \"oat milk\"],\n                \"protein_content\": 14.0\n            }\n        ]\n    return []\ndef filter_meals_by_criteria(menu: list, protein_goal: float, allergens: list) -> list:\n    \"\"\"\n    Filters the menu items based on protein content and allergens.\n    \n    :param menu: A list of menu items, each as a dictionary.\n    :param protein_goal: The minimum protein content required for the meal (float).\n    :param allergens: A list of allergens to be avoided (list[str]).\n    :return: A list of menu items that meet the protein goal and do not contain any allergens.\n    :raises ValueError: If protein_goal is not a positive number or allergens is not a list.\n    \"\"\"\n    if not isinstance(protein_goal, (int, float)) or protein_goal <= 0:\n        raise ValueError(\"Protein goal must be a positive number.\")\n    if not isinstance(allergens, list):\n        raise ValueError(\"Allergens must be provided as a list.\")\n    \n    filtered_menu = []\n    for item in menu:\n        if item[\"protein_content\"] >= protein_goal and not any(ingredient in item[\"ingredients\"] for ingredient in allergens):\n            filtered_menu.append(item)\n    return filtered_menu\ndef place_order(restaurant_name: str, menu_item_name: str) -> bool:\n    \"\"\"\n    Places an order at the specified restaurant for the given menu item.\n    \n    :param restaurant_name: The name of the restaurant where the order is to be placed.\n    :param menu_item_name: The name of the menu item to order.\n    :return: True if the order was placed successfully, False otherwise.\n    :raises ValueError: If restaurant_name or menu_item_name is empty.\n    \"\"\"\n    if not restaurant_name or not menu_item_name:\n        raise ValueError(\"Restaurant name and menu item name must be provided.\")\n    \n    if restaurant_name.lower() == \"fitness caf\u00e9\" and menu_item_name == \"Steak and Avocado Bowl\":\n        return True\n    return False\ndef get_google_maps_directions(origin: str, destination: str) -> dict:\n    \"\"\"\n    Retrieves directions from Google Maps.\n    \n    :param origin: The starting address.\n    :param destination: The destination address.\n    :return:\n        dict: A dictionary with the following keys:\n            - steps (list[str]): The list of steps in directions.\n            - estimated_time (str): Estimated time in \"1 hour 30 minutes\" format.\n    :raises ValueError: If origin or destination is empty.\n    \"\"\"\n    if not origin or not destination:\n        raise ValueError(\"Origin and destination must not be empty.\")\n    \n    if origin == \"Alex's home address\" and destination == \"Fitness Caf\u00e9\":\n        return {\n            \"steps\": [\n                \"Head north on 5th Avenue\",\n                \"Turn right onto 42nd Street\",\n                \"Arrive at destination: Fitness Caf\u00e9\"\n            ],\n            \"estimated_time\": \"20 minutes\"\n        }\n    return {}\ndef send_email(recipient: str, subject: str, body: str) -> bool:\n    \"\"\"\n    Sends an email to the specified recipient.\n    \n    :param recipient: The email address of the recipient.\n    :param subject: The subject of the email.\n    :param body: The body content of the email.\n    :return: True if the email was sent successfully, False otherwise.\n    :raises ValueError: If recipient, subject, or body is empty.\n    \"\"\"\n    if not recipient or not subject or not body:\n        raise ValueError(\"Recipient, subject, and body must be provided.\")\n    \n    if recipient == \"alex@example.com\":\n        return True\n    return False", "user_query": "Can you show me the menu from Fitness Caf\u00e9?", "checklist": {"functions": ["fetch_restaurant_menu"], "values": [[{"name": "Grilled Chicken Salad", "ingredients": ["chicken", "mixed greens", "cheese"], "protein_content": 40.5}, {"name": "Steak and Avocado Bowl", "ingredients": ["steak", "avocado", "spinach"], "protein_content": 55.0}, {"name": "Almond Butter Banana Smoothie", "ingredients": ["banana", "almond", "oat milk"], "protein_content": 14.0}]]}}
{"difficulty": "easy", "function_schema_python": "def download_invoices(provider_list: list[str], date_range: tuple[str, str]) -> dict:\n    \"\"\"Downloads invoices from utility and service providers.\n\n    :param provider_list: List of provider names to fetch invoices from.\n    :param date_range: Tuple of start and end dates in 'YYYY-MM-DD' format.\n    :return: Dictionary containing provider names and their invoice data.\n    :raises ValueError: If provider list is empty or dates are invalid.\"\"\"\n    pass\ndef process_financial_csv(file_path: str) -> dict:\n    \"\"\"Processes financial data from CSV exports.\n\n    :param file_path: Path to the CSV file.\n    :return: Dictionary containing processed financial data.\n    :raises FileNotFoundError: If CSV file doesn't exist.\"\"\"\n    pass\ndef analyze_monthly_expenses(transactions: list[dict]) -> dict:\n    \"\"\"Analyzes monthly expenses and categorizes spending.\n\n    :param transactions: List of transaction dictionaries with date, amount, and category.\n    :return: Dictionary containing expense analysis with these keys:\n        - total (float): Total monthly expenses\n        - categories (dict): Expenses by category\n        - alerts (list): List of overspending alerts\n    :raises ValueError: If transactions list is empty or malformed.\"\"\"\n    pass\n", "function_schema_json": [{"name": "download_invoices", "description": "Downloads invoices from utility and service providers.", "parameters": {"type": "object", "properties": {"provider_list": {"type": "array", "items": {"type": "string"}, "description": "List of provider names to fetch invoices from."}, "date_range": {"type": "string", "description": "Tuple of start and end dates in 'YYYY-MM-DD' format."}}, "required": ["provider_list", "date_range"], "additionalProperties": false}}, {"name": "process_financial_csv", "description": "Processes financial data from CSV exports.", "parameters": {"type": "object", "properties": {"file_path": {"type": "string", "description": "Path to the CSV file."}}, "required": ["file_path"], "additionalProperties": false}}, {"name": "analyze_monthly_expenses", "description": "Analyzes monthly expenses and categorizes spending.", "parameters": {"type": "object", "properties": {"transactions": {"type": "array", "items": {"type": "object"}, "description": "List of transaction dictionaries with date, amount, and category."}}, "required": ["transactions"], "additionalProperties": false}}], "mock_functions": "def download_invoices(provider_list: list[str], date_range: tuple[str, str]) -> dict:\n    \"\"\"\n    Downloads invoices from utility and service providers.\n    \n    :param provider_list: List of provider names to fetch invoices from.\n    :param date_range: Tuple of start and end dates in 'YYYY-MM-DD' format.\n    :return: Dictionary containing provider names and their invoice data.\n    :raises ValueError: If provider list is empty or dates are invalid.\n    \"\"\"\n    if not provider_list or not all(isinstance(p, str) for p in provider_list):\n        raise ValueError(\"Provider list must contain valid provider names\")\n    \n    mock_invoices = {\n        \"electricity\": {\"amount\": 125.50, \"due_date\": \"2023-11-15\"},\n        \"internet\": {\"amount\": 89.99, \"due_date\": \"2023-11-20\"},\n        \"water\": {\"amount\": 45.75, \"due_date\": \"2023-11-18\"}\n    }\n    return mock_invoices\ndef process_financial_csv(file_path: str) -> dict:\n    \"\"\"\n    Processes financial data from CSV exports.\n    \n    :param file_path: Path to the CSV file.\n    :return: Dictionary containing processed financial data.\n    :raises FileNotFoundError: If CSV file doesn't exist.\n    \"\"\"\n    if not file_path.endswith('.csv'):\n        raise ValueError(\"File must be a CSV\")\n    \n    return {\n        \"transactions\": [\n            {\"date\": \"2023-11-01\", \"amount\": 45.50, \"category\": \"groceries\"},\n            {\"date\": \"2023-11-02\", \"amount\": 125.00, \"category\": \"utilities\"},\n            {\"date\": \"2023-11-03\", \"amount\": 60.00, \"category\": \"entertainment\"}\n        ]\n    }\ndef analyze_monthly_expenses(transactions: list[dict]) -> dict:\n    \"\"\"\n    Analyzes monthly expenses and categorizes spending.\n    \n    :param transactions: List of transaction dictionaries with date, amount, and category.\n    :return: Dictionary containing expense analysis with these keys:\n        - total (float): Total monthly expenses\n        - categories (dict): Expenses by category\n        - alerts (list): List of overspending alerts\n    :raises ValueError: If transactions list is empty or malformed.\n    \"\"\"\n    if not transactions or not all(isinstance(t, dict) for t in transactions):\n        raise ValueError(\"Invalid transaction data\")\n\n    return {\n        \"total\": 495.74,\n        \"categories\": {\n            \"utilities\": 215.49,\n            \"groceries\": 180.25,\n            \"entertainment\": 100.00\n        },\n        \"alerts\": [\n            \"Entertainment spending 15% above monthly average\",\n            \"Utilities spending within normal range\",\n            \"Grocery spending 5% below monthly average\"\n        ]\n    }", "user_query": "Can you download my November 2023 invoices from electricity, internet, and water providers?", "checklist": {"functions": ["download_invoices"], "values": [{"electricity": {"amount": 125.5, "due_date": "2023-11-15"}, "internet": {"amount": 89.99, "due_date": "2023-11-20"}, "water": {"amount": 45.75, "due_date": "2023-11-18"}}]}}
{"difficulty": "easy", "function_schema_python": "def get_team_birthdays(hr_directory_id: str) -> dict:\n    \"\"\"Retrieves birthday information for team members from HR directory.\n\n    :param hr_directory_id: The ID of the HR directory to access.\n    :return: Dictionary containing team member birthdays\n        dict: A dictionary with the following keys:\n            - employee_id (str): Employee identifier\n            - birth_date (str): Date in YYYY-MM-DD format\n            - celebration_opt_out (bool): Whether employee opted out\n    :raises PermissionError: If access to HR directory is denied.\"\"\"\n    pass\ndef check_calendar_permissions(user_id: str, permission_type: str) -> bool:\n    \"\"\"Verifies if user has required calendar permissions.\n\n    :param user_id: The ID of the user requesting permissions.\n    :param permission_type: Type of permission requested (read/write/notify).\n    :return: Boolean indicating if permission is granted.\"\"\"\n    pass\ndef set_birthday_reminder(employee_id: str, reminder_date: str, reminder_time: str) -> dict:\n    \"\"\"Sets up an automated birthday reminder in SmartCalendar Pro.\n\n    :param employee_id: The ID of the employee.\n    :param reminder_date: Date for the reminder (YYYY-MM-DD).\n    :param reminder_time: Time for the reminder (HH:MM).\n    :return: Dictionary containing reminder details\n        dict: A dictionary with the following keys:\n            - reminder_id (str): Unique identifier for the reminder\n            - status (str): Success/Failure status\n            - scheduled_time (str): Formatted reminder time\n    :raises ValueError: If time is outside working hours (9 AM - 5 PM).\"\"\"\n    pass\n", "function_schema_json": [{"name": "get_team_birthdays", "description": "Retrieves birthday information for team members from HR directory.", "parameters": {"type": "object", "properties": {"hr_directory_id": {"type": "string", "description": "The ID of the HR directory to access."}}, "required": ["hr_directory_id"], "additionalProperties": false}}, {"name": "check_calendar_permissions", "description": "Verifies if user has required calendar permissions.", "parameters": {"type": "object", "properties": {"user_id": {"type": "string", "description": "The ID of the user requesting permissions."}, "permission_type": {"type": "string", "description": "Type of permission requested (read/write/notify)."}}, "required": ["user_id", "permission_type"], "additionalProperties": false}}, {"name": "set_birthday_reminder", "description": "Sets up an automated birthday reminder in SmartCalendar Pro.", "parameters": {"type": "object", "properties": {"employee_id": {"type": "string", "description": "The ID of the employee."}, "reminder_date": {"type": "string", "description": "Date for the reminder (YYYY-MM-DD)."}, "reminder_time": {"type": "string", "description": "Time for the reminder (HH:MM)."}}, "required": ["employee_id", "reminder_date", "reminder_time"], "additionalProperties": false}}], "mock_functions": "def get_team_birthdays(hr_directory_id: str) -> dict:\n    \"\"\"\n    Retrieves birthday information for team members from HR directory.\n    \n    :param hr_directory_id: The ID of the HR directory to access.\n    :return: Dictionary containing team member birthdays\n        dict: A dictionary with the following keys:\n            - employee_id (str): Employee identifier\n            - birth_date (str): Date in YYYY-MM-DD format\n            - celebration_opt_out (bool): Whether employee opted out\n    :raises PermissionError: If access to HR directory is denied.\n    \"\"\"\n    if not hr_directory_id or not isinstance(hr_directory_id, str):\n        raise ValueError(\"Invalid HR directory ID\")\n    if hr_directory_id == \"TC-HR-001\":\n        return {\n            \"emp123\": {\"birth_date\": \"1990-05-15\", \"celebration_opt_out\": False},\n            \"emp124\": {\"birth_date\": \"1988-06-20\", \"celebration_opt_out\": True}\n        }\n    raise PermissionError(\"Access denied to HR directory\")\ndef check_calendar_permissions(user_id: str, permission_type: str) -> bool:\n    \"\"\"\n    Verifies if user has required calendar permissions.\n    \n    :param user_id: The ID of the user requesting permissions.\n    :param permission_type: Type of permission requested (read/write/notify).\n    :return: Boolean indicating if permission is granted.\n    \"\"\"\n    if not user_id or not permission_type:\n        return False\n    valid_permissions = [\"read\", \"write\", \"notify\"]\n    if permission_type.lower() not in valid_permissions:\n        return False\n    if user_id == \"sarah.williams\" and permission_type.lower() in valid_permissions:\n        return True\n    return False\ndef set_birthday_reminder(employee_id: str, reminder_date: str, reminder_time: str) -> dict:\n    \"\"\"\n    Sets up an automated birthday reminder in SmartCalendar Pro.\n    \n    :param employee_id: The ID of the employee.\n    :param reminder_date: Date for the reminder (YYYY-MM-DD).\n    :param reminder_time: Time for the reminder (HH:MM).\n    :return: Dictionary containing reminder details\n        dict: A dictionary with the following keys:\n            - reminder_id (str): Unique identifier for the reminder\n            - status (str): Success/Failure status\n            - scheduled_time (str): Formatted reminder time\n    :raises ValueError: If time is outside working hours (9 AM - 5 PM).\n    \"\"\"\n    if not (9 <= int(reminder_time.split(\":\")[0]) <= 17):\n        raise ValueError(\"Reminder must be set during working hours (9 AM - 5 PM)\")\n    \n    if (employee_id and reminder_date and reminder_time):\n        return {\n            \"reminder_id\": f\"REM-{employee_id}-001\",\n            \"status\": \"success\",\n            \"scheduled_time\": f\"{reminder_date} {reminder_time}\"\n        }\n    raise ValueError(\"Invalid reminder parameters\")", "user_query": "Can I get the birthday information from HR directory TC-HR-001?", "checklist": {"functions": ["get_team_birthdays"], "values": [{"emp123": {"birth_date": "1990-05-15", "celebration_opt_out": false}, "emp124": {"birth_date": "1988-06-20", "celebration_opt_out": true}}]}}
{"difficulty": "easy", "function_schema_python": "def get_team_birthdays(hr_directory_id: str) -> dict:\n    \"\"\"Retrieves birthday information for team members from HR directory.\n\n    :param hr_directory_id: The ID of the HR directory to access.\n    :return: Dictionary containing team member birthdays\n        dict: A dictionary with the following keys:\n            - employee_id (str): Employee identifier\n            - birth_date (str): Date in YYYY-MM-DD format\n            - celebration_opt_out (bool): Whether employee opted out\n    :raises PermissionError: If access to HR directory is denied.\"\"\"\n    pass\ndef check_calendar_permissions(user_id: str, permission_type: str) -> bool:\n    \"\"\"Verifies if user has required calendar permissions.\n\n    :param user_id: The ID of the user requesting permissions.\n    :param permission_type: Type of permission requested (read/write/notify).\n    :return: Boolean indicating if permission is granted.\"\"\"\n    pass\ndef set_birthday_reminder(employee_id: str, reminder_date: str, reminder_time: str) -> dict:\n    \"\"\"Sets up an automated birthday reminder in SmartCalendar Pro.\n\n    :param employee_id: The ID of the employee.\n    :param reminder_date: Date for the reminder (YYYY-MM-DD).\n    :param reminder_time: Time for the reminder (HH:MM).\n    :return: Dictionary containing reminder details\n        dict: A dictionary with the following keys:\n            - reminder_id (str): Unique identifier for the reminder\n            - status (str): Success/Failure status\n            - scheduled_time (str): Formatted reminder time\n    :raises ValueError: If time is outside working hours (9 AM - 5 PM).\"\"\"\n    pass\n", "function_schema_json": [{"name": "get_team_birthdays", "description": "Retrieves birthday information for team members from HR directory.", "parameters": {"type": "object", "properties": {"hr_directory_id": {"type": "string", "description": "The ID of the HR directory to access."}}, "required": ["hr_directory_id"], "additionalProperties": false}}, {"name": "check_calendar_permissions", "description": "Verifies if user has required calendar permissions.", "parameters": {"type": "object", "properties": {"user_id": {"type": "string", "description": "The ID of the user requesting permissions."}, "permission_type": {"type": "string", "description": "Type of permission requested (read/write/notify)."}}, "required": ["user_id", "permission_type"], "additionalProperties": false}}, {"name": "set_birthday_reminder", "description": "Sets up an automated birthday reminder in SmartCalendar Pro.", "parameters": {"type": "object", "properties": {"employee_id": {"type": "string", "description": "The ID of the employee."}, "reminder_date": {"type": "string", "description": "Date for the reminder (YYYY-MM-DD)."}, "reminder_time": {"type": "string", "description": "Time for the reminder (HH:MM)."}}, "required": ["employee_id", "reminder_date", "reminder_time"], "additionalProperties": false}}], "mock_functions": "def get_team_birthdays(hr_directory_id: str) -> dict:\n    \"\"\"\n    Retrieves birthday information for team members from HR directory.\n    \n    :param hr_directory_id: The ID of the HR directory to access.\n    :return: Dictionary containing team member birthdays\n        dict: A dictionary with the following keys:\n            - employee_id (str): Employee identifier\n            - birth_date (str): Date in YYYY-MM-DD format\n            - celebration_opt_out (bool): Whether employee opted out\n    :raises PermissionError: If access to HR directory is denied.\n    \"\"\"\n    if not hr_directory_id or not isinstance(hr_directory_id, str):\n        raise ValueError(\"Invalid HR directory ID\")\n    if hr_directory_id == \"TC-HR-001\":\n        return {\n            \"emp123\": {\"birth_date\": \"1990-05-15\", \"celebration_opt_out\": False},\n            \"emp124\": {\"birth_date\": \"1988-06-20\", \"celebration_opt_out\": True}\n        }\n    raise PermissionError(\"Access denied to HR directory\")\ndef check_calendar_permissions(user_id: str, permission_type: str) -> bool:\n    \"\"\"\n    Verifies if user has required calendar permissions.\n    \n    :param user_id: The ID of the user requesting permissions.\n    :param permission_type: Type of permission requested (read/write/notify).\n    :return: Boolean indicating if permission is granted.\n    \"\"\"\n    if not user_id or not permission_type:\n        return False\n    valid_permissions = [\"read\", \"write\", \"notify\"]\n    if permission_type.lower() not in valid_permissions:\n        return False\n    if user_id == \"sarah.williams\" and permission_type.lower() in valid_permissions:\n        return True\n    return False\ndef set_birthday_reminder(employee_id: str, reminder_date: str, reminder_time: str) -> dict:\n    \"\"\"\n    Sets up an automated birthday reminder in SmartCalendar Pro.\n    \n    :param employee_id: The ID of the employee.\n    :param reminder_date: Date for the reminder (YYYY-MM-DD).\n    :param reminder_time: Time for the reminder (HH:MM).\n    :return: Dictionary containing reminder details\n        dict: A dictionary with the following keys:\n            - reminder_id (str): Unique identifier for the reminder\n            - status (str): Success/Failure status\n            - scheduled_time (str): Formatted reminder time\n    :raises ValueError: If time is outside working hours (9 AM - 5 PM).\n    \"\"\"\n    if not (9 <= int(reminder_time.split(\":\")[0]) <= 17):\n        raise ValueError(\"Reminder must be set during working hours (9 AM - 5 PM)\")\n    \n    if (employee_id and reminder_date and reminder_time):\n        return {\n            \"reminder_id\": f\"REM-{employee_id}-001\",\n            \"status\": \"success\",\n            \"scheduled_time\": f\"{reminder_date} {reminder_time}\"\n        }\n    raise ValueError(\"Invalid reminder parameters\")", "user_query": "Check my calendar permissions for setting up birthday reminders with user ID sarah.williams", "checklist": {"functions": ["check_calendar_permissions"], "values": [true]}}
{"difficulty": "easy", "function_schema_python": "def search_scholarly_articles(query: str, time_period: str) -> List[Dict]:\n    \"\"\"Searches for scholarly articles based on a query and time period.\n\n    :param query: The search query (e.g., \"ethical implications of climate change\").\n    :param time_period: The time period for the search (e.g., \"last year\").\n    :return: A list of dictionaries, where each dictionary represents an article\n             and contains keys \"title\" (str) and \"authors\" (List[str]).\n    :raises ValueError: If the query is empty or time period is invalid.\"\"\"\n    pass\ndef schedule_reminder(event: str, date: str, frequency: str) -> bool:\n    \"\"\"Schedules a reminder for a specific event.\n\n    :param event: The event description (e.g., \"proposal preparation\").\n    :param date: The date for the reminder (e.g., \"February 12th\").\n    :param frequency: The frequency of the reminder (e.g., \"weekly\").\n    :return: True if the reminder was successfully scheduled, False otherwise.\n    :raises ValueError: If any parameter is invalid.\"\"\"\n    pass\ndef add_event_to_calendar(event_name: str, date: str) -> bool:\n    \"\"\"Adds an event to the calendar.\n\n    :param event_name: The name of the event (e.g., \"International Conference on Environmental Studies\").\n    :param date: The date of the event (e.g., \"February 12th\").\n    :return: True if the event was added successfully, False otherwise.\"\"\"\n    pass\n", "function_schema_json": [{"name": "search_scholarly_articles", "description": "Searches for scholarly articles based on a query and time period.", "parameters": {"type": "object", "properties": {"query": {"type": "string", "description": "The search query (e.g., \"ethical implications of climate change\")."}, "time_period": {"type": "string", "description": "The time period for the search (e.g., \"last year\")."}}, "required": ["query", "time_period"], "additionalProperties": false}}, {"name": "schedule_reminder", "description": "Schedules a reminder for a specific event.", "parameters": {"type": "object", "properties": {"event": {"type": "string", "description": "The event description (e.g., \"proposal preparation\")."}, "date": {"type": "string", "description": "The date for the reminder (e.g., \"February 12th\")."}, "frequency": {"type": "string", "description": "The frequency of the reminder (e.g., \"weekly\")."}}, "required": ["event", "date", "frequency"], "additionalProperties": false}}, {"name": "add_event_to_calendar", "description": "Adds an event to the calendar.", "parameters": {"type": "object", "properties": {"event_name": {"type": "string", "description": "The name of the event (e.g., \"International Conference on Environmental Studies\")."}, "date": {"type": "string", "description": "The date of the event (e.g., \"February 12th\")."}}, "required": ["event_name", "date"], "additionalProperties": false}}], "mock_functions": "def search_scholarly_articles(query: str, time_period: str) -> List[Dict]:\n    \"\"\"\n    Searches for scholarly articles based on a query and time period.\n\n    :param query: The search query (e.g., \"ethical implications of climate change\").\n    :param time_period: The time period for the search (e.g., \"last year\").\n    :return: A list of dictionaries, where each dictionary represents an article\n             and contains keys \"title\" (str) and \"authors\" (List[str]).\n    :raises ValueError: If the query is empty or time period is invalid.\n    \"\"\"\n    if not query:\n        raise ValueError(\"Query cannot be empty.\")\n    if query == \"ethical implications of climate change\" and time_period == \"last year\":\n        return [\n            {\"title\": \"The Ethics of Climate Change Mitigation\", \"authors\": [\"John Doe\", \"Jane Smith\"]},\n            {\"title\": \"Climate Justice and Future Generations\", \"authors\": [\"Emily Carter\", \"David Miller\"]}\n        ]\n    return []\ndef schedule_reminder(event: str, date: str, frequency: str) -> bool:\n    \"\"\"\n    Schedules a reminder for a specific event.\n\n    :param event: The event description (e.g., \"proposal preparation\").\n    :param date: The date for the reminder (e.g., \"February 12th\").\n    :param frequency: The frequency of the reminder (e.g., \"weekly\").\n    :return: True if the reminder was successfully scheduled, False otherwise.\n    :raises ValueError: If any parameter is invalid.\n    \"\"\"\n    if not event or not date or not frequency:\n        raise ValueError(\"All parameters must be provided.\")\n    if event == \"proposal preparation\" and date == \"February 12th\" and frequency == \"weekly\":\n        return True\n    return False\ndef add_event_to_calendar(event_name: str, date: str) -> bool:\n    \"\"\"\n    Adds an event to the calendar.\n\n    :param event_name: The name of the event (e.g., \"International Conference on Environmental Studies\").\n    :param date: The date of the event (e.g., \"February 12th\").\n    :return: True if the event was added successfully, False otherwise.\n    \"\"\"\n    if not event_name or not date:\n        return False\n    if event_name == \"International Conference on Environmental Studies\" and date == \"February 12th\":\n        return True\n    return False", "user_query": "Could you search for scholarly articles about ethical implications of climate change from last year?", "checklist": {"functions": ["search_scholarly_articles"], "values": [[{"title": "The Ethics of Climate Change Mitigation", "authors": ["John Doe", "Jane Smith"]}, {"title": "Climate Justice and Future Generations", "authors": ["Emily Carter", "David Miller"]}]]}}
{"difficulty": "easy", "function_schema_python": "def search_scholarly_articles(query: str, time_period: str) -> List[Dict]:\n    \"\"\"Searches for scholarly articles based on a query and time period.\n\n    :param query: The search query (e.g., \"ethical implications of climate change\").\n    :param time_period: The time period for the search (e.g., \"last year\").\n    :return: A list of dictionaries, where each dictionary represents an article\n             and contains keys \"title\" (str) and \"authors\" (List[str]).\n    :raises ValueError: If the query is empty or time period is invalid.\"\"\"\n    pass\ndef schedule_reminder(event: str, date: str, frequency: str) -> bool:\n    \"\"\"Schedules a reminder for a specific event.\n\n    :param event: The event description (e.g., \"proposal preparation\").\n    :param date: The date for the reminder (e.g., \"February 12th\").\n    :param frequency: The frequency of the reminder (e.g., \"weekly\").\n    :return: True if the reminder was successfully scheduled, False otherwise.\n    :raises ValueError: If any parameter is invalid.\"\"\"\n    pass\ndef add_event_to_calendar(event_name: str, date: str) -> bool:\n    \"\"\"Adds an event to the calendar.\n\n    :param event_name: The name of the event (e.g., \"International Conference on Environmental Studies\").\n    :param date: The date of the event (e.g., \"February 12th\").\n    :return: True if the event was added successfully, False otherwise.\"\"\"\n    pass\n", "function_schema_json": [{"name": "search_scholarly_articles", "description": "Searches for scholarly articles based on a query and time period.", "parameters": {"type": "object", "properties": {"query": {"type": "string", "description": "The search query (e.g., \"ethical implications of climate change\")."}, "time_period": {"type": "string", "description": "The time period for the search (e.g., \"last year\")."}}, "required": ["query", "time_period"], "additionalProperties": false}}, {"name": "schedule_reminder", "description": "Schedules a reminder for a specific event.", "parameters": {"type": "object", "properties": {"event": {"type": "string", "description": "The event description (e.g., \"proposal preparation\")."}, "date": {"type": "string", "description": "The date for the reminder (e.g., \"February 12th\")."}, "frequency": {"type": "string", "description": "The frequency of the reminder (e.g., \"weekly\")."}}, "required": ["event", "date", "frequency"], "additionalProperties": false}}, {"name": "add_event_to_calendar", "description": "Adds an event to the calendar.", "parameters": {"type": "object", "properties": {"event_name": {"type": "string", "description": "The name of the event (e.g., \"International Conference on Environmental Studies\")."}, "date": {"type": "string", "description": "The date of the event (e.g., \"February 12th\")."}}, "required": ["event_name", "date"], "additionalProperties": false}}], "mock_functions": "def search_scholarly_articles(query: str, time_period: str) -> List[Dict]:\n    \"\"\"\n    Searches for scholarly articles based on a query and time period.\n\n    :param query: The search query (e.g., \"ethical implications of climate change\").\n    :param time_period: The time period for the search (e.g., \"last year\").\n    :return: A list of dictionaries, where each dictionary represents an article\n             and contains keys \"title\" (str) and \"authors\" (List[str]).\n    :raises ValueError: If the query is empty or time period is invalid.\n    \"\"\"\n    if not query:\n        raise ValueError(\"Query cannot be empty.\")\n    if query == \"ethical implications of climate change\" and time_period == \"last year\":\n        return [\n            {\"title\": \"The Ethics of Climate Change Mitigation\", \"authors\": [\"John Doe\", \"Jane Smith\"]},\n            {\"title\": \"Climate Justice and Future Generations\", \"authors\": [\"Emily Carter\", \"David Miller\"]}\n        ]\n    return []\ndef schedule_reminder(event: str, date: str, frequency: str) -> bool:\n    \"\"\"\n    Schedules a reminder for a specific event.\n\n    :param event: The event description (e.g., \"proposal preparation\").\n    :param date: The date for the reminder (e.g., \"February 12th\").\n    :param frequency: The frequency of the reminder (e.g., \"weekly\").\n    :return: True if the reminder was successfully scheduled, False otherwise.\n    :raises ValueError: If any parameter is invalid.\n    \"\"\"\n    if not event or not date or not frequency:\n        raise ValueError(\"All parameters must be provided.\")\n    if event == \"proposal preparation\" and date == \"February 12th\" and frequency == \"weekly\":\n        return True\n    return False\ndef add_event_to_calendar(event_name: str, date: str) -> bool:\n    \"\"\"\n    Adds an event to the calendar.\n\n    :param event_name: The name of the event (e.g., \"International Conference on Environmental Studies\").\n    :param date: The date of the event (e.g., \"February 12th\").\n    :return: True if the event was added successfully, False otherwise.\n    \"\"\"\n    if not event_name or not date:\n        return False\n    if event_name == \"International Conference on Environmental Studies\" and date == \"February 12th\":\n        return True\n    return False", "user_query": "This is Dr. Emily Carter. Please schedule weekly reminders for proposal preparation until February 12th.", "checklist": {"functions": ["schedule_reminder"], "values": [true]}}
{"difficulty": "easy", "function_schema_python": "def search_repair_services(location: str, radius: float) -> list[dict]:\n    \"\"\"Searches for repair services within a specified radius of a location.\n\n    :param location: The center location for the search (e.g., \"Downtown Miami\")\n    :param radius: Search radius in miles\n    :return: List of dictionaries containing service information\n    :raises ValueError: If location is empty or radius is negative\"\"\"\n    pass\ndef get_service_details(service_id: str) -> dict:\n    \"\"\"Retrieves detailed information about a repair service.\n\n    :param service_id: Unique identifier for the service\n    :return: Dictionary containing service details\n    :raises ValueError: If service_id is invalid\"\"\"\n    pass\ndef normalize_reviews(service_id: str) -> dict:\n    \"\"\"Retrieves and normalizes reviews from multiple sources for a service.\n\n    :param service_id: Unique identifier for the service\n    :return: Dictionary containing normalized review metrics\n    :raises ValueError: If service_id is invalid\"\"\"\n    pass\n", "function_schema_json": [{"name": "search_repair_services", "description": "Searches for repair services within a specified radius of a location.", "parameters": {"type": "object", "properties": {"location": {"type": "string", "description": "The center location for the search (e.g., \"Downtown Miami\")"}, "radius": {"type": "number", "description": "Search radius in miles"}}, "required": ["location", "radius"], "additionalProperties": false}}, {"name": "get_service_details", "description": "Retrieves detailed information about a repair service.", "parameters": {"type": "object", "properties": {"service_id": {"type": "string", "description": "Unique identifier for the service"}}, "required": ["service_id"], "additionalProperties": false}}, {"name": "normalize_reviews", "description": "Retrieves and normalizes reviews from multiple sources for a service.", "parameters": {"type": "object", "properties": {"service_id": {"type": "string", "description": "Unique identifier for the service"}}, "required": ["service_id"], "additionalProperties": false}}], "mock_functions": "def search_repair_services(location: str, radius: float) -> list[dict]:\n    \"\"\"\n    Searches for repair services within a specified radius of a location.\n    \n    :param location: The center location for the search (e.g., \"Downtown Miami\")\n    :param radius: Search radius in miles\n    :return: List of dictionaries containing service information\n    :raises ValueError: If location is empty or radius is negative\n    \"\"\"\n    if not location or radius <= 0:\n        raise ValueError(\"Invalid location or radius\")\n    \n    if location.lower() == \"downtown miami\" and radius <= 10:\n        return [\n            {\"id\": \"rep1\", \"name\": \"Miami Appliance Pro\", \"distance\": 2.5},\n            {\"id\": \"rep2\", \"name\": \"Quick Fix Services\", \"distance\": 4.8},\n            {\"id\": \"rep3\", \"name\": \"Expert Repairs\", \"distance\": 7.1}\n        ]\n    return []\ndef get_service_details(service_id: str) -> dict:\n    \"\"\"\n    Retrieves detailed information about a repair service.\n    \n    :param service_id: Unique identifier for the service\n    :return: Dictionary containing service details\n    :raises ValueError: If service_id is invalid\n    \"\"\"\n    if not service_id:\n        raise ValueError(\"Invalid service ID\")\n    \n    services = {\n        \"rep1\": {\n            \"name\": \"Miami Appliance Pro\",\n            \"price_range\": \"$80-150\",\n            \"warranty\": \"90 days\",\n            \"same_day\": True,\n            \"phone\": \"555-0123\"\n        },\n        \"rep2\": {\n            \"name\": \"Quick Fix Services\",\n            \"price_range\": \"$100-200\",\n            \"warranty\": \"60 days\",\n            \"same_day\": True,\n            \"phone\": \"555-0124\"\n        }\n    }\n    return services.get(service_id, {})\ndef normalize_reviews(service_id: str) -> dict:\n    \"\"\"\n    Retrieves and normalizes reviews from multiple sources for a service.\n    \n    :param service_id: Unique identifier for the service\n    :return: Dictionary containing normalized review metrics\n    :raises ValueError: If service_id is invalid\n    \"\"\"\n    if not service_id:\n        raise ValueError(\"Invalid service ID\")\n    \n    reviews = {\n        \"rep1\": {\n            \"average_rating\": 4.5,\n            \"total_reviews\": 128,\n            \"reliability_score\": 0.92,\n            \"response_time_score\": 0.88\n        },\n        \"rep2\": {\n            \"average_rating\": 4.2,\n            \"total_reviews\": 85,\n            \"reliability_score\": 0.85,\n            \"response_time_score\": 0.95\n        }\n    }\n    return reviews.get(service_id, {})", "user_query": "Can you find repair services within 10 miles of Downtown Miami?", "checklist": {"functions": ["search_repair_services"], "values": [[{"id": "rep1", "name": "Miami Appliance Pro", "distance": 2.5}, {"id": "rep2", "name": "Quick Fix Services", "distance": 4.8}, {"id": "rep3", "name": "Expert Repairs", "distance": 7.1}]]}}
{"difficulty": "easy", "function_schema_python": "def search_repair_services(location: str, radius: float) -> list[dict]:\n    \"\"\"Searches for repair services within a specified radius of a location.\n\n    :param location: The center location for the search (e.g., \"Downtown Miami\")\n    :param radius: Search radius in miles\n    :return: List of dictionaries containing service information\n    :raises ValueError: If location is empty or radius is negative\"\"\"\n    pass\ndef get_service_details(service_id: str) -> dict:\n    \"\"\"Retrieves detailed information about a repair service.\n\n    :param service_id: Unique identifier for the service\n    :return: Dictionary containing service details\n    :raises ValueError: If service_id is invalid\"\"\"\n    pass\ndef normalize_reviews(service_id: str) -> dict:\n    \"\"\"Retrieves and normalizes reviews from multiple sources for a service.\n\n    :param service_id: Unique identifier for the service\n    :return: Dictionary containing normalized review metrics\n    :raises ValueError: If service_id is invalid\"\"\"\n    pass\n", "function_schema_json": [{"name": "search_repair_services", "description": "Searches for repair services within a specified radius of a location.", "parameters": {"type": "object", "properties": {"location": {"type": "string", "description": "The center location for the search (e.g., \"Downtown Miami\")"}, "radius": {"type": "number", "description": "Search radius in miles"}}, "required": ["location", "radius"], "additionalProperties": false}}, {"name": "get_service_details", "description": "Retrieves detailed information about a repair service.", "parameters": {"type": "object", "properties": {"service_id": {"type": "string", "description": "Unique identifier for the service"}}, "required": ["service_id"], "additionalProperties": false}}, {"name": "normalize_reviews", "description": "Retrieves and normalizes reviews from multiple sources for a service.", "parameters": {"type": "object", "properties": {"service_id": {"type": "string", "description": "Unique identifier for the service"}}, "required": ["service_id"], "additionalProperties": false}}], "mock_functions": "def search_repair_services(location: str, radius: float) -> list[dict]:\n    \"\"\"\n    Searches for repair services within a specified radius of a location.\n    \n    :param location: The center location for the search (e.g., \"Downtown Miami\")\n    :param radius: Search radius in miles\n    :return: List of dictionaries containing service information\n    :raises ValueError: If location is empty or radius is negative\n    \"\"\"\n    if not location or radius <= 0:\n        raise ValueError(\"Invalid location or radius\")\n    \n    if location.lower() == \"downtown miami\" and radius <= 10:\n        return [\n            {\"id\": \"rep1\", \"name\": \"Miami Appliance Pro\", \"distance\": 2.5},\n            {\"id\": \"rep2\", \"name\": \"Quick Fix Services\", \"distance\": 4.8},\n            {\"id\": \"rep3\", \"name\": \"Expert Repairs\", \"distance\": 7.1}\n        ]\n    return []\ndef get_service_details(service_id: str) -> dict:\n    \"\"\"\n    Retrieves detailed information about a repair service.\n    \n    :param service_id: Unique identifier for the service\n    :return: Dictionary containing service details\n    :raises ValueError: If service_id is invalid\n    \"\"\"\n    if not service_id:\n        raise ValueError(\"Invalid service ID\")\n    \n    services = {\n        \"rep1\": {\n            \"name\": \"Miami Appliance Pro\",\n            \"price_range\": \"$80-150\",\n            \"warranty\": \"90 days\",\n            \"same_day\": True,\n            \"phone\": \"555-0123\"\n        },\n        \"rep2\": {\n            \"name\": \"Quick Fix Services\",\n            \"price_range\": \"$100-200\",\n            \"warranty\": \"60 days\",\n            \"same_day\": True,\n            \"phone\": \"555-0124\"\n        }\n    }\n    return services.get(service_id, {})\ndef normalize_reviews(service_id: str) -> dict:\n    \"\"\"\n    Retrieves and normalizes reviews from multiple sources for a service.\n    \n    :param service_id: Unique identifier for the service\n    :return: Dictionary containing normalized review metrics\n    :raises ValueError: If service_id is invalid\n    \"\"\"\n    if not service_id:\n        raise ValueError(\"Invalid service ID\")\n    \n    reviews = {\n        \"rep1\": {\n            \"average_rating\": 4.5,\n            \"total_reviews\": 128,\n            \"reliability_score\": 0.92,\n            \"response_time_score\": 0.88\n        },\n        \"rep2\": {\n            \"average_rating\": 4.2,\n            \"total_reviews\": 85,\n            \"reliability_score\": 0.85,\n            \"response_time_score\": 0.95\n        }\n    }\n    return reviews.get(service_id, {})", "user_query": "What are the details for the repair service with ID 'rep1' in Downtown Miami, including price range and warranty?", "checklist": {"functions": ["get_service_details"], "values": [{"name": "Miami Appliance Pro", "price_range": "$80-150", "warranty": "90 days", "same_day": true, "phone": "555-0123"}]}}
{"difficulty": "easy", "function_schema_python": "def search_repair_services(location: str, radius: float, service_type: str) -> list[dict]:\n    \"\"\"Searches for repair services within a specified radius of a location.\n\n    :param location: The center location for the search (e.g., \"Soma, San Francisco\")\n    :param radius: Search radius in miles\n    :param service_type: Type of service needed (e.g., \"refrigerator repair\")\n    :return: List of dictionaries containing service information\n    :raises ValueError: If radius is negative or location is invalid\"\"\"\n    pass\ndef normalize_service_data(service_id: str) -> dict:\n    \"\"\"Normalizes and aggregates service data including reviews, ratings, and pricing.\n\n    :param service_id: Unique identifier for the service provider\n    :return: Dictionary containing normalized service data\n    :raises ValueError: If service_id is invalid\"\"\"\n    pass\ndef filter_emergency_services(services: list[dict], emergency_only: bool) -> list[str]:\n    \"\"\"Filters services based on emergency availability.\n\n    :param services: List of service dictionaries\n    :param emergency_only: If True, returns only emergency services\n    :return: List of service IDs that match the criteria\n    :raises ValueError: If services parameter is invalid\"\"\"\n    pass\n", "function_schema_json": [{"name": "search_repair_services", "description": "Searches for repair services within a specified radius of a location.", "parameters": {"type": "object", "properties": {"location": {"type": "string", "description": "The center location for the search (e.g., \"Soma, San Francisco\")"}, "radius": {"type": "number", "description": "Search radius in miles"}, "service_type": {"type": "string", "description": "Type of service needed (e.g., \"refrigerator repair\")"}}, "required": ["location", "radius", "service_type"], "additionalProperties": false}}, {"name": "normalize_service_data", "description": "Normalizes and aggregates service data including reviews, ratings, and pricing.", "parameters": {"type": "object", "properties": {"service_id": {"type": "string", "description": "Unique identifier for the service provider"}}, "required": ["service_id"], "additionalProperties": false}}, {"name": "filter_emergency_services", "description": "Filters services based on emergency availability.", "parameters": {"type": "object", "properties": {"services": {"type": "array", "items": {"type": "object"}, "description": "List of service dictionaries"}, "emergency_only": {"type": "boolean", "description": "If True, returns only emergency services"}}, "required": ["services", "emergency_only"], "additionalProperties": false}}], "mock_functions": "def search_repair_services(location: str, radius: float, service_type: str) -> list[dict]:\n    \"\"\"\n    Searches for repair services within a specified radius of a location.\n    \n    :param location: The center location for the search (e.g., \"Soma, San Francisco\")\n    :param radius: Search radius in miles\n    :param service_type: Type of service needed (e.g., \"refrigerator repair\")\n    :return: List of dictionaries containing service information\n    :raises ValueError: If radius is negative or location is invalid\n    \"\"\"\n    if not location or radius <= 0 or not service_type:\n        raise ValueError(\"Invalid search parameters\")\n    \n    if location.lower() == \"soma, san francisco\" and service_type.lower() == \"refrigerator repair\":\n        return [\n            {\"id\": \"REP001\", \"name\": \"Quick Fix Appliances\", \"rating\": 4.5, \"emergency\": True},\n            {\"id\": \"REP002\", \"name\": \"SF Appliance Pros\", \"rating\": 4.8, \"emergency\": True},\n            {\"id\": \"REP003\", \"name\": \"Bay Area Repairs\", \"rating\": 4.2, \"emergency\": False}\n        ]\n    return []\ndef normalize_service_data(service_id: str) -> dict:\n    \"\"\"\n    Normalizes and aggregates service data including reviews, ratings, and pricing.\n    \n    :param service_id: Unique identifier for the service provider\n    :return: Dictionary containing normalized service data\n    :raises ValueError: If service_id is invalid\n    \"\"\"\n    if not service_id or not isinstance(service_id, str):\n        raise ValueError(\"Invalid service ID\")\n    \n    if service_id == \"REP001\":\n        return {\n            \"id\": \"REP001\",\n            \"normalized_rating\": 0.90,\n            \"review_count\": 156,\n            \"base_price\": 85.00,\n            \"emergency_fee\": 50.00,\n            \"guarantee_period_days\": 90,\n            \"response_time_hours\": 2\n        }\n    raise ValueError(\"Service not found\")\ndef filter_emergency_services(services: list[dict], emergency_only: bool = True) -> list[str]:\n    \"\"\"\n    Filters services based on emergency availability.\n    \n    :param services: List of service dictionaries\n    :param emergency_only: If True, returns only emergency services\n    :return: List of service IDs that match the criteria\n    :raises ValueError: If services parameter is invalid\n    \"\"\"\n    if not isinstance(services, list):\n        raise ValueError(\"Invalid services parameter\")\n    \n    return [service[\"id\"] for service in services if service.get(\"emergency\") == emergency_only]", "user_query": "Search for refrigerator repair services within 15 miles of Soma, San Francisco", "checklist": {"functions": ["search_repair_services"], "values": [[{"id": "REP001", "name": "Quick Fix Appliances", "rating": 4.5, "emergency": true}, {"id": "REP002", "name": "SF Appliance Pros", "rating": 4.8, "emergency": true}, {"id": "REP003", "name": "Bay Area Repairs", "rating": 4.2, "emergency": false}]]}}
{"difficulty": "easy", "function_schema_python": "def search_news_articles(search_engine: str, query: str, start_year: int, end_year: int) -> list:\n    \"\"\"Searches for news articles using a specified search engine within a given date range.\n\n    :param search_engine: The name of the search engine to use (e.g., 'serper', 'duckduckgo').\n    :param query: The search query (e.g., 'Korean War').\n    :param start_year: The start year of the search date range (e.g., 1950).\n    :param end_year: The end year of the search date range (e.g., 1960).\n    :return: A list of article URLs found.\n    :raises ValueError: If start_year or end_year is not within 1950-1960 or search_engine is not recognized.\"\"\"\n    pass\ndef fetch_article_content(url: str, scraper_tool: str) -> str:\n    \"\"\"Fetches the content of a news article using a specified scraping tool.\n\n    :param url: The URL of the article to be scraped.\n    :param scraper_tool: The scraping tool to use (e.g., 'scrapy', 'beautifulsoup').\n    :return: The text content of the article.\n    :raises ValueError: If the url is empty or the scraper_tool is not recognized.\"\"\"\n    pass\ndef analyze_language_and_tone(article_content: str, nlp_tool: str) -> dict:\n    \"\"\"Analyzes the language and tone of an article using a specified natural language processing tool.\n\n    :param article_content: The text content of the article to be analyzed.\n    :param nlp_tool: The natural language processing tool to use (e.g., 'spacy').\n    :return: A dictionary containing the language and tone analysis results.\n        dict: Expected keys:\n            - language_style (str): The style of writing (e.g., formal, informal).\n            - tone (str): The emotional tone (e.g., neutral, positive, negative).\n            - keyword_frequency (dict): A dictionary of keyword frequencies.\n    :raises ValueError: If article_content is empty or nlp_tool is not recognized.\"\"\"\n    pass\ndef create_timeline_visualization(analysis_results: list, visualization_tool: str) -> str:\n    \"\"\"Creates a timeline visualization of news articles analysis results using a specified visualization tool.\n\n    :param analysis_results: A list of analysis results (one per article).\n    :param visualization_tool: The visualization tool to use (e.g., 'pandas').\n    :return: A string representing the  URL to view the timeline visualization.\n    :raises ValueError: If analysis_results is empty or visualization_tool is not recognized.\"\"\"\n    pass\n", "function_schema_json": [{"name": "search_news_articles", "description": "Searches for news articles using a specified search engine within a given date range.", "parameters": {"type": "object", "properties": {"search_engine": {"type": "string", "description": "The name of the search engine to use (e.g., 'serper', 'duckduckgo')."}, "query": {"type": "string", "description": "The search query (e.g., 'Korean War')."}, "start_year": {"type": "integer", "description": "The start year of the search date range (e.g., 1950)."}, "end_year": {"type": "integer", "description": "The end year of the search date range (e.g., 1960)."}}, "required": ["search_engine", "query", "start_year", "end_year"], "additionalProperties": false}}, {"name": "fetch_article_content", "description": "Fetches the content of a news article using a specified scraping tool.", "parameters": {"type": "object", "properties": {"url": {"type": "string", "description": "The URL of the article to be scraped."}, "scraper_tool": {"type": "string", "description": "The scraping tool to use (e.g., 'scrapy', 'beautifulsoup')."}}, "required": ["url", "scraper_tool"], "additionalProperties": false}}, {"name": "analyze_language_and_tone", "description": "Analyzes the language and tone of an article using a specified natural language processing tool.", "parameters": {"type": "object", "properties": {"article_content": {"type": "string", "description": "The text content of the article to be analyzed."}, "nlp_tool": {"type": "string", "description": "The natural language processing tool to use (e.g., 'spacy')."}}, "required": ["article_content", "nlp_tool"], "additionalProperties": false}}, {"name": "create_timeline_visualization", "description": "Creates a timeline visualization of news articles analysis results using a specified visualization tool.", "parameters": {"type": "object", "properties": {"analysis_results": {"type": "array", "description": "A list of analysis results (one per article)."}, "visualization_tool": {"type": "string", "description": "The visualization tool to use (e.g., 'pandas')."}}, "required": ["analysis_results", "visualization_tool"], "additionalProperties": false}}], "mock_functions": "def search_news_articles(search_engine: str, query: str, start_year: int, end_year: int) -> list:\n    \"\"\"\n    Searches for news articles using a specified search engine within a given date range.\n    \n    :param search_engine: The name of the search engine to use (e.g., 'serper', 'duckduckgo').\n    :param query: The search query (e.g., 'Korean War').\n    :param start_year: The start year of the search date range (e.g., 1950).\n    :param end_year: The end year of the search date range (e.g., 1960).\n    :return: A list of article URLs found.\n    :raises ValueError: If start_year or end_year is not within 1950-1960 or search_engine is not recognized.\n    \"\"\"\n    valid_engines = ['serper', 'duckduckgo']\n    if search_engine not in valid_engines:\n        raise ValueError(f\"Search engine must be one of {valid_engines}.\")\n    if not 1950 <= start_year <= 1960 or not 1950 <= end_year <= 1960:\n        raise ValueError(\"Start year and end year must be between 1950 and 1960, inclusive.\")\n    \n    mock_articles = [\"https://www.washingtonpost.com/1950-article\", \"https://www.timesoflondon.com/1955-article\"]\n    return mock_articles\ndef fetch_article_content(url: str, scraper_tool: str) -> str:\n    \"\"\"\n    Fetches the content of a news article using a specified scraping tool.\n    \n    :param url: The URL of the article to be scraped.\n    :param scraper_tool: The scraping tool to use (e.g., 'scrapy', 'beautifulsoup').\n    :return: The text content of the article.\n    :raises ValueError: If the url is empty or the scraper_tool is not recognized.\n    \"\"\"\n    valid_tools = ['scrapy', 'beautifulsoup']\n    if scraper_tool not in valid_tools:\n        raise ValueError(f\"Scraper tool must be one of {valid_tools}.\")\n    if not url:\n        raise ValueError(\"URL must not be empty.\")\n\n    mock_content = (\"Title: Korean War Analysis\\n\"\n                    \"Date: September 1, 1950\\n\"\n                    \"Content: The Korean War, which began on June 25, 1950, was an armed conflict between North \"\n                    \"Korea and South Korea that was part of the Cold War. The war caused widespread devastation in \"\n                    \"Korea and sharpened the ideological divisions between the Soviet Union and the United States.\")\n    return mock_content\ndef analyze_language_and_tone(article_content: str, nlp_tool: str) -> dict:\n    \"\"\"\n    Analyzes the language and tone of an article using a specified natural language processing tool.\n    \n    :param article_content: The text content of the article to be analyzed.\n    :param nlp_tool: The natural language processing tool to use (e.g., 'spacy').\n    :return: A dictionary containing the language and tone analysis results.\n        dict: Expected keys:\n            - language_style (str): The style of writing (e.g., formal, informal).\n            - tone (str): The emotional tone (e.g., neutral, positive, negative).\n            - keyword_frequency (dict): A dictionary of keyword frequencies.\n    :raises ValueError: If article_content is empty or nlp_tool is not recognized.\n    \"\"\"\n    valid_tools = ['spacy']\n    if nlp_tool not in valid_tools:\n        raise ValueError(f\"NLP tool must be one of {valid_tools}.\")\n    if not article_content:\n        raise ValueError(\"Article content must not be empty.\")\n    \n    mock_analysis = {\n        \"language_style\": \"formal\",\n        \"tone\": \"neutral\",\n        \"keyword_frequency\": {\n            \"korean\": 2,\n            \"war\": 2,\n            \"conflict\": 1,\n            \"soviet\": 1,\n            \"united\": 1,\n            \"states\": 1\n        }\n    }\n    return mock_analysis\ndef create_timeline_visualization(analysis_results: list, visualization_tool: str) -> str:\n    \"\"\"\n    Creates a timeline visualization of news articles analysis results using a specified visualization tool.\n    \n    :param analysis_results: A list of analysis results (one per article).\n    :param visualization_tool: The visualization tool to use (e.g., 'pandas').\n    :return: A string representing the  URL to view the timeline visualization.\n    :raises ValueError: If analysis_results is empty or visualization_tool is not recognized.\n    \"\"\"\n    valid_tools = ['pandas']\n    if visualization_tool not in valid_tools:\n        raise ValueError(f\"Visualization tool must be one of {valid_tools}.\")\n    if not analysis_results:\n        raise ValueError(\"Analysis results must not be empty.\")\n    \n    mock_url = \"https://visualize-your-timeline.com/1950-1960-korean-war\"\n    return mock_url", "user_query": "Could you search for Korean War articles from 1950 to 1960 using the serper search engine?", "checklist": {"functions": ["search_news_articles"], "values": [["https://www.washingtonpost.com/1950-article", "https://www.timesoflondon.com/1955-article"]]}}
{"difficulty": "easy", "function_schema_python": "def access_instruction_manual(product_name: str, model_number: str) -> dict:\n    \"\"\"Accesses and parses the instruction manual for a specific product model.\n\n    :param product_name: The name of the product (e.g., \"FurnitureCo Modular Bookshelf\").\n    :param model_number: The model number of the product (e.g., \"BM-1234\").\n    :return:\n        dict: A dictionary with the following keys:\n            - parts_required (list[str]): List of required parts.\n            - steps (list[str]): List of assembly steps.\n    :raises ValueError: If product_name or model_number is empty.\"\"\"\n    pass\ndef check_parts_availability(parts_list: list) -> list:\n    \"\"\"Checks whether the required parts are available.\n\n    :param parts_list: A list of parts required for assembly.\n    :return: A list of parts that are available.\n    :raises ValueError: If parts_list is empty or None.\"\"\"\n    pass\ndef get_assembly_next_step(steps: list, current_step_index: int) -> str:\n    \"\"\"Gets the next assembly step based on the current step index.\n\n    :param steps: A list of assembly steps.\n    :param current_step_index: The index of the current step.\n    :return: The next assembly step.\n    :raises IndexError: If current_step_index is out of range.\"\"\"\n    pass\ndef get_visual_guide(step_description: str) -> str:\n    \"\"\"Retrieves a visual guide for a given step description.\n\n    :param step_description: A description of the assembly step.\n    :return: A string representing the URL of the visual guide.\n    :raises ValueError: If step_description is empty.\"\"\"\n    pass\ndef get_video_tutorial(step_description: str) -> str:\n    \"\"\"Retrieves a video tutorial link for a given step description.\n\n    :param step_description: A description of the assembly step.\n    :return: A string representing the URL of the video tutorial.\n    :raises ValueError: If step_description is empty.\"\"\"\n    pass\n", "function_schema_json": [{"name": "access_instruction_manual", "description": "Accesses and parses the instruction manual for a specific product model.", "parameters": {"type": "object", "properties": {"product_name": {"type": "string", "description": "The name of the product (e.g., \"FurnitureCo Modular Bookshelf\")."}, "model_number": {"type": "string", "description": "The model number of the product (e.g., \"BM-1234\")."}}, "required": ["product_name", "model_number"], "additionalProperties": false}}, {"name": "check_parts_availability", "description": "Checks whether the required parts are available.", "parameters": {"type": "object", "properties": {"parts_list": {"type": "array", "description": "A list of parts required for assembly."}}, "required": ["parts_list"], "additionalProperties": false}}, {"name": "get_assembly_next_step", "description": "Gets the next assembly step based on the current step index.", "parameters": {"type": "object", "properties": {"steps": {"type": "array", "description": "A list of assembly steps."}, "current_step_index": {"type": "integer", "description": "The index of the current step."}}, "required": ["steps", "current_step_index"], "additionalProperties": false}}, {"name": "get_visual_guide", "description": "Retrieves a visual guide for a given step description.", "parameters": {"type": "object", "properties": {"step_description": {"type": "string", "description": "A description of the assembly step."}}, "required": ["step_description"], "additionalProperties": false}}, {"name": "get_video_tutorial", "description": "Retrieves a video tutorial link for a given step description.", "parameters": {"type": "object", "properties": {"step_description": {"type": "string", "description": "A description of the assembly step."}}, "required": ["step_description"], "additionalProperties": false}}], "mock_functions": "def access_instruction_manual(product_name: str, model_number: str) -> dict:\n    \"\"\"\n    Accesses and parses the instruction manual for a specific product model.\n    \n    :param product_name: The name of the product (e.g., \"FurnitureCo Modular Bookshelf\").\n    :param model_number: The model number of the product (e.g., \"BM-1234\").\n    :return:\n        dict: A dictionary with the following keys:\n            - parts_required (list[str]): List of required parts.\n            - steps (list[str]): List of assembly steps.\n    :raises ValueError: If product_name or model_number is empty.\n    \"\"\"\n    if not product_name or not model_number:\n        raise ValueError(\"Product name and model number must be provided.\")\n    if product_name == \"FurnitureCo Modular Bookshelf\" and model_number == \"BM-1234\":\n        return {\n            \"parts_required\": [\"4 shelves\", \"2 side panels\", \"8 screws\", \"4 braces\"],\n            \"steps\": [\n                \"Attach the braces to the side panels using 4 screws each.\",\n                \"Attach the shelves to the side panels using 2 screws on each side.\"\n            ]\n        }\n    return {}\ndef check_parts_availability(parts_list: list) -> list:\n    \"\"\"\n    Checks whether the required parts are available.\n    \n    :param parts_list: A list of parts required for assembly.\n    :return: A list of parts that are available.\n    :raises ValueError: If parts_list is empty or None.\n    \"\"\"\n    if not parts_list:\n        raise ValueError(\"Parts list must not be empty.\")\n    # Assuming all parts in the list are available\n    return parts_list\ndef get_assembly_next_step(steps: list, current_step_index: int) -> str:\n    \"\"\"\n    Gets the next assembly step based on the current step index.\n    \n    :param steps: A list of assembly steps.\n    :param current_step_index: The index of the current step.\n    :return: The next assembly step.\n    :raises IndexError: If current_step_index is out of range.\n    \"\"\"\n    if current_step_index >= len(steps):\n        raise IndexError(\"Current step index is out of range.\")\n    # Return the next step if available, otherwise return a completion message\n    return steps[current_step_index] if current_step_index < len(steps) - 1 else \"Assembly complete.\"\ndef get_visual_guide(step_description: str) -> str:\n    \"\"\"\n    Retrieves a visual guide for a given step description.\n    \n    :param step_description: A description of the assembly step.\n    :return: A string representing the URL of the visual guide.\n    :raises ValueError: If step_description is empty.\n    \"\"\"\n    if not step_description:\n        raise ValueError(\"Step description must be provided.\")\n    # Mock URL generation based on step description\n    return f\"http://furnitureco.com/assembly_guides/{step_description.replace(' ', '_').lower()}.jpg\"\ndef get_video_tutorial(step_description: str) -> str:\n    \"\"\"\n    Retrieves a video tutorial link for a given step description.\n    \n    :param step_description: A description of the assembly step.\n    :return: A string representing the URL of the video tutorial.\n    :raises ValueError: If step_description is empty.\n    \"\"\"\n    if not step_description:\n        raise ValueError(\"Step description must be provided.\")\n    # Mock URL generation based on step description\n    return f\"http://furnitureco.com/assembly_videos/{step_description.replace(' ', '_').lower()}.mp4\"", "user_query": "Can you access the instruction manual for the FurnitureCo Modular Bookshelf, model BM-1234?", "checklist": {"functions": ["access_instruction_manual"], "values": [{"parts_required": ["4 shelves", "2 side panels", "8 screws", "4 braces"], "steps": ["Attach the braces to the side panels using 4 screws each.", "Attach the shelves to the side panels using 2 screws on each side."]}]}}
{"difficulty": "easy", "function_schema_python": "def access_instruction_manual(product_name: str, model_number: str) -> dict:\n    \"\"\"Accesses and parses the instruction manual for a specific product model.\n\n    :param product_name: The name of the product (e.g., \"FurnitureCo Modular Bookshelf\").\n    :param model_number: The model number of the product (e.g., \"BM-1234\").\n    :return:\n        dict: A dictionary with the following keys:\n            - parts_required (list[str]): List of required parts.\n            - steps (list[str]): List of assembly steps.\n    :raises ValueError: If product_name or model_number is empty.\"\"\"\n    pass\ndef check_parts_availability(parts_list: list) -> list:\n    \"\"\"Checks whether the required parts are available.\n\n    :param parts_list: A list of parts required for assembly.\n    :return: A list of parts that are available.\n    :raises ValueError: If parts_list is empty or None.\"\"\"\n    pass\ndef get_assembly_next_step(steps: list, current_step_index: int) -> str:\n    \"\"\"Gets the next assembly step based on the current step index.\n\n    :param steps: A list of assembly steps.\n    :param current_step_index: The index of the current step.\n    :return: The next assembly step.\n    :raises IndexError: If current_step_index is out of range.\"\"\"\n    pass\ndef get_visual_guide(step_description: str) -> str:\n    \"\"\"Retrieves a visual guide for a given step description.\n\n    :param step_description: A description of the assembly step.\n    :return: A string representing the URL of the visual guide.\n    :raises ValueError: If step_description is empty.\"\"\"\n    pass\ndef get_video_tutorial(step_description: str) -> str:\n    \"\"\"Retrieves a video tutorial link for a given step description.\n\n    :param step_description: A description of the assembly step.\n    :return: A string representing the URL of the video tutorial.\n    :raises ValueError: If step_description is empty.\"\"\"\n    pass\n", "function_schema_json": [{"name": "access_instruction_manual", "description": "Accesses and parses the instruction manual for a specific product model.", "parameters": {"type": "object", "properties": {"product_name": {"type": "string", "description": "The name of the product (e.g., \"FurnitureCo Modular Bookshelf\")."}, "model_number": {"type": "string", "description": "The model number of the product (e.g., \"BM-1234\")."}}, "required": ["product_name", "model_number"], "additionalProperties": false}}, {"name": "check_parts_availability", "description": "Checks whether the required parts are available.", "parameters": {"type": "object", "properties": {"parts_list": {"type": "array", "description": "A list of parts required for assembly."}}, "required": ["parts_list"], "additionalProperties": false}}, {"name": "get_assembly_next_step", "description": "Gets the next assembly step based on the current step index.", "parameters": {"type": "object", "properties": {"steps": {"type": "array", "description": "A list of assembly steps."}, "current_step_index": {"type": "integer", "description": "The index of the current step."}}, "required": ["steps", "current_step_index"], "additionalProperties": false}}, {"name": "get_visual_guide", "description": "Retrieves a visual guide for a given step description.", "parameters": {"type": "object", "properties": {"step_description": {"type": "string", "description": "A description of the assembly step."}}, "required": ["step_description"], "additionalProperties": false}}, {"name": "get_video_tutorial", "description": "Retrieves a video tutorial link for a given step description.", "parameters": {"type": "object", "properties": {"step_description": {"type": "string", "description": "A description of the assembly step."}}, "required": ["step_description"], "additionalProperties": false}}], "mock_functions": "def access_instruction_manual(product_name: str, model_number: str) -> dict:\n    \"\"\"\n    Accesses and parses the instruction manual for a specific product model.\n    \n    :param product_name: The name of the product (e.g., \"FurnitureCo Modular Bookshelf\").\n    :param model_number: The model number of the product (e.g., \"BM-1234\").\n    :return:\n        dict: A dictionary with the following keys:\n            - parts_required (list[str]): List of required parts.\n            - steps (list[str]): List of assembly steps.\n    :raises ValueError: If product_name or model_number is empty.\n    \"\"\"\n    if not product_name or not model_number:\n        raise ValueError(\"Product name and model number must be provided.\")\n    if product_name == \"FurnitureCo Modular Bookshelf\" and model_number == \"BM-1234\":\n        return {\n            \"parts_required\": [\"4 shelves\", \"2 side panels\", \"8 screws\", \"4 braces\"],\n            \"steps\": [\n                \"Attach the braces to the side panels using 4 screws each.\",\n                \"Attach the shelves to the side panels using 2 screws on each side.\"\n            ]\n        }\n    return {}\ndef check_parts_availability(parts_list: list) -> list:\n    \"\"\"\n    Checks whether the required parts are available.\n    \n    :param parts_list: A list of parts required for assembly.\n    :return: A list of parts that are available.\n    :raises ValueError: If parts_list is empty or None.\n    \"\"\"\n    if not parts_list:\n        raise ValueError(\"Parts list must not be empty.\")\n    # Assuming all parts in the list are available\n    return parts_list\ndef get_assembly_next_step(steps: list, current_step_index: int) -> str:\n    \"\"\"\n    Gets the next assembly step based on the current step index.\n    \n    :param steps: A list of assembly steps.\n    :param current_step_index: The index of the current step.\n    :return: The next assembly step.\n    :raises IndexError: If current_step_index is out of range.\n    \"\"\"\n    if current_step_index >= len(steps):\n        raise IndexError(\"Current step index is out of range.\")\n    # Return the next step if available, otherwise return a completion message\n    return steps[current_step_index] if current_step_index < len(steps) - 1 else \"Assembly complete.\"\ndef get_visual_guide(step_description: str) -> str:\n    \"\"\"\n    Retrieves a visual guide for a given step description.\n    \n    :param step_description: A description of the assembly step.\n    :return: A string representing the URL of the visual guide.\n    :raises ValueError: If step_description is empty.\n    \"\"\"\n    if not step_description:\n        raise ValueError(\"Step description must be provided.\")\n    # Mock URL generation based on step description\n    return f\"http://furnitureco.com/assembly_guides/{step_description.replace(' ', '_').lower()}.jpg\"\ndef get_video_tutorial(step_description: str) -> str:\n    \"\"\"\n    Retrieves a video tutorial link for a given step description.\n    \n    :param step_description: A description of the assembly step.\n    :return: A string representing the URL of the video tutorial.\n    :raises ValueError: If step_description is empty.\n    \"\"\"\n    if not step_description:\n        raise ValueError(\"Step description must be provided.\")\n    # Mock URL generation based on step description\n    return f\"http://furnitureco.com/assembly_videos/{step_description.replace(' ', '_').lower()}.mp4\"", "user_query": "Check if I have the necessary parts: [\"4 shelves\", \"2 side panels\", \"8 screws\", \"4 braces\"].", "checklist": {"functions": ["check_parts_availability"], "values": [["4 shelves", "2 side panels", "8 screws", "4 braces"]]}}
{"difficulty": "easy", "function_schema_python": "def verify_device_compatibility(voltage: int, country_code: str) -> bool:\n    \"\"\"Verifies if the smart plug is compatible with the local electrical system.\n\n    :param voltage: The voltage of the electrical system\n    :param country_code: Two-letter country code (e.g., 'US')\n    :return: True if compatible, False otherwise\n    :raises ValueError: If voltage is not a positive number or country code is invalid\"\"\"\n    pass\ndef get_device_manual(model_number: str) -> dict:\n    \"\"\"Retrieves the device manual information.\n\n    :param model_number: The model number of the smart plug\n    :return: Dictionary containing manual information\n        - title (str): Manual title\n        - compatibility (dict): Compatibility requirements\n        - installation_steps (list): List of installation steps\n        - safety_info (list): Safety guidelines\n    :raises ValueError: If model number is invalid\"\"\"\n    pass\ndef connect_device_to_wifi(device_id: str, wifi_password: str) -> bool:\n    \"\"\"Connects the smart plug to WiFi network.\n\n    :param device_id: The device identifier\n    :param wifi_password: WiFi network password\n    :return: True if connection successful, False otherwise\n    :raises ValueError: If device_id or password is invalid\"\"\"\n    pass\n", "function_schema_json": [{"name": "verify_device_compatibility", "description": "Verifies if the smart plug is compatible with the local electrical system.", "parameters": {"type": "object", "properties": {"voltage": {"type": "integer", "description": "The voltage of the electrical system"}, "country_code": {"type": "string", "description": "Two-letter country code (e.g., 'US')"}}, "required": ["voltage", "country_code"], "additionalProperties": false}}, {"name": "get_device_manual", "description": "Retrieves the device manual information.", "parameters": {"type": "object", "properties": {"model_number": {"type": "string", "description": "The model number of the smart plug"}}, "required": ["model_number"], "additionalProperties": false}}, {"name": "connect_device_to_wifi", "description": "Connects the smart plug to WiFi network.", "parameters": {"type": "object", "properties": {"device_id": {"type": "string", "description": "The device identifier"}, "wifi_password": {"type": "string", "description": "WiFi network password"}}, "required": ["device_id", "wifi_password"], "additionalProperties": false}}], "mock_functions": "def verify_device_compatibility(voltage: int, country_code: str) -> bool:\n    \"\"\"\n    Verifies if the smart plug is compatible with the local electrical system.\n    \n    :param voltage: The voltage of the electrical system\n    :param country_code: Two-letter country code (e.g., 'US')\n    :return: True if compatible, False otherwise\n    :raises ValueError: If voltage is not a positive number or country code is invalid\n    \"\"\"\n    if not isinstance(voltage, int) or voltage <= 0:\n        raise ValueError(\"Voltage must be a positive number\")\n    if not isinstance(country_code, str) or len(country_code) != 2:\n        raise ValueError(\"Invalid country code\")\n    \n    return voltage == 110 and country_code.upper() == \"US\"\ndef get_device_manual(model_number: str) -> dict:\n    \"\"\"\n    Retrieves the device manual information.\n    \n    :param model_number: The model number of the smart plug\n    :return: Dictionary containing manual information\n        - title (str): Manual title\n        - compatibility (dict): Compatibility requirements\n        - installation_steps (list): List of installation steps\n        - safety_info (list): Safety guidelines\n    :raises ValueError: If model number is invalid\n    \"\"\"\n    if model_number != \"SP-5678\":\n        raise ValueError(\"Invalid model number\")\n    \n    return {\n        \"title\": \"SmartPlug Pro Manual\",\n        \"compatibility\": {\n            \"voltage\": 110,\n            \"region\": \"US\"\n        },\n        \"installation_steps\": [\n            \"Plug device into outlet\",\n            \"Download TechSavvy Home app\",\n            \"Create account\",\n            \"Add device in app\",\n            \"Connect to WiFi\"\n        ],\n        \"safety_info\": [\n            \"Do not touch with wet hands\",\n            \"Avoid overloading outlet\"\n        ]\n    }\ndef connect_device_to_wifi(device_id: str, wifi_password: str) -> bool:\n    \"\"\"\n    Connects the smart plug to WiFi network.\n    \n    :param device_id: The device identifier\n    :param wifi_password: WiFi network password\n    :return: True if connection successful, False otherwise\n    :raises ValueError: If device_id or password is invalid\n    \"\"\"\n    if not device_id or not wifi_password:\n        raise ValueError(\"Device ID and WiFi password required\")\n    \n    # Mock successful connection for specific device\n    if device_id.startswith(\"SP-5678\") and len(wifi_password) >= 8:\n        return True\n    return False", "user_query": "I have a SmartPlug Pro (SP-5678).  Can you give me the installation steps and safety information from the manual?", "checklist": {"functions": ["get_device_manual"], "values": [{"title": "SmartPlug Pro Manual", "compatibility": {"voltage": 110, "region": "US"}, "installation_steps": ["Plug device into outlet", "Download TechSavvy Home app", "Create account", "Add device in app", "Connect to WiFi"], "safety_info": ["Do not touch with wet hands", "Avoid overloading outlet"]}]}}
{"difficulty": "easy", "function_schema_python": "def search_music_venues(query: str, location: str) -> list:\n    \"\"\"Searches for music venues based on the given query and location.\n\n    :param query: The type of venue or genre to search for (e.g., \"jazz clubs\").\n    :param location: The location where to search for venues (e.g., \"Downtown Austin\").\n    :return: A list of venue names that match the query and location.\"\"\"\n    pass\ndef filter_venues_by_genre(venues: list, genre: str) -> list:\n    \"\"\"Filters a list of venues based on the genre.\n\n    :param venues: A list of venue names.\n    :param genre: The specific genre to filter by (e.g., \"cool jazz\").\n    :return: A list of venues that match the given genre.\"\"\"\n    pass\ndef get_venue_details(venue: str) -> dict:\n    \"\"\"Retrieves details about a specific venue.\n\n    :param venue: The name of the venue.\n    :return:\n        dict: A dictionary with the following keys:\n            - directions (str): Directions to the venue.\n            - cover_charge (float): Amount of cover charge.\n            - performance_schedule (list[str]): List of performance schedules.\"\"\"\n    pass\n", "function_schema_json": [{"name": "search_music_venues", "description": "Searches for music venues based on the given query and location.", "parameters": {"type": "object", "properties": {"query": {"type": "string", "description": "The type of venue or genre to search for (e.g., \"jazz clubs\")."}, "location": {"type": "string", "description": "The location where to search for venues (e.g., \"Downtown Austin\")."}}, "required": ["query", "location"], "additionalProperties": false}}, {"name": "filter_venues_by_genre", "description": "Filters a list of venues based on the genre.", "parameters": {"type": "object", "properties": {"venues": {"type": "array", "description": "A list of venue names."}, "genre": {"type": "string", "description": "The specific genre to filter by (e.g., \"cool jazz\")."}}, "required": ["venues", "genre"], "additionalProperties": false}}, {"name": "get_venue_details", "description": "Retrieves details about a specific venue.", "parameters": {"type": "object", "properties": {"venue": {"type": "string", "description": "The name of the venue."}}, "required": ["venue"], "additionalProperties": false}}], "mock_functions": "def search_music_venues(query: str, location: str) -> list:\n    \"\"\"\n    Searches for music venues based on the given query and location.\n    \n    :param query: The type of venue or genre to search for (e.g., \"jazz clubs\").\n    :param location: The location where to search for venues (e.g., \"Downtown Austin\").\n    :return: A list of venue names that match the query and location.\n    \"\"\"\n    # Mock logic: If the query is \"jazz clubs\" and location is \"Downtown Austin\", return known venues.\n    if query.lower() == \"jazz clubs\" and location.lower() == \"downtown austin\":\n        return [\"Elephant Room\", \"Parker Jazz Club\", \"Volstead Lounge\", \"Whistler's\"]\n    return []\ndef filter_venues_by_genre(venues: list, genre: str) -> list:\n    \"\"\"\n    Filters a list of venues based on the genre.\n    \n    :param venues: A list of venue names.\n    :param genre: The specific genre to filter by (e.g., \"cool jazz\").\n    :return: A list of venues that match the given genre.\n    \"\"\"\n    # Mock logic: If the genre is \"cool jazz\", return known venues that fit this genre.\n    if genre.lower() == \"cool jazz\" and venues == [\"Elephant Room\", \"Parker Jazz Club\", \"Volstead Lounge\", \"Whistler's\"]:\n        return [\"Elephant Room\", \"Parker Jazz Club\"]\n    return []\ndef get_venue_details(venue: str) -> dict:\n    \"\"\"\n    Retrieves details about a specific venue.\n    \n    :param venue: The name of the venue.\n    :return:\n        dict: A dictionary with the following keys:\n            - directions (str): Directions to the venue.\n            - cover_charge (float): Amount of cover charge.\n            - performance_schedule (list[str]): List of performance schedules.\n    \"\"\"\n    # Mock logic: Return details for known venues.\n    if venue == \"Elephant Room\":\n        return {\n            \"directions\": \"Head west on 6th Street, turn right on Congress Avenue.\",\n            \"cover_charge\": 20.0,\n            \"performance_schedule\": [\"7 PM\", \"9 PM\", \"11 PM\"]\n        }\n    elif venue == \"Parker Jazz Club\":\n        return {\n            \"directions\": \"Head east on 6th Street, take the second left onto 1st Street.\",\n            \"cover_charge\": 15.0,\n            \"performance_schedule\": [\"8 PM\", \"10 PM\"]\n        }\n    return {}", "user_query": "What jazz clubs are in Downtown Austin?", "checklist": {"functions": ["search_music_venues"], "values": [["Elephant Room", "Parker Jazz Club", "Volstead Lounge", "Whistler's"]]}}
{"difficulty": "easy", "function_schema_python": "def search_recipe_by_image(image_url: str) -> dict:\n    \"\"\"Searches for recipes based on an uploaded image using image recognition.\n\n    :param image_url: URL or path to the uploaded image\n    :return: Dictionary containing recipe matches and their details\n    :raises ValueError: If image_url is invalid or empty\"\"\"\n    pass\ndef get_recipe_details(recipe_id: str) -> dict:\n    \"\"\"Retrieves detailed information about a specific recipe.\n\n    :param recipe_id: Unique identifier for the recipe\n    :return: Dictionary containing complete recipe details\n    :raises ValueError: If recipe_id is invalid\"\"\"\n    pass\ndef place_grocery_order(ingredients: list, delivery_time: str) -> dict:\n    \"\"\"Places an order for groceries with specified delivery time.\n\n    :param ingredients: List of ingredients to order\n    :param delivery_time: Requested delivery time\n    :return: Dictionary containing order confirmation details\n    :raises ValueError: If ingredients list is empty or delivery time is invalid\"\"\"\n    pass\n", "function_schema_json": [{"name": "search_recipe_by_image", "description": "Searches for recipes based on an uploaded image using image recognition.", "parameters": {"type": "object", "properties": {"image_url": {"type": "string", "description": "URL or path to the uploaded image"}}, "required": ["image_url"], "additionalProperties": false}}, {"name": "get_recipe_details", "description": "Retrieves detailed information about a specific recipe.", "parameters": {"type": "object", "properties": {"recipe_id": {"type": "string", "description": "Unique identifier for the recipe"}}, "required": ["recipe_id"], "additionalProperties": false}}, {"name": "place_grocery_order", "description": "Places an order for groceries with specified delivery time.", "parameters": {"type": "object", "properties": {"ingredients": {"type": "array", "description": "List of ingredients to order"}, "delivery_time": {"type": "string", "description": "Requested delivery time"}}, "required": ["ingredients", "delivery_time"], "additionalProperties": false}}], "mock_functions": "def search_recipe_by_image(image_url: str) -> dict:\n    \"\"\"\n    Searches for recipes based on an uploaded image using image recognition.\n    \n    :param image_url: URL or path to the uploaded image\n    :return: Dictionary containing recipe matches and their details\n    :raises ValueError: If image_url is invalid or empty\n    \"\"\"\n    if not image_url:\n        raise ValueError(\"Image URL cannot be empty\")\n    \n    if \"pasta_primavera\" in image_url.lower():\n        return {\n            \"matched_recipes\": [\n                {\n                    \"id\": \"recipe_123\",\n                    \"name\": \"Pasta Primavera\",\n                    \"ingredients\": [\"pasta\", \"vegetables\", \"olive oil\", \"garlic\"],\n                    \"instructions\": [\"Boil pasta\", \"Saut\u00e9 vegetables\", \"Combine ingredients\"],\n                    \"difficulty\": \"medium\",\n                    \"cooking_time\": \"45 minutes\"\n                }\n            ]\n        }\n    return {\"matched_recipes\": []}\ndef get_recipe_details(recipe_id: str) -> dict:\n    \"\"\"\n    Retrieves detailed information about a specific recipe.\n    \n    :param recipe_id: Unique identifier for the recipe\n    :return: Dictionary containing complete recipe details\n    :raises ValueError: If recipe_id is invalid\n    \"\"\"\n    if not recipe_id or recipe_id != \"recipe_123\":\n        raise ValueError(\"Invalid recipe ID\")\n    \n    return {\n        \"id\": \"recipe_123\",\n        \"name\": \"Pasta Primavera\",\n        \"ingredients\": [\n            {\"item\": \"pasta\", \"quantity\": \"1 pound\"},\n            {\"item\": \"mixed vegetables\", \"quantity\": \"2 cups\"},\n            {\"item\": \"olive oil\", \"quantity\": \"1/4 cup\"},\n            {\"item\": \"garlic\", \"quantity\": \"3 cloves\"}\n        ],\n        \"instructions\": [\n            \"Boil pasta according to package instructions\",\n            \"Saut\u00e9 vegetables in olive oil\",\n            \"Combine all ingredients and serve\"\n        ],\n        \"prep_time\": \"15 minutes\",\n        \"cook_time\": \"30 minutes\",\n        \"servings\": 4\n    }\ndef place_grocery_order(ingredients: list, delivery_time: str) -> dict:\n    \"\"\"\n    Places an order for groceries with specified delivery time.\n    \n    :param ingredients: List of ingredients to order\n    :param delivery_time: Requested delivery time\n    :return: Dictionary containing order confirmation details\n    :raises ValueError: If ingredients list is empty or delivery time is invalid\n    \"\"\"\n    if not ingredients or not delivery_time:\n        raise ValueError(\"Ingredients and delivery time must be provided\")\n    \n    if len(ingredients) > 0 and \"evening\" in delivery_time.lower():\n        return {\n            \"order_number\": \"789456\",\n            \"status\": \"confirmed\",\n            \"delivery_time\": \"6:00 PM - 8:00 PM\",\n            \"items\": ingredients,\n            \"total\": 45.99\n        }\n    raise ValueError(\"Invalid order parameters\")", "user_query": "Can you find recipes similar to this image: [image_url_of_pasta_primavera]?", "checklist": {"functions": ["search_recipe_by_image"], "values": [{"matched_recipes": [{"id": "recipe_123", "name": "Pasta Primavera", "ingredients": ["pasta", "vegetables", "olive oil", "garlic"], "instructions": ["Boil pasta", "Saut\u00e9 vegetables", "Combine ingredients"], "difficulty": "medium", "cooking_time": "45 minutes"}]}]}}
{"difficulty": "easy", "function_schema_python": "def search_image_for_food(image_data: bytes, cuisine_type: str) -> dict:\n    \"\"\"Analyzes an image to identify food items.\n\n    :param image_data: Binary image data to analyze\n    :param cuisine_type: Optional cuisine type to narrow search\n    :return: Dictionary containing matched food items and their details\n    :raises ValueError: If image_data is empty or invalid\"\"\"\n    pass\ndef find_nearby_restaurants(cuisine_type: str, dish_name: str, radius_km: float) -> dict:\n    \"\"\"Searches for nearby restaurants serving specific dishes.\n\n    :param cuisine_type: Type of cuisine (e.g., \"Japanese\")\n    :param dish_name: Name of the dish to search for\n    :param radius_km: Search radius in kilometers\n    :return: Dictionary containing restaurant information\n    :raises ValueError: If parameters are invalid\"\"\"\n    pass\ndef place_food_order(restaurant_id: str, items: list, order_id: str) -> dict:\n    \"\"\"Places a food delivery order.\n\n    :param restaurant_id: ID of the restaurant\n    :param items: List of items to order\n    :param order_id: Unique order identifier\n    :return: Dictionary containing order confirmation and tracking info\n    :raises ValueError: If order parameters are invalid\"\"\"\n    pass\n", "function_schema_json": [{"name": "search_image_for_food", "description": "Analyzes an image to identify food items.", "parameters": {"type": "object", "properties": {"image_data": {"type": "string", "description": "Binary image data to analyze"}, "cuisine_type": {"type": "string", "description": "Optional cuisine type to narrow search"}}, "required": ["image_data", "cuisine_type"], "additionalProperties": false}}, {"name": "find_nearby_restaurants", "description": "Searches for nearby restaurants serving specific dishes.", "parameters": {"type": "object", "properties": {"cuisine_type": {"type": "string", "description": "Type of cuisine (e.g., \"Japanese\")"}, "dish_name": {"type": "string", "description": "Name of the dish to search for"}, "radius_km": {"type": "number", "description": "Search radius in kilometers"}}, "required": ["cuisine_type", "dish_name", "radius_km"], "additionalProperties": false}}, {"name": "place_food_order", "description": "Places a food delivery order.", "parameters": {"type": "object", "properties": {"restaurant_id": {"type": "string", "description": "ID of the restaurant"}, "items": {"type": "array", "description": "List of items to order"}, "order_id": {"type": "string", "description": "Unique order identifier"}}, "required": ["restaurant_id", "items", "order_id"], "additionalProperties": false}}], "mock_functions": "def search_image_for_food(image_data: bytes, cuisine_type: str = None) -> dict:\n    \"\"\"\n    Analyzes an image to identify food items.\n    \n    :param image_data: Binary image data to analyze\n    :param cuisine_type: Optional cuisine type to narrow search\n    :return: Dictionary containing matched food items and their details\n    :raises ValueError: If image_data is empty or invalid\n    \"\"\"\n    if not image_data:\n        raise ValueError(\"Image data cannot be empty\")\n    \n    if b'sushi_menu' in image_data:\n        return {\n            \"matches\": [\n                {\n                    \"name\": \"Unagi Avocado Roll\",\n                    \"confidence\": 0.92,\n                    \"ingredients\": [\"eel\", \"avocado\", \"rice\", \"nori\"],\n                    \"image_url\": \"https://example.com/unagi_roll.jpg\"\n                },\n                {\n                    \"name\": \"Dragon Roll\",\n                    \"confidence\": 0.85,\n                    \"ingredients\": [\"eel\", \"cucumber\", \"avocado\", \"rice\", \"nori\"],\n                    \"image_url\": \"https://example.com/dragon_roll.jpg\"\n                }\n            ]\n        }\n    return {\"matches\": []}\ndef find_nearby_restaurants(cuisine_type: str, dish_name: str, radius_km: float) -> dict:\n    \"\"\"\n    Searches for nearby restaurants serving specific dishes.\n    \n    :param cuisine_type: Type of cuisine (e.g., \"Japanese\")\n    :param dish_name: Name of the dish to search for\n    :param radius_km: Search radius in kilometers\n    :return: Dictionary containing restaurant information\n    :raises ValueError: If parameters are invalid\n    \"\"\"\n    if not cuisine_type or not dish_name or radius_km <= 0:\n        raise ValueError(\"Invalid search parameters\")\n    \n    if cuisine_type.lower() == \"japanese\" and \"unagi\" in dish_name.lower():\n        return {\n            \"restaurants\": [\n                {\n                    \"name\": \"Sushi Express\",\n                    \"rating\": 4.5,\n                    \"delivery_time\": \"30-45 min\",\n                    \"menu_items\": {\"Unagi Avocado Roll\": 12.99},\n                    \"id\": \"sushi_express_1\"\n                }\n            ]\n        }\n    return {\"restaurants\": []}\ndef place_food_order(restaurant_id: str, items: list, order_id: str) -> dict:\n    \"\"\"\n    Places a food delivery order.\n    \n    :param restaurant_id: ID of the restaurant\n    :param items: List of items to order\n    :param order_id: Unique order identifier\n    :return: Dictionary containing order confirmation and tracking info\n    :raises ValueError: If order parameters are invalid\n    \"\"\"\n    if not restaurant_id or not items or not order_id:\n        raise ValueError(\"Invalid order parameters\")\n    \n    if restaurant_id == \"sushi_express_1\" and order_id == \"#12345\":\n        return {\n            \"order_status\": \"confirmed\",\n            \"estimated_delivery\": \"35 minutes\",\n            \"tracking_url\": \"https://tracking.example.com/12345\",\n            \"total_amount\": 25.98\n        }\n    raise ValueError(\"Invalid order details\")", "user_query": "Can you analyze this sushi menu photo (image_data: b'sushi_menu_photo') and identify what type of sushi it shows?", "checklist": {"functions": ["search_image_for_food"], "values": [{"matches": [{"name": "Unagi Avocado Roll", "confidence": 0.92, "ingredients": ["eel", "avocado", "rice", "nori"], "image_url": "https://example.com/unagi_roll.jpg"}, {"name": "Dragon Roll", "confidence": 0.85, "ingredients": ["eel", "cucumber", "avocado", "rice", "nori"], "image_url": "https://example.com/dragon_roll.jpg"}]}]}}
{"difficulty": "easy", "function_schema_python": "def search_image_for_food(image_data: bytes, cuisine_type: str) -> dict:\n    \"\"\"Analyzes an image to identify food items.\n\n    :param image_data: Binary image data to analyze\n    :param cuisine_type: Optional cuisine type to narrow search\n    :return: Dictionary containing matched food items and their details\n    :raises ValueError: If image_data is empty or invalid\"\"\"\n    pass\ndef find_nearby_restaurants(cuisine_type: str, dish_name: str, radius_km: float) -> dict:\n    \"\"\"Searches for nearby restaurants serving specific dishes.\n\n    :param cuisine_type: Type of cuisine (e.g., \"Japanese\")\n    :param dish_name: Name of the dish to search for\n    :param radius_km: Search radius in kilometers\n    :return: Dictionary containing restaurant information\n    :raises ValueError: If parameters are invalid\"\"\"\n    pass\ndef place_food_order(restaurant_id: str, items: list, order_id: str) -> dict:\n    \"\"\"Places a food delivery order.\n\n    :param restaurant_id: ID of the restaurant\n    :param items: List of items to order\n    :param order_id: Unique order identifier\n    :return: Dictionary containing order confirmation and tracking info\n    :raises ValueError: If order parameters are invalid\"\"\"\n    pass\n", "function_schema_json": [{"name": "search_image_for_food", "description": "Analyzes an image to identify food items.", "parameters": {"type": "object", "properties": {"image_data": {"type": "string", "description": "Binary image data to analyze"}, "cuisine_type": {"type": "string", "description": "Optional cuisine type to narrow search"}}, "required": ["image_data", "cuisine_type"], "additionalProperties": false}}, {"name": "find_nearby_restaurants", "description": "Searches for nearby restaurants serving specific dishes.", "parameters": {"type": "object", "properties": {"cuisine_type": {"type": "string", "description": "Type of cuisine (e.g., \"Japanese\")"}, "dish_name": {"type": "string", "description": "Name of the dish to search for"}, "radius_km": {"type": "number", "description": "Search radius in kilometers"}}, "required": ["cuisine_type", "dish_name", "radius_km"], "additionalProperties": false}}, {"name": "place_food_order", "description": "Places a food delivery order.", "parameters": {"type": "object", "properties": {"restaurant_id": {"type": "string", "description": "ID of the restaurant"}, "items": {"type": "array", "description": "List of items to order"}, "order_id": {"type": "string", "description": "Unique order identifier"}}, "required": ["restaurant_id", "items", "order_id"], "additionalProperties": false}}], "mock_functions": "def search_image_for_food(image_data: bytes, cuisine_type: str = None) -> dict:\n    \"\"\"\n    Analyzes an image to identify food items.\n    \n    :param image_data: Binary image data to analyze\n    :param cuisine_type: Optional cuisine type to narrow search\n    :return: Dictionary containing matched food items and their details\n    :raises ValueError: If image_data is empty or invalid\n    \"\"\"\n    if not image_data:\n        raise ValueError(\"Image data cannot be empty\")\n    \n    if b'sushi_menu' in image_data:\n        return {\n            \"matches\": [\n                {\n                    \"name\": \"Unagi Avocado Roll\",\n                    \"confidence\": 0.92,\n                    \"ingredients\": [\"eel\", \"avocado\", \"rice\", \"nori\"],\n                    \"image_url\": \"https://example.com/unagi_roll.jpg\"\n                },\n                {\n                    \"name\": \"Dragon Roll\",\n                    \"confidence\": 0.85,\n                    \"ingredients\": [\"eel\", \"cucumber\", \"avocado\", \"rice\", \"nori\"],\n                    \"image_url\": \"https://example.com/dragon_roll.jpg\"\n                }\n            ]\n        }\n    return {\"matches\": []}\ndef find_nearby_restaurants(cuisine_type: str, dish_name: str, radius_km: float) -> dict:\n    \"\"\"\n    Searches for nearby restaurants serving specific dishes.\n    \n    :param cuisine_type: Type of cuisine (e.g., \"Japanese\")\n    :param dish_name: Name of the dish to search for\n    :param radius_km: Search radius in kilometers\n    :return: Dictionary containing restaurant information\n    :raises ValueError: If parameters are invalid\n    \"\"\"\n    if not cuisine_type or not dish_name or radius_km <= 0:\n        raise ValueError(\"Invalid search parameters\")\n    \n    if cuisine_type.lower() == \"japanese\" and \"unagi\" in dish_name.lower():\n        return {\n            \"restaurants\": [\n                {\n                    \"name\": \"Sushi Express\",\n                    \"rating\": 4.5,\n                    \"delivery_time\": \"30-45 min\",\n                    \"menu_items\": {\"Unagi Avocado Roll\": 12.99},\n                    \"id\": \"sushi_express_1\"\n                }\n            ]\n        }\n    return {\"restaurants\": []}\ndef place_food_order(restaurant_id: str, items: list, order_id: str) -> dict:\n    \"\"\"\n    Places a food delivery order.\n    \n    :param restaurant_id: ID of the restaurant\n    :param items: List of items to order\n    :param order_id: Unique order identifier\n    :return: Dictionary containing order confirmation and tracking info\n    :raises ValueError: If order parameters are invalid\n    \"\"\"\n    if not restaurant_id or not items or not order_id:\n        raise ValueError(\"Invalid order parameters\")\n    \n    if restaurant_id == \"sushi_express_1\" and order_id == \"#12345\":\n        return {\n            \"order_status\": \"confirmed\",\n            \"estimated_delivery\": \"35 minutes\",\n            \"tracking_url\": \"https://tracking.example.com/12345\",\n            \"total_amount\": 25.98\n        }\n    raise ValueError(\"Invalid order details\")", "user_query": "Please find Japanese restaurants near me that serve Unagi Avocado Roll within 5 kilometers.", "checklist": {"functions": ["find_nearby_restaurants"], "values": [{"restaurants": [{"name": "Sushi Express", "rating": 4.5, "delivery_time": "30-45 min", "menu_items": {"Unagi Avocado Roll": 12.99}, "id": "sushi_express_1"}]}]}}
{"difficulty": "easy", "function_schema_python": "def serper_search(query: str) -> dict:\n    \"\"\"Perform a search query using the Serper API.\n\n    :param query: The search query.\n    :return: A dictionary with the following keys:\n            - results (list[dict]): The list of search results.\n    :raises ValueError: If the query is empty.\"\"\"\n    pass\ndef duckduckgo_search(query: str) -> dict:\n    \"\"\"Perform a search query using the DuckDuckGo API.\n\n    :param query: The search query.\n    :return: A dictionary with the following keys:\n            - results (list[dict]): The list of search results.\n    :raises ValueError: If the query is empty.\"\"\"\n    pass\ndef scrape_website(url: str) -> str:\n    \"\"\"Scrape content from a given website URL using Scrapy.\n\n    :param url: The URL of the website to scrape.\n    :return: The scraped HTML content as a string.\n    :raises ValueError: If the URL is invalid.\"\"\"\n    pass\ndef extract_text_with_beautifulsoup(html_content: str) -> str:\n    \"\"\"Extract text from HTML content using BeautifulSoup.\n\n    :param html_content: The HTML content to parse.\n    :return: The extracted text as a string.\n    :raises ValueError: If the HTML content is empty.\"\"\"\n    pass\ndef process_text_with_spacy(text: str) -> list:\n    \"\"\"Process text using spacy for named entity recognition.\n\n    :param text: The text to process.\n    :return: A list of named entities.\n    :raises ValueError: If the text is empty.\"\"\"\n    pass\ndef analyze_data_with_pandas(data: dict) -> dict:\n    \"\"\"Analyze data using pandas.\n\n    :param data: The data to analyze, provided as a dictionary.\n    :return: A dictionary with the analysis results.\n    :raises ValueError: If the data dictionary is empty.\"\"\"\n    pass\n", "function_schema_json": [{"name": "serper_search", "description": "Perform a search query using the Serper API.", "parameters": {"type": "object", "properties": {"query": {"type": "string", "description": "The search query."}}, "required": ["query"], "additionalProperties": false}}, {"name": "duckduckgo_search", "description": "Perform a search query using the DuckDuckGo API.", "parameters": {"type": "object", "properties": {"query": {"type": "string", "description": "The search query."}}, "required": ["query"], "additionalProperties": false}}, {"name": "scrape_website", "description": "Scrape content from a given website URL using Scrapy.", "parameters": {"type": "object", "properties": {"url": {"type": "string", "description": "The URL of the website to scrape."}}, "required": ["url"], "additionalProperties": false}}, {"name": "extract_text_with_beautifulsoup", "description": "Extract text from HTML content using BeautifulSoup.", "parameters": {"type": "object", "properties": {"html_content": {"type": "string", "description": "The HTML content to parse."}}, "required": ["html_content"], "additionalProperties": false}}, {"name": "process_text_with_spacy", "description": "Process text using spacy for named entity recognition.", "parameters": {"type": "object", "properties": {"text": {"type": "string", "description": "The text to process."}}, "required": ["text"], "additionalProperties": false}}, {"name": "analyze_data_with_pandas", "description": "Analyze data using pandas.", "parameters": {"type": "object", "properties": {"data": {"type": "object", "description": "The data to analyze, provided as a dictionary."}}, "required": ["data"], "additionalProperties": false}}], "mock_functions": "def serper_search(query: str) -> dict:\n    \"\"\"\n    Perform a search query using the Serper API.\n    \n    :param query: The search query.\n    :return: A dictionary with the following keys:\n            - results (list[dict]): The list of search results.\n    :raises ValueError: If the query is empty.\n    \"\"\"\n    if not query:\n        raise ValueError(\"Query must not be empty.\")\n    # Mock logic: Return a pseudo search result.\n    if query.lower() == \"python programming\":\n        return {\n            \"results\": [\n                {\"title\": \"Python Programming Basics\", \"link\": \"https://example.com/python-basics\"},\n                {\"title\": \"Advanced Python Programming\", \"link\": \"https://example.com/advanced-python\"},\n            ]\n        }\n    return {}\ndef duckduckgo_search(query: str) -> dict:\n    \"\"\"\n    Perform a search query using the DuckDuckGo API.\n    \n    :param query: The search query.\n    :return: A dictionary with the following keys:\n            - results (list[dict]): The list of search results.\n    :raises ValueError: If the query is empty.\n    \"\"\"\n    if not query:\n        raise ValueError(\"Query must not be empty.\")\n    # Mock logic: Return a pseudo search result.\n    if query.lower() == \"machine learning\":\n        return {\n            \"results\": [\n                {\"title\": \"Introduction to Machine Learning\", \"link\": \"https://example.com/ml-intro\"},\n                {\"title\": \"Machine Learning Algorithms\", \"link\": \"https://example.com/ml-algos\"},\n            ]\n        }\n    return {}\ndef scrape_website(url: str) -> str:\n    \"\"\"\n    Scrape content from a given website URL using Scrapy.\n    \n    :param url: The URL of the website to scrape.\n    :return: The scraped HTML content as a string.\n    :raises ValueError: If the URL is invalid.\n    \"\"\"\n    if not url:\n        raise ValueError(\"URL must not be empty.\")\n    # Mock logic: Return a pseudo HTML content.\n    if url == \"https://example.com/python-basics\":\n        return \"<html><head><title>Test</title></head><body><p>Hello, world!</p></body></html>\"\n    return \"\"\ndef extract_text_with_beautifulsoup(html_content: str) -> str:\n    \"\"\"\n    Extract text from HTML content using BeautifulSoup.\n    \n    :param html_content: The HTML content to parse.\n    :return: The extracted text as a string.\n    :raises ValueError: If the HTML content is empty.\n    \"\"\"\n    if not html_content:\n        raise ValueError(\"HTML content must not be empty.\")\n    # Mock logic: Return the text inside the body.\n    if \"<body><p>Hello, world!</p></body>\" in html_content:\n        return \"Hello, world!\"\n    return \"\"\ndef process_text_with_spacy(text: str) -> list:\n    \"\"\"\n    Process text using spacy for named entity recognition.\n    \n    :param text: The text to process.\n    :return: A list of named entities.\n    :raises ValueError: If the text is empty.\n    \"\"\"\n    if not text:\n        raise ValueError(\"Text must not be empty.\")\n    # Mock logic: Return a list of named entities.\n    if \"Hello, world!\" in text:\n        return [\"world\"]\n    return []\ndef analyze_data_with_pandas(data: dict) -> dict:\n    \"\"\"\n    Analyze data using pandas.\n    \n    :param data: The data to analyze, provided as a dictionary.\n    :return: A dictionary with the analysis results.\n    :raises ValueError: If the data dictionary is empty.\n    \"\"\"\n    if not data:\n        raise ValueError(\"Data must not be empty.\")\n    # Mock logic: Return a pseudo analysis result.\n    if data == {\"name\": \"John\", \"age\": 30, \"city\": \"New York\"}:\n        return {\n            \"summary\": {\n                \"average_age\": 30,\n                \"most_common_city\": \"New York\"\n            }\n        }\n    return {}", "user_query": "Search for \"python programming\" using Serper.", "checklist": {"functions": ["serper_search"], "values": [{"results": [{"title": "Python Programming Basics", "link": "https://example.com/python-basics"}, {"title": "Advanced Python Programming", "link": "https://example.com/advanced-python"}]}]}}
{"difficulty": "easy", "function_schema_python": "def fetch_articles(source_preference: str, credibility_rating: int) -> list:\n    \"\"\"Fetches articles based on the given source preference and credibility rating.\n\n    :param source_preference: The preferred source category (e.g., \"academic\", \"news_outlet\").\n    :param credibility_rating: The minimum credibility rating for the articles (1-10).\n    :return: A list of dictionaries, each containing article details.\n             Keys in each dictionary:\n                 - title (str): The title of the article.\n                 - source (str): The source of the article.\n                 - credibility (int): The credibility rating of the article.\n                 - summary (str): A brief summary of the article.\n    :raises ValueError: If credibility rating is not between 1 and 10.\"\"\"\n    pass\ndef filter_articles_by_tags(articles: list, tags: list) -> list:\n    \"\"\"Filters articles based on the given thematic tags.\n\n    :param articles: A list of dictionaries containing article details.\n    :param tags: A list of thematic tags to filter by (e.g., [\"media_innovation\", \"digital_communication\"]).\n    :return: A list of dictionaries containing articles that match the thematic tags.\n    :raises ValueError: If articles or tags are not provided.\"\"\"\n    pass\ndef generate_news_briefing(filtered_articles: list) -> str:\n    \"\"\"Generates a news briefing from the filtered articles.\n\n    :param filtered_articles: A list of dictionaries containing articles to include in the briefing.\n    :return: A string containing the formatted news briefing.\n    :raises ValueError: If no articles are provided.\"\"\"\n    pass\n", "function_schema_json": [{"name": "fetch_articles", "description": "Fetches articles based on the given source preference and credibility rating.", "parameters": {"type": "object", "properties": {"source_preference": {"type": "string", "description": "The preferred source category (e.g., \"academic\", \"news_outlet\")."}, "credibility_rating": {"type": "integer", "description": "The minimum credibility rating for the articles (1-10)."}}, "required": ["source_preference", "credibility_rating"], "additionalProperties": false}}, {"name": "filter_articles_by_tags", "description": "Filters articles based on the given thematic tags.", "parameters": {"type": "object", "properties": {"articles": {"type": "array", "description": "A list of dictionaries containing article details."}, "tags": {"type": "array", "description": "A list of thematic tags to filter by (e.g., [\"media_innovation\", \"digital_communication\"])."}}, "required": ["articles", "tags"], "additionalProperties": false}}, {"name": "generate_news_briefing", "description": "Generates a news briefing from the filtered articles.", "parameters": {"type": "object", "properties": {"filtered_articles": {"type": "array", "description": "A list of dictionaries containing articles to include in the briefing."}}, "required": ["filtered_articles"], "additionalProperties": false}}], "mock_functions": "def fetch_articles(source_preference: str, credibility_rating: int) -> list:\n    \"\"\"\n    Fetches articles based on the given source preference and credibility rating.\n    \n    :param source_preference: The preferred source category (e.g., \"academic\", \"news_outlet\").\n    :param credibility_rating: The minimum credibility rating for the articles (1-10).\n    :return: A list of dictionaries, each containing article details.\n             Keys in each dictionary:\n                 - title (str): The title of the article.\n                 - source (str): The source of the article.\n                 - credibility (int): The credibility rating of the article.\n                 - summary (str): A brief summary of the article.\n    :raises ValueError: If credibility rating is not between 1 and 10.\n    \"\"\"\n    if not (1 <= credibility_rating <= 10):\n        raise ValueError(\"Credibility rating must be between 1 and 10.\")\n    \n    # Mock logic: Return a list of articles based on the criteria\n    mock_articles = [\n        {\n            \"title\": \"The Future of Digital Journalism\",\n            \"source\": \"Academic Journal of Media Studies\",\n            \"credibility\": 9,\n            \"summary\": \"An overview of emerging trends in digital journalism.\"\n        },\n        {\n            \"title\": \"The Impact of Social Media on Journalism\",\n            \"source\": \"CNN Opinion\",\n            \"credibility\": 7,\n            \"summary\": \"An analysis of how social media shapes news consumption.\"\n        }\n    ]\n    \n    return [article for article in mock_articles if article['credibility'] >= credibility_rating and source_preference in article['source'].lower()]\ndef filter_articles_by_tags(articles: list, tags: list) -> list:\n    \"\"\"\n    Filters articles based on the given thematic tags.\n    \n    :param articles: A list of dictionaries containing article details.\n    :param tags: A list of thematic tags to filter by (e.g., [\"media_innovation\", \"digital_communication\"]).\n    :return: A list of dictionaries containing articles that match the thematic tags.\n    :raises ValueError: If articles or tags are not provided.\n    \"\"\"\n    if not articles or not tags:\n        raise ValueError(\"Articles and tags must be provided.\")\n    \n    # Mock logic: Return a list of articles containing the specified tags in their summary\n    tagged_articles = [\n        {\n            \"title\": \"The Future of Digital Journalism\",\n            \"source\": \"Academic Journal of Media Studies\",\n            \"credibility\": 9,\n            \"summary\": \"An overview of emerging trends in digital journalism and media innovation.\"\n        },\n        {\n            \"title\": \"Advancements in Digital Communication Technologies\",\n            \"source\": \"TechDaily\",\n            \"credibility\": 8,\n            \"summary\": \"Latest technologies driving digital communication trends.\"\n        }\n    ]\n    \n    filtered_articles = [\n        article for article in tagged_articles\n        if any(tag in article['summary'].lower() for tag in tags)\n    ]\n    \n    return filtered_articles\ndef generate_news_briefing(filtered_articles: list) -> str:\n    \"\"\"\n    Generates a news briefing from the filtered articles.\n    \n    :param filtered_articles: A list of dictionaries containing articles to include in the briefing.\n    :return: A string containing the formatted news briefing.\n    :raises ValueError: If no articles are provided.\n    \"\"\"\n    if not filtered_articles:\n        raise ValueError(\"Filtered articles must be provided.\")\n    \n    # Mock logic: Generate a simple news briefing\n    briefing = \"News Briefing on recent developments in digital journalism:\\n\\n\"\n    for article in filtered_articles:\n        briefing += f\"- Title: {article['title']}\\n\"\n        briefing += f\"  Source: {article['source']}\\n\"\n        briefing += f\"  Credibility: {article['credibility']}\\n\"\n        briefing += f\"  Summary: {article['summary']}\\n\\n\"\n    \n    return briefing\n", "user_query": "Can you fetch academic articles with a credibility rating of 8 or higher?", "checklist": {"functions": ["fetch_articles"], "values": [[{"title": "The Future of Digital Journalism", "source": "Academic Journal of Media Studies", "credibility": 9, "summary": "An overview of emerging trends in digital journalism."}]]}}
{"difficulty": "easy", "function_schema_python": "def analyze_service_invoices(start_date: str, end_date: str) -> dict:\n    \"\"\"Analyzes service invoices within a specified date range.\n\n    :param start_date: Start date in 'YYYY-MM-DD' format\n    :param end_date: End date in 'YYYY-MM-DD' format\n    :return: Dictionary containing invoice analysis\n    :raises ValueError: If date format is invalid\"\"\"\n    pass\ndef calculate_labor_costs(service_type: str, hours_worked: float) -> dict:\n    \"\"\"Calculates labor costs for a specific service type.\n\n    :param service_type: Type of service (lawn_maintenance, landscaping, tree_service)\n    :param hours_worked: Number of hours worked\n    :return: Dictionary containing labor cost breakdown\n    :raises ValueError: If service type is invalid or hours are negative\"\"\"\n    pass\ndef track_equipment_usage(equipment_id: str, usage_hours: float) -> dict:\n    \"\"\"Tracks equipment usage and associated costs.\n\n    :param equipment_id: Unique identifier for equipment\n    :param usage_hours: Hours of equipment usage\n    :return: Dictionary containing equipment usage analysis\n    :raises ValueError: If equipment_id is invalid or usage_hours is negative\"\"\"\n    pass\n", "function_schema_json": [{"name": "analyze_service_invoices", "description": "Analyzes service invoices within a specified date range.", "parameters": {"type": "object", "properties": {"start_date": {"type": "string", "description": "Start date in 'YYYY-MM-DD' format"}, "end_date": {"type": "string", "description": "End date in 'YYYY-MM-DD' format"}}, "required": ["start_date", "end_date"], "additionalProperties": false}}, {"name": "calculate_labor_costs", "description": "Calculates labor costs for a specific service type.", "parameters": {"type": "object", "properties": {"service_type": {"type": "string", "description": "Type of service (lawn_maintenance, landscaping, tree_service)"}, "hours_worked": {"type": "number", "description": "Number of hours worked"}}, "required": ["service_type", "hours_worked"], "additionalProperties": false}}, {"name": "track_equipment_usage", "description": "Tracks equipment usage and associated costs.", "parameters": {"type": "object", "properties": {"equipment_id": {"type": "string", "description": "Unique identifier for equipment"}, "usage_hours": {"type": "number", "description": "Hours of equipment usage"}}, "required": ["equipment_id", "usage_hours"], "additionalProperties": false}}], "mock_functions": "def analyze_service_invoices(start_date: str, end_date: str) -> dict:\n    \"\"\"\n    Analyzes service invoices within a specified date range.\n    \n    :param start_date: Start date in 'YYYY-MM-DD' format\n    :param end_date: End date in 'YYYY-MM-DD' format\n    :return: Dictionary containing invoice analysis\n    :raises ValueError: If date format is invalid\n    \"\"\"\n    if not (start_date.startswith(\"2023\") and end_date.startswith(\"2023\")):\n        raise ValueError(\"Invalid date format or year\")\n    \n    return {\n        \"total_revenue\": 45000.00,\n        \"service_breakdown\": {\n            \"lawn_maintenance\": 25000.00,\n            \"landscaping\": 15000.00,\n            \"tree_service\": 5000.00\n        },\n        \"billable_hours\": 450,\n        \"average_hourly_rate\": 100.00\n    }\ndef calculate_labor_costs(service_type: str, hours_worked: float) -> dict:\n    \"\"\"\n    Calculates labor costs for a specific service type.\n    \n    :param service_type: Type of service (lawn_maintenance, landscaping, tree_service)\n    :param hours_worked: Number of hours worked\n    :return: Dictionary containing labor cost breakdown\n    :raises ValueError: If service type is invalid or hours are negative\n    \"\"\"\n    if service_type not in [\"lawn_maintenance\", \"landscaping\", \"tree_service\"] or hours_worked < 0:\n        raise ValueError(\"Invalid service type or hours\")\n    \n    return {\n        \"total_labor_cost\": hours_worked * 45.00,\n        \"overhead_cost\": hours_worked * 15.00,\n        \"net_labor_cost\": hours_worked * 30.00,\n        \"billable_amount\": hours_worked * 85.00\n    }\ndef track_equipment_usage(equipment_id: str, usage_hours: float) -> dict:\n    \"\"\"\n    Tracks equipment usage and associated costs.\n    \n    :param equipment_id: Unique identifier for equipment\n    :param usage_hours: Hours of equipment usage\n    :return: Dictionary containing equipment usage analysis\n    :raises ValueError: If equipment_id is invalid or usage_hours is negative\n    \"\"\"\n    if not equipment_id.startswith(\"EQ\") or usage_hours < 0:\n        raise ValueError(\"Invalid equipment ID or usage hours\")\n    \n    return {\n        \"equipment_cost\": usage_hours * 25.00,\n        \"maintenance_cost\": usage_hours * 5.00,\n        \"fuel_cost\": usage_hours * 10.00,\n        \"total_cost\": usage_hours * 40.00\n    }", "user_query": "Can you analyze my service invoices for the last quarter, from 2023-10-01 to 2023-12-31?", "checklist": {"functions": ["analyze_service_invoices"], "values": [{"total_revenue": 45000.0, "service_breakdown": {"lawn_maintenance": 25000.0, "landscaping": 15000.0, "tree_service": 5000.0}, "billable_hours": 450, "average_hourly_rate": 100.0}]}}
{"difficulty": "easy", "function_schema_python": "def analyze_service_invoices(start_date: str, end_date: str) -> dict:\n    \"\"\"Analyzes service invoices within a specified date range.\n\n    :param start_date: Start date in 'YYYY-MM-DD' format\n    :param end_date: End date in 'YYYY-MM-DD' format\n    :return: Dictionary containing invoice analysis\n    :raises ValueError: If date format is invalid\"\"\"\n    pass\ndef calculate_labor_costs(service_type: str, hours_worked: float) -> dict:\n    \"\"\"Calculates labor costs for a specific service type.\n\n    :param service_type: Type of service (lawn_maintenance, landscaping, tree_service)\n    :param hours_worked: Number of hours worked\n    :return: Dictionary containing labor cost breakdown\n    :raises ValueError: If service type is invalid or hours are negative\"\"\"\n    pass\ndef track_equipment_usage(equipment_id: str, usage_hours: float) -> dict:\n    \"\"\"Tracks equipment usage and associated costs.\n\n    :param equipment_id: Unique identifier for equipment\n    :param usage_hours: Hours of equipment usage\n    :return: Dictionary containing equipment usage analysis\n    :raises ValueError: If equipment_id is invalid or usage_hours is negative\"\"\"\n    pass\n", "function_schema_json": [{"name": "analyze_service_invoices", "description": "Analyzes service invoices within a specified date range.", "parameters": {"type": "object", "properties": {"start_date": {"type": "string", "description": "Start date in 'YYYY-MM-DD' format"}, "end_date": {"type": "string", "description": "End date in 'YYYY-MM-DD' format"}}, "required": ["start_date", "end_date"], "additionalProperties": false}}, {"name": "calculate_labor_costs", "description": "Calculates labor costs for a specific service type.", "parameters": {"type": "object", "properties": {"service_type": {"type": "string", "description": "Type of service (lawn_maintenance, landscaping, tree_service)"}, "hours_worked": {"type": "number", "description": "Number of hours worked"}}, "required": ["service_type", "hours_worked"], "additionalProperties": false}}, {"name": "track_equipment_usage", "description": "Tracks equipment usage and associated costs.", "parameters": {"type": "object", "properties": {"equipment_id": {"type": "string", "description": "Unique identifier for equipment"}, "usage_hours": {"type": "number", "description": "Hours of equipment usage"}}, "required": ["equipment_id", "usage_hours"], "additionalProperties": false}}], "mock_functions": "def analyze_service_invoices(start_date: str, end_date: str) -> dict:\n    \"\"\"\n    Analyzes service invoices within a specified date range.\n    \n    :param start_date: Start date in 'YYYY-MM-DD' format\n    :param end_date: End date in 'YYYY-MM-DD' format\n    :return: Dictionary containing invoice analysis\n    :raises ValueError: If date format is invalid\n    \"\"\"\n    if not (start_date.startswith(\"2023\") and end_date.startswith(\"2023\")):\n        raise ValueError(\"Invalid date format or year\")\n    \n    return {\n        \"total_revenue\": 45000.00,\n        \"service_breakdown\": {\n            \"lawn_maintenance\": 25000.00,\n            \"landscaping\": 15000.00,\n            \"tree_service\": 5000.00\n        },\n        \"billable_hours\": 450,\n        \"average_hourly_rate\": 100.00\n    }\ndef calculate_labor_costs(service_type: str, hours_worked: float) -> dict:\n    \"\"\"\n    Calculates labor costs for a specific service type.\n    \n    :param service_type: Type of service (lawn_maintenance, landscaping, tree_service)\n    :param hours_worked: Number of hours worked\n    :return: Dictionary containing labor cost breakdown\n    :raises ValueError: If service type is invalid or hours are negative\n    \"\"\"\n    if service_type not in [\"lawn_maintenance\", \"landscaping\", \"tree_service\"] or hours_worked < 0:\n        raise ValueError(\"Invalid service type or hours\")\n    \n    return {\n        \"total_labor_cost\": hours_worked * 45.00,\n        \"overhead_cost\": hours_worked * 15.00,\n        \"net_labor_cost\": hours_worked * 30.00,\n        \"billable_amount\": hours_worked * 85.00\n    }\ndef track_equipment_usage(equipment_id: str, usage_hours: float) -> dict:\n    \"\"\"\n    Tracks equipment usage and associated costs.\n    \n    :param equipment_id: Unique identifier for equipment\n    :param usage_hours: Hours of equipment usage\n    :return: Dictionary containing equipment usage analysis\n    :raises ValueError: If equipment_id is invalid or usage_hours is negative\n    \"\"\"\n    if not equipment_id.startswith(\"EQ\") or usage_hours < 0:\n        raise ValueError(\"Invalid equipment ID or usage hours\")\n    \n    return {\n        \"equipment_cost\": usage_hours * 25.00,\n        \"maintenance_cost\": usage_hours * 5.00,\n        \"fuel_cost\": usage_hours * 10.00,\n        \"total_cost\": usage_hours * 40.00\n    }", "user_query": "Could you calculate labor costs for my lawn maintenance service if my team worked 120 hours?", "checklist": {"functions": ["calculate_labor_costs"], "values": [{"total_labor_cost": 5400.0, "overhead_cost": 1800.0, "net_labor_cost": 3600.0, "billable_amount": 10200.0}]}}
{"difficulty": "easy", "function_schema_python": "def find_venues(city: str, capacity: int, requirements: List[str]) -> List[Dict]:\n    \"\"\"Finds venues in a city that meet specified criteria.\n\n    :param city: The city to search in.\n    :param capacity: The minimum capacity of the venue.\n    :param requirements: A list of additional requirements (e.g., \"acoustics\", \"dining\").\n    :return: A list of dictionaries, where each dictionary represents a venue and contains\n             \"name\", \"capacity\", \"acoustics\", and \"dining\" keys.\"\"\"\n    pass\ndef integrate_ticket_sales(venue_name: str, software: str) -> bool:\n    \"\"\"Integrates ticket sales data from a venue with the festival's management software.\n\n    :param venue_name: The name of the venue.\n    :param software: The name of the festival's management software.\n    :return: True if integration is successful, False otherwise.\"\"\"\n    pass\ndef sync_attendee_info(venue_name: str, software: str) -> bool:\n    \"\"\"Synchronizes attendee information between the venue and the festival's management software.\n\n    :param venue_name: The name of the venue.\n    :param software: The name of the festival's management software.\n    :return: True if synchronization is successful, False otherwise.\"\"\"\n    pass\n", "function_schema_json": [{"name": "find_venues", "description": "Finds venues in a city that meet specified criteria.", "parameters": {"type": "object", "properties": {"city": {"type": "string", "description": "The city to search in."}, "capacity": {"type": "integer", "description": "The minimum capacity of the venue."}, "requirements": {"type": "array", "items": {"type": "string"}, "description": "A list of additional requirements (e.g., \"acoustics\", \"dining\")."}}, "required": ["city", "capacity", "requirements"], "additionalProperties": false}}, {"name": "integrate_ticket_sales", "description": "Integrates ticket sales data from a venue with the festival's management software.", "parameters": {"type": "object", "properties": {"venue_name": {"type": "string", "description": "The name of the venue."}, "software": {"type": "string", "description": "The name of the festival's management software."}}, "required": ["venue_name", "software"], "additionalProperties": false}}, {"name": "sync_attendee_info", "description": "Synchronizes attendee information between the venue and the festival's management software.", "parameters": {"type": "object", "properties": {"venue_name": {"type": "string", "description": "The name of the venue."}, "software": {"type": "string", "description": "The name of the festival's management software."}}, "required": ["venue_name", "software"], "additionalProperties": false}}], "mock_functions": "def find_venues(city: str, capacity: int, requirements: List[str]) -> List[Dict]:\n    \"\"\"\n    Finds venues in a city that meet specified criteria.\n\n    :param city: The city to search in.\n    :param capacity: The minimum capacity of the venue.\n    :param requirements: A list of additional requirements (e.g., \"acoustics\", \"dining\").\n    :return: A list of dictionaries, where each dictionary represents a venue and contains\n             \"name\", \"capacity\", \"acoustics\", and \"dining\" keys.\n    \"\"\"\n    if city.lower() == \"any city\" and capacity >= 2000 and all(req in requirements for req in [\"acoustics\", \"dining\"]):\n        return [\n            {\"name\": \"Harmony Hall\", \"capacity\": 2500, \"acoustics\": \"excellent\", \"dining\": \"nearby\"},\n            {\"name\": \"Jazz Palace\", \"capacity\": 2200, \"acoustics\": \"good\", \"dining\": \"on-site\"}\n        ]\n    return []\ndef integrate_ticket_sales(venue_name: str, software: str) -> bool:\n    \"\"\"\n    Integrates ticket sales data from a venue with the festival's management software.\n\n    :param venue_name: The name of the venue.\n    :param software: The name of the festival's management software.\n    :return: True if integration is successful, False otherwise.\n    \"\"\"\n    if venue_name in [\"Harmony Hall\", \"Jazz Palace\"] and software == \"any software\":\n        return True\n    return False\ndef sync_attendee_info(venue_name: str, software: str) -> bool:\n    \"\"\"\n    Synchronizes attendee information between the venue and the festival's management software.\n\n    :param venue_name: The name of the venue.\n    :param software: The name of the festival's management software.\n    :return: True if synchronization is successful, False otherwise.\n    \"\"\"\n    if venue_name in [\"Harmony Hall\", \"Jazz Palace\"] and software == \"any software\":\n        return True\n    return False", "user_query": "Can you find venues in Any City that can hold 2000 people with requirements [\"acoustics\", \"dining\"]?", "checklist": {"functions": ["find_venues"], "values": [[{"name": "Harmony Hall", "capacity": 2500, "acoustics": "excellent", "dining": "nearby"}, {"name": "Jazz Palace", "capacity": 2200, "acoustics": "good", "dining": "on-site"}]]}}
{"difficulty": "easy", "function_schema_python": "def venue_search(location: str, capacity: int, amenities: list[str]) -> list[dict]:\n    \"\"\"Searches for venues in a given location that meet the specified capacity and amenities.\n\n    :param location: The location to search for venues.\n    :param capacity: The required capacity of the venue.\n    :param amenities: A list of amenities the venue must have.\n    :return: A list of dictionaries, each representing a venue with the following keys:\n             - name (str): The name of the venue.\n             - location (str): The location of the venue.\n             - capacity (int): The capacity of the venue.\n             - amenities (list[str]): The amenities available in the venue.\n    :raises ValueError: If location, capacity, or amenities are invalid.\"\"\"\n    pass\ndef calendar_management(date: str, time: str, event_name: str) -> bool:\n    \"\"\"Adds an event to the calendar and checks for conflicts.\n\n    :param date: The date of the event (e.g., \"June 15, 2024\").\n    :param time: The time of the event (e.g., \"10 AM\").\n    :param event_name: The name of the event.\n    :return: True if the event was successfully added without any conflicts, False otherwise.\n    :raises ValueError: If date, time, or event_name are invalid.\"\"\"\n    pass\ndef rideshare_booking(service: str, origin: str, destination: str) -> dict:\n    \"\"\"Books a rideshare service for the given origin and destination.\n\n    :param service: The name of the rideshare service (e.g., \"Uber\", \"Grab\").\n    :param origin: The starting location.\n    :param destination: The destination location.\n    :return: A dictionary with booking details, including the following keys:\n             - service (str): The name of the rideshare service.\n             - origin (str): The starting location.\n             - destination (str): The destination location.\n             - booking_id (str): A unique booking ID.\n             - estimated_time (str): Estimated time in \"1 hour 30 minutes\" format.\n    :raises ValueError: If service, origin, or destination are invalid.\"\"\"\n    pass\n", "function_schema_json": [{"name": "venue_search", "description": "Searches for venues in a given location that meet the specified capacity and amenities.", "parameters": {"type": "object", "properties": {"location": {"type": "string", "description": "The location to search for venues."}, "capacity": {"type": "integer", "description": "The required capacity of the venue."}, "amenities": {"type": "array", "items": {"type": "string"}, "description": "A list of amenities the venue must have."}}, "required": ["location", "capacity", "amenities"], "additionalProperties": false}}, {"name": "calendar_management", "description": "Adds an event to the calendar and checks for conflicts.", "parameters": {"type": "object", "properties": {"date": {"type": "string", "description": "The date of the event (e.g., \"June 15, 2024\")."}, "time": {"type": "string", "description": "The time of the event (e.g., \"10 AM\")."}, "event_name": {"type": "string", "description": "The name of the event."}}, "required": ["date", "time", "event_name"], "additionalProperties": false}}, {"name": "rideshare_booking", "description": "Books a rideshare service for the given origin and destination.", "parameters": {"type": "object", "properties": {"service": {"type": "string", "description": "The name of the rideshare service (e.g., \"Uber\", \"Grab\")."}, "origin": {"type": "string", "description": "The starting location."}, "destination": {"type": "string", "description": "The destination location."}}, "required": ["service", "origin", "destination"], "additionalProperties": false}}], "mock_functions": "def venue_search(location: str, capacity: int, amenities: list[str]) -> list[dict]:\n    \"\"\"\n    Searches for venues in a given location that meet the specified capacity and amenities.\n\n    :param location: The location to search for venues.\n    :param capacity: The required capacity of the venue.\n    :param amenities: A list of amenities the venue must have.\n    :return: A list of dictionaries, each representing a venue with the following keys:\n             - name (str): The name of the venue.\n             - location (str): The location of the venue.\n             - capacity (int): The capacity of the venue.\n             - amenities (list[str]): The amenities available in the venue.\n    :raises ValueError: If location, capacity, or amenities are invalid.\n    \"\"\"\n    if not location or capacity <= 0 or not amenities:\n        raise ValueError(\"Location, capacity, and amenities must be provided and valid.\")\n    if location == \"central area\" and capacity >= 500 and \"presentation facilities\" in amenities and \"workshop facilities\" in amenities:\n        return [\n            {\n                \"name\": \"Convention Center A\",\n                \"location\": \"Downtown\",\n                \"capacity\": 600,\n                \"amenities\": [\"presentation facilities\", \"workshop facilities\", \"parking\"]\n            },\n            {\n                \"name\": \"Conference Hotel B\",\n                \"location\": \"City Center\",\n                \"capacity\": 550,\n                \"amenities\": [\"presentation facilities\", \"workshop facilities\", \"restaurant\"]\n            }\n        ]\n    return []\ndef calendar_management(date: str, time: str, event_name: str) -> bool:\n    \"\"\"\n    Adds an event to the calendar and checks for conflicts.\n\n    :param date: The date of the event (e.g., \"June 15, 2024\").\n    :param time: The time of the event (e.g., \"10 AM\").\n    :param event_name: The name of the event.\n    :return: True if the event was successfully added without any conflicts, False otherwise.\n    :raises ValueError: If date, time, or event_name are invalid.\n    \"\"\"\n    if not date or not time or not event_name:\n        raise ValueError(\"Date, time, and event name must be provided.\")\n    # Mock logic: Assume no conflicts for the following dates and times\n    if date in [\"June 15, 2024\", \"June 16, 2024\", \"June 17, 2024\"] and time in [\"10 AM\", \"3 PM\"]:\n        return True\n    return False\ndef rideshare_booking(service: str, origin: str, destination: str) -> dict:\n    \"\"\"\n    Books a rideshare service for the given origin and destination.\n\n    :param service: The name of the rideshare service (e.g., \"Uber\", \"Grab\").\n    :param origin: The starting location.\n    :param destination: The destination location.\n    :return: A dictionary with booking details, including the following keys:\n             - service (str): The name of the rideshare service.\n             - origin (str): The starting location.\n             - destination (str): The destination location.\n             - booking_id (str): A unique booking ID.\n             - estimated_time (str): Estimated time in \"1 hour 30 minutes\" format.\n    :raises ValueError: If service, origin, or destination are invalid.\n    \"\"\"\n    if not service or not origin or not destination:\n        raise ValueError(\"Service, origin, and destination must be provided.\")\n    if service in [\"Uber\", \"Grab\"] and origin == \"nearest airport\" and destination == \"conference hotel\":\n        return {\n            \"service\": service,\n            \"origin\": origin,\n            \"destination\": destination,\n            \"booking_id\": \"ABC123XYZ\",\n            \"estimated_time\": \"30 minutes\"\n        }\n    return {}", "user_query": "This is Dr. Emily Smith. Can you check if June 15, 2024 at 10 AM is available in the calendar for \"AI Conference Opening Session\"?", "checklist": {"functions": ["calendar_management"], "values": [true]}}
{"difficulty": "easy", "function_schema_python": "def venue_search(conference_name: str, year: int) -> dict:\n    \"\"\"Searches for the venue of a specified conference in a given year.\n\n    :param conference_name: The name of the conference.\n    :param year: The year of the conference.\n    :return:\n        dict: A dictionary with the following keys:\n            - venue (str): The name of the conference venue.\n            - address (str): The address of the conference venue.\n    :raises ValueError: If conference_name or year is not provided.\"\"\"\n    pass\ndef calendar_management(date: str, event_name: str) -> bool:\n    \"\"\"Adds an event to John's calendar.\n\n    :param date: The date of the event (e.g., \"June 1-3, 2024\").\n    :param event_name: The name of the event (e.g., \"International Conference on Artificial Intelligence\").\n    :return: True if the event was successfully added, False otherwise.\n    :raises ValueError: If any parameter is invalid.\"\"\"\n    pass\ndef rideshare_booking(service: str, origin: str, destination: str) -> dict:\n    \"\"\"Books a ride using a specified rideshare service from origin to destination.\n\n    :param service: The rideshare service to use (e.g., \"Uber\", \"Grab\").\n    :param origin: The starting address.\n    :param destination: The destination address.\n    :return:\n        dict: A dictionary with the following keys:\n            - booking_id (str): The ID of the booked ride.\n            - estimated_time (str): Estimated time in \"1 hour 30 minutes\" format.\n    :raises ValueError: If service, origin, or destination is empty.\"\"\"\n    pass\n", "function_schema_json": [{"name": "venue_search", "description": "Searches for the venue of a specified conference in a given year.", "parameters": {"type": "object", "properties": {"conference_name": {"type": "string", "description": "The name of the conference."}, "year": {"type": "integer", "description": "The year of the conference."}}, "required": ["conference_name", "year"], "additionalProperties": false}}, {"name": "calendar_management", "description": "Adds an event to John's calendar.", "parameters": {"type": "object", "properties": {"date": {"type": "string", "description": "The date of the event (e.g., \"June 1-3, 2024\")."}, "event_name": {"type": "string", "description": "The name of the event (e.g., \"International Conference on Artificial Intelligence\")."}}, "required": ["date", "event_name"], "additionalProperties": false}}, {"name": "rideshare_booking", "description": "Books a ride using a specified rideshare service from origin to destination.", "parameters": {"type": "object", "properties": {"service": {"type": "string", "description": "The rideshare service to use (e.g., \"Uber\", \"Grab\")."}, "origin": {"type": "string", "description": "The starting address."}, "destination": {"type": "string", "description": "The destination address."}}, "required": ["service", "origin", "destination"], "additionalProperties": false}}], "mock_functions": "def venue_search(conference_name: str, year: int) -> dict:\n    \"\"\"\n    Searches for the venue of a specified conference in a given year.\n    \n    :param conference_name: The name of the conference.\n    :param year: The year of the conference.\n    :return:\n        dict: A dictionary with the following keys:\n            - venue (str): The name of the conference venue.\n            - address (str): The address of the conference venue.\n    :raises ValueError: If conference_name or year is not provided.\n    \"\"\"\n    if not conference_name or not year:\n        raise ValueError(\"Conference name and year must be provided.\")\n    if conference_name.lower() == \"international conference on artificial intelligence\" and year == 2024:\n        return {\n            \"venue\": \"Convention Center\",\n            \"address\": \"123 AI Road, Tech City\"\n        }\n    return {}\ndef calendar_management(date: str, event_name: str) -> bool:\n    \"\"\"\n    Adds an event to John's calendar.\n    \n    :param date: The date of the event (e.g., \"June 1-3, 2024\").\n    :param event_name: The name of the event (e.g., \"International Conference on Artificial Intelligence\").\n    :return: True if the event was successfully added, False otherwise.\n    :raises ValueError: If any parameter is invalid.\n    \"\"\"\n    if not date or not event_name:\n        raise ValueError(\"Date and event name must be provided.\")\n    if date == \"June 1-3, 2024\" and event_name == \"International Conference on Artificial Intelligence\":\n        return True\n    return False\ndef rideshare_booking(service: str, origin: str, destination: str) -> dict:\n    \"\"\"\n    Books a ride using a specified rideshare service from origin to destination.\n    \n    :param service: The rideshare service to use (e.g., \"Uber\", \"Grab\").\n    :param origin: The starting address.\n    :param destination: The destination address.\n    :return:\n        dict: A dictionary with the following keys:\n            - booking_id (str): The ID of the booked ride.\n            - estimated_time (str): Estimated time in \"1 hour 30 minutes\" format.\n    :raises ValueError: If service, origin, or destination is empty.\n    \"\"\"\n    if not service or not origin or not destination:\n        raise ValueError(\"Service, origin, and destination must not be empty.\")\n    if service in [\"Uber\", \"Grab\"] and origin == \"Airport\" and destination == \"123 AI Road, Tech City\":\n        return {\n            \"booking_id\": \"12345\",\n            \"estimated_time\": \"30 minutes\"\n        }\n    return {}", "user_query": "Where is the International Conference on Artificial Intelligence being held in 2024?", "checklist": {"functions": ["venue_search"], "values": [{"venue": "Convention Center", "address": "123 AI Road, Tech City"}]}}
{"difficulty": "easy", "function_schema_python": "def venue_search(conference_name: str, year: int) -> dict:\n    \"\"\"Searches for the venue of a specified conference in a given year.\n\n    :param conference_name: The name of the conference.\n    :param year: The year of the conference.\n    :return:\n        dict: A dictionary with the following keys:\n            - venue (str): The name of the conference venue.\n            - address (str): The address of the conference venue.\n    :raises ValueError: If conference_name or year is not provided.\"\"\"\n    pass\ndef calendar_management(date: str, event_name: str) -> bool:\n    \"\"\"Adds an event to John's calendar.\n\n    :param date: The date of the event (e.g., \"June 1-3, 2024\").\n    :param event_name: The name of the event (e.g., \"International Conference on Artificial Intelligence\").\n    :return: True if the event was successfully added, False otherwise.\n    :raises ValueError: If any parameter is invalid.\"\"\"\n    pass\ndef rideshare_booking(service: str, origin: str, destination: str) -> dict:\n    \"\"\"Books a ride using a specified rideshare service from origin to destination.\n\n    :param service: The rideshare service to use (e.g., \"Uber\", \"Grab\").\n    :param origin: The starting address.\n    :param destination: The destination address.\n    :return:\n        dict: A dictionary with the following keys:\n            - booking_id (str): The ID of the booked ride.\n            - estimated_time (str): Estimated time in \"1 hour 30 minutes\" format.\n    :raises ValueError: If service, origin, or destination is empty.\"\"\"\n    pass\n", "function_schema_json": [{"name": "venue_search", "description": "Searches for the venue of a specified conference in a given year.", "parameters": {"type": "object", "properties": {"conference_name": {"type": "string", "description": "The name of the conference."}, "year": {"type": "integer", "description": "The year of the conference."}}, "required": ["conference_name", "year"], "additionalProperties": false}}, {"name": "calendar_management", "description": "Adds an event to John's calendar.", "parameters": {"type": "object", "properties": {"date": {"type": "string", "description": "The date of the event (e.g., \"June 1-3, 2024\")."}, "event_name": {"type": "string", "description": "The name of the event (e.g., \"International Conference on Artificial Intelligence\")."}}, "required": ["date", "event_name"], "additionalProperties": false}}, {"name": "rideshare_booking", "description": "Books a ride using a specified rideshare service from origin to destination.", "parameters": {"type": "object", "properties": {"service": {"type": "string", "description": "The rideshare service to use (e.g., \"Uber\", \"Grab\")."}, "origin": {"type": "string", "description": "The starting address."}, "destination": {"type": "string", "description": "The destination address."}}, "required": ["service", "origin", "destination"], "additionalProperties": false}}], "mock_functions": "def venue_search(conference_name: str, year: int) -> dict:\n    \"\"\"\n    Searches for the venue of a specified conference in a given year.\n    \n    :param conference_name: The name of the conference.\n    :param year: The year of the conference.\n    :return:\n        dict: A dictionary with the following keys:\n            - venue (str): The name of the conference venue.\n            - address (str): The address of the conference venue.\n    :raises ValueError: If conference_name or year is not provided.\n    \"\"\"\n    if not conference_name or not year:\n        raise ValueError(\"Conference name and year must be provided.\")\n    if conference_name.lower() == \"international conference on artificial intelligence\" and year == 2024:\n        return {\n            \"venue\": \"Convention Center\",\n            \"address\": \"123 AI Road, Tech City\"\n        }\n    return {}\ndef calendar_management(date: str, event_name: str) -> bool:\n    \"\"\"\n    Adds an event to John's calendar.\n    \n    :param date: The date of the event (e.g., \"June 1-3, 2024\").\n    :param event_name: The name of the event (e.g., \"International Conference on Artificial Intelligence\").\n    :return: True if the event was successfully added, False otherwise.\n    :raises ValueError: If any parameter is invalid.\n    \"\"\"\n    if not date or not event_name:\n        raise ValueError(\"Date and event name must be provided.\")\n    if date == \"June 1-3, 2024\" and event_name == \"International Conference on Artificial Intelligence\":\n        return True\n    return False\ndef rideshare_booking(service: str, origin: str, destination: str) -> dict:\n    \"\"\"\n    Books a ride using a specified rideshare service from origin to destination.\n    \n    :param service: The rideshare service to use (e.g., \"Uber\", \"Grab\").\n    :param origin: The starting address.\n    :param destination: The destination address.\n    :return:\n        dict: A dictionary with the following keys:\n            - booking_id (str): The ID of the booked ride.\n            - estimated_time (str): Estimated time in \"1 hour 30 minutes\" format.\n    :raises ValueError: If service, origin, or destination is empty.\n    \"\"\"\n    if not service or not origin or not destination:\n        raise ValueError(\"Service, origin, and destination must not be empty.\")\n    if service in [\"Uber\", \"Grab\"] and origin == \"Airport\" and destination == \"123 AI Road, Tech City\":\n        return {\n            \"booking_id\": \"12345\",\n            \"estimated_time\": \"30 minutes\"\n        }\n    return {}", "user_query": "Can you add the conference dates (June 1-3, 2024) to my calendar for the International Conference on Artificial Intelligence?", "checklist": {"functions": ["calendar_management"], "values": [true]}}
{"difficulty": "easy", "function_schema_python": "def venue_search(conference_name: str, year: int) -> dict:\n    \"\"\"Searches for the venue of a specified conference in a given year.\n\n    :param conference_name: The name of the conference.\n    :param year: The year of the conference.\n    :return:\n        dict: A dictionary with the following keys:\n            - venue (str): The name of the conference venue.\n            - address (str): The address of the conference venue.\n    :raises ValueError: If conference_name or year is not provided.\"\"\"\n    pass\ndef calendar_management(date: str, event_name: str) -> bool:\n    \"\"\"Adds an event to John's calendar.\n\n    :param date: The date of the event (e.g., \"June 1-3, 2024\").\n    :param event_name: The name of the event (e.g., \"International Conference on Artificial Intelligence\").\n    :return: True if the event was successfully added, False otherwise.\n    :raises ValueError: If any parameter is invalid.\"\"\"\n    pass\ndef rideshare_booking(service: str, origin: str, destination: str) -> dict:\n    \"\"\"Books a ride using a specified rideshare service from origin to destination.\n\n    :param service: The rideshare service to use (e.g., \"Uber\", \"Grab\").\n    :param origin: The starting address.\n    :param destination: The destination address.\n    :return:\n        dict: A dictionary with the following keys:\n            - booking_id (str): The ID of the booked ride.\n            - estimated_time (str): Estimated time in \"1 hour 30 minutes\" format.\n    :raises ValueError: If service, origin, or destination is empty.\"\"\"\n    pass\n", "function_schema_json": [{"name": "venue_search", "description": "Searches for the venue of a specified conference in a given year.", "parameters": {"type": "object", "properties": {"conference_name": {"type": "string", "description": "The name of the conference."}, "year": {"type": "integer", "description": "The year of the conference."}}, "required": ["conference_name", "year"], "additionalProperties": false}}, {"name": "calendar_management", "description": "Adds an event to John's calendar.", "parameters": {"type": "object", "properties": {"date": {"type": "string", "description": "The date of the event (e.g., \"June 1-3, 2024\")."}, "event_name": {"type": "string", "description": "The name of the event (e.g., \"International Conference on Artificial Intelligence\")."}}, "required": ["date", "event_name"], "additionalProperties": false}}, {"name": "rideshare_booking", "description": "Books a ride using a specified rideshare service from origin to destination.", "parameters": {"type": "object", "properties": {"service": {"type": "string", "description": "The rideshare service to use (e.g., \"Uber\", \"Grab\")."}, "origin": {"type": "string", "description": "The starting address."}, "destination": {"type": "string", "description": "The destination address."}}, "required": ["service", "origin", "destination"], "additionalProperties": false}}], "mock_functions": "def venue_search(conference_name: str, year: int) -> dict:\n    \"\"\"\n    Searches for the venue of a specified conference in a given year.\n    \n    :param conference_name: The name of the conference.\n    :param year: The year of the conference.\n    :return:\n        dict: A dictionary with the following keys:\n            - venue (str): The name of the conference venue.\n            - address (str): The address of the conference venue.\n    :raises ValueError: If conference_name or year is not provided.\n    \"\"\"\n    if not conference_name or not year:\n        raise ValueError(\"Conference name and year must be provided.\")\n    if conference_name.lower() == \"international conference on artificial intelligence\" and year == 2024:\n        return {\n            \"venue\": \"Convention Center\",\n            \"address\": \"123 AI Road, Tech City\"\n        }\n    return {}\ndef calendar_management(date: str, event_name: str) -> bool:\n    \"\"\"\n    Adds an event to John's calendar.\n    \n    :param date: The date of the event (e.g., \"June 1-3, 2024\").\n    :param event_name: The name of the event (e.g., \"International Conference on Artificial Intelligence\").\n    :return: True if the event was successfully added, False otherwise.\n    :raises ValueError: If any parameter is invalid.\n    \"\"\"\n    if not date or not event_name:\n        raise ValueError(\"Date and event name must be provided.\")\n    if date == \"June 1-3, 2024\" and event_name == \"International Conference on Artificial Intelligence\":\n        return True\n    return False\ndef rideshare_booking(service: str, origin: str, destination: str) -> dict:\n    \"\"\"\n    Books a ride using a specified rideshare service from origin to destination.\n    \n    :param service: The rideshare service to use (e.g., \"Uber\", \"Grab\").\n    :param origin: The starting address.\n    :param destination: The destination address.\n    :return:\n        dict: A dictionary with the following keys:\n            - booking_id (str): The ID of the booked ride.\n            - estimated_time (str): Estimated time in \"1 hour 30 minutes\" format.\n    :raises ValueError: If service, origin, or destination is empty.\n    \"\"\"\n    if not service or not origin or not destination:\n        raise ValueError(\"Service, origin, and destination must not be empty.\")\n    if service in [\"Uber\", \"Grab\"] and origin == \"Airport\" and destination == \"123 AI Road, Tech City\":\n        return {\n            \"booking_id\": \"12345\",\n            \"estimated_time\": \"30 minutes\"\n        }\n    return {}", "user_query": "This is John Doe. I need to book an Uber from the Airport to the conference venue at 123 AI Road, Tech City for my upcoming AI conference. Can you help me book the ride and confirm the estimated travel time?", "checklist": {"functions": ["rideshare_booking"], "values": [{"booking_id": "12345", "estimated_time": "30 minutes"}]}}
{"difficulty": "easy", "function_schema_python": "def validate_api_credentials(api_key: str) -> bool:\n    \"\"\"Validates the provided API key against the QuantEdge API.\n\n    :param api_key: The API key to validate.\n    :return: True if the API key is valid, False otherwise.\"\"\"\n    pass\ndef establish_market_data_feed(market: str, data_type: str) -> list:\n    \"\"\"Establishes a real-time market data feed for the specified market and data type.\n\n    :param market: The target market (e.g., \"cryptocurrency\", \"forex\").\n    :param data_type: The type of market data required (e.g., \"orderbook\", \"trades\").\n    :return: A list of mock market data updates.\"\"\"\n    pass\ndef configure_risk_management(strategy: str, parameters: dict) -> bool:\n    \"\"\"Configures automated risk mitigation strategies for trading algorithms.\n\n    :param strategy: The risk management strategy to implement (e.g., \"stop-loss\", \"take-profit\").\n    :param parameters: A dictionary containing strategy-specific parameters.\n    :return: True if the configuration is successful, False otherwise.\"\"\"\n    pass\n", "function_schema_json": [{"name": "validate_api_credentials", "description": "Validates the provided API key against the QuantEdge API.", "parameters": {"type": "object", "properties": {"api_key": {"type": "string", "description": "The API key to validate."}}, "required": ["api_key"], "additionalProperties": false}}, {"name": "establish_market_data_feed", "description": "Establishes a real-time market data feed for the specified market and data type.", "parameters": {"type": "object", "properties": {"market": {"type": "string", "description": "The target market (e.g., \"cryptocurrency\", \"forex\")."}, "data_type": {"type": "string", "description": "The type of market data required (e.g., \"orderbook\", \"trades\")."}}, "required": ["market", "data_type"], "additionalProperties": false}}, {"name": "configure_risk_management", "description": "Configures automated risk mitigation strategies for trading algorithms.", "parameters": {"type": "object", "properties": {"strategy": {"type": "string", "description": "The risk management strategy to implement (e.g., \"stop-loss\", \"take-profit\")."}, "parameters": {"type": "object", "description": "A dictionary containing strategy-specific parameters."}}, "required": ["strategy", "parameters"], "additionalProperties": false}}], "mock_functions": "def validate_api_credentials(api_key: str) -> bool:\n    \"\"\"\n    Validates the provided API key against the QuantEdge API.\n\n    :param api_key: The API key to validate.\n    :return: True if the API key is valid, False otherwise.\n    \"\"\"\n    return api_key == \"QE-TRADER-9863-2023\"\ndef establish_market_data_feed(market: str, data_type: str) -> list:\n    \"\"\"\n    Establishes a real-time market data feed for the specified market and data type.\n\n    :param market: The target market (e.g., \"cryptocurrency\", \"forex\").\n    :param data_type: The type of market data required (e.g., \"orderbook\", \"trades\").\n    :return: A list of mock market data updates.\n    \"\"\"\n    if market.lower() in (\"cryptocurrency\", \"forex\") and data_type.lower() in (\"orderbook\", \"trades\"):\n        return [{\"time\": datetime.datetime.now().isoformat(), \"price\": 12345.67}]\n    return []\ndef configure_risk_management(strategy: str, parameters: dict) -> bool:\n    \"\"\"\n    Configures automated risk mitigation strategies for trading algorithms.\n\n    :param strategy: The risk management strategy to implement (e.g., \"stop-loss\", \"take-profit\").\n    :param parameters: A dictionary containing strategy-specific parameters.\n    :return: True if the configuration is successful, False otherwise.\n    \"\"\"\n    if strategy.lower() in (\"stop-loss\", \"take-profit\") and isinstance(parameters, dict):\n        return True\n    return False", "user_query": "Can you validate my API key: QE-TRADER-9863-2023?", "checklist": {"functions": ["validate_api_credentials"], "values": [true]}}
{"difficulty": "easy", "function_schema_python": "def search_scholars(query: str) -> list:\n    \"\"\"Searches for scholars based on a given query.\n\n    :param query: The search query string.\n    :return: A list of dictionaries representing scholars with keys: 'id', 'name', 'research_area'.\n    :raises ValueError: If the query is empty.\"\"\"\n    pass\ndef evaluate_risk(scholar_id: str) -> int:\n    \"\"\"Evaluates the risk profile of a scholar by their ID.\n\n    :param scholar_id: The unique identifier for the scholar.\n    :return: An integer representing the risk score, 1 (low risk) to 10 (high risk).\n    :raises ValueError: If the scholar_id is not valid.\"\"\"\n    pass\ndef aggregate_scholars(scholar_list: list, risk_scores: dict, top_n: int) -> list:\n    \"\"\"Aggregates scholars based on their research potential and risk scores.\n\n    :param scholar_list: A list of dictionaries with keys: 'id', 'name', 'research_area'.\n    :param risk_scores: A dictionary with scholar IDs as keys and risk scores as values.\n    :param top_n: The number of top scholars to include in the result.\n    :return: A list of dictionaries for the top N scholars with keys: 'id', 'name', 'research_area', 'risk_score'.\n    :raises ValueError: If parameters are invalid.\"\"\"\n    pass\n", "function_schema_json": [{"name": "search_scholars", "description": "Searches for scholars based on a given query.", "parameters": {"type": "object", "properties": {"query": {"type": "string", "description": "The search query string."}}, "required": ["query"], "additionalProperties": false}}, {"name": "evaluate_risk", "description": "Evaluates the risk profile of a scholar by their ID.", "parameters": {"type": "object", "properties": {"scholar_id": {"type": "string", "description": "The unique identifier for the scholar."}}, "required": ["scholar_id"], "additionalProperties": false}}, {"name": "aggregate_scholars", "description": "Aggregates scholars based on their research potential and risk scores.", "parameters": {"type": "object", "properties": {"scholar_list": {"type": "array", "description": "A list of dictionaries with keys: 'id', 'name', 'research_area'."}, "risk_scores": {"type": "object", "description": "A dictionary with scholar IDs as keys and risk scores as values."}, "top_n": {"type": "integer", "description": "The number of top scholars to include in the result."}}, "required": ["scholar_list", "risk_scores", "top_n"], "additionalProperties": false}}], "mock_functions": "def search_scholars(query: str) -> list:\n    \"\"\"\n    Searches for scholars based on a given query.\n\n    :param query: The search query string.\n    :return: A list of dictionaries representing scholars with keys: 'id', 'name', 'research_area'.\n    :raises ValueError: If the query is empty.\n    \"\"\"\n    if not query:\n        raise ValueError(\"Query must not be empty.\")\n    if query.lower() == \"scholars in renewable energy\":\n        return [\n            {\"id\": \"S1\", \"name\": \"Alice Johnson\", \"research_area\": \"Solar Power\"},\n            {\"id\": \"S2\", \"name\": \"Bob Smith\", \"research_area\": \"Wind Energy\"},\n            {\"id\": \"S3\", \"name\": \"Charlie Brown\", \"research_area\": \"Hydro Power\"},\n        ]\n    return []\ndef evaluate_risk(scholar_id: str) -> int:\n    \"\"\"\n    Evaluates the risk profile of a scholar by their ID.\n    \n    :param scholar_id: The unique identifier for the scholar.\n    :return: An integer representing the risk score, 1 (low risk) to 10 (high risk).\n    :raises ValueError: If the scholar_id is not valid.\n    \"\"\"\n    # Mock logic: Assign risk scores based on scholar_id\n    risk_scores = {\n        \"S1\": 5,\n        \"S2\": 3,\n        \"S3\": 8\n    }\n    if scholar_id not in risk_scores:\n        raise ValueError(\"Invalid scholar ID.\")\n    return risk_scores[scholar_id]\ndef aggregate_scholars(scholar_list: list, risk_scores: dict, top_n: int) -> list:\n    \"\"\"\n    Aggregates scholars based on their research potential and risk scores.\n    \n    :param scholar_list: A list of dictionaries with keys: 'id', 'name', 'research_area'.\n    :param risk_scores: A dictionary with scholar IDs as keys and risk scores as values.\n    :param top_n: The number of top scholars to include in the result.\n    :return: A list of dictionaries for the top N scholars with keys: 'id', 'name', 'research_area', 'risk_score'.\n    :raises ValueError: If parameters are invalid.\n    \"\"\"\n    if not scholar_list or not risk_scores or top_n <= 0:\n        raise ValueError(\"Invalid parameters.\")\n    scholars_with_scores = [\n        {**scholar, **{'risk_score': risk_scores[scholar['id']]}} for scholar in scholar_list\n    ]\n    scholars_with_scores.sort(key=lambda x: x['risk_score'])\n    return scholars_with_scores[:top_n]\n", "user_query": "What is the risk score for scholar with ID S1 from Redwood Capital database?", "checklist": {"functions": ["evaluate_risk"], "values": [5]}}
{"difficulty": "easy", "function_schema_python": "def inspect_remote_infrastructure(vm_ip: str) -> dict:\n    \"\"\"Inspects the remote infrastructure using SSH to gather performance data.\n\n    :param vm_ip: The IP address of the virtual machine to inspect.\n    :return:\n        dict: A dictionary with the following keys:\n            - cpu_usage (float): CPU usage percentage.\n            - memory_usage (float): Memory usage percentage.\n            - disk_usage (float): Disk usage percentage.\n            - network_usage (float): Network usage percentage.\n    :raises ValueError: If vm_ip is not a valid IPv4 address.\"\"\"\n    pass\ndef check_db_migration_script(vm_ip: str, script_path: str) -> str:\n    \"\"\"Executes the database migration script on the virtual machine via SSH and captures the output.\n\n    :param vm_ip: The IP address of the virtual machine.\n    :param script_path: The path to the database migration script.\n    :return: A string containing the output of the script execution.\n    :raises ValueError: If vm_ip is not a valid IPv4 address or script_path is empty.\"\"\"\n    pass\ndef connect_to_vm_via_ssh(vm_ip: str) -> str:\n    \"\"\"Attempts to establish an SSH connection to the virtual machine.\n\n    :param vm_ip: The IP address of the virtual machine.\n    :return: A string indicating the success or failure of the connection attempt.\n    :raises ValueError: If vm_ip is not a valid IPv4 address.\"\"\"\n    pass\ndef execute_migration_script_remotely(vm_ip: str, script_path: str) -> str:\n    \"\"\"Executes a database migration script on a remote virtual machine via SSH.\n\n    :param vm_ip: The IP address of the virtual machine.\n    :param script_path: The path to the database migration script.\n    :return: A string indicating the result of the script execution.\n    :raises ValueError: If vm_ip is not a valid IPv4 address or script_path is empty.\"\"\"\n    pass\n", "function_schema_json": [{"name": "inspect_remote_infrastructure", "description": "Inspects the remote infrastructure using SSH to gather performance data.", "parameters": {"type": "object", "properties": {"vm_ip": {"type": "string", "description": "The IP address of the virtual machine to inspect."}}, "required": ["vm_ip"], "additionalProperties": false}}, {"name": "check_db_migration_script", "description": "Executes the database migration script on the virtual machine via SSH and captures the output.", "parameters": {"type": "object", "properties": {"vm_ip": {"type": "string", "description": "The IP address of the virtual machine."}, "script_path": {"type": "string", "description": "The path to the database migration script."}}, "required": ["vm_ip", "script_path"], "additionalProperties": false}}, {"name": "connect_to_vm_via_ssh", "description": "Attempts to establish an SSH connection to the virtual machine.", "parameters": {"type": "object", "properties": {"vm_ip": {"type": "string", "description": "The IP address of the virtual machine."}}, "required": ["vm_ip"], "additionalProperties": false}}, {"name": "execute_migration_script_remotely", "description": "Executes a database migration script on a remote virtual machine via SSH.", "parameters": {"type": "object", "properties": {"vm_ip": {"type": "string", "description": "The IP address of the virtual machine."}, "script_path": {"type": "string", "description": "The path to the database migration script."}}, "required": ["vm_ip", "script_path"], "additionalProperties": false}}], "mock_functions": "def inspect_remote_infrastructure(vm_ip: str) -> dict:\n    \"\"\"\n    Inspects the remote infrastructure using SSH to gather performance data.\n    \n    :param vm_ip: The IP address of the virtual machine to inspect.\n    :return:\n        dict: A dictionary with the following keys:\n            - cpu_usage (float): CPU usage percentage.\n            - memory_usage (float): Memory usage percentage.\n            - disk_usage (float): Disk usage percentage.\n            - network_usage (float): Network usage percentage.\n    :raises ValueError: If vm_ip is not a valid IPv4 address.\n    \"\"\"\n    import re\n    if not re.match(r\"^\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}$\", vm_ip):\n        raise ValueError(\"Invalid IPv4 address.\")\n    \n    return {\n        \"cpu_usage\": 75.0,\n        \"memory_usage\": 60.0,\n        \"disk_usage\": 80.0,\n        \"network_usage\": 25.0\n    }\ndef check_db_migration_script(vm_ip: str, script_path: str) -> str:\n    \"\"\"\n    Executes the database migration script on the virtual machine via SSH and captures the output.\n    \n    :param vm_ip: The IP address of the virtual machine.\n    :param script_path: The path to the database migration script.\n    :return: A string containing the output of the script execution.\n    :raises ValueError: If vm_ip is not a valid IPv4 address or script_path is empty.\n    \"\"\"\n    import re\n    if not re.match(r\"^\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}$\", vm_ip):\n        raise ValueError(\"Invalid IPv4 address.\")\n    if not script_path:\n        raise ValueError(\"Script path cannot be empty.\")\n    \n    return f\"Executing script {script_path} on {vm_ip}...\\nError: Table 'users' already exists.\"\ndef connect_to_vm_via_ssh(vm_ip: str) -> str:\n    \"\"\"\n    Attempts to establish an SSH connection to the virtual machine.\n    \n    :param vm_ip: The IP address of the virtual machine.\n    :return: A string indicating the success or failure of the connection attempt.\n    :raises ValueError: If vm_ip is not a valid IPv4 address.\n    \"\"\"\n    import re\n    if not re.match(r\"^\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}$\", vm_ip):\n        raise ValueError(\"Invalid IPv4 address.\")\n    \n    return f\"Successfully connected to {vm_ip} via SSH.\"\ndef execute_migration_script_remotely(vm_ip: str, script_path: str) -> str:\n    \"\"\"\n    Executes a database migration script on a remote virtual machine via SSH.\n    \n    :param vm_ip: The IP address of the virtual machine.\n    :param script_path: The path to the database migration script.\n    :return: A string indicating the result of the script execution.\n    :raises ValueError: If vm_ip is not a valid IPv4 address or script_path is empty.\n    \"\"\"\n    import re\n    if not re.match(r\"^\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}$\", vm_ip):\n        raise ValueError(\"Invalid IPv4 address.\")\n    if not script_path:\n        raise ValueError(\"Script path cannot be empty.\")\n    \n    return f\"Executing script {script_path} on {vm_ip}...\\nMigration successful.\"", "user_query": "Can you inspect the remote infrastructure for VM with IP 192.168.1.100 and check its performance metrics?", "checklist": {"functions": ["inspect_remote_infrastructure"], "values": [{"cpu_usage": 75.0, "memory_usage": 60.0, "disk_usage": 80.0, "network_usage": 25.0}]}}
{"difficulty": "easy", "function_schema_python": "def inspect_remote_infrastructure(vm_ip: str) -> dict:\n    \"\"\"Inspects the remote infrastructure using SSH to gather performance data.\n\n    :param vm_ip: The IP address of the virtual machine to inspect.\n    :return:\n        dict: A dictionary with the following keys:\n            - cpu_usage (float): CPU usage percentage.\n            - memory_usage (float): Memory usage percentage.\n            - disk_usage (float): Disk usage percentage.\n            - network_usage (float): Network usage percentage.\n    :raises ValueError: If vm_ip is not a valid IPv4 address.\"\"\"\n    pass\ndef check_db_migration_script(vm_ip: str, script_path: str) -> str:\n    \"\"\"Executes the database migration script on the virtual machine via SSH and captures the output.\n\n    :param vm_ip: The IP address of the virtual machine.\n    :param script_path: The path to the database migration script.\n    :return: A string containing the output of the script execution.\n    :raises ValueError: If vm_ip is not a valid IPv4 address or script_path is empty.\"\"\"\n    pass\ndef connect_to_vm_via_ssh(vm_ip: str) -> str:\n    \"\"\"Attempts to establish an SSH connection to the virtual machine.\n\n    :param vm_ip: The IP address of the virtual machine.\n    :return: A string indicating the success or failure of the connection attempt.\n    :raises ValueError: If vm_ip is not a valid IPv4 address.\"\"\"\n    pass\ndef execute_migration_script_remotely(vm_ip: str, script_path: str) -> str:\n    \"\"\"Executes a database migration script on a remote virtual machine via SSH.\n\n    :param vm_ip: The IP address of the virtual machine.\n    :param script_path: The path to the database migration script.\n    :return: A string indicating the result of the script execution.\n    :raises ValueError: If vm_ip is not a valid IPv4 address or script_path is empty.\"\"\"\n    pass\n", "function_schema_json": [{"name": "inspect_remote_infrastructure", "description": "Inspects the remote infrastructure using SSH to gather performance data.", "parameters": {"type": "object", "properties": {"vm_ip": {"type": "string", "description": "The IP address of the virtual machine to inspect."}}, "required": ["vm_ip"], "additionalProperties": false}}, {"name": "check_db_migration_script", "description": "Executes the database migration script on the virtual machine via SSH and captures the output.", "parameters": {"type": "object", "properties": {"vm_ip": {"type": "string", "description": "The IP address of the virtual machine."}, "script_path": {"type": "string", "description": "The path to the database migration script."}}, "required": ["vm_ip", "script_path"], "additionalProperties": false}}, {"name": "connect_to_vm_via_ssh", "description": "Attempts to establish an SSH connection to the virtual machine.", "parameters": {"type": "object", "properties": {"vm_ip": {"type": "string", "description": "The IP address of the virtual machine."}}, "required": ["vm_ip"], "additionalProperties": false}}, {"name": "execute_migration_script_remotely", "description": "Executes a database migration script on a remote virtual machine via SSH.", "parameters": {"type": "object", "properties": {"vm_ip": {"type": "string", "description": "The IP address of the virtual machine."}, "script_path": {"type": "string", "description": "The path to the database migration script."}}, "required": ["vm_ip", "script_path"], "additionalProperties": false}}], "mock_functions": "def inspect_remote_infrastructure(vm_ip: str) -> dict:\n    \"\"\"\n    Inspects the remote infrastructure using SSH to gather performance data.\n    \n    :param vm_ip: The IP address of the virtual machine to inspect.\n    :return:\n        dict: A dictionary with the following keys:\n            - cpu_usage (float): CPU usage percentage.\n            - memory_usage (float): Memory usage percentage.\n            - disk_usage (float): Disk usage percentage.\n            - network_usage (float): Network usage percentage.\n    :raises ValueError: If vm_ip is not a valid IPv4 address.\n    \"\"\"\n    import re\n    if not re.match(r\"^\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}$\", vm_ip):\n        raise ValueError(\"Invalid IPv4 address.\")\n    \n    return {\n        \"cpu_usage\": 75.0,\n        \"memory_usage\": 60.0,\n        \"disk_usage\": 80.0,\n        \"network_usage\": 25.0\n    }\ndef check_db_migration_script(vm_ip: str, script_path: str) -> str:\n    \"\"\"\n    Executes the database migration script on the virtual machine via SSH and captures the output.\n    \n    :param vm_ip: The IP address of the virtual machine.\n    :param script_path: The path to the database migration script.\n    :return: A string containing the output of the script execution.\n    :raises ValueError: If vm_ip is not a valid IPv4 address or script_path is empty.\n    \"\"\"\n    import re\n    if not re.match(r\"^\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}$\", vm_ip):\n        raise ValueError(\"Invalid IPv4 address.\")\n    if not script_path:\n        raise ValueError(\"Script path cannot be empty.\")\n    \n    return f\"Executing script {script_path} on {vm_ip}...\\nError: Table 'users' already exists.\"\ndef connect_to_vm_via_ssh(vm_ip: str) -> str:\n    \"\"\"\n    Attempts to establish an SSH connection to the virtual machine.\n    \n    :param vm_ip: The IP address of the virtual machine.\n    :return: A string indicating the success or failure of the connection attempt.\n    :raises ValueError: If vm_ip is not a valid IPv4 address.\n    \"\"\"\n    import re\n    if not re.match(r\"^\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}$\", vm_ip):\n        raise ValueError(\"Invalid IPv4 address.\")\n    \n    return f\"Successfully connected to {vm_ip} via SSH.\"\ndef execute_migration_script_remotely(vm_ip: str, script_path: str) -> str:\n    \"\"\"\n    Executes a database migration script on a remote virtual machine via SSH.\n    \n    :param vm_ip: The IP address of the virtual machine.\n    :param script_path: The path to the database migration script.\n    :return: A string indicating the result of the script execution.\n    :raises ValueError: If vm_ip is not a valid IPv4 address or script_path is empty.\n    \"\"\"\n    import re\n    if not re.match(r\"^\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}$\", vm_ip):\n        raise ValueError(\"Invalid IPv4 address.\")\n    if not script_path:\n        raise ValueError(\"Script path cannot be empty.\")\n    \n    return f\"Executing script {script_path} on {vm_ip}...\\nMigration successful.\"", "user_query": "Please check the database migration script located at /home/greentech/migrations/user_migration.sql on the VM with IP 192.168.1.100 and tell me what error it's encountering.", "checklist": {"functions": ["check_db_migration_script"], "values": ["Executing script /home/greentech/migrations/user_migration.sql on 192.168.1.100...\nError: Table 'users' already exists."]}}
{"difficulty": "easy", "function_schema_python": "def add_event_to_calendar(date: str, time: str, event_name: str) -> bool:\n    \"\"\"Adds an event to Google Calendar.\n\n    :param date: The date of the event in 'DD-MM-YYYY' format.\n    :param time: The time of the event in 'HH:MM' format.\n    :param event_name: The name of the event, e.g., 'Payment Reminder'.\n    :return: True if the event was successfully added, False otherwise.\n    :raises ValueError: If any parameter is invalid.\"\"\"\n    pass\ndef categorize_income(categories: list, income: float) -> dict:\n    \"\"\"Categorizes the income based on previous expenses.\n\n    :param categories: A list of possible expense categories.\n    :param income: The total income amount to be categorized.\n    :return:\n        dict: A dictionary with the following keys:\n            - category (str): The category to which the income is allocated.\n            - amount (float): The amount allocated to each category.\n    :raises ValueError: If categories is empty or income is not a positive number.\"\"\"\n    pass\ndef read_expenses_csv(file_name: str) -> list:\n    \"\"\"Reads the expenses data from a CSV file and returns a list of dictionaries.\n\n    :param file_name: The name of the CSV file containing expenses data.\n    :return: A list of dictionaries, each representing an expense entry.\n    :raises FileNotFoundError: If the file does not exist.\"\"\"\n    pass\ndef analyze_expenses(expenses: list) -> dict:\n    \"\"\"Analyzes the expenses data to provide insights.\n\n    :param expenses: A list of dictionaries, each representing an expense entry.\n    :return:\n        dict: A dictionary with the following keys:\n            - total_expenses (float): The total amount of expenses.\n            - average_expense (float): The average expense per category.\n            - category_totals (dict): A dictionary with categories as keys and their total expenses.\n    :raises ValueError: If expenses list is empty.\"\"\"\n    pass\n", "function_schema_json": [{"name": "add_event_to_calendar", "description": "Adds an event to Google Calendar.", "parameters": {"type": "object", "properties": {"date": {"type": "string", "description": "The date of the event in 'DD-MM-YYYY' format."}, "time": {"type": "string", "description": "The time of the event in 'HH:MM' format."}, "event_name": {"type": "string", "description": "The name of the event, e.g., 'Payment Reminder'."}}, "required": ["date", "time", "event_name"], "additionalProperties": false}}, {"name": "categorize_income", "description": "Categorizes the income based on previous expenses.", "parameters": {"type": "object", "properties": {"categories": {"type": "array", "description": "A list of possible expense categories."}, "income": {"type": "number", "description": "The total income amount to be categorized."}}, "required": ["categories", "income"], "additionalProperties": false}}, {"name": "read_expenses_csv", "description": "Reads the expenses data from a CSV file and returns a list of dictionaries.", "parameters": {"type": "object", "properties": {"file_name": {"type": "string", "description": "The name of the CSV file containing expenses data."}}, "required": ["file_name"], "additionalProperties": false}}, {"name": "analyze_expenses", "description": "Analyzes the expenses data to provide insights.", "parameters": {"type": "object", "properties": {"expenses": {"type": "array", "description": "A list of dictionaries, each representing an expense entry."}}, "required": ["expenses"], "additionalProperties": false}}], "mock_functions": "def add_event_to_calendar(date: str, time: str, event_name: str) -> bool:\n    \"\"\"\n    Adds an event to Google Calendar.\n    \n    :param date: The date of the event in 'DD-MM-YYYY' format.\n    :param time: The time of the event in 'HH:MM' format.\n    :param event_name: The name of the event, e.g., 'Payment Reminder'.\n    :return: True if the event was successfully added, False otherwise.\n    :raises ValueError: If any parameter is invalid.\n    \"\"\"\n    if not (date and time and event_name):\n        raise ValueError(\"Date, time, and event name must be provided.\")\n    if date in [\"15-03-2023\", \"30-04-2023\"] and event_name == \"Payment Reminder\":\n        return True\n    return False\ndef categorize_income(categories: list, income: float) -> dict:\n    \"\"\"\n    Categorizes the income based on previous expenses.\n    \n    :param categories: A list of possible expense categories.\n    :param income: The total income amount to be categorized.\n    :return:\n        dict: A dictionary with the following keys:\n            - category (str): The category to which the income is allocated.\n            - amount (float): The amount allocated to each category.\n    :raises ValueError: If categories is empty or income is not a positive number.\n    \"\"\"\n    if not categories or income <= 0:\n        raise ValueError(\"Categories must be provided and income must be positive.\")\n    category_distribution = {category: income / len(categories) for category in categories}\n    return category_distribution\ndef read_expenses_csv(file_name: str) -> list:\n    \"\"\"\n    Reads the expenses data from a CSV file and returns a list of dictionaries.\n    \n    :param file_name: The name of the CSV file containing expenses data.\n    :return: A list of dictionaries, each representing an expense entry.\n    :raises FileNotFoundError: If the file does not exist.\n    \"\"\"\n    if file_name != \"expenses2023.csv\":\n        raise FileNotFoundError(\"The file does not exist.\")\n    # Mock expenses data\n    mock_expenses = [\n        {\"category\": \"Utilities\", \"amount\": 200.0},\n        {\"category\": \"Supplies\", \"amount\": 150.0},\n        {\"category\": \"Marketing\", \"amount\": 300.0},\n        {\"category\": \"Salaries\", \"amount\": 1200.0},\n        {\"category\": \"Travel\", \"amount\": 400.0}\n    ]\n    return mock_expenses\ndef analyze_expenses(expenses: list) -> dict:\n    \"\"\"\n    Analyzes the expenses data to provide insights.\n    \n    :param expenses: A list of dictionaries, each representing an expense entry.\n    :return:\n        dict: A dictionary with the following keys:\n            - total_expenses (float): The total amount of expenses.\n            - average_expense (float): The average expense per category.\n            - category_totals (dict): A dictionary with categories as keys and their total expenses.\n    :raises ValueError: If expenses list is empty.\n    \"\"\"\n    if not expenses:\n        raise ValueError(\"Expenses list must not be empty.\")\n    \n    category_totals = {}\n    for expense in expenses:\n        category = expense.get(\"category\")\n        amount = expense.get(\"amount\", 0)\n        if category:\n            category_totals[category] = category_totals.get(category, 0) + amount\n    \n    total_expenses = sum(category_totals.values())\n    average_expense = total_expenses / len(category_totals) if category_totals else 0\n    \n    return {\n        \"total_expenses\": total_expenses,\n        \"average_expense\": average_expense,\n        \"category_totals\": category_totals\n    }", "user_query": "Can you add a calendar event for a payment reminder on 15-03-2024 at 10:00 for the Green Earth project?", "checklist": {"functions": ["add_event_to_calendar"], "values": [false]}}
{"difficulty": "easy", "function_schema_python": "def analyze_business_needs(current_orders: int, projected_orders: int) -> Dict[str, Any]:\n    \"\"\"Analyzes the business needs based on current and projected order volumes.\n\n    :param current_orders: The current number of orders per month.\n    :param projected_orders: The projected number of orders per month.\n    :return: A dictionary containing analysis results.\n        - order_increase (int): The increase in orders.\n        - scaling_factor (float): The factor by which orders are expected to increase.\"\"\"\n    pass\ndef recommend_api_strategy(inventory_system: str, marketplace_platform: str) -> str:\n    \"\"\"Recommends an API integration strategy.\n\n    :param inventory_system: The name of the inventory management system.\n    :param marketplace_platform: The name of the marketplace platform.\n    :return: A string describing the recommended API strategy.\"\"\"\n    pass\ndef design_api_endpoints(required_functionality: List[str]) -> List[Dict[str, str]]:\n    \"\"\"Designs API endpoints based on required functionality.\n\n    :param required_functionality: A list of required functionalities.\n    :return: A list of dictionaries, each representing an API endpoint.\n        - endpoint (str): The API endpoint path.\n        - method (str): The HTTP method (e.g., GET, POST).\n        - description (str): A description of the endpoint's purpose.\"\"\"\n    pass\ndef create_mock_fastapi_app(endpoints: List[Dict[str, str]]) -> str:\n    \"\"\"Mocks a FastAPI app setup based on endpoints.\n    :param endpoints: endpoints to implement\n    :return: a string with the mock code\"\"\"\n    pass\ndef estimate_scaling_costs(scaling_factor: float) -> float:\n    \"\"\"Estimates the costs associated with scaling.\n\n    :param scaling_factor: The factor by which operations are scaled.\n    :return: The estimated cost.\"\"\"\n    pass\n", "function_schema_json": [{"name": "analyze_business_needs", "description": "Analyzes the business needs based on current and projected order volumes.", "parameters": {"type": "object", "properties": {"current_orders": {"type": "integer", "description": "The current number of orders per month."}, "projected_orders": {"type": "integer", "description": "The projected number of orders per month."}}, "required": ["current_orders", "projected_orders"], "additionalProperties": false}}, {"name": "recommend_api_strategy", "description": "Recommends an API integration strategy.", "parameters": {"type": "object", "properties": {"inventory_system": {"type": "string", "description": "The name of the inventory management system."}, "marketplace_platform": {"type": "string", "description": "The name of the marketplace platform."}}, "required": ["inventory_system", "marketplace_platform"], "additionalProperties": false}}, {"name": "design_api_endpoints", "description": "Designs API endpoints based on required functionality.", "parameters": {"type": "object", "properties": {"required_functionality": {"type": "array", "items": {"type": "string"}, "description": "A list of required functionalities."}}, "required": ["required_functionality"], "additionalProperties": false}}, {"name": "create_mock_fastapi_app", "description": "Mocks a FastAPI app setup based on endpoints.", "parameters": {"type": "object", "properties": {"endpoints": {"type": "array", "items": {"type": "object"}, "description": "endpoints to implement"}}, "required": ["endpoints"], "additionalProperties": false}}, {"name": "estimate_scaling_costs", "description": "Estimates the costs associated with scaling.", "parameters": {"type": "object", "properties": {"scaling_factor": {"type": "number", "description": "The factor by which operations are scaled."}}, "required": ["scaling_factor"], "additionalProperties": false}}], "mock_functions": "def analyze_business_needs(current_orders: int, projected_orders: int) -> Dict[str, Any]:\n    \"\"\"\n    Analyzes the business needs based on current and projected order volumes.\n\n    :param current_orders: The current number of orders per month.\n    :param projected_orders: The projected number of orders per month.\n    :return: A dictionary containing analysis results.\n        - order_increase (int): The increase in orders.\n        - scaling_factor (float): The factor by which orders are expected to increase.\n    \"\"\"\n    order_increase = projected_orders - current_orders\n    scaling_factor = projected_orders / current_orders if current_orders > 0 else 0\n    return {\n        \"order_increase\": order_increase,\n        \"scaling_factor\": scaling_factor\n    }\ndef recommend_api_strategy(inventory_system: str, marketplace_platform: str) -> str:\n    \"\"\"\n    Recommends an API integration strategy.\n\n    :param inventory_system: The name of the inventory management system.\n    :param marketplace_platform: The name of the marketplace platform.\n    :return: A string describing the recommended API strategy.\n    \"\"\"\n    return f\"Recommended API strategy for integrating {inventory_system} with {marketplace_platform}:  Use a RESTful API with webhooks for real-time inventory updates and order status synchronization.\"\ndef design_api_endpoints(required_functionality: List[str]) -> List[Dict[str, str]]:\n    \"\"\"\n    Designs API endpoints based on required functionality.\n\n    :param required_functionality: A list of required functionalities.\n    :return: A list of dictionaries, each representing an API endpoint.\n        - endpoint (str): The API endpoint path.\n        - method (str): The HTTP method (e.g., GET, POST).\n        - description (str): A description of the endpoint's purpose.\n    \"\"\"\n    endpoints = []\n    for func in required_functionality:\n        endpoints.append({\n            \"endpoint\": f\"/{func.lower().replace(' ', '_')}\",\n            \"method\": \"POST\" if func.startswith(\"Update\") else \"GET\",\n            \"description\": f\"Endpoint for {func}\"\n        })\n    return endpoints\ndef create_mock_fastapi_app(endpoints: List[Dict[str, str]]) -> str:\n    \"\"\"\n    Mocks a FastAPI app setup based on endpoints.\n    :param endpoints: endpoints to implement\n    :return: a string with the mock code\n    \"\"\"\n    mock_code = \"from fastapi import FastAPI\\napp = FastAPI()\\n\\n\"\n    for endpoint in endpoints:\n        mock_code += f\"@app.{endpoint['method'].lower()}('{endpoint['endpoint']}')\\n\"\n        mock_code += f\"async def {endpoint['endpoint'].replace('/', '_')}(item: dict):\\n\"\n        mock_code += f\"    return item\\n\\n\"\n    return mock_code\ndef estimate_scaling_costs(scaling_factor: float) -> float:\n    \"\"\"\n    Estimates the costs associated with scaling.\n\n    :param scaling_factor: The factor by which operations are scaled.\n    :return: The estimated cost.\n    \"\"\"\n    # Placeholder mock logic\n    return 1000 * scaling_factor", "user_query": "Can you analyze my current 300 monthly orders and projected 600 monthly orders?", "checklist": {"functions": ["analyze_business_needs"], "values": [{"order_increase": 300, "scaling_factor": 2.0}]}}
{"difficulty": "easy", "function_schema_python": "def create_seller_api_key(seller_id: str, permissions: list) -> dict:\n    \"\"\"Creates an API key for third-party sellers.\n\n    :param seller_id: Unique identifier for the seller.\n    :param permissions: List of permitted actions ['inventory', 'orders', 'pricing'].\n    :return: Dictionary containing API credentials.\n    :raises ValueError: If seller_id is invalid or permissions are empty.\"\"\"\n    pass\ndef process_order_batch(orders: list, priority: str) -> dict:\n    \"\"\"Processes a batch of orders automatically.\n\n    :param orders: List of order dictionaries containing order details.\n    :param priority: Processing priority ('high', 'normal', 'low').\n    :return: Dictionary containing processing results.\n    :raises ValueError: If orders list is empty or priority is invalid.\"\"\"\n    pass\ndef validate_seller_inventory(seller_id: str, inventory_data: dict) -> dict:\n    \"\"\"Validates seller inventory data before integration.\n\n    :param seller_id: Unique identifier for the seller.\n    :param inventory_data: Dictionary containing product inventory information.\n    :return: Dictionary containing validation results.\n    :raises ValueError: If seller_id or inventory_data is invalid.\"\"\"\n    pass\n", "function_schema_json": [{"name": "create_seller_api_key", "description": "Creates an API key for third-party sellers.", "parameters": {"type": "object", "properties": {"seller_id": {"type": "string", "description": "Unique identifier for the seller."}, "permissions": {"type": "array", "description": "List of permitted actions ['inventory', 'orders', 'pricing']."}}, "required": ["seller_id", "permissions"], "additionalProperties": false}}, {"name": "process_order_batch", "description": "Processes a batch of orders automatically.", "parameters": {"type": "object", "properties": {"orders": {"type": "array", "description": "List of order dictionaries containing order details."}, "priority": {"type": "string", "description": "Processing priority ('high', 'normal', 'low')."}}, "required": ["orders", "priority"], "additionalProperties": false}}, {"name": "validate_seller_inventory", "description": "Validates seller inventory data before integration.", "parameters": {"type": "object", "properties": {"seller_id": {"type": "string", "description": "Unique identifier for the seller."}, "inventory_data": {"type": "object", "description": "Dictionary containing product inventory information."}}, "required": ["seller_id", "inventory_data"], "additionalProperties": false}}], "mock_functions": "def create_seller_api_key(seller_id: str, permissions: list) -> dict:\n    \"\"\"\n    Creates an API key for third-party sellers.\n    \n    :param seller_id: Unique identifier for the seller.\n    :param permissions: List of permitted actions ['inventory', 'orders', 'pricing'].\n    :return: Dictionary containing API credentials.\n    :raises ValueError: If seller_id is invalid or permissions are empty.\n    \"\"\"\n    if not seller_id or not permissions:\n        raise ValueError(\"Seller ID and permissions must be provided\")\n    if seller_id.startswith(\"TECH_\") and all(p in ['inventory', 'orders', 'pricing'] for p in permissions):\n        return {\n            \"api_key\": f\"tk_{seller_id}_2024\",\n            \"secret\": \"abc123xyz789\",\n            \"permissions\": permissions\n        }\n    raise ValueError(\"Invalid seller ID or permissions\")\ndef process_order_batch(orders: list, priority: str = \"normal\") -> dict:\n    \"\"\"\n    Processes a batch of orders automatically.\n    \n    :param orders: List of order dictionaries containing order details.\n    :param priority: Processing priority ('high', 'normal', 'low').\n    :return: Dictionary containing processing results.\n    :raises ValueError: If orders list is empty or priority is invalid.\n    \"\"\"\n    if not orders or priority not in ['high', 'normal', 'low']:\n        raise ValueError(\"Invalid orders or priority\")\n    \n    processed = len([order for order in orders if order.get('status') == 'pending'])\n    failed = len(orders) - processed\n    \n    return {\n        \"total_processed\": processed,\n        \"failed_orders\": failed,\n        \"processing_time\": f\"{processed * 1.5}s\",\n        \"status\": \"completed\"\n    }\ndef validate_seller_inventory(seller_id: str, inventory_data: dict) -> dict:\n    \"\"\"\n    Validates seller inventory data before integration.\n    \n    :param seller_id: Unique identifier for the seller.\n    :param inventory_data: Dictionary containing product inventory information.\n    :return: Dictionary containing validation results.\n    :raises ValueError: If seller_id or inventory_data is invalid.\n    \"\"\"\n    if not seller_id.startswith(\"TECH_\") or not inventory_data:\n        raise ValueError(\"Invalid seller ID or inventory data\")\n    \n    required_fields = ['sku', 'price', 'quantity']\n    valid_items = sum(1 for item in inventory_data.get('items', [])\n                     if all(field in item for field in required_fields))\n    \n    return {\n        \"valid_items\": valid_items,\n        \"invalid_items\": len(inventory_data.get('items', [])) - valid_items,\n        \"validation_status\": \"passed\" if valid_items > 0 else \"failed\"\n    }", "user_query": "Can you create an API key for seller ID 'TECH_SELLER1' with inventory and orders permissions?", "checklist": {"functions": ["create_seller_api_key"], "values": [{"api_key": "tk_TECH_SELLER1_2024", "secret": "abc123xyz789", "permissions": ["inventory", "orders"]}]}}
{"difficulty": "easy", "function_schema_python": "def create_seller_api_key(seller_id: str, permissions: list) -> dict:\n    \"\"\"Creates an API key for third-party sellers.\n\n    :param seller_id: Unique identifier for the seller.\n    :param permissions: List of permitted actions ['inventory', 'orders', 'pricing'].\n    :return: Dictionary containing API credentials.\n    :raises ValueError: If seller_id is invalid or permissions are empty.\"\"\"\n    pass\ndef process_order_batch(orders: list, priority: str) -> dict:\n    \"\"\"Processes a batch of orders automatically.\n\n    :param orders: List of order dictionaries containing order details.\n    :param priority: Processing priority ('high', 'normal', 'low').\n    :return: Dictionary containing processing results.\n    :raises ValueError: If orders list is empty or priority is invalid.\"\"\"\n    pass\ndef validate_seller_inventory(seller_id: str, inventory_data: dict) -> dict:\n    \"\"\"Validates seller inventory data before integration.\n\n    :param seller_id: Unique identifier for the seller.\n    :param inventory_data: Dictionary containing product inventory information.\n    :return: Dictionary containing validation results.\n    :raises ValueError: If seller_id or inventory_data is invalid.\"\"\"\n    pass\n", "function_schema_json": [{"name": "create_seller_api_key", "description": "Creates an API key for third-party sellers.", "parameters": {"type": "object", "properties": {"seller_id": {"type": "string", "description": "Unique identifier for the seller."}, "permissions": {"type": "array", "description": "List of permitted actions ['inventory', 'orders', 'pricing']."}}, "required": ["seller_id", "permissions"], "additionalProperties": false}}, {"name": "process_order_batch", "description": "Processes a batch of orders automatically.", "parameters": {"type": "object", "properties": {"orders": {"type": "array", "description": "List of order dictionaries containing order details."}, "priority": {"type": "string", "description": "Processing priority ('high', 'normal', 'low')."}}, "required": ["orders", "priority"], "additionalProperties": false}}, {"name": "validate_seller_inventory", "description": "Validates seller inventory data before integration.", "parameters": {"type": "object", "properties": {"seller_id": {"type": "string", "description": "Unique identifier for the seller."}, "inventory_data": {"type": "object", "description": "Dictionary containing product inventory information."}}, "required": ["seller_id", "inventory_data"], "additionalProperties": false}}], "mock_functions": "def create_seller_api_key(seller_id: str, permissions: list) -> dict:\n    \"\"\"\n    Creates an API key for third-party sellers.\n    \n    :param seller_id: Unique identifier for the seller.\n    :param permissions: List of permitted actions ['inventory', 'orders', 'pricing'].\n    :return: Dictionary containing API credentials.\n    :raises ValueError: If seller_id is invalid or permissions are empty.\n    \"\"\"\n    if not seller_id or not permissions:\n        raise ValueError(\"Seller ID and permissions must be provided\")\n    if seller_id.startswith(\"TECH_\") and all(p in ['inventory', 'orders', 'pricing'] for p in permissions):\n        return {\n            \"api_key\": f\"tk_{seller_id}_2024\",\n            \"secret\": \"abc123xyz789\",\n            \"permissions\": permissions\n        }\n    raise ValueError(\"Invalid seller ID or permissions\")\ndef process_order_batch(orders: list, priority: str = \"normal\") -> dict:\n    \"\"\"\n    Processes a batch of orders automatically.\n    \n    :param orders: List of order dictionaries containing order details.\n    :param priority: Processing priority ('high', 'normal', 'low').\n    :return: Dictionary containing processing results.\n    :raises ValueError: If orders list is empty or priority is invalid.\n    \"\"\"\n    if not orders or priority not in ['high', 'normal', 'low']:\n        raise ValueError(\"Invalid orders or priority\")\n    \n    processed = len([order for order in orders if order.get('status') == 'pending'])\n    failed = len(orders) - processed\n    \n    return {\n        \"total_processed\": processed,\n        \"failed_orders\": failed,\n        \"processing_time\": f\"{processed * 1.5}s\",\n        \"status\": \"completed\"\n    }\ndef validate_seller_inventory(seller_id: str, inventory_data: dict) -> dict:\n    \"\"\"\n    Validates seller inventory data before integration.\n    \n    :param seller_id: Unique identifier for the seller.\n    :param inventory_data: Dictionary containing product inventory information.\n    :return: Dictionary containing validation results.\n    :raises ValueError: If seller_id or inventory_data is invalid.\n    \"\"\"\n    if not seller_id.startswith(\"TECH_\") or not inventory_data:\n        raise ValueError(\"Invalid seller ID or inventory data\")\n    \n    required_fields = ['sku', 'price', 'quantity']\n    valid_items = sum(1 for item in inventory_data.get('items', [])\n                     if all(field in item for field in required_fields))\n    \n    return {\n        \"valid_items\": valid_items,\n        \"invalid_items\": len(inventory_data.get('items', [])) - valid_items,\n        \"validation_status\": \"passed\" if valid_items > 0 else \"failed\"\n    }", "user_query": "Please process this batch of pending orders: [{\"id\": 1, \"status\": \"pending\"}, {\"id\": 2, \"status\": \"pending\"}, {\"id\": 3, \"status\": \"pending\"}] with high priority.", "checklist": {"functions": ["process_order_batch"], "values": [{"total_processed": 3, "failed_orders": 0, "processing_time": "4.5s", "status": "completed"}]}}
{"difficulty": "easy", "function_schema_python": "def initiate_token_transfer(sender: str, recipient: str, amount: int) -> Dict:\n    \"\"\"Initiates a token transfer within the BrewMasters loyalty program.\n\n    :param sender: The name of the sender (e.g., \"Alex\").\n    :param recipient: The name of the recipient (e.g., \"Jamie\").\n    :param amount: The amount of loyalty points to transfer.\n    :return: \n        dict: A dictionary containing the transaction status. Keys are:\n            - status (str): Status of the transfer (\"success\" or \"failed\").\n            - message (str): A message describing the status.\n    :raises ValueError: If any input is invalid.\"\"\"\n    pass\ndef get_loyalty_balance(customer_name: str) -> int:\n    \"\"\"Retrieves the loyalty balance for a given customer.\n\n    :param customer_name: The name of the customer.\n    :return: The customer's loyalty balance as an integer.\n    :raises ValueError: If the customer name is invalid.\"\"\"\n    pass\ndef redeem_loyalty_points(customer_name: str, points: int) -> Dict:\n    \"\"\"Redeems loyalty points for a customer.\n\n    :param customer_name: The name of the customer.\n    :param points: The number of points to redeem.\n    :return:\n        dict: A dictionary with the following keys:\n            - status (str): Status of the redemption (\"success\", \"failed\").\n            - message (str): A message providing details.\n    :raises ValueError: If any parameter is invalid.\"\"\"\n    pass\ndef get_smart_contract_status() -> str:\n    \"\"\"Retrieves the status of the BrewMasters smart contract.\n\n    :return: The status of the smart contract (\"deployed\", \"pending\", \"error\").\"\"\"\n    pass\ndef check_transaction_history(customer_name: str) -> List[Dict]:\n    \"\"\"Retrieves the transaction history for a customer.\n\n    :param customer_name: The name of the customer.\n    :return: A list of transaction dictionaries, each with keys:\n            - timestamp (str): Timestamp of the transaction.\n            - type (str): Type of transaction (e.g., \"transfer\", \"redemption\").\n            - amount (int): Amount of points involved.\"\"\"\n    pass\n", "function_schema_json": [{"name": "initiate_token_transfer", "description": "Initiates a token transfer within the BrewMasters loyalty program.", "parameters": {"type": "object", "properties": {"sender": {"type": "string", "description": "The name of the sender (e.g., \"Alex\")."}, "recipient": {"type": "string", "description": "The name of the recipient (e.g., \"Jamie\")."}, "amount": {"type": "integer", "description": "The amount of loyalty points to transfer."}}, "required": ["sender", "recipient", "amount"], "additionalProperties": false}}, {"name": "get_loyalty_balance", "description": "Retrieves the loyalty balance for a given customer.", "parameters": {"type": "object", "properties": {"customer_name": {"type": "string", "description": "The name of the customer."}}, "required": ["customer_name"], "additionalProperties": false}}, {"name": "redeem_loyalty_points", "description": "Redeems loyalty points for a customer.", "parameters": {"type": "object", "properties": {"customer_name": {"type": "string", "description": "The name of the customer."}, "points": {"type": "integer", "description": "The number of points to redeem."}}, "required": ["customer_name", "points"], "additionalProperties": false}}, {"name": "get_smart_contract_status", "description": "Retrieves the status of the BrewMasters smart contract.", "parameters": {"type": "object", "properties": {}, "required": [], "additionalProperties": false}}, {"name": "check_transaction_history", "description": "Retrieves the transaction history for a customer.", "parameters": {"type": "object", "properties": {"customer_name": {"type": "string", "description": "The name of the customer."}}, "required": ["customer_name"], "additionalProperties": false}}], "mock_functions": "def initiate_token_transfer(sender: str, recipient: str, amount: int) -> Dict:\n    \"\"\"\n    Initiates a token transfer within the BrewMasters loyalty program.\n\n    :param sender: The name of the sender (e.g., \"Alex\").\n    :param recipient: The name of the recipient (e.g., \"Jamie\").\n    :param amount: The amount of loyalty points to transfer.\n    :return: \n        dict: A dictionary containing the transaction status. Keys are:\n            - status (str): Status of the transfer (\"success\" or \"failed\").\n            - message (str): A message describing the status.\n    :raises ValueError: If any input is invalid.\n    \"\"\"\n    if not sender or not recipient or amount <= 0:\n        raise ValueError(\"Invalid input parameters.\")\n\n    if sender == \"Alex\" and recipient == \"Jamie\" and amount > 0:\n        return {\"status\": \"failed\", \"message\": \"Insufficient balance or network error.\"}  # Simulating Alex's issue\n    return {\"status\": \"failed\", \"message\": \"Invalid input parameters.\"}\ndef get_loyalty_balance(customer_name: str) -> int:\n    \"\"\"\n    Retrieves the loyalty balance for a given customer.\n\n    :param customer_name: The name of the customer.\n    :return: The customer's loyalty balance as an integer.\n    :raises ValueError: If the customer name is invalid.\n    \"\"\"\n    if not customer_name:\n        raise ValueError(\"Customer name cannot be empty.\")\n    if customer_name == \"Alex\":\n        return 1500  # Example balance for Alex\n    elif customer_name == \"Jamie\":\n        return 500 # Example balance for Jamie\n    return 0\ndef redeem_loyalty_points(customer_name: str, points: int) -> Dict:\n    \"\"\"\n    Redeems loyalty points for a customer.\n\n    :param customer_name: The name of the customer.\n    :param points: The number of points to redeem.\n    :return:\n        dict: A dictionary with the following keys:\n            - status (str): Status of the redemption (\"success\", \"failed\").\n            - message (str): A message providing details.\n    :raises ValueError: If any parameter is invalid.\n    \"\"\"\n    if not customer_name or points <= 0:\n        raise ValueError(\"Invalid input parameters.\")\n    if customer_name == \"Alex\" and points <= 1500:\n        return {\"status\": \"success\", \"message\": f\"{points} points redeemed successfully.\"}\n    elif customer_name == \"Jamie\" and points <= 500:\n        return {\"status\": \"success\", \"message\": f\"{points} points redeemed successfully.\"}\n    else:\n        return {\"status\": \"failed\", \"message\": \"Insufficient points.\"}\ndef get_smart_contract_status() -> str:\n    \"\"\"\n    Retrieves the status of the BrewMasters smart contract.\n\n    :return: The status of the smart contract (\"deployed\", \"pending\", \"error\").\n    \"\"\"\n    return \"deployed\"\ndef check_transaction_history(customer_name: str) -> List[Dict]:\n    \"\"\"\n    Retrieves the transaction history for a customer.\n\n    :param customer_name: The name of the customer.\n    :return: A list of transaction dictionaries, each with keys:\n            - timestamp (str): Timestamp of the transaction.\n            - type (str): Type of transaction (e.g., \"transfer\", \"redemption\").\n            - amount (int): Amount of points involved.\n    \"\"\"\n    if customer_name == \"Alex\":\n        return [\n            {\"timestamp\": \"2024-07-26 10:00:00\", \"type\": \"purchase\", \"amount\": 200},\n            {\"timestamp\": \"2024-07-26 10:05:00\", \"type\": \"transfer\", \"amount\": -100}\n        ]\n    return []", "user_query": "What is my current loyalty point balance for BrewMasters? My name is Alex.", "checklist": {"functions": ["get_loyalty_balance"], "values": [1500]}}
{"difficulty": "easy", "function_schema_python": "def search_academic_repositories(query: str) -> list:\n    \"\"\"Searches academic repositories for research papers related to the given query.\n\n    :param query: The search term or keyword related to the academic research.\n    :return: A list of URLs of research papers matching the query.\n    :raises ValueError: If the query is empty or not a string.\"\"\"\n    pass\ndef parse_pdf(url: str) -> dict:\n    \"\"\"Parses the content of a PDF research paper from the given URL.\n\n    :param url: The URL of the PDF to be parsed.\n    :return:\n        dict: A dictionary with the following keys:\n            - title (str): The title of the research paper.\n            - abstract (str): The abstract of the research paper.\n            - refs (list[str]): A list of references in the research paper.\n            - keywords (list[str]): A list of keywords from the research paper.\n    :raises ValueError: If the URL is empty or not a string.\"\"\"\n    pass\ndef generate_research_clusters(papers: list) -> dict:\n    \"\"\"Generates a visual mapping of research clusters from a list of parsed papers.\n\n    :param papers: A list of dictionaries representing parsed research papers.\n    :return:\n        dict: A dictionary with the following keys:\n            - clusters (list[dict]): A list of clusters, each dict contains:\n                - name (str): The name of the cluster.\n                - size (int): The number of papers in the cluster.\n                - keywords (list[str]): The top keywords in the cluster.\n    :raises ValueError: If the papers list is empty.\"\"\"\n    pass\ndef analyze_keyword_correlations(papers: list) -> dict:\n    \"\"\"Analyzes keyword correlations in a list of parsed papers to identify significant trends.\n\n    :param papers: A list of dictionaries representing parsed research papers.\n    :return:\n        dict: A dictionary with the following keys:\n            - correlations (list[dict]): A list of correlations, each dict contains:\n                - keywords (list[str]): The pair of keywords.\n                - correlation_score (float): The correlation score between the keywords.\n    :raises ValueError: If the papers list is empty.\"\"\"\n    pass\ndef analyze_citation_patterns(papers: list) -> dict:\n    \"\"\"Analyzes citation patterns in a list of parsed papers to understand the impact and influence of research.\n\n    :param papers: A list of dictionaries representing parsed research papers.\n    :return:\n        dict: A dictionary with the following keys:\n            - citations (list[dict]): A list of citation patterns, each dict contains:\n                - paper (str): The title of the paper.\n                - cited_by (int): The number of times the paper is cited.\n    :raises ValueError: If the papers list is empty.\"\"\"\n    pass\n", "function_schema_json": [{"name": "search_academic_repositories", "description": "Searches academic repositories for research papers related to the given query.", "parameters": {"type": "object", "properties": {"query": {"type": "string", "description": "The search term or keyword related to the academic research."}}, "required": ["query"], "additionalProperties": false}}, {"name": "parse_pdf", "description": "Parses the content of a PDF research paper from the given URL.", "parameters": {"type": "object", "properties": {"url": {"type": "string", "description": "The URL of the PDF to be parsed."}}, "required": ["url"], "additionalProperties": false}}, {"name": "generate_research_clusters", "description": "Generates a visual mapping of research clusters from a list of parsed papers.", "parameters": {"type": "object", "properties": {"papers": {"type": "array", "description": "A list of dictionaries representing parsed research papers."}}, "required": ["papers"], "additionalProperties": false}}, {"name": "analyze_keyword_correlations", "description": "Analyzes keyword correlations in a list of parsed papers to identify significant trends.", "parameters": {"type": "object", "properties": {"papers": {"type": "array", "description": "A list of dictionaries representing parsed research papers."}}, "required": ["papers"], "additionalProperties": false}}, {"name": "analyze_citation_patterns", "description": "Analyzes citation patterns in a list of parsed papers to understand the impact and influence of research.", "parameters": {"type": "object", "properties": {"papers": {"type": "array", "description": "A list of dictionaries representing parsed research papers."}}, "required": ["papers"], "additionalProperties": false}}], "mock_functions": "def search_academic_repositories(query: str) -> list:\n    \"\"\"\n    Searches academic repositories for research papers related to the given query.\n    \n    :param query: The search term or keyword related to the academic research.\n    :return: A list of URLs of research papers matching the query.\n    :raises ValueError: If the query is empty or not a string.\n    \"\"\"\n    if not isinstance(query, str) or not query.strip():\n        raise ValueError(\"Query must be a non-empty string.\")\n    mock_urls = [\n        \"http://example.com/paper1.pdf\",\n        \"http://example.com/paper2.pdf\",\n        \"http://example.com/paper3.pdf\"\n    ]\n    return mock_urls\ndef parse_pdf(url: str) -> dict:\n    \"\"\"\n    Parses the content of a PDF research paper from the given URL.\n    \n    :param url: The URL of the PDF to be parsed.\n    :return:\n        dict: A dictionary with the following keys:\n            - title (str): The title of the research paper.\n            - abstract (str): The abstract of the research paper.\n            - refs (list[str]): A list of references in the research paper.\n            - keywords (list[str]): A list of keywords from the research paper.\n    :raises ValueError: If the URL is empty or not a string.\n    \"\"\"\n    if not isinstance(url, str) or not url.strip():\n        raise ValueError(\"URL must be a non-empty string.\")\n    mock_content = {\n        \"title\": \"Evolution of Machine Learning Algorithms\",\n        \"abstract\": \"This paper discusses the evolution of machine learning algorithms over the years.\",\n        \"refs\": [\"Author A et al., Journal of AI, 2020\", \"Author B et al., Conference on Machine Learning, 2019\"],\n        \"keywords\": [\"machine learning\", \"algorithm evolution\", \"scholarly research\"]\n    }\n    return mock_content\ndef generate_research_clusters(papers: list) -> dict:\n    \"\"\"\n    Generates a visual mapping of research clusters from a list of parsed papers.\n    \n    :param papers: A list of dictionaries representing parsed research papers.\n    :return:\n        dict: A dictionary with the following keys:\n            - clusters (list[dict]): A list of clusters, each dict contains:\n                - name (str): The name of the cluster.\n                - size (int): The number of papers in the cluster.\n                - keywords (list[str]): The top keywords in the cluster.\n    :raises ValueError: If the papers list is empty.\n    \"\"\"\n    if not isinstance(papers, list) or not papers:\n        raise ValueError(\"Papers list must be a non-empty list.\")\n    mock_clusters = [\n        {\"name\": \"Cluster 1\", \"size\": 5, \"keywords\": [\"algorithm evolution\", \"AI\"]},\n        {\"name\": \"Cluster 2\", \"size\": 3, \"keywords\": [\"machine learning\", \"statistics\"]}\n    ]\n    return {\"clusters\": mock_clusters}\ndef analyze_keyword_correlations(papers: list) -> dict:\n    \"\"\"\n    Analyzes keyword correlations in a list of parsed papers to identify significant trends.\n    \n    :param papers: A list of dictionaries representing parsed research papers.\n    :return:\n        dict: A dictionary with the following keys:\n            - correlations (list[dict]): A list of correlations, each dict contains:\n                - keywords (list[str]): The pair of keywords.\n                - correlation_score (float): The correlation score between the keywords.\n    :raises ValueError: If the papers list is empty.\n    \"\"\"\n    if not isinstance(papers, list) or not papers:\n        raise ValueError(\"Papers list must be a non-empty list.\")\n    mock_correlations = [\n        {\"keywords\": [\"machine learning\", \"algorithm evolution\"], \"correlation_score\": 0.95},\n        {\"keywords\": [\"statistics\", \"data analysis\"], \"correlation_score\": 0.85}\n    ]\n    return {\"correlations\": mock_correlations}\ndef analyze_citation_patterns(papers: list) -> dict:\n    \"\"\"\n    Analyzes citation patterns in a list of parsed papers to understand the impact and influence of research.\n    \n    :param papers: A list of dictionaries representing parsed research papers.\n    :return:\n        dict: A dictionary with the following keys:\n            - citations (list[dict]): A list of citation patterns, each dict contains:\n                - paper (str): The title of the paper.\n                - cited_by (int): The number of times the paper is cited.\n    :raises ValueError: If the papers list is empty.\n    \"\"\"\n    if not isinstance(papers, list) or not papers:\n        raise ValueError(\"Papers list must be a non-empty list.\")\n    mock_citations = [\n        {\"paper\": \"Evolution of Machine Learning Algorithms\", \"cited_by\": 50},\n        {\"paper\": \"Another Paper\", \"cited_by\": 30}\n    ]\n    return {\"citations\": mock_citations}", "user_query": "Can you search academic repositories for \"machine learning algorithm evolution\"?", "checklist": {"functions": ["search_academic_repositories"], "values": [["http://example.com/paper1.pdf", "http://example.com/paper2.pdf", "http://example.com/paper3.pdf"]]}}
{"difficulty": "easy", "function_schema_python": "def verify_user_alt(username: str, security_question_answer: str) -> bool:\n    \"\"\"Verifies user identity using alternative methods.\n\n    :param username: The username of the user to verify.\n    :param security_question_answer: The answer to a previously set security question.\n    :return: True if the user is verified, False otherwise.\n    :raises ValueError: If the username or security question answer is empty.\"\"\"\n    pass\ndef check_access_control(user_id: int) -> bool:\n    \"\"\"Checks user access permissions.\n\n    :param user_id: The ID of the user to check.\n    :return: True if the user has proper access, False otherwise.\n    :raises ValueError: If the user ID is not provided or invalid.\"\"\"\n    pass\ndef check_calendar_sync(user_id: int) -> bool:\n    \"\"\"Checks for calendar synchronization issues.\n\n    :param user_id: The ID of the user to check.\n    :return: True if there are no synchronization issues, False otherwise.\n    :raises ValueError: If the user ID is not provided or invalid.\"\"\"\n    pass\ndef reset_password(user_id: int) -> dict:\n    \"\"\"Initiates a secure password reset process.\n\n    :param user_id: The ID of the user to reset the password for.\n    :return:\n        dict: A dictionary with the following keys:\n            - status (bool): True if the password reset is initiated successfully, False otherwise.\n            - message (str): A status message.\n    :raises ValueError: If the user ID is not provided or invalid.\"\"\"\n    pass\n", "function_schema_json": [{"name": "verify_user_alt", "description": "Verifies user identity using alternative methods.", "parameters": {"type": "object", "properties": {"username": {"type": "string", "description": "The username of the user to verify."}, "security_question_answer": {"type": "string", "description": "The answer to a previously set security question."}}, "required": ["username", "security_question_answer"], "additionalProperties": false}}, {"name": "check_access_control", "description": "Checks user access permissions.", "parameters": {"type": "object", "properties": {"user_id": {"type": "integer", "description": "The ID of the user to check."}}, "required": ["user_id"], "additionalProperties": false}}, {"name": "check_calendar_sync", "description": "Checks for calendar synchronization issues.", "parameters": {"type": "object", "properties": {"user_id": {"type": "integer", "description": "The ID of the user to check."}}, "required": ["user_id"], "additionalProperties": false}}, {"name": "reset_password", "description": "Initiates a secure password reset process.", "parameters": {"type": "object", "properties": {"user_id": {"type": "integer", "description": "The ID of the user to reset the password for."}}, "required": ["user_id"], "additionalProperties": false}}], "mock_functions": "def verify_user_alt(username: str, security_question_answer: str) -> bool:\n    \"\"\"\n    Verifies user identity using alternative methods.\n    \n    :param username: The username of the user to verify.\n    :param security_question_answer: The answer to a previously set security question.\n    :return: True if the user is verified, False otherwise.\n    :raises ValueError: If the username or security question answer is empty.\n    \"\"\"\n    if not username or not security_question_answer:\n        raise ValueError(\"Username and security question answer must be provided.\")\n    if username == \"john.doe123\" and security_question_answer == \"mydogspot\":\n        return True\n    return False\ndef check_access_control(user_id: int) -> bool:\n    \"\"\"\n    Checks user access permissions.\n    \n    :param user_id: The ID of the user to check.\n    :return: True if the user has proper access, False otherwise.\n    :raises ValueError: If the user ID is not provided or invalid.\n    \"\"\"\n    if not user_id:\n        raise ValueError(\"User ID must be provided.\")\n    if user_id == 9876:\n        return True\n    return False\ndef check_calendar_sync(user_id: int) -> bool:\n    \"\"\"\n    Checks for calendar synchronization issues.\n    \n    :param user_id: The ID of the user to check.\n    :return: True if there are no synchronization issues, False otherwise.\n    :raises ValueError: If the user ID is not provided or invalid.\n    \"\"\"\n    if not user_id:\n        raise ValueError(\"User ID must be provided.\")\n    if user_id == 9876:\n        return False  # Simulate a synchronization issue\n    return True\ndef reset_password(user_id: int) -> dict:\n    \"\"\"\n    Initiates a secure password reset process.\n    \n    :param user_id: The ID of the user to reset the password for.\n    :return:\n        dict: A dictionary with the following keys:\n            - status (bool): True if the password reset is initiated successfully, False otherwise.\n            - message (str): A status message.\n    :raises ValueError: If the user ID is not provided or invalid.\n    \"\"\"\n    if not user_id:\n        raise ValueError(\"User ID must be provided.\")\n    if user_id == 9876:\n        return {\n            \"status\": True,\n            \"message\": \"Password reset initiated successfully.\"\n        }\n    return {\n        \"status\": False,\n        \"message\": \"Failed to initiate password reset.\"\n    }", "user_query": "This is John. Could you verify my identity using my username 'john.doe123' and my answer 'mydogspot' to the security question?", "checklist": {"functions": ["verify_user_alt"], "values": [true]}}
{"difficulty": "easy", "function_schema_python": "def fetch_logs(log_system_id: str, server_ip: str) -> str:\n    \"\"\"Fetches log data from the specified log management system for a given server.\n\n    :param log_system_id: The ID of the log management system.\n    :param server_ip: The IP address of the server whose logs are requested.\n    :return: A string containing the log data.\n    :raises ValueError: If log_system_id or server_ip is not valid.\"\"\"\n    pass\ndef identify_unusual_login_attempts(log_data: str, internal_ip_range: str) -> list:\n    \"\"\"Identifies unusual login attempts from outside the specified internal IP range.\n\n    :param log_data: The log data as a string.\n    :param internal_ip_range: The internal IP range in CIDR notation.\n    :return: A list of unusual login attempt log entries.\"\"\"\n    pass\ndef analyze_log_for_brute_force(log_data: str, threshold: int) -> dict:\n    \"\"\"Analyzes the log data to identify potential brute-force attacks.\n\n    :param log_data: The log data as a string.\n    :param threshold: The number of failed login attempts within a short period to consider as brute-force.\n    :return:\n        dict: A dictionary with the following keys:\n            - ip_addresses (list[str]): List of IP addresses exhibiting brute-force behavior.\n            - attempts (int): Number of attempts for the most suspicious IP.\"\"\"\n    pass\n", "function_schema_json": [{"name": "fetch_logs", "description": "Fetches log data from the specified log management system for a given server.", "parameters": {"type": "object", "properties": {"log_system_id": {"type": "string", "description": "The ID of the log management system."}, "server_ip": {"type": "string", "description": "The IP address of the server whose logs are requested."}}, "required": ["log_system_id", "server_ip"], "additionalProperties": false}}, {"name": "identify_unusual_login_attempts", "description": "Identifies unusual login attempts from outside the specified internal IP range.", "parameters": {"type": "object", "properties": {"log_data": {"type": "string", "description": "The log data as a string."}, "internal_ip_range": {"type": "string", "description": "The internal IP range in CIDR notation."}}, "required": ["log_data", "internal_ip_range"], "additionalProperties": false}}, {"name": "analyze_log_for_brute_force", "description": "Analyzes the log data to identify potential brute-force attacks.", "parameters": {"type": "object", "properties": {"log_data": {"type": "string", "description": "The log data as a string."}, "threshold": {"type": "integer", "description": "The number of failed login attempts within a short period to consider as brute-force."}}, "required": ["log_data", "threshold"], "additionalProperties": false}}], "mock_functions": "def fetch_logs(log_system_id: str, server_ip: str) -> str:\n    \"\"\"\n    Fetches log data from the specified log management system for a given server.\n    \n    :param log_system_id: The ID of the log management system.\n    :param server_ip: The IP address of the server whose logs are requested.\n    :return: A string containing the log data.\n    :raises ValueError: If log_system_id or server_ip is not valid.\n    \"\"\"\n    if log_system_id != \"GLT-LMS-42\":\n        raise ValueError(\"Invalid log management system ID.\")\n    if server_ip != \"192.168.1.100\":\n        raise ValueError(\"Invalid server IP address.\")\n    # Mock log data\n    return \"\"\"\n    2023-10-01T12:00:00 192.168.1.50 192.168.1.100 login failed\n    2023-10-01T12:01:00 192.168.1.51 192.168.1.100 login failed\n    2023-10-01T12:02:00 192.168.1.50 192.168.1.100 login failed\n    2023-10-01T12:03:00 192.168.1.51 192.168.1.100 login failed\n    2023-10-01T12:05:00 203.0.113.1 192.168.1.100 login failed\n    2023-10-01T12:06:00 203.0.113.2 192.168.1.100 login failed\n    2023-10-01T12:07:00 203.0.113.1 192.168.1.100 login failed\n    \"\"\"\ndef identify_unusual_login_attempts(log_data: str, internal_ip_range: str) -> list:\n    \"\"\"\n    Identifies unusual login attempts from outside the specified internal IP range.\n    \n    :param log_data: The log data as a string.\n    :param internal_ip_range: The internal IP range in CIDR notation.\n    :return: A list of unusual login attempt log entries.\n    \"\"\"\n    unusual_attempts = []\n    # Regular expression to match log entries\n    pattern = re.compile(r'(\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2})\\s+(\\d+\\.\\d+\\.\\d+\\.\\d+)\\s+\\d+\\.\\d+\\.\\d+\\.\\d+\\s+login failed')\n    for match in pattern.finditer(log_data):\n        timestamp, source_ip = match.groups()\n        # Check if the source IP is outside the internal IP range\n        if not source_ip.startswith('192.168.1'):\n            unusual_attempts.append(f\"{timestamp} {source_ip} login failed\")\n    return unusual_attempts\ndef analyze_log_for_brute_force(log_data: str, threshold: int) -> dict:\n    \"\"\"\n    Analyzes the log data to identify potential brute-force attacks.\n    \n    :param log_data: The log data as a string.\n    :param threshold: The number of failed login attempts within a short period to consider as brute-force.\n    :return:\n        dict: A dictionary with the following keys:\n            - ip_addresses (list[str]): List of IP addresses exhibiting brute-force behavior.\n            - attempts (int): Number of attempts for the most suspicious IP.\n    \"\"\"\n    ip_attempts = {}\n    # Regular expression to match log entries\n    pattern = re.compile(r'(\\d+\\.\\d+\\.\\d+\\.\\d+)')\n    for match in pattern.findall(log_data):\n        ip_attempts[match] = ip_attempts.get(match, 0) + 1\n    # Find the IP with the highest number of attempts\n    suspicious_ip = max(ip_attempts, key=ip_attempts.get)\n    return {\n        \"ip_addresses\": [ip for ip, attempts in ip_attempts.items() if attempts >= threshold],\n        \"attempts\": ip_attempts[suspicious_ip]\n    }", "user_query": "Can you fetch the logs for server 192.168.1.100 from log system GLT-LMS-42?", "checklist": {"functions": ["fetch_logs"], "values": ["2023-10-01T12:00:00 192.168.1.50 192.168.1.100 login failed\n2023-10-01T12:01:00 192.168.1.51 192.168.1.100 login failed\n2023-10-01T12:02:00 192.168.1.50 192.168.1.100 login failed\n2023-10-01T12:03:00 192.168.1.51 192.168.1.100 login failed\n2023-10-01T12:05:00 203.0.113.1 192.168.1.100 login failed\n2023-10-01T12:06:00 203.0.113.2 192.168.1.100 login failed\n2023-10-01T12:07:00 203.0.113.1 192.168.1.100 login failed\n"]}}
{"difficulty": "easy", "function_schema_python": "def implement_api_keys(api_key_type: str, security_level: str) -> Dict[str, str]:\n    \"\"\"Implements API keys for authentication.\n\n    :param api_key_type: The type of API key to implement (e.g., \"UUID\", \"Bearer\").\n    :param security_level: The desired security level (e.g., \"high\", \"medium\").\n    :return: A dictionary containing the implemented API key details.\n        - type (str): The type of API key implemented.\n        - level (str): The security level implemented.\n    :raises ValueError: If invalid parameters are provided.\"\"\"\n    pass\ndef handle_user_sessions(session_management: str, encryption_method: str) -> bool:\n    \"\"\"Handles user sessions securely.\n\n    :param session_management: The session management method (e.g., \"JWT\", \"server-side\").\n    :param encryption_method: The encryption method to use (e.g., \"AES-256\", \"RSA\").\n    :return: True if sessions are handled successfully, False otherwise.\n    :raises ValueError: If invalid parameters are provided.\"\"\"\n    pass\ndef secure_health_records(data_encryption: str, access_control: str) -> str:\n    \"\"\"Secures health records using encryption and access control.\n\n    :param data_encryption: The encryption method for health data.\n    :param access_control: The access control method to implement.\n    :return: A string confirming the security implementation.\n    :raises ValueError: If invalid parameters are provided.\"\"\"\n    pass\ndef consult_smart_agent(query: str) -> str:\n    \"\"\"Consults the smart agent, Maya, for advice.\n\n    :param query: The query to ask Maya.\n    :return: Maya's response to the query.\n    :raises ValueError: If the query is empty.\"\"\"\n    pass\n", "function_schema_json": [{"name": "implement_api_keys", "description": "Implements API keys for authentication.", "parameters": {"type": "object", "properties": {"api_key_type": {"type": "string", "description": "The type of API key to implement (e.g., \"UUID\", \"Bearer\")."}, "security_level": {"type": "string", "description": "The desired security level (e.g., \"high\", \"medium\")."}}, "required": ["api_key_type", "security_level"], "additionalProperties": false}}, {"name": "handle_user_sessions", "description": "Handles user sessions securely.", "parameters": {"type": "object", "properties": {"session_management": {"type": "string", "description": "The session management method (e.g., \"JWT\", \"server-side\")."}, "encryption_method": {"type": "string", "description": "The encryption method to use (e.g., \"AES-256\", \"RSA\")."}}, "required": ["session_management", "encryption_method"], "additionalProperties": false}}, {"name": "secure_health_records", "description": "Secures health records using encryption and access control.", "parameters": {"type": "object", "properties": {"data_encryption": {"type": "string", "description": "The encryption method for health data."}, "access_control": {"type": "string", "description": "The access control method to implement."}}, "required": ["data_encryption", "access_control"], "additionalProperties": false}}, {"name": "consult_smart_agent", "description": "Consults the smart agent, Maya, for advice.", "parameters": {"type": "object", "properties": {"query": {"type": "string", "description": "The query to ask Maya."}}, "required": ["query"], "additionalProperties": false}}], "mock_functions": "def implement_api_keys(api_key_type: str, security_level: str) -> Dict[str, str]:\n    \"\"\"\n    Implements API keys for authentication.\n\n    :param api_key_type: The type of API key to implement (e.g., \"UUID\", \"Bearer\").\n    :param security_level: The desired security level (e.g., \"high\", \"medium\").\n    :return: A dictionary containing the implemented API key details.\n        - type (str): The type of API key implemented.\n        - level (str): The security level implemented.\n    :raises ValueError: If invalid parameters are provided.\n    \"\"\"\n    if not api_key_type or not security_level:\n        raise ValueError(\"API key type and security level must be provided.\")\n\n    if api_key_type.lower() in [\"uuid\", \"bearer\"] and security_level.lower() in [\"high\", \"medium\", \"low\"]:\n        return {\"type\": api_key_type, \"level\": security_level}\n    else:\n        raise ValueError(\"Invalid API key type or security level.\")\ndef handle_user_sessions(session_management: str, encryption_method: str) -> bool:\n    \"\"\"\n    Handles user sessions securely.\n\n    :param session_management: The session management method (e.g., \"JWT\", \"server-side\").\n    :param encryption_method: The encryption method to use (e.g., \"AES-256\", \"RSA\").\n    :return: True if sessions are handled successfully, False otherwise.\n    :raises ValueError: If invalid parameters are provided.\n    \"\"\"\n    if not session_management or not encryption_method:\n        raise ValueError(\"Session management and encryption method must be provided.\")\n\n    if session_management.lower() in [\"jwt\", \"server-side\"] and encryption_method in [\"aes-256\", \"rsa\"]:\n        return True\n    else:\n        return False\ndef secure_health_records(data_encryption: str, access_control: str) -> str:\n    \"\"\"\n    Secures health records using encryption and access control.\n\n    :param data_encryption: The encryption method for health data.\n    :param access_control: The access control method to implement.\n    :return: A string confirming the security implementation.\n    :raises ValueError: If invalid parameters are provided.\n    \"\"\"\n    if not data_encryption or not access_control:\n        raise ValueError(\"Data encryption and access control methods must be provided.\")\n    return f\"Health records secured with {data_encryption} encryption and {access_control} access control.\"\ndef consult_smart_agent(query: str) -> str:\n    \"\"\"\n    Consults the smart agent, Maya, for advice.\n\n    :param query: The query to ask Maya.\n    :return: Maya's response to the query.\n    :raises ValueError: If the query is empty.\n    \"\"\"\n    if not query:\n        raise ValueError(\"Query cannot be empty.\")\n\n    if \"best practices\" in query.lower() and \"api keys\" in query.lower() and \"user sessions\" in query.lower():\n        return \"Recommend using strong encryption like AES-256 for user sessions and UUIDs for API keys with high security levels.\"\n    elif \"secure health records\" in query.lower():\n        return \"Implement end-to-end encryption and role-based access control for maximum security.\"\n    else:\n        return \"I am still learning about that topic.\"", "user_query": "This is Mark from HealthLink. How can I handle user sessions securely using JWT with AES-256 encryption for the VitalTrack app?", "checklist": {"functions": ["handle_user_sessions"], "values": [true]}}
{"difficulty": "easy", "function_schema_python": "def load_sales_data(region: str, quarter: str) -> list:\n    \"\"\"Loads historical sales data for a specific region and quarter.\n\n    :param region: The name of the region (e.g., \"North\", \"South\").\n    :param quarter: The quarter for which to load sales data (e.g., \"Q1\", \"Q2\").\n    :return: A list of dictionaries representing sales data.\n    :raises ValueError: If the region or quarter is not recognized.\"\"\"\n    pass\ndef train_predictive_model(data: list) -> dict:\n    \"\"\"Trains a predictive model using the given sales data.\n\n    :param data: A list of dictionaries representing sales data.\n    :return: A dictionary with the model's parameters.\n    :raises ValueError: If the data list is empty.\"\"\"\n    pass\ndef evaluate_model_performance(model_params: dict, test_data: list) -> dict:\n    \"\"\"Evaluates the performance of a predictive model using test data.\n\n    :param model_params: A dictionary containing the model's parameters.\n    :param test_data: A list of dictionaries representing test sales data.\n    :return:\n        dict: A dictionary with the following keys:\n            - accuracy (float): The accuracy of the model's predictions.\n            - error_margin (float): The margin of error.\n    :raises ValueError: If model_params or test_data is invalid.\"\"\"\n    pass\ndef is_model_within_error_margin(evaluation: dict) -> bool:\n    \"\"\"Checks if the model's error margin is within an acceptable range.\n\n    :param evaluation: A dictionary containing the evaluation results.\n    :return: True if the error margin is within the acceptable range, False otherwise.\n    :raises ValueError: If the evaluation dictionary is invalid.\"\"\"\n    pass\n", "function_schema_json": [{"name": "load_sales_data", "description": "Loads historical sales data for a specific region and quarter.", "parameters": {"type": "object", "properties": {"region": {"type": "string", "description": "The name of the region (e.g., \"North\", \"South\")."}, "quarter": {"type": "string", "description": "The quarter for which to load sales data (e.g., \"Q1\", \"Q2\")."}}, "required": ["region", "quarter"], "additionalProperties": false}}, {"name": "train_predictive_model", "description": "Trains a predictive model using the given sales data.", "parameters": {"type": "object", "properties": {"data": {"type": "array", "description": "A list of dictionaries representing sales data."}}, "required": ["data"], "additionalProperties": false}}, {"name": "evaluate_model_performance", "description": "Evaluates the performance of a predictive model using test data.", "parameters": {"type": "object", "properties": {"model_params": {"type": "object", "description": "A dictionary containing the model's parameters."}, "test_data": {"type": "array", "description": "A list of dictionaries representing test sales data."}}, "required": ["model_params", "test_data"], "additionalProperties": false}}, {"name": "is_model_within_error_margin", "description": "Checks if the model's error margin is within an acceptable range.", "parameters": {"type": "object", "properties": {"evaluation": {"type": "object", "description": "A dictionary containing the evaluation results."}}, "required": ["evaluation"], "additionalProperties": false}}], "mock_functions": "def load_sales_data(region: str, quarter: str) -> list:\n    \"\"\"\n    Loads historical sales data for a specific region and quarter.\n    \n    :param region: The name of the region (e.g., \"North\", \"South\").\n    :param quarter: The quarter for which to load sales data (e.g., \"Q1\", \"Q2\").\n    :return: A list of dictionaries representing sales data.\n    :raises ValueError: If the region or quarter is not recognized.\n    \"\"\"\n    if region not in [f\"Region{i}\" for i in range(1, 26)]:\n        raise ValueError(\"Invalid region specified.\")\n    if quarter not in [\"Q1\", \"Q2\", \"Q3\", \"Q4\"]:\n        raise ValueError(\"Invalid quarter specified.\")\n    \n    # Mock data generation\n    sales_data = [\n        {\"date\": f\"2023-{random.randint(1, 4)}-{random.randint(10, 25)}\", \"amount\": round(random.uniform(100.0, 5000.0), 2)}\n        for _ in range(random.randint(50, 100))\n    ]\n    return sales_data\ndef train_predictive_model(data: list) -> dict:\n    \"\"\"\n    Trains a predictive model using the given sales data.\n    \n    :param data: A list of dictionaries representing sales data.\n    :return: A dictionary with the model's parameters.\n    :raises ValueError: If the data list is empty.\n    \"\"\"\n    if not data:\n        raise ValueError(\"Data list cannot be empty.\")\n    \n    # Mock model training\n    model_params = {\n        \"coefficients\": [round(random.uniform(-1.0, 1.0), 2) for _ in range(5)],\n        \"intercept\": round(random.uniform(-1.0, 1.0), 2),\n        \"error\": round(random.uniform(0.0, 0.2), 3)  # Simulated error\n    }\n    return model_params\ndef evaluate_model_performance(model_params: dict, test_data: list) -> dict:\n    \"\"\"\n    Evaluates the performance of a predictive model using test data.\n    \n    :param model_params: A dictionary containing the model's parameters.\n    :param test_data: A list of dictionaries representing test sales data.\n    :return:\n        dict: A dictionary with the following keys:\n            - accuracy (float): The accuracy of the model's predictions.\n            - error_margin (float): The margin of error.\n    :raises ValueError: If model_params or test_data is invalid.\n    \"\"\"\n    if not model_params or not isinstance(model_params, dict):\n        raise ValueError(\"Model parameters must be a valid dictionary.\")\n    if not test_data:\n        raise ValueError(\"Test data list cannot be empty.\")\n    \n    # Mock performance evaluation\n    accuracy = round(1.0 - model_params['error'], 3)\n    error_margin = round(random.uniform(0.0, 0.1), 3)  # Simulated error margin\n    \n    return {\n        \"accuracy\": accuracy,\n        \"error_margin\": error_margin\n    }\ndef is_model_within_error_margin(evaluation: dict) -> bool:\n    \"\"\"\n    Checks if the model's error margin is within an acceptable range.\n    \n    :param evaluation: A dictionary containing the evaluation results.\n    :return: True if the error margin is within the acceptable range, False otherwise.\n    :raises ValueError: If the evaluation dictionary is invalid.\n    \"\"\"\n    if not evaluation or not isinstance(evaluation, dict) or \"error_margin\" not in evaluation:\n        raise ValueError(\"Evaluation must be a valid dictionary containing an error_margin key.\")\n    \n    acceptable_margin = 0.05\n    return evaluation[\"error_margin\"] <= acceptable_margin", "user_query": "Can you load sales data for Region1 for Q2?", "checklist": {"functions": ["load_sales_data"], "values": [{"type": "list", "contains": "dictionaries with date and amount keys"}]}}
{"difficulty": "easy", "function_schema_python": "def monitor_cpu_usage(threshold: float) -> float:\n    \"\"\"Monitors the CPU usage in real-time and returns the current CPU usage percentage.\n\n    :param threshold: The CPU usage threshold percentage (e.g., 85.0).\n    :return: The current CPU usage percentage.\n    :raises ValueError: If the threshold is not a valid number between 0 and 100.\"\"\"\n    pass\ndef restart_services(threshold: float) -> bool:\n    \"\"\"Automatically restarts services if CPU usage exceeds the given threshold.\n\n    :param threshold: The CPU usage threshold percentage (e.g., 85.0).\n    :return: True if services were restarted, False otherwise.\n    :raises ValueError: If the threshold is not a valid number between 0 and 100.\"\"\"\n    pass\ndef create_backup_snapshot(service_name: str, backup_path: str) -> dict:\n    \"\"\"Creates a backup snapshot of a critical system configuration for the specified service.\n\n    :param service_name: The name of the service to back up.\n    :param backup_path: The path where the backup should be stored.\n    :return: A dictionary with the status of the backup operation.\n        dict: A dictionary with the following keys:\n            - success (bool): True if the backup was successful, False otherwise.\n            - message (str): A status message describing the result.\n    :raises ValueError: If service_name or backup_path is empty.\"\"\"\n    pass\ndef generate_system_alert(alert_message: str, alert_level: str) -> bool:\n    \"\"\"Generates an alert for unexpected system state changes.\n\n    :param alert_message: The message to be included in the alert.\n    :param alert_level: The level of the alert (e.g., \"critical\", \"warning\").\n    :return: True if the alert was generated successfully, False otherwise.\n    :raises ValueError: If alert_message or alert_level is empty.\"\"\"\n    pass\ndef log_activity(activity_description: str, log_file: str) -> bool:\n    \"\"\"Logs all script activities for audit and troubleshooting purposes.\n\n    :param activity_description: The description of the activity to be logged.\n    :param log_file: The file path where the activity should be logged.\n    :return: True if the activity was logged successfully, False otherwise.\n    :raises ValueError: If activity_description or log_file is empty.\n    :raises IOError: If the log file cannot be written.\"\"\"\n    pass\n", "function_schema_json": [{"name": "monitor_cpu_usage", "description": "Monitors the CPU usage in real-time and returns the current CPU usage percentage.", "parameters": {"type": "object", "properties": {"threshold": {"type": "number", "description": "The CPU usage threshold percentage (e.g., 85.0)."}}, "required": ["threshold"], "additionalProperties": false}}, {"name": "restart_services", "description": "Automatically restarts services if CPU usage exceeds the given threshold.", "parameters": {"type": "object", "properties": {"threshold": {"type": "number", "description": "The CPU usage threshold percentage (e.g., 85.0)."}}, "required": ["threshold"], "additionalProperties": false}}, {"name": "create_backup_snapshot", "description": "Creates a backup snapshot of a critical system configuration for the specified service.", "parameters": {"type": "object", "properties": {"service_name": {"type": "string", "description": "The name of the service to back up."}, "backup_path": {"type": "string", "description": "The path where the backup should be stored."}}, "required": ["service_name", "backup_path"], "additionalProperties": false}}, {"name": "generate_system_alert", "description": "Generates an alert for unexpected system state changes.", "parameters": {"type": "object", "properties": {"alert_message": {"type": "string", "description": "The message to be included in the alert."}, "alert_level": {"type": "string", "description": "The level of the alert (e.g., \"critical\", \"warning\")."}}, "required": ["alert_message", "alert_level"], "additionalProperties": false}}, {"name": "log_activity", "description": "Logs all script activities for audit and troubleshooting purposes.", "parameters": {"type": "object", "properties": {"activity_description": {"type": "string", "description": "The description of the activity to be logged."}, "log_file": {"type": "string", "description": "The file path where the activity should be logged."}}, "required": ["activity_description", "log_file"], "additionalProperties": false}}], "mock_functions": "def monitor_cpu_usage(threshold: float) -> float:\n    \"\"\"\n    Monitors the CPU usage in real-time and returns the current CPU usage percentage.\n    \n    :param threshold: The CPU usage threshold percentage (e.g., 85.0).\n    :return: The current CPU usage percentage.\n    :raises ValueError: If the threshold is not a valid number between 0 and 100.\n    \"\"\"\n    if not (0 <= threshold <= 100):\n        raise ValueError(\"Threshold must be a number between 0 and 100.\")\n    # Mock logic: Return a random CPU usage value less than or equal to 100.\n    current_cpu_usage = psutil.cpu_percent(interval=1)\n    return current_cpu_usage\ndef restart_services(threshold: float) -> bool:\n    \"\"\"\n    Automatically restarts services if CPU usage exceeds the given threshold.\n    \n    :param threshold: The CPU usage threshold percentage (e.g., 85.0).\n    :return: True if services were restarted, False otherwise.\n    :raises ValueError: If the threshold is not a valid number between 0 and 100.\n    \"\"\"\n    if not (0 <= threshold <= 100):\n        raise ValueError(\"Threshold must be a number between 0 and 100.\")\n    # Mock logic: Assume services are restarted if CPU usage is over 85.\n    current_cpu_usage = monitor_cpu_usage(threshold)\n    if current_cpu_usage > threshold:\n        print(\"CPU usage exceeded threshold. Restarting services...\")\n        return True\n    return False\ndef create_backup_snapshot(service_name: str, backup_path: str) -> dict:\n    \"\"\"\n    Creates a backup snapshot of a critical system configuration for the specified service.\n    \n    :param service_name: The name of the service to back up.\n    :param backup_path: The path where the backup should be stored.\n    :return: A dictionary with the status of the backup operation.\n        dict: A dictionary with the following keys:\n            - success (bool): True if the backup was successful, False otherwise.\n            - message (str): A status message describing the result.\n    :raises ValueError: If service_name or backup_path is empty.\n    \"\"\"\n    if not service_name or not backup_path:\n        raise ValueError(\"Service name and backup path must not be empty.\")\n    # Mock logic: Assume backup is successful if service_name is valid.\n    print(f\"Creating backup for {service_name} at {backup_path}\")\n    return {\n        \"success\": True,\n        \"message\": f\"Backup for {service_name} was successful.\"\n    }\ndef generate_system_alert(alert_message: str, alert_level: str) -> bool:\n    \"\"\"\n    Generates an alert for unexpected system state changes.\n    \n    :param alert_message: The message to be included in the alert.\n    :param alert_level: The level of the alert (e.g., \"critical\", \"warning\").\n    :return: True if the alert was generated successfully, False otherwise.\n    :raises ValueError: If alert_message or alert_level is empty.\n    \"\"\"\n    if not alert_message or not alert_level:\n        raise ValueError(\"Alert message and alert level must not be empty.\")\n    # Mock logic: Assume alert is generated successfully.\n    print(f\"Alert generated: {alert_level} - {alert_message}\")\n    return True\ndef log_activity(activity_description: str, log_file: str) -> bool:\n    \"\"\"\n    Logs all script activities for audit and troubleshooting purposes.\n    \n    :param activity_description: The description of the activity to be logged.\n    :param log_file: The file path where the activity should be logged.\n    :return: True if the activity was logged successfully, False otherwise.\n    :raises ValueError: If activity_description or log_file is empty.\n    :raises IOError: If the log file cannot be written.\n    \"\"\"\n    if not activity_description or not log_file:\n        raise ValueError(\"Activity description and log file must not be empty.\")\n    # Mock logic: Assume logging is successful if file and description are valid.\n    try:\n        with open(log_file, 'a') as file:\n            file.write(activity_description + '\\n')\n        return True\n    except IOError:\n        raise IOError(\"Failed to write to log file.\")", "user_query": "What's the current CPU usage with a threshold of 85%?", "checklist": {"functions": ["monitor_cpu_usage"], "values": [83.0]}}
{"difficulty": "easy", "function_schema_python": "def get_employee_birthdays(month: str, year: int) -> List[Tuple[str, str]]:\n    \"\"\"Retrieves employee birthdays for a given month and year.\n\n    :param month: The month for which to retrieve birthdays (e.g., \"January\", \"February\").\n    :param year: The year for which to retrieve birthdays.\n    :return: A list of tuples, where each tuple contains (employee_name, birthday_date).\"\"\"\n    pass\ndef create_calendar_event(date: str, time: str, timezone: str, attendees: List[str], reminder_category: str) -> bool:\n    \"\"\"Creates a calendar event with specified details.\n\n    :param date: The date of the event (e.g., \"2024-01-15\").\n    :param time: The time of the event (e.g., \"10:00 AM\").\n    :param timezone: The timezone for the event (e.g., \"EST\", \"PST\", \"GMT\").\n    :param attendees: A list of employee names to invite.\n    :param reminder_category: The reminder category (e.g., \"department-wide\", \"team-specific\").\n    :return: True if the event was created successfully, False otherwise.\"\"\"\n    pass\ndef set_event_permissions(event_id: str, permissions: Dict[str, bool]) -> bool:\n    \"\"\"Sets permissions for a calendar event.\n\n    :param event_id: The ID of the event.\n    :param permissions: A dictionary of permissions, where keys are employee names and values are booleans\n                       indicating whether the employee has permission to view/modify the event.\n    :return: True if permissions were set successfully, False otherwise.\"\"\"\n    pass\ndef sync_with_microsoft_365(calendar_data: dict) -> bool:\n    \"\"\"Syncs calendar data with Microsoft 365.\n\n    :param calendar_data: A dictionary containing calendar data to sync.\n    :return: True if sync was successful, False otherwise.\"\"\"\n    pass\n", "function_schema_json": [{"name": "get_employee_birthdays", "description": "Retrieves employee birthdays for a given month and year.", "parameters": {"type": "object", "properties": {"month": {"type": "string", "description": "The month for which to retrieve birthdays (e.g., \"January\", \"February\")."}, "year": {"type": "integer", "description": "The year for which to retrieve birthdays."}}, "required": ["month", "year"], "additionalProperties": false}}, {"name": "create_calendar_event", "description": "Creates a calendar event with specified details.", "parameters": {"type": "object", "properties": {"date": {"type": "string", "description": "The date of the event (e.g., \"2024-01-15\")."}, "time": {"type": "string", "description": "The time of the event (e.g., \"10:00 AM\")."}, "timezone": {"type": "string", "description": "The timezone for the event (e.g., \"EST\", \"PST\", \"GMT\")."}, "attendees": {"type": "array", "items": {"type": "string"}, "description": "A list of employee names to invite."}, "reminder_category": {"type": "string", "description": "The reminder category (e.g., \"department-wide\", \"team-specific\")."}}, "required": ["date", "time", "timezone", "attendees", "reminder_category"], "additionalProperties": false}}, {"name": "set_event_permissions", "description": "Sets permissions for a calendar event.", "parameters": {"type": "object", "properties": {"event_id": {"type": "string", "description": "The ID of the event."}, "permissions": {"type": "object", "description": "A dictionary of permissions, where keys are employee names and values are booleans"}}, "required": ["event_id", "permissions"], "additionalProperties": false}}, {"name": "sync_with_microsoft_365", "description": "Syncs calendar data with Microsoft 365.", "parameters": {"type": "object", "properties": {"calendar_data": {"type": "object", "description": "A dictionary containing calendar data to sync."}}, "required": ["calendar_data"], "additionalProperties": false}}], "mock_functions": "def get_employee_birthdays(month: str, year: int) -> List[Tuple[str, str]]:\n    \"\"\"\n    Retrieves employee birthdays for a given month and year.\n\n    :param month: The month for which to retrieve birthdays (e.g., \"January\", \"February\").\n    :param year: The year for which to retrieve birthdays.\n    :return: A list of tuples, where each tuple contains (employee_name, birthday_date).\n    \"\"\"\n    if month == \"January\" and year == 2024:  # Example mock data\n        return [(\"Alice\", \"2024-01-15\"), (\"Bob\", \"2024-01-22\")]\n    return []\ndef create_calendar_event(date: str, time: str, timezone: str, attendees: List[str], reminder_category: str) -> bool:\n    \"\"\"\n    Creates a calendar event with specified details.\n\n    :param date: The date of the event (e.g., \"2024-01-15\").\n    :param time: The time of the event (e.g., \"10:00 AM\").\n    :param timezone: The timezone for the event (e.g., \"EST\", \"PST\", \"GMT\").\n    :param attendees: A list of employee names to invite.\n    :param reminder_category: The reminder category (e.g., \"department-wide\", \"team-specific\").\n    :return: True if the event was created successfully, False otherwise.\n    \"\"\"\n    if date and time and timezone and attendees and reminder_category:\n        return True  # Mock success\n    return False\ndef set_event_permissions(event_id: str, permissions: Dict[str, bool]) -> bool:\n    \"\"\"\n    Sets permissions for a calendar event.\n\n    :param event_id: The ID of the event.\n    :param permissions: A dictionary of permissions, where keys are employee names and values are booleans\n                       indicating whether the employee has permission to view/modify the event.\n    :return: True if permissions were set successfully, False otherwise.\n    \"\"\"\n    if event_id and permissions:\n        return True  # Mock success\n    return False\ndef sync_with_microsoft_365(calendar_data: dict) -> bool:\n    \"\"\"\n    Syncs calendar data with Microsoft 365.\n\n    :param calendar_data: A dictionary containing calendar data to sync.\n    :return: True if sync was successful, False otherwise.\n    \"\"\"\n\n    if calendar_data:\n        return True\n    return False", "user_query": "What are the employee birthdays in January 2024?", "checklist": {"functions": ["get_employee_birthdays"], "values": [[["Alice", "2024-01-15"], ["Bob", "2024-01-22"]]]}}
{"difficulty": "easy", "function_schema_python": "def analyze_business_needs(current_orders: int, projected_orders: int) -> Dict[str, Any]:\n    \"\"\"Analyzes the business needs based on current and projected order volumes.\n\n    :param current_orders: The current number of orders per month.\n    :param projected_orders: The projected number of orders per month.\n    :return: A dictionary containing analysis results.\n        - order_increase (int): The increase in orders.\n        - scaling_factor (float): The factor by which orders are expected to increase.\"\"\"\n    pass\ndef recommend_api_strategy(inventory_system: str, marketplace_platform: str) -> str:\n    \"\"\"Recommends an API integration strategy.\n\n    :param inventory_system: The name of the inventory management system.\n    :param marketplace_platform: The name of the marketplace platform.\n    :return: A string describing the recommended API strategy.\"\"\"\n    pass\ndef design_api_endpoints(required_functionality: List[str]) -> List[Dict[str, str]]:\n    \"\"\"Designs API endpoints based on required functionality.\n\n    :param required_functionality: A list of required functionalities.\n    :return: A list of dictionaries, each representing an API endpoint.\n        - endpoint (str): The API endpoint path.\n        - method (str): The HTTP method (e.g., GET, POST).\n        - description (str): A description of the endpoint's purpose.\"\"\"\n    pass\ndef create_mock_fastapi_app(endpoints: List[Dict[str, str]]) -> str:\n    \"\"\"Mocks a FastAPI app setup based on endpoints.\n    :param endpoints: endpoints to implement\n    :return: a string with the mock code\"\"\"\n    pass\ndef estimate_scaling_costs(scaling_factor: float) -> float:\n    \"\"\"Estimates the costs associated with scaling.\n\n    :param scaling_factor: The factor by which operations are scaled.\n    :return: The estimated cost.\"\"\"\n    pass\n", "function_schema_json": [{"name": "analyze_business_needs", "description": "Analyzes the business needs based on current and projected order volumes.", "parameters": {"type": "object", "properties": {"current_orders": {"type": "integer", "description": "The current number of orders per month."}, "projected_orders": {"type": "integer", "description": "The projected number of orders per month."}}, "required": ["current_orders", "projected_orders"], "additionalProperties": false}}, {"name": "recommend_api_strategy", "description": "Recommends an API integration strategy.", "parameters": {"type": "object", "properties": {"inventory_system": {"type": "string", "description": "The name of the inventory management system."}, "marketplace_platform": {"type": "string", "description": "The name of the marketplace platform."}}, "required": ["inventory_system", "marketplace_platform"], "additionalProperties": false}}, {"name": "design_api_endpoints", "description": "Designs API endpoints based on required functionality.", "parameters": {"type": "object", "properties": {"required_functionality": {"type": "array", "items": {"type": "string"}, "description": "A list of required functionalities."}}, "required": ["required_functionality"], "additionalProperties": false}}, {"name": "create_mock_fastapi_app", "description": "Mocks a FastAPI app setup based on endpoints.", "parameters": {"type": "object", "properties": {"endpoints": {"type": "array", "items": {"type": "object"}, "description": "endpoints to implement"}}, "required": ["endpoints"], "additionalProperties": false}}, {"name": "estimate_scaling_costs", "description": "Estimates the costs associated with scaling.", "parameters": {"type": "object", "properties": {"scaling_factor": {"type": "number", "description": "The factor by which operations are scaled."}}, "required": ["scaling_factor"], "additionalProperties": false}}], "mock_functions": "def analyze_business_needs(current_orders: int, projected_orders: int) -> Dict[str, Any]:\n    \"\"\"\n    Analyzes the business needs based on current and projected order volumes.\n\n    :param current_orders: The current number of orders per month.\n    :param projected_orders: The projected number of orders per month.\n    :return: A dictionary containing analysis results.\n        - order_increase (int): The increase in orders.\n        - scaling_factor (float): The factor by which orders are expected to increase.\n    \"\"\"\n    order_increase = projected_orders - current_orders\n    scaling_factor = projected_orders / current_orders if current_orders > 0 else 0\n    return {\n        \"order_increase\": order_increase,\n        \"scaling_factor\": scaling_factor\n    }\ndef recommend_api_strategy(inventory_system: str, marketplace_platform: str) -> str:\n    \"\"\"\n    Recommends an API integration strategy.\n\n    :param inventory_system: The name of the inventory management system.\n    :param marketplace_platform: The name of the marketplace platform.\n    :return: A string describing the recommended API strategy.\n    \"\"\"\n    return f\"Recommended API strategy for integrating {inventory_system} with {marketplace_platform}:  Use a RESTful API with webhooks for real-time inventory updates and order status synchronization.\"\ndef design_api_endpoints(required_functionality: List[str]) -> List[Dict[str, str]]:\n    \"\"\"\n    Designs API endpoints based on required functionality.\n\n    :param required_functionality: A list of required functionalities.\n    :return: A list of dictionaries, each representing an API endpoint.\n        - endpoint (str): The API endpoint path.\n        - method (str): The HTTP method (e.g., GET, POST).\n        - description (str): A description of the endpoint's purpose.\n    \"\"\"\n    endpoints = []\n    for func in required_functionality:\n        endpoints.append({\n            \"endpoint\": f\"/{func.lower().replace(' ', '_')}\",\n            \"method\": \"POST\" if func.startswith(\"Update\") else \"GET\",\n            \"description\": f\"Endpoint for {func}\"\n        })\n    return endpoints\ndef create_mock_fastapi_app(endpoints: List[Dict[str, str]]) -> str:\n    \"\"\"\n    Mocks a FastAPI app setup based on endpoints.\n    :param endpoints: endpoints to implement\n    :return: a string with the mock code\n    \"\"\"\n    mock_code = \"from fastapi import FastAPI\\napp = FastAPI()\\n\\n\"\n    for endpoint in endpoints:\n        mock_code += f\"@app.{endpoint['method'].lower()}('{endpoint['endpoint']}')\\n\"\n        mock_code += f\"async def {endpoint['endpoint'].replace('/', '_')}(item: dict):\\n\"\n        mock_code += f\"    return item\\n\\n\"\n    return mock_code\ndef estimate_scaling_costs(scaling_factor: float) -> float:\n    \"\"\"\n    Estimates the costs associated with scaling.\n\n    :param scaling_factor: The factor by which operations are scaled.\n    :return: The estimated cost.\n    \"\"\"\n    # Placeholder mock logic\n    return 1000 * scaling_factor", "user_query": "What API strategy do you recommend for integrating my \"TrendyThreads Inventory\" system with the online marketplace platform?", "checklist": {"functions": ["recommend_api_strategy"], "values": ["Recommended API strategy for integrating TrendyThreads Inventory with marketplace_platform:  Use a RESTful API with webhooks for real-time inventory updates and order status synchronization."]}}
{"difficulty": "easy", "function_schema_python": "def get_cpc_for_ad_group(ad_group: str) -> float:\n    \"\"\"Retrieves the current Cost Per Click (CPC) for a given ad group.\n\n    :param ad_group: The name of the ad group (e.g., \"Renewable Energy\").\n    :return: A float representing the CPC.\n    :raises ValueError: If the ad group name is invalid.\"\"\"\n    pass\ndef get_conversion_rate_for_ad_group(ad_group: str) -> float:\n    \"\"\"Retrieves the conversion rate for a given ad group.\n\n    :param ad_group: The name of the ad group (e.g., \"Renewable Energy\").\n    :return: A float representing the conversion rate.\n    :raises ValueError: If the ad group name is invalid.\"\"\"\n    pass\ndef get_top_ad_group_by_conversion_rate() -> str:\n    \"\"\"Retrieves the ad group with the highest conversion rate.\n\n    :return: A string representing the name of the ad group with the highest conversion rate.\"\"\"\n    pass\ndef get_ad_group_performance_summary() -> dict:\n    \"\"\"Retrieves a summary of the performance of all ad groups.\n\n    :return: A dictionary with the following keys:\n            - ad_group (str): The name of the ad group.\n            - cpc (float): The current Cost Per Click (CPC).\n            - conversion_rate (float): The conversion rate.\"\"\"\n    pass\n", "function_schema_json": [{"name": "get_cpc_for_ad_group", "description": "Retrieves the current Cost Per Click (CPC) for a given ad group.", "parameters": {"type": "object", "properties": {"ad_group": {"type": "string", "description": "The name of the ad group (e.g., \"Renewable Energy\")."}}, "required": ["ad_group"], "additionalProperties": false}}, {"name": "get_conversion_rate_for_ad_group", "description": "Retrieves the conversion rate for a given ad group.", "parameters": {"type": "object", "properties": {"ad_group": {"type": "string", "description": "The name of the ad group (e.g., \"Renewable Energy\")."}}, "required": ["ad_group"], "additionalProperties": false}}, {"name": "get_top_ad_group_by_conversion_rate", "description": "Retrieves the ad group with the highest conversion rate.", "parameters": {"type": "object", "properties": {}, "required": [], "additionalProperties": false}}, {"name": "get_ad_group_performance_summary", "description": "Retrieves a summary of the performance of all ad groups.", "parameters": {"type": "object", "properties": {}, "required": [], "additionalProperties": false}}], "mock_functions": "def get_cpc_for_ad_group(ad_group: str) -> float:\n    \"\"\"\n    Retrieves the current Cost Per Click (CPC) for a given ad group.\n    \n    :param ad_group: The name of the ad group (e.g., \"Renewable Energy\").\n    :return: A float representing the CPC.\n    :raises ValueError: If the ad group name is invalid.\n    \"\"\"\n    cpc_values = {\n        \"Renewable Energy\": 0.45 + random.uniform(-0.01, 0.01),\n        \"Sustainable Living\": 0.55 + random.uniform(-0.01, 0.01),\n        \"Eco-Friendly Products\": 0.35 + random.uniform(-0.01, 0.01)\n    }\n    if ad_group in cpc_values:\n        return cpc_values[ad_group]\n    else:\n        raise ValueError(f\"The specified ad group '{ad_group}' is invalid.\")\ndef get_conversion_rate_for_ad_group(ad_group: str) -> float:\n    \"\"\"\n    Retrieves the conversion rate for a given ad group.\n    \n    :param ad_group: The name of the ad group (e.g., \"Renewable Energy\").\n    :return: A float representing the conversion rate.\n    :raises ValueError: If the ad group name is invalid.\n    \"\"\"\n    conversion_rates = {\n        \"Renewable Energy\": 2.5 + random.uniform(-0.1, 0.1),\n        \"Sustainable Living\": 1.8 + random.uniform(-0.1, 0.1),\n        \"Eco-Friendly Products\": 3.2 + random.uniform(-0.1, 0.1)\n    }\n    if ad_group in conversion_rates:\n        return conversion_rates[ad_group]\n    else:\n        raise ValueError(f\"The specified ad group '{ad_group}' is invalid.\")\ndef get_top_ad_group_by_conversion_rate() -> str:\n    \"\"\"\n    Retrieves the ad group with the highest conversion rate.\n    \n    :return: A string representing the name of the ad group with the highest conversion rate.\n    \"\"\"\n    conversion_rates = {\n        \"Renewable Energy\": 2.5 + random.uniform(-0.1, 0.1),\n        \"Sustainable Living\": 1.8 + random.uniform(-0.1, 0.1),\n        \"Eco-Friendly Products\": 3.2 + random.uniform(-0.1, 0.1)\n    }\n    return max(conversion_rates, key=conversion_rates.get)\ndef get_ad_group_performance_summary() -> dict:\n    \"\"\"\n    Retrieves a summary of the performance of all ad groups.\n    \n    :return: A dictionary with the following keys:\n            - ad_group (str): The name of the ad group.\n            - cpc (float): The current Cost Per Click (CPC).\n            - conversion_rate (float): The conversion rate.\n    \"\"\"\n    performance_summary = []\n    ad_groups = [\"Renewable Energy\", \"Sustainable Living\", \"Eco-Friendly Products\"]\n    \n    for ad_group in ad_groups:\n        cpc = get_cpc_for_ad_group(ad_group)\n        conversion_rate = get_conversion_rate_for_ad_group(ad_group)\n        performance_summary.append({\n            \"ad_group\": ad_group,\n            \"cpc\": cpc,\n            \"conversion_rate\": conversion_rate\n        })\n    \n    return performance_summary\n", "user_query": "What is the current Cost Per Click (CPC) for the \"Renewable Energy\" ad group?", "checklist": {"functions": ["get_cpc_for_ad_group"], "values": [{"min": 0.44, "max": 0.46}]}}
{"difficulty": "easy", "function_schema_python": "def create_ad_campaign(game_name: str, budget: float, target_demographics: dict) -> dict:\n    \"\"\"Creates a new ad campaign for a mobile game.\n\n    :param game_name: Name of the game to advertise\n    :param budget: Total budget for the campaign in USD\n    :param target_demographics: Dictionary containing demographic targeting parameters\n    :return: Dictionary containing campaign details and initial metrics\n    :raises ValueError: If budget is negative or game_name is empty\"\"\"\n    pass\ndef analyze_user_demographics(campaign_id: str) -> dict:\n    \"\"\"Analyzes user demographics for a specific campaign.\n\n    :param campaign_id: The unique identifier for the campaign\n    :return: Dictionary containing demographic analysis results\n    :raises ValueError: If campaign_id is invalid\"\"\"\n    pass\ndef optimize_ad_placements(campaign_id: str, performance_data: dict) -> dict:\n    \"\"\"Optimizes ad placements based on performance data.\n\n    :param campaign_id: The unique identifier for the campaign\n    :param performance_data: Dictionary containing current performance metrics\n    :return: Dictionary containing optimized placement recommendations\n    :raises ValueError: If performance_data is incomplete\"\"\"\n    pass\n", "function_schema_json": [{"name": "create_ad_campaign", "description": "Creates a new ad campaign for a mobile game.", "parameters": {"type": "object", "properties": {"game_name": {"type": "string", "description": "Name of the game to advertise"}, "budget": {"type": "number", "description": "Total budget for the campaign in USD"}, "target_demographics": {"type": "object", "description": "Dictionary containing demographic targeting parameters"}}, "required": ["game_name", "budget", "target_demographics"], "additionalProperties": false}}, {"name": "analyze_user_demographics", "description": "Analyzes user demographics for a specific campaign.", "parameters": {"type": "object", "properties": {"campaign_id": {"type": "string", "description": "The unique identifier for the campaign"}}, "required": ["campaign_id"], "additionalProperties": false}}, {"name": "optimize_ad_placements", "description": "Optimizes ad placements based on performance data.", "parameters": {"type": "object", "properties": {"campaign_id": {"type": "string", "description": "The unique identifier for the campaign"}, "performance_data": {"type": "object", "description": "Dictionary containing current performance metrics"}}, "required": ["campaign_id", "performance_data"], "additionalProperties": false}}], "mock_functions": "def create_ad_campaign(game_name: str, budget: float, target_demographics: dict) -> dict:\n    \"\"\"\n    Creates a new ad campaign for a mobile game.\n    \n    :param game_name: Name of the game to advertise\n    :param budget: Total budget for the campaign in USD\n    :param target_demographics: Dictionary containing demographic targeting parameters\n    :return: Dictionary containing campaign details and initial metrics\n    :raises ValueError: If budget is negative or game_name is empty\n    \"\"\"\n    if not game_name or budget <= 0:\n        raise ValueError(\"Invalid game name or budget\")\n    \n    if game_name.lower() == \"galaxy quest\" and budget >= 10000:\n        return {\n            \"campaign_id\": \"GQ2023001\",\n            \"status\": \"active\",\n            \"projected_reach\": 500000,\n            \"target_platforms\": [\"iOS\", \"Android\"],\n            \"daily_budget\": budget / 30\n        }\n    return {}\ndef analyze_user_demographics(campaign_id: str) -> dict:\n    \"\"\"\n    Analyzes user demographics for a specific campaign.\n    \n    :param campaign_id: The unique identifier for the campaign\n    :return: Dictionary containing demographic analysis results\n    :raises ValueError: If campaign_id is invalid\n    \"\"\"\n    if campaign_id == \"GQ2023001\":\n        return {\n            \"age_groups\": {\n                \"13-17\": 0.15,\n                \"18-24\": 0.45,\n                \"25-34\": 0.30,\n                \"35+\": 0.10\n            },\n            \"gender_distribution\": {\n                \"male\": 0.65,\n                \"female\": 0.32,\n                \"other\": 0.03\n            },\n            \"top_regions\": [\"North America\", \"Europe\", \"Asia Pacific\"]\n        }\n    raise ValueError(\"Invalid campaign ID\")\ndef optimize_ad_placements(campaign_id: str, performance_data: dict) -> dict:\n    \"\"\"\n    Optimizes ad placements based on performance data.\n    \n    :param campaign_id: The unique identifier for the campaign\n    :param performance_data: Dictionary containing current performance metrics\n    :return: Dictionary containing optimized placement recommendations\n    :raises ValueError: If performance_data is incomplete\n    \"\"\"\n    required_metrics = [\"click_through_rate\", \"conversion_rate\", \"cost_per_install\"]\n    if not all(metric in performance_data for metric in required_metrics):\n        raise ValueError(\"Incomplete performance data\")\n        \n    if campaign_id == \"GQ2023001\":\n        return {\n            \"recommended_platforms\": [\"Instagram\", \"TikTok\", \"Unity Ads\"],\n            \"budget_allocation\": {\n                \"Instagram\": 0.4,\n                \"TikTok\": 0.35,\n                \"Unity Ads\": 0.25\n            },\n            \"best_performing_creatives\": [\"space_adventure_15s\", \"character_showcase_30s\"],\n            \"estimated_improvement\": \"25%\"\n        }\n    return {}", "user_query": "For campaign GQ2023001, analyze the user demographics and show me the age groups and top regions.", "checklist": {"functions": ["analyze_user_demographics"], "values": [{"age_groups": {"13-17": 0.15, "18-24": 0.45, "25-34": 0.3, "35+": 0.1}, "top_regions": ["North America", "Europe", "Asia Pacific"]}]}}
{"difficulty": "easy", "function_schema_python": "def venue_search(location: str, capacity: int, amenities: list[str]) -> list[dict]:\n    \"\"\"Searches for venues in a given location that meet the specified capacity and amenities.\n\n    :param location: The location to search for venues.\n    :param capacity: The required capacity of the venue.\n    :param amenities: A list of amenities the venue must have.\n    :return: A list of dictionaries, each representing a venue with the following keys:\n             - name (str): The name of the venue.\n             - location (str): The location of the venue.\n             - capacity (int): The capacity of the venue.\n             - amenities (list[str]): The amenities available in the venue.\n    :raises ValueError: If location, capacity, or amenities are invalid.\"\"\"\n    pass\ndef calendar_management(date: str, time: str, event_name: str) -> bool:\n    \"\"\"Adds an event to the calendar and checks for conflicts.\n\n    :param date: The date of the event (e.g., \"June 15, 2024\").\n    :param time: The time of the event (e.g., \"10 AM\").\n    :param event_name: The name of the event.\n    :return: True if the event was successfully added without any conflicts, False otherwise.\n    :raises ValueError: If date, time, or event_name are invalid.\"\"\"\n    pass\ndef rideshare_booking(service: str, origin: str, destination: str) -> dict:\n    \"\"\"Books a rideshare service for the given origin and destination.\n\n    :param service: The name of the rideshare service (e.g., \"Uber\", \"Grab\").\n    :param origin: The starting location.\n    :param destination: The destination location.\n    :return: A dictionary with booking details, including the following keys:\n             - service (str): The name of the rideshare service.\n             - origin (str): The starting location.\n             - destination (str): The destination location.\n             - booking_id (str): A unique booking ID.\n             - estimated_time (str): Estimated time in \"1 hour 30 minutes\" format.\n    :raises ValueError: If service, origin, or destination are invalid.\"\"\"\n    pass\n", "function_schema_json": [{"name": "venue_search", "description": "Searches for venues in a given location that meet the specified capacity and amenities.", "parameters": {"type": "object", "properties": {"location": {"type": "string", "description": "The location to search for venues."}, "capacity": {"type": "integer", "description": "The required capacity of the venue."}, "amenities": {"type": "array", "items": {"type": "string"}, "description": "A list of amenities the venue must have."}}, "required": ["location", "capacity", "amenities"], "additionalProperties": false}}, {"name": "calendar_management", "description": "Adds an event to the calendar and checks for conflicts.", "parameters": {"type": "object", "properties": {"date": {"type": "string", "description": "The date of the event (e.g., \"June 15, 2024\")."}, "time": {"type": "string", "description": "The time of the event (e.g., \"10 AM\")."}, "event_name": {"type": "string", "description": "The name of the event."}}, "required": ["date", "time", "event_name"], "additionalProperties": false}}, {"name": "rideshare_booking", "description": "Books a rideshare service for the given origin and destination.", "parameters": {"type": "object", "properties": {"service": {"type": "string", "description": "The name of the rideshare service (e.g., \"Uber\", \"Grab\")."}, "origin": {"type": "string", "description": "The starting location."}, "destination": {"type": "string", "description": "The destination location."}}, "required": ["service", "origin", "destination"], "additionalProperties": false}}], "mock_functions": "def venue_search(location: str, capacity: int, amenities: list[str]) -> list[dict]:\n    \"\"\"\n    Searches for venues in a given location that meet the specified capacity and amenities.\n\n    :param location: The location to search for venues.\n    :param capacity: The required capacity of the venue.\n    :param amenities: A list of amenities the venue must have.\n    :return: A list of dictionaries, each representing a venue with the following keys:\n             - name (str): The name of the venue.\n             - location (str): The location of the venue.\n             - capacity (int): The capacity of the venue.\n             - amenities (list[str]): The amenities available in the venue.\n    :raises ValueError: If location, capacity, or amenities are invalid.\n    \"\"\"\n    if not location or capacity <= 0 or not amenities:\n        raise ValueError(\"Location, capacity, and amenities must be provided and valid.\")\n    if location == \"central area\" and capacity >= 500 and \"presentation facilities\" in amenities and \"workshop facilities\" in amenities:\n        return [\n            {\n                \"name\": \"Convention Center A\",\n                \"location\": \"Downtown\",\n                \"capacity\": 600,\n                \"amenities\": [\"presentation facilities\", \"workshop facilities\", \"parking\"]\n            },\n            {\n                \"name\": \"Conference Hotel B\",\n                \"location\": \"City Center\",\n                \"capacity\": 550,\n                \"amenities\": [\"presentation facilities\", \"workshop facilities\", \"restaurant\"]\n            }\n        ]\n    return []\ndef calendar_management(date: str, time: str, event_name: str) -> bool:\n    \"\"\"\n    Adds an event to the calendar and checks for conflicts.\n\n    :param date: The date of the event (e.g., \"June 15, 2024\").\n    :param time: The time of the event (e.g., \"10 AM\").\n    :param event_name: The name of the event.\n    :return: True if the event was successfully added without any conflicts, False otherwise.\n    :raises ValueError: If date, time, or event_name are invalid.\n    \"\"\"\n    if not date or not time or not event_name:\n        raise ValueError(\"Date, time, and event name must be provided.\")\n    # Mock logic: Assume no conflicts for the following dates and times\n    if date in [\"June 15, 2024\", \"June 16, 2024\", \"June 17, 2024\"] and time in [\"10 AM\", \"3 PM\"]:\n        return True\n    return False\ndef rideshare_booking(service: str, origin: str, destination: str) -> dict:\n    \"\"\"\n    Books a rideshare service for the given origin and destination.\n\n    :param service: The name of the rideshare service (e.g., \"Uber\", \"Grab\").\n    :param origin: The starting location.\n    :param destination: The destination location.\n    :return: A dictionary with booking details, including the following keys:\n             - service (str): The name of the rideshare service.\n             - origin (str): The starting location.\n             - destination (str): The destination location.\n             - booking_id (str): A unique booking ID.\n             - estimated_time (str): Estimated time in \"1 hour 30 minutes\" format.\n    :raises ValueError: If service, origin, or destination are invalid.\n    \"\"\"\n    if not service or not origin or not destination:\n        raise ValueError(\"Service, origin, and destination must be provided.\")\n    if service in [\"Uber\", \"Grab\"] and origin == \"nearest airport\" and destination == \"conference hotel\":\n        return {\n            \"service\": service,\n            \"origin\": origin,\n            \"destination\": destination,\n            \"booking_id\": \"ABC123XYZ\",\n            \"estimated_time\": \"30 minutes\"\n        }\n    return {}", "user_query": "Could you search for venues in the central area that can hold 500 people and have presentation facilities and workshop facilities?", "checklist": {"functions": ["venue_search"], "values": [[{"name": "Convention Center A", "location": "Downtown", "capacity": 600, "amenities": ["presentation facilities", "workshop facilities", "parking"]}, {"name": "Conference Hotel B", "location": "City Center", "capacity": 550, "amenities": ["presentation facilities", "workshop facilities", "restaurant"]}]]}}
{"difficulty": "easy", "function_schema_python": "def fetch_email_feedback(query: str, date_range: tuple) -> List[str]:\n    \"\"\"Fetches customer feedback from emails based on a search query within a specified date range.\n\n    :param query: The search query to filter emails (e.g., \"Alpha v2.0\").\n    :param date_range: A tuple of start and end dates (e.g., (datetime(2023, 10, 1), datetime(2023, 10, 31))).\n    :return: A list of email feedback strings.\"\"\"\n    pass\ndef fetch_support_tickets(ticket_ids: List[int]) -> List[str]:\n    \"\"\"Fetches customer feedback from support tickets based on a list of ticket IDs.\n\n    :param ticket_ids: A list of ticket IDs (e.g., [123, 456, 789]).\n    :return: A list of support ticket feedback strings.\"\"\"\n    pass\ndef fetch_survey_responses(survey_ids: List[str]) -> List[str]:\n    \"\"\"Fetches customer feedback from survey responses based on a list of survey IDs.\n\n    :param survey_ids: A list of survey IDs (e.g., [\"XYZ123\"]).\n    :return: A list of survey response feedback strings.\"\"\"\n    pass\ndef categorize_feedback(feedbacks: List[str]) -> Dict[str, List[str]]:\n    \"\"\"Categorizes feedback into feature requests and bug reports.\n\n    :param feedbacks: A list of feedback strings.\n    :return:\n        dict: A dictionary with the following keys:\n            - feature_requests (list[str]): The list of feature request feedback strings.\n            - bug_reports (list[str]): The list of bug report feedback strings.\"\"\"\n    pass\ndef summarize_feedback(categorized_feedback: Dict[str, List[str]]) -> Dict[str, List[str]]:\n    \"\"\"Summarizes categorized feedback by grouping similar feedback.\n\n    :param categorized_feedback: A dictionary containing categorized feedback (feature requests and bug reports).\n    :return:\n        dict: A dictionary with the following keys:\n            - summary_feature_requests (list[str]): The list of summarized feature request feedback strings.\n            - summary_bug_reports (list[str]): The list of summarized bug report feedback strings.\"\"\"\n    pass\ndef update_crm_product_record(product_id: str, summary: Dict[str, List[str]]) -> bool:\n    \"\"\"Updates the product record in CRM with summarized feedback.\n\n    :param product_id: The product ID (e.g., \"Alpha v2.0\").\n    :param summary: A dictionary containing summarized feedback (feature requests and bug reports).\n    :return: True if the CRM product record was updated successfully, False otherwise.\"\"\"\n    pass\n", "function_schema_json": [{"name": "fetch_email_feedback", "description": "Fetches customer feedback from emails based on a search query within a specified date range.", "parameters": {"type": "object", "properties": {"query": {"type": "string", "description": "The search query to filter emails (e.g., \"Alpha v2.0\")."}, "date_range": {"type": "string", "description": "A tuple of start and end dates (e.g., (datetime(2023, 10, 1), datetime(2023, 10, 31)))."}}, "required": ["query", "date_range"], "additionalProperties": false}}, {"name": "fetch_support_tickets", "description": "Fetches customer feedback from support tickets based on a list of ticket IDs.", "parameters": {"type": "object", "properties": {"ticket_ids": {"type": "array", "items": {"type": "integer"}, "description": "A list of ticket IDs (e.g., [123, 456, 789])."}}, "required": ["ticket_ids"], "additionalProperties": false}}, {"name": "fetch_survey_responses", "description": "Fetches customer feedback from survey responses based on a list of survey IDs.", "parameters": {"type": "object", "properties": {"survey_ids": {"type": "array", "items": {"type": "string"}, "description": "A list of survey IDs (e.g., [\"XYZ123\"])."}}, "required": ["survey_ids"], "additionalProperties": false}}, {"name": "categorize_feedback", "description": "Categorizes feedback into feature requests and bug reports.", "parameters": {"type": "object", "properties": {"feedbacks": {"type": "array", "items": {"type": "string"}, "description": "A list of feedback strings."}}, "required": ["feedbacks"], "additionalProperties": false}}, {"name": "summarize_feedback", "description": "Summarizes categorized feedback by grouping similar feedback.", "parameters": {"type": "object", "properties": {"categorized_feedback": {"type": "object", "description": "A dictionary containing categorized feedback (feature requests and bug reports)."}}, "required": ["categorized_feedback"], "additionalProperties": false}}, {"name": "update_crm_product_record", "description": "Updates the product record in CRM with summarized feedback.", "parameters": {"type": "object", "properties": {"product_id": {"type": "string", "description": "The product ID (e.g., \"Alpha v2.0\")."}, "summary": {"type": "object", "description": "A dictionary containing summarized feedback (feature requests and bug reports)."}}, "required": ["product_id", "summary"], "additionalProperties": false}}], "mock_functions": "def fetch_email_feedback(query: str, date_range: tuple) -> List[str]:\n    \"\"\"\n    Fetches customer feedback from emails based on a search query within a specified date range.\n    \n    :param query: The search query to filter emails (e.g., \"Alpha v2.0\").\n    :param date_range: A tuple of start and end dates (e.g., (datetime(2023, 10, 1), datetime(2023, 10, 31))).\n    :return: A list of email feedback strings.\n    \"\"\"\n    if not query:\n        raise ValueError(\"Query must not be empty.\")\n    if not date_range or len(date_range) != 2:\n        raise ValueError(\"Date range must be provided as a tuple of start and end dates.\")\n    start_date, end_date = date_range\n    if start_date > end_date:\n        raise ValueError(\"Start date must be earlier than end date.\")\n    \n    mock_emails = [\n        \"Great product Alpha v2.0! I love the new features.\",\n        \"Found a bug in Alpha v2.0, crashes when logging in.\",\n        \"Alpha v2.0 needs a dark mode feature.\",\n        \"Really enjoying Alpha v2.0, keep up the good work.\"\n    ]\n    return [email for email in mock_emails if query in email and start_date <= datetime.now() <= end_date]\ndef fetch_support_tickets(ticket_ids: List[int]) -> List[str]:\n    \"\"\"\n    Fetches customer feedback from support tickets based on a list of ticket IDs.\n    \n    :param ticket_ids: A list of ticket IDs (e.g., [123, 456, 789]).\n    :return: A list of support ticket feedback strings.\n    \"\"\"\n    if not ticket_ids:\n        raise ValueError(\"Ticket IDs must not be empty.\")\n    \n    mock_tickets = {\n        123: \"Facing issues with the login process in Alpha v2.0.\",\n        456: \"Requesting more customization options in Alpha v2.0.\",\n        789: \"Alpha v2.0 performance is very good, but needs optimization.\"\n    }\n    return [mock_tickets[id] for id in ticket_ids if id in mock_tickets]\ndef fetch_survey_responses(survey_ids: List[str]) -> List[str]:\n    \"\"\"\n    Fetches customer feedback from survey responses based on a list of survey IDs.\n    \n    :param survey_ids: A list of survey IDs (e.g., [\"XYZ123\"]).\n    :return: A list of survey response feedback strings.\n    \"\"\"\n    if not survey_ids:\n        raise ValueError(\"Survey IDs must not be empty.\")\n    \n    mock_surveys = {\n        \"XYZ123\": [\n            \"Alpha v2.0 is intuitive to use.\",\n            \"Please add more widgets to Alpha v2.0.\",\n            \"Bugs encountered in Alpha v2.0 need fixing.\",\n            \"Overall, Alpha v2.0 is a big improvement.\"\n        ]\n    }\n    return [response for survey_id in survey_ids for response in mock_surveys.get(survey_id, [])]\ndef categorize_feedback(feedbacks: List[str]) -> Dict[str, List[str]]:\n    \"\"\"\n    Categorizes feedback into feature requests and bug reports.\n    \n    :param feedbacks: A list of feedback strings.\n    :return:\n        dict: A dictionary with the following keys:\n            - feature_requests (list[str]): The list of feature request feedback strings.\n            - bug_reports (list[str]): The list of bug report feedback strings.\n    \"\"\"\n    if not feedbacks:\n        raise ValueError(\"Feedbacks must not be empty.\")\n    \n    feature_requests = [fb for fb in feedbacks if \"feature\" in fb.lower() or \"request\" in fb.lower()]\n    bug_reports = [fb for fb in feedbacks if \"bug\" in fb.lower() or \"crash\" in fb.lower()]\n    \n    return {\n        \"feature_requests\": feature_requests,\n        \"bug_reports\": bug_reports\n    }\ndef summarize_feedback(categorized_feedback: Dict[str, List[str]]) -> Dict[str, List[str]]:\n    \"\"\"\n    Summarizes categorized feedback by grouping similar feedback.\n    \n    :param categorized_feedback: A dictionary containing categorized feedback (feature requests and bug reports).\n    :return:\n        dict: A dictionary with the following keys:\n            - summary_feature_requests (list[str]): The list of summarized feature request feedback strings.\n            - summary_bug_reports (list[str]): The list of summarized bug report feedback strings.\n    \"\"\"\n    if not categorized_feedback:\n        raise ValueError(\"Categorized feedback must not be empty.\")\n    \n    summary_feature_requests = [\"Need for more customization options.\", \"Dark mode feature request.\"]\n    summary_bug_reports = [\"Login process issues.\", \"Performance optimization needed.\", \"Some bugs encountered.\"]\n\n    return {\n        \"summary_feature_requests\": summary_feature_requests,\n        \"summary_bug_reports\": summary_bug_reports\n    }\ndef update_crm_product_record(product_id: str, summary: Dict[str, List[str]]) -> bool:\n    \"\"\"\n    Updates the product record in CRM with summarized feedback.\n    \n    :param product_id: The product ID (e.g., \"Alpha v2.0\").\n    :param summary: A dictionary containing summarized feedback (feature requests and bug reports).\n    :return: True if the CRM product record was updated successfully, False otherwise.\n    \"\"\"\n    if not product_id:\n        raise ValueError(\"Product ID must not be empty.\")\n    if not summary:\n        raise ValueError(\"Summary must not be empty.\")\n    \n    # Mock implementation: Assume the update always succeeds.\n    print(f\"Updating product record for {product_id} with:\\n{summary}\")\n    return True\n", "user_query": "Can you fetch email feedback related to \"Alpha v2.0\" from the date range (datetime(2023, 10, 1), datetime(2023, 10, 31))?", "checklist": {"functions": ["fetch_email_feedback"], "values": [["Great product Alpha v2.0! I love the new features.", "Found a bug in Alpha v2.0, crashes when logging in.", "Alpha v2.0 needs a dark mode feature.", "Really enjoying Alpha v2.0, keep up the good work."]]}}
{"difficulty": "easy", "function_schema_python": "def analyze_deployment_script(script_path: str) -> dict:\n    \"\"\"Analyzes a deployment script to evaluate its effectiveness and performance in managing Docker containers.\n\n    :param script_path: The file path to the deployment script.\n    :return:\n        dict: A dictionary with the following keys:\n            - performance_score (int): A score from 1 to 100 indicating script performance.\n            - issues (list[str]): A list of identified issues in the script.\n    :raises FileNotFoundError: If the script file does not exist at the given path.\n    :raises ValueError: If the script content is empty or invalid.\"\"\"\n    pass\ndef optimize_docker_script(script_path: str, output_path: str) -> bool:\n    \"\"\"Optimizes a Docker deployment script based on performance analysis.\n\n    :param script_path: The file path to the original deployment script.\n    :param output_path: The file path where the optimized script should be saved.\n    :return: True if the script was successfully optimized and saved, False otherwise.\n    :raises FileNotFoundError: If the script file does not exist at the given path.\n    :raises ValueError: If the script content is empty or invalid.\n    :raises IOError: If there is an error writing the optimized script to output_path.\"\"\"\n    pass\ndef test_docker_image(image_name: str) -> dict:\n    \"\"\"Tests a Docker image to ensure it functions as expected.\n\n    :param image_name: The name of the Docker image to test.\n    :return:\n        dict: A dictionary with the following keys:\n            - test_passed (bool): True if the tests passed, False otherwise.\n            - logs (list[str]): Logs from the testing process.\n    :raises ValueError: If the image_name is empty or invalid.\"\"\"\n    pass\n", "function_schema_json": [{"name": "analyze_deployment_script", "description": "Analyzes a deployment script to evaluate its effectiveness and performance in managing Docker containers.", "parameters": {"type": "object", "properties": {"script_path": {"type": "string", "description": "The file path to the deployment script."}}, "required": ["script_path"], "additionalProperties": false}}, {"name": "optimize_docker_script", "description": "Optimizes a Docker deployment script based on performance analysis.", "parameters": {"type": "object", "properties": {"script_path": {"type": "string", "description": "The file path to the original deployment script."}, "output_path": {"type": "string", "description": "The file path where the optimized script should be saved."}}, "required": ["script_path", "output_path"], "additionalProperties": false}}, {"name": "test_docker_image", "description": "Tests a Docker image to ensure it functions as expected.", "parameters": {"type": "object", "properties": {"image_name": {"type": "string", "description": "The name of the Docker image to test."}}, "required": ["image_name"], "additionalProperties": false}}], "mock_functions": "def analyze_deployment_script(script_path: str) -> dict:\n    \"\"\"\n    Analyzes a deployment script to evaluate its effectiveness and performance in managing Docker containers.\n    \n    :param script_path: The file path to the deployment script.\n    :return:\n        dict: A dictionary with the following keys:\n            - performance_score (int): A score from 1 to 100 indicating script performance.\n            - issues (list[str]): A list of identified issues in the script.\n    :raises FileNotFoundError: If the script file does not exist at the given path.\n    :raises ValueError: If the script content is empty or invalid.\n    \"\"\"\n    if not script_path:\n        raise ValueError(\"Script path must be provided.\")\n    \n    # Mock logic for file existence and content\n    try:\n        with open(script_path, 'r') as file:\n            script_content = file.read()\n            if not script_content:\n                raise ValueError(\"Script content is empty.\")\n    except FileNotFoundError:\n        raise FileNotFoundError(f\"Script file not found at path: {script_path}\")\n    \n    # Mock performance analysis logic\n    performance_score = 85  # Assuming a moderate score\n    issues = [\n        \"Lack of logging in Docker commands.\",\n        \"No error handling for Docker build failures.\",\n        \"Redundant commands in the script.\",\n        \"No use of multi-stage builds for Docker images.\"\n    ]\n    \n    return {\n        \"performance_score\": performance_score,\n        \"issues\": issues\n    }\ndef optimize_docker_script(script_path: str, output_path: str) -> bool:\n    \"\"\"\n    Optimizes a Docker deployment script based on performance analysis.\n    \n    :param script_path: The file path to the original deployment script.\n    :param output_path: The file path where the optimized script should be saved.\n    :return: True if the script was successfully optimized and saved, False otherwise.\n    :raises FileNotFoundError: If the script file does not exist at the given path.\n    :raises ValueError: If the script content is empty or invalid.\n    :raises IOError: If there is an error writing the optimized script to output_path.\n    \"\"\"\n    if not script_path or not output_path:\n        raise ValueError(\"Script path and output path must be provided.\")\n    \n    # Mock logic for file existence and content\n    try:\n        with open(script_path, 'r') as file:\n            script_content = file.read()\n            if not script_content:\n                raise ValueError(\"Script content is empty.\")\n    except FileNotFoundError:\n        raise FileNotFoundError(f\"Script file not found at path: {script_path}\")\n    \n    # Mock optimization logic\n    optimized_script_content = (\n        \"# Optimized Docker Deployment Script\\n\"\n        \"# Added logging and error handling\\n\"\n        \"# Removed redundant commands\\n\"\n        \"# Implemented multi-stage build\\n\"\n        \"# ... rest of the optimized script ...\"\n    )\n    \n    # Mock writing the optimized script to output_path\n    try:\n        with open(output_path, 'w') as file:\n            file.write(optimized_script_content)\n            return True\n    except IOError as e:\n        raise IOError(f\"Error writing optimized script to {output_path}: {e}\")\ndef test_docker_image(image_name: str) -> dict:\n    \"\"\"\n    Tests a Docker image to ensure it functions as expected.\n    \n    :param image_name: The name of the Docker image to test.\n    :return:\n        dict: A dictionary with the following keys:\n            - test_passed (bool): True if the tests passed, False otherwise.\n            - logs (list[str]): Logs from the testing process.\n    :raises ValueError: If the image_name is empty or invalid.\n    \"\"\"\n    if not image_name:\n        raise ValueError(\"Image name must be provided.\")\n    \n    # Mock test logic\n    test_passed = True\n    logs = [\n        \"Running unit tests...\",\n        \"All unit tests passed.\",\n        \"Running integration tests...\",\n        \"All integration tests passed.\"\n    ]\n    \n    # Simulate a test failure\n    if \"failure\" in image_name:\n        test_passed = False\n        logs.append(\"Test failure detected.\")\n    \n    return {\n        \"test_passed\": test_passed,\n        \"logs\": logs\n    }", "user_query": "Could you analyze the deployment script located at /users/alice/projects/deploy_script.sh?", "checklist": {"functions": ["analyze_deployment_script"], "values": [{"performance_score": 85, "issues": ["Lack of logging in Docker commands.", "No error handling for Docker build failures.", "Redundant commands in the script.", "No use of multi-stage builds for Docker images."]}]}}
{"difficulty": "easy", "function_schema_python": "def validate_github_workflow(workflow_content: str) -> dict:\n    \"\"\"Validates a GitHub Actions workflow file for syntax and best practices.\n\n    :param workflow_content: The content of the workflow file as a string.\n    :return: A dictionary containing validation results with keys:\n        - is_valid (bool): Whether the workflow is valid\n        - errors (list[str]): List of error messages if any\n        - warnings (list[str]): List of warning messages if any\n    :raises ValueError: If workflow_content is empty\"\"\"\n    pass\ndef check_docker_configuration(dockerfile_path: str, registry_url: str) -> dict:\n    \"\"\"Validates Docker configuration and registry settings.\n\n    :param dockerfile_path: Path to the Dockerfile\n    :param registry_url: URL of the Docker registry\n    :return: A dictionary containing check results with keys:\n        - registry_accessible (bool): Whether registry is accessible\n        - dockerfile_valid (bool): Whether Dockerfile is valid\n        - suggestions (list[str]): List of improvement suggestions\n    :raises FileNotFoundError: If Dockerfile doesn't exist\"\"\"\n    pass\ndef generate_workflow_template(service_name: str, registry_type: str) -> str:\n    \"\"\"Generates a template for GitHub Actions workflow based on service requirements.\n\n    :param service_name: Name of the service\n    :param registry_type: Type of container registry (e.g., 'docker-hub', 'aws-ecr')\n    :return: A string containing the workflow template\n    :raises ValueError: If invalid registry_type is provided\"\"\"\n    pass\n", "function_schema_json": [{"name": "validate_github_workflow", "description": "Validates a GitHub Actions workflow file for syntax and best practices.", "parameters": {"type": "object", "properties": {"workflow_content": {"type": "string", "description": "The content of the workflow file as a string."}}, "required": ["workflow_content"], "additionalProperties": false}}, {"name": "check_docker_configuration", "description": "Validates Docker configuration and registry settings.", "parameters": {"type": "object", "properties": {"dockerfile_path": {"type": "string", "description": "Path to the Dockerfile"}, "registry_url": {"type": "string", "description": "URL of the Docker registry"}}, "required": ["dockerfile_path", "registry_url"], "additionalProperties": false}}, {"name": "generate_workflow_template", "description": "Generates a template for GitHub Actions workflow based on service requirements.", "parameters": {"type": "object", "properties": {"service_name": {"type": "string", "description": "Name of the service"}, "registry_type": {"type": "string", "description": "Type of container registry (e.g., 'docker-hub', 'aws-ecr')"}}, "required": ["service_name", "registry_type"], "additionalProperties": false}}], "mock_functions": "def validate_github_workflow(workflow_content: str) -> dict:\n    \"\"\"\n    Validates a GitHub Actions workflow file for syntax and best practices.\n    \n    :param workflow_content: The content of the workflow file as a string.\n    :return: A dictionary containing validation results with keys:\n        - is_valid (bool): Whether the workflow is valid\n        - errors (list[str]): List of error messages if any\n        - warnings (list[str]): List of warning messages if any\n    :raises ValueError: If workflow_content is empty\n    \"\"\"\n    if not workflow_content:\n        raise ValueError(\"Workflow content cannot be empty\")\n    \n    if \"docker/build-push-action\" in workflow_content and \"steps:\" in workflow_content:\n        return {\n            \"is_valid\": True,\n            \"errors\": [],\n            \"warnings\": [\"Consider adding timeout limits to jobs\"]\n        }\n    return {\n        \"is_valid\": False,\n        \"errors\": [\"Missing required docker build step\"],\n        \"warnings\": []\n    }\ndef check_docker_configuration(dockerfile_path: str, registry_url: str) -> dict:\n    \"\"\"\n    Validates Docker configuration and registry settings.\n    \n    :param dockerfile_path: Path to the Dockerfile\n    :param registry_url: URL of the Docker registry\n    :return: A dictionary containing check results with keys:\n        - registry_accessible (bool): Whether registry is accessible\n        - dockerfile_valid (bool): Whether Dockerfile is valid\n        - suggestions (list[str]): List of improvement suggestions\n    :raises FileNotFoundError: If Dockerfile doesn't exist\n    \"\"\"\n    if not dockerfile_path or not registry_url:\n        raise ValueError(\"Both dockerfile_path and registry_url are required\")\n    \n    if dockerfile_path.endswith(\"Dockerfile\") and \"docker.io\" in registry_url:\n        return {\n            \"registry_accessible\": True,\n            \"dockerfile_valid\": True,\n            \"suggestions\": [\"Consider using multi-stage builds\"]\n        }\n    return {\n        \"registry_accessible\": False,\n        \"dockerfile_valid\": False,\n        \"suggestions\": [\"Invalid registry URL or Dockerfile path\"]\n    }\ndef generate_workflow_template(service_name: str, registry_type: str) -> str:\n    \"\"\"\n    Generates a template for GitHub Actions workflow based on service requirements.\n    \n    :param service_name: Name of the service\n    :param registry_type: Type of container registry (e.g., 'docker-hub', 'aws-ecr')\n    :return: A string containing the workflow template\n    :raises ValueError: If invalid registry_type is provided\n    \"\"\"\n    valid_registries = ['docker-hub', 'aws-ecr']\n    if not service_name or registry_type not in valid_registries:\n        raise ValueError(\"Invalid service name or registry type\")\n    \n    if registry_type == 'docker-hub':\n        return \"\"\"name: Build and Push\non: [push]\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2\n      - uses: docker/build-push-action@v2\n\"\"\"\n    return \"\"", "user_query": "Check the Docker configuration using `./ServiceLink/Dockerfile` and `registry.hub.docker.com` as the registry URL.", "checklist": {"functions": ["check_docker_configuration"], "values": [{"registry_accessible": false, "dockerfile_valid": false, "suggestions": ["Invalid registry URL or Dockerfile path"]}]}}
{"difficulty": "easy", "function_schema_python": "def calculate_lead_score(email_opens: int, website_visits: int, demo_requests: int, last_interaction_days: int) -> dict:\n    \"\"\"Calculates a lead score based on various engagement metrics.\n\n    :param email_opens: Number of marketing emails opened by the lead\n    :param website_visits: Number of website visits by the lead\n    :param demo_requests: Number of demo requests made\n    :param last_interaction_days: Days since last interaction\n    :return: Dictionary containing score and classification\n    :raises ValueError: If any parameter is negative\"\"\"\n    pass\ndef get_lead_engagement_metrics(lead_id: str) -> dict:\n    \"\"\"Retrieves engagement metrics for a specific lead.\n\n    :param lead_id: Unique identifier for the lead\n    :return: Dictionary containing engagement metrics\n    :raises ValueError: If lead_id is invalid\"\"\"\n    pass\ndef batch_process_leads(lead_ids: list[str]) -> dict:\n    \"\"\"Process multiple leads and return their scores.\n\n    :param lead_ids: List of lead IDs to process\n    :return: Dictionary containing scores for each lead\n    :raises ValueError: If lead_ids is empty\"\"\"\n    pass\n", "function_schema_json": [{"name": "calculate_lead_score", "description": "Calculates a lead score based on various engagement metrics.", "parameters": {"type": "object", "properties": {"email_opens": {"type": "integer", "description": "Number of marketing emails opened by the lead"}, "website_visits": {"type": "integer", "description": "Number of website visits by the lead"}, "demo_requests": {"type": "integer", "description": "Number of demo requests made"}, "last_interaction_days": {"type": "integer", "description": "Days since last interaction"}}, "required": ["email_opens", "website_visits", "demo_requests", "last_interaction_days"], "additionalProperties": false}}, {"name": "get_lead_engagement_metrics", "description": "Retrieves engagement metrics for a specific lead.", "parameters": {"type": "object", "properties": {"lead_id": {"type": "string", "description": "Unique identifier for the lead"}}, "required": ["lead_id"], "additionalProperties": false}}, {"name": "batch_process_leads", "description": "Process multiple leads and return their scores.", "parameters": {"type": "object", "properties": {"lead_ids": {"type": "array", "items": {"type": "string"}, "description": "List of lead IDs to process"}}, "required": ["lead_ids"], "additionalProperties": false}}], "mock_functions": "def calculate_lead_score(\n    email_opens: int,\n    website_visits: int,\n    demo_requests: int,\n    last_interaction_days: int\n) -> dict:\n    \"\"\"\n    Calculates a lead score based on various engagement metrics.\n    \n    :param email_opens: Number of marketing emails opened by the lead\n    :param website_visits: Number of website visits by the lead\n    :param demo_requests: Number of demo requests made\n    :param last_interaction_days: Days since last interaction\n    :return: Dictionary containing score and classification\n    :raises ValueError: If any parameter is negative\n    \"\"\"\n    if any(param < 0 for param in [email_opens, website_visits, demo_requests, last_interaction_days]):\n        raise ValueError(\"Parameters cannot be negative\")\n    \n    # Mock scoring logic\n    base_score = (email_opens * 2) + (website_visits * 3) + (demo_requests * 10)\n    engagement_score = base_score * (1 / (1 + last_interaction_days/30))  # Decay factor\n    \n    if engagement_score >= 50:\n        classification = \"Hot\"\n    elif engagement_score >= 30:\n        classification = \"Warm\"\n    else:\n        classification = \"Cold\"\n    \n    return {\n        \"score\": round(engagement_score, 2),\n        \"classification\": classification,\n        \"metrics_analyzed\": [\"email_opens\", \"website_visits\", \"demo_requests\", \"recency\"]\n    }\ndef get_lead_engagement_metrics(lead_id: str) -> dict:\n    \"\"\"\n    Retrieves engagement metrics for a specific lead.\n    \n    :param lead_id: Unique identifier for the lead\n    :return: Dictionary containing engagement metrics\n    :raises ValueError: If lead_id is invalid\n    \"\"\"\n    if not lead_id or not isinstance(lead_id, str):\n        raise ValueError(\"Invalid lead ID\")\n    \n    # Mock data for demonstration\n    if lead_id == \"LEAD123\":\n        return {\n            \"email_opens\": 15,\n            \"website_visits\": 8,\n            \"demo_requests\": 2,\n            \"last_interaction_days\": 3\n        }\n    return {\n        \"email_opens\": 0,\n        \"website_visits\": 0,\n        \"demo_requests\": 0,\n        \"last_interaction_days\": 999\n    }\ndef batch_process_leads(lead_ids: list[str]) -> dict:\n    \"\"\"\n    Process multiple leads and return their scores.\n    \n    :param lead_ids: List of lead IDs to process\n    :return: Dictionary containing scores for each lead\n    :raises ValueError: If lead_ids is empty\n    \"\"\"\n    if not lead_ids:\n        raise ValueError(\"Lead IDs list cannot be empty\")\n    \n    # Mock batch processing\n    if \"LEAD123\" in lead_ids:\n        return {\n            \"processed_leads\": len(lead_ids),\n            \"high_priority_leads\": [\"LEAD123\"],\n            \"scoring_summary\": {\n                \"hot\": 1,\n                \"warm\": 2,\n                \"cold\": len(lead_ids) - 3\n            }\n        }\n    return {\n        \"processed_leads\": len(lead_ids),\n        \"high_priority_leads\": [],\n        \"scoring_summary\": {\n            \"hot\": 0,\n            \"warm\": 0,\n            \"cold\": len(lead_ids)\n        }\n    }", "user_query": "Calculate lead scores for LEAD123, LEAD456, LEAD789, and LEAD000.", "checklist": {"functions": ["batch_process_leads"], "values": [{"processed_leads": 4, "high_priority_leads": ["LEAD123"], "scoring_summary": {"hot": 1, "warm": 2, "cold": 1}}]}}
{"difficulty": "easy", "function_schema_python": "def extract_data_from_pdf(pdf_path: str, data_points: list) -> dict:\n    \"\"\"Extracts specified data points from a PDF document.\n\n    :param pdf_path: Path to the PDF file.\n    :param data_points: A list of data points to extract (e.g., [\"revenue\", \"expenses\"]).\n    :return: \n        dict: A dictionary containing the extracted data points and their values.\n             For example: {\"revenue\": 1000000, \"expenses\": 500000}\n    :raises FileNotFoundError: If the PDF file is not found.\n    :raises ValueError: If any of the specified data points are not found in the PDF.\"\"\"\n    pass\ndef update_financial_models(financial_data: dict) -> bool:\n    \"\"\"Updates financial models with the extracted data.\n\n    :param financial_data: A dictionary containing the financial data to update the model with.\n                          The dictionary should contain keys like \"revenue\", \"expenses\", \"profit margins\".\n    :return: True if the models were updated successfully, False otherwise.\n    :raises ValueError: If the input data is invalid or missing required keys.\"\"\"\n    pass\ndef parse_pdf_with_financepro(pdf_path: str) -> str:\n    \"\"\"Parses a PDF document using FinancePro.\n\n    :param pdf_path: The path to the PDF file.\n    :return: A string indicating success or failure.\n    :raises Exception: If an error occurs during parsing.\"\"\"\n    pass\n", "function_schema_json": [{"name": "extract_data_from_pdf", "description": "Extracts specified data points from a PDF document.", "parameters": {"type": "object", "properties": {"pdf_path": {"type": "string", "description": "Path to the PDF file."}, "data_points": {"type": "array", "description": "A list of data points to extract (e.g., [\"revenue\", \"expenses\"])."}}, "required": ["pdf_path", "data_points"], "additionalProperties": false}}, {"name": "update_financial_models", "description": "Updates financial models with the extracted data.", "parameters": {"type": "object", "properties": {"financial_data": {"type": "object", "description": "A dictionary containing the financial data to update the model with."}}, "required": ["financial_data"], "additionalProperties": false}}, {"name": "parse_pdf_with_financepro", "description": "Parses a PDF document using FinancePro.", "parameters": {"type": "object", "properties": {"pdf_path": {"type": "string", "description": "The path to the PDF file."}}, "required": ["pdf_path"], "additionalProperties": false}}], "mock_functions": "def extract_data_from_pdf(pdf_path: str, data_points: list) -> dict:\n    \"\"\"\n    Extracts specified data points from a PDF document.\n\n    :param pdf_path: Path to the PDF file.\n    :param data_points: A list of data points to extract (e.g., [\"revenue\", \"expenses\"]).\n    :return: \n        dict: A dictionary containing the extracted data points and their values.\n             For example: {\"revenue\": 1000000, \"expenses\": 500000}\n    :raises FileNotFoundError: If the PDF file is not found.\n    :raises ValueError: If any of the specified data points are not found in the PDF.\n    \"\"\"\n    if pdf_path == \"Q3_Financial_Report_2023.pdf\":\n        if all(item in [\"revenue\", \"expenses\", \"profit margins\"] for item in data_points):\n            return {\"revenue\": 1000000, \"expenses\": 500000, \"profit margins\": 0.5}\n        else:\n            raise ValueError(\"Not all data points found in the PDF.\")\n    else:\n        raise FileNotFoundError(\"PDF file not found.\")\ndef update_financial_models(financial_data: dict) -> bool:\n    \"\"\"\n    Updates financial models with the extracted data.\n\n    :param financial_data: A dictionary containing the financial data to update the model with.\n                          The dictionary should contain keys like \"revenue\", \"expenses\", \"profit margins\".\n    :return: True if the models were updated successfully, False otherwise.\n    :raises ValueError: If the input data is invalid or missing required keys.\n    \"\"\"\n    if financial_data and all(key in financial_data for key in [\"revenue\", \"expenses\", \"profit margins\"]):\n        if isinstance(financial_data[\"revenue\"], (int, float)) and \\\n           isinstance(financial_data[\"expenses\"], (int, float)) and \\\n           isinstance(financial_data[\"profit margins\"], (int, float)):\n            return True\n        else:\n            raise ValueError(\"Invalid data types in financial_data\")\n\n    else:\n        raise ValueError(\"Invalid or missing data in financial_data\")\ndef parse_pdf_with_financepro(pdf_path: str) -> str:\n    \"\"\"\n    Parses a PDF document using FinancePro.\n\n    :param pdf_path: The path to the PDF file.\n    :return: A string indicating success or failure.\n    :raises Exception: If an error occurs during parsing.\n    \"\"\"\n    if pdf_path == \"Q3_Financial_Report_2023.pdf\":\n        return \"PDF parsed successfully.\"\n    else:\n        raise FileNotFoundError(\"PDF file not found.\")", "user_query": "Could you extract revenue and expenses data from Q3_Financial_Report_2023.pdf?", "checklist": {"functions": ["extract_data_from_pdf"], "values": [{"revenue": 1000000, "expenses": 500000, "profit margins": 0.5}]}}
{"difficulty": "easy", "function_schema_python": "def get_api_specification(url: str) -> dict:\n    \"\"\"Retrieves the OpenAPI specification from the provided URL.\n\n    :param url: The URL where the OpenAPI specification is hosted.\n    :return:\n        dict: A dictionary representing the OpenAPI specification with the following keys:\n            - info (dict): Information about the API.\n            - paths (dict): Paths and their operations.\n            - components (dict): Reusable components like schemas.\n    :raises ValueError: If the URL is incorrect or if the specification cannot be retrieved.\"\"\"\n    pass\ndef test_order_api(endpoint: str, method: str, payload: dict) -> dict:\n    \"\"\"Tests the Order Management API endpoint with a specific HTTP method and payload.\n\n    :param endpoint: The API endpoint to test (e.g., \"/orders\").\n    :param method: The HTTP method to use (e.g., \"GET\", \"POST\", \"PUT\", \"DELETE\").\n    :param payload: The payload to send with the request (valid only for POST and PUT).\n    :return:\n        dict: A dictionary representing the API response with the following keys:\n            - status (int): The HTTP status code.\n            - data (dict or list): The response data.\n            - headers (dict): The response headers.\n    :raises ValueError: If the endpoint, method, or payload is invalid.\"\"\"\n    pass\ndef simulate_high_load_tests(concurrent_requests: int) -> dict:\n    \"\"\"Simulates high load testing on the Order Management API.\n\n    :param concurrent_requests: The number of concurrent requests to simulate.\n    :return:\n        dict: A dictionary representing the test results with the following keys:\n            - success_rate (float): The percentage of successful requests.\n            - avg_response_time (float): The average response time in milliseconds.\n            - max_response_time (float): The maximum response time in milliseconds.\n    :raises ValueError: If the number of concurrent requests is invalid.\"\"\"\n    pass\n", "function_schema_json": [{"name": "get_api_specification", "description": "Retrieves the OpenAPI specification from the provided URL.", "parameters": {"type": "object", "properties": {"url": {"type": "string", "description": "The URL where the OpenAPI specification is hosted."}}, "required": ["url"], "additionalProperties": false}}, {"name": "test_order_api", "description": "Tests the Order Management API endpoint with a specific HTTP method and payload.", "parameters": {"type": "object", "properties": {"endpoint": {"type": "string", "description": "The API endpoint to test (e.g., \"/orders\")."}, "method": {"type": "string", "description": "The HTTP method to use (e.g., \"GET\", \"POST\", \"PUT\", \"DELETE\")."}, "payload": {"type": "object", "description": "The payload to send with the request (valid only for POST and PUT)."}}, "required": ["endpoint", "method", "payload"], "additionalProperties": false}}, {"name": "simulate_high_load_tests", "description": "Simulates high load testing on the Order Management API.", "parameters": {"type": "object", "properties": {"concurrent_requests": {"type": "integer", "description": "The number of concurrent requests to simulate."}}, "required": ["concurrent_requests"], "additionalProperties": false}}], "mock_functions": "def get_api_specification(url: str) -> dict:\n    \"\"\"\n    Retrieves the OpenAPI specification from the provided URL.\n    \n    :param url: The URL where the OpenAPI specification is hosted.\n    :return:\n        dict: A dictionary representing the OpenAPI specification with the following keys:\n            - info (dict): Information about the API.\n            - paths (dict): Paths and their operations.\n            - components (dict): Reusable components like schemas.\n    :raises ValueError: If the URL is incorrect or if the specification cannot be retrieved.\n    \"\"\"\n    if url == \"https://acmecorp.com/api/om-42/openapi.yaml\":\n        return {\n            \"info\": {\"title\": \"Order Management API\", \"version\": \"1.0.0\"},\n            \"paths\": {\n                \"/orders\": {\n                    \"get\": {\"summary\": \"Retrieve a list of orders\", \"operationId\": \"getOrders\"},\n                    \"post\": {\"summary\": \"Place a new order\", \"operationId\": \"placeOrder\"},\n                    \"put\": {\"summary\": \"Update an existing order\", \"operationId\": \"updateOrder\"},\n                    \"delete\": {\"summary\": \"Cancel an order\", \"operationId\": \"cancelOrder\"}\n                }\n            },\n            \"components\": {\n                \"schemas\": {\n                    \"Order\": {\n                        \"type\": \"object\",\n                        \"properties\": {\n                            \"orderId\": {\"type\": \"string\"},\n                            \"customerId\": {\"type\": \"string\"},\n                            \"items\": {\"type\": \"array\", \"items\": {\"type\": \"object\"}},\n                            \"status\": {\"type\": \"string\"}\n                        }\n                    }\n                }\n            }\n        }\n    raise ValueError(\"Incorrect URL or unable to retrieve the specification.\")\ndef test_order_api(endpoint: str, method: str, payload: dict = None) -> dict:\n    \"\"\"\n    Tests the Order Management API endpoint with a specific HTTP method and payload.\n    \n    :param endpoint: The API endpoint to test (e.g., \"/orders\").\n    :param method: The HTTP method to use (e.g., \"GET\", \"POST\", \"PUT\", \"DELETE\").\n    :param payload: The payload to send with the request (valid only for POST and PUT).\n    :return:\n        dict: A dictionary representing the API response with the following keys:\n            - status (int): The HTTP status code.\n            - data (dict or list): The response data.\n            - headers (dict): The response headers.\n    :raises ValueError: If the endpoint, method, or payload is invalid.\n    \"\"\"\n    if endpoint != \"/orders\":\n        raise ValueError(\"Invalid endpoint.\")\n    \n    valid_methods = [\"GET\", \"POST\", \"PUT\", \"DELETE\"]\n    if method not in valid_methods:\n        raise ValueError(\"Invalid HTTP method.\")\n    \n    response = {\n        \"status\": None,\n        \"data\": None,\n        \"headers\": {\"Content-Type\": \"application/json\"}\n    }\n    \n    if method == \"GET\":\n        response[\"status\"] = 200\n        response[\"data\"] = [{\"orderId\": \"1\", \"customerId\": \"C-101\", \"items\": [{\"itemId\": \"I-201\", \"quantity\": 2}], \"status\": \"Processing\"}]\n        \n    elif method == \"POST\":\n        if not payload:\n            raise ValueError(\"Payload is required for POST method.\")\n        response[\"status\"] = 201\n        response[\"data\"] = {**payload, \"orderId\": str(random.randint(1000, 9999)), \"status\": \"Received\"}\n        \n    elif method == \"PUT\":\n        if not payload:\n            raise ValueError(\"Payload is required for PUT method.\")\n        response[\"status\"] = 200\n        response[\"data\"] = {**payload, \"status\": \"Updated\"}\n        \n    elif method == \"DELETE\":\n        response[\"status\"] = 204\n        response[\"data\"] = {}\n    \n    return response\ndef simulate_high_load_tests(concurrent_requests: int) -> dict:\n    \"\"\"\n    Simulates high load testing on the Order Management API.\n    \n    :param concurrent_requests: The number of concurrent requests to simulate.\n    :return:\n        dict: A dictionary representing the test results with the following keys:\n            - success_rate (float): The percentage of successful requests.\n            - avg_response_time (float): The average response time in milliseconds.\n            - max_response_time (float): The maximum response time in milliseconds.\n    :raises ValueError: If the number of concurrent requests is invalid.\n    \"\"\"\n    if concurrent_requests <= 0:\n        raise ValueError(\"Number of concurrent requests must be greater than zero.\")\n    \n    # Simulate random success rates and response times for a high load test\n    success_count = random.randint(80, concurrent_requests)\n    response_times = [random.uniform(50, 1000) for _ in range(success_count)] + [random.uniform(1000, 5000) for _ in range(concurrent_requests - success_count)]\n    \n    return {\n        \"success_rate\": (success_count / concurrent_requests) * 100,\n        \"avg_response_time\": sum(response_times) / len(response_times) if response_times else 0,\n        \"max_response_time\": max(response_times) if response_times else 0\n    }", "user_query": "This is Sarah at Acme Corp. Can you simulate a high load test on the Order Management API with 500 concurrent requests, then summarize the success rate and response times?", "checklist": {"functions": ["simulate_high_load_tests"], "values": [{"success_rate": "float", "avg_response_time": "float", "max_response_time": "float"}]}}
{"difficulty": "easy", "function_schema_python": "def get_api_specification(url: str) -> dict:\n    \"\"\"Retrieves the OpenAPI specification from the provided URL.\n\n    :param url: The URL where the OpenAPI specification is hosted.\n    :return:\n        dict: A dictionary representing the OpenAPI specification with the following keys:\n            - info (dict): Information about the API.\n            - paths (dict): Paths and their operations.\n            - components (dict): Reusable components like schemas.\n    :raises ValueError: If the URL is incorrect or if the specification cannot be retrieved.\"\"\"\n    pass\ndef test_order_api(endpoint: str, method: str, payload: dict) -> dict:\n    \"\"\"Tests the Order Management API endpoint with a specific HTTP method and payload.\n\n    :param endpoint: The API endpoint to test (e.g., \"/orders\").\n    :param method: The HTTP method to use (e.g., \"GET\", \"POST\", \"PUT\", \"DELETE\").\n    :param payload: The payload to send with the request (valid only for POST and PUT).\n    :return:\n        dict: A dictionary representing the API response with the following keys:\n            - status (int): The HTTP status code.\n            - data (dict or list): The response data.\n            - headers (dict): The response headers.\n    :raises ValueError: If the endpoint, method, or payload is invalid.\"\"\"\n    pass\ndef simulate_high_load_tests(concurrent_requests: int) -> dict:\n    \"\"\"Simulates high load testing on the Order Management API.\n\n    :param concurrent_requests: The number of concurrent requests to simulate.\n    :return:\n        dict: A dictionary representing the test results with the following keys:\n            - success_rate (float): The percentage of successful requests.\n            - avg_response_time (float): The average response time in milliseconds.\n            - max_response_time (float): The maximum response time in milliseconds.\n    :raises ValueError: If the number of concurrent requests is invalid.\"\"\"\n    pass\n", "function_schema_json": [{"name": "get_api_specification", "description": "Retrieves the OpenAPI specification from the provided URL.", "parameters": {"type": "object", "properties": {"url": {"type": "string", "description": "The URL where the OpenAPI specification is hosted."}}, "required": ["url"], "additionalProperties": false}}, {"name": "test_order_api", "description": "Tests the Order Management API endpoint with a specific HTTP method and payload.", "parameters": {"type": "object", "properties": {"endpoint": {"type": "string", "description": "The API endpoint to test (e.g., \"/orders\")."}, "method": {"type": "string", "description": "The HTTP method to use (e.g., \"GET\", \"POST\", \"PUT\", \"DELETE\")."}, "payload": {"type": "object", "description": "The payload to send with the request (valid only for POST and PUT)."}}, "required": ["endpoint", "method", "payload"], "additionalProperties": false}}, {"name": "simulate_high_load_tests", "description": "Simulates high load testing on the Order Management API.", "parameters": {"type": "object", "properties": {"concurrent_requests": {"type": "integer", "description": "The number of concurrent requests to simulate."}}, "required": ["concurrent_requests"], "additionalProperties": false}}], "mock_functions": "def get_api_specification(url: str) -> dict:\n    \"\"\"\n    Retrieves the OpenAPI specification from the provided URL.\n    \n    :param url: The URL where the OpenAPI specification is hosted.\n    :return:\n        dict: A dictionary representing the OpenAPI specification with the following keys:\n            - info (dict): Information about the API.\n            - paths (dict): Paths and their operations.\n            - components (dict): Reusable components like schemas.\n    :raises ValueError: If the URL is incorrect or if the specification cannot be retrieved.\n    \"\"\"\n    if url == \"https://acmecorp.com/api/om-42/openapi.yaml\":\n        return {\n            \"info\": {\"title\": \"Order Management API\", \"version\": \"1.0.0\"},\n            \"paths\": {\n                \"/orders\": {\n                    \"get\": {\"summary\": \"Retrieve a list of orders\", \"operationId\": \"getOrders\"},\n                    \"post\": {\"summary\": \"Place a new order\", \"operationId\": \"placeOrder\"},\n                    \"put\": {\"summary\": \"Update an existing order\", \"operationId\": \"updateOrder\"},\n                    \"delete\": {\"summary\": \"Cancel an order\", \"operationId\": \"cancelOrder\"}\n                }\n            },\n            \"components\": {\n                \"schemas\": {\n                    \"Order\": {\n                        \"type\": \"object\",\n                        \"properties\": {\n                            \"orderId\": {\"type\": \"string\"},\n                            \"customerId\": {\"type\": \"string\"},\n                            \"items\": {\"type\": \"array\", \"items\": {\"type\": \"object\"}},\n                            \"status\": {\"type\": \"string\"}\n                        }\n                    }\n                }\n            }\n        }\n    raise ValueError(\"Incorrect URL or unable to retrieve the specification.\")\ndef test_order_api(endpoint: str, method: str, payload: dict = None) -> dict:\n    \"\"\"\n    Tests the Order Management API endpoint with a specific HTTP method and payload.\n    \n    :param endpoint: The API endpoint to test (e.g., \"/orders\").\n    :param method: The HTTP method to use (e.g., \"GET\", \"POST\", \"PUT\", \"DELETE\").\n    :param payload: The payload to send with the request (valid only for POST and PUT).\n    :return:\n        dict: A dictionary representing the API response with the following keys:\n            - status (int): The HTTP status code.\n            - data (dict or list): The response data.\n            - headers (dict): The response headers.\n    :raises ValueError: If the endpoint, method, or payload is invalid.\n    \"\"\"\n    if endpoint != \"/orders\":\n        raise ValueError(\"Invalid endpoint.\")\n    \n    valid_methods = [\"GET\", \"POST\", \"PUT\", \"DELETE\"]\n    if method not in valid_methods:\n        raise ValueError(\"Invalid HTTP method.\")\n    \n    response = {\n        \"status\": None,\n        \"data\": None,\n        \"headers\": {\"Content-Type\": \"application/json\"}\n    }\n    \n    if method == \"GET\":\n        response[\"status\"] = 200\n        response[\"data\"] = [{\"orderId\": \"1\", \"customerId\": \"C-101\", \"items\": [{\"itemId\": \"I-201\", \"quantity\": 2}], \"status\": \"Processing\"}]\n        \n    elif method == \"POST\":\n        if not payload:\n            raise ValueError(\"Payload is required for POST method.\")\n        response[\"status\"] = 201\n        response[\"data\"] = {**payload, \"orderId\": str(random.randint(1000, 9999)), \"status\": \"Received\"}\n        \n    elif method == \"PUT\":\n        if not payload:\n            raise ValueError(\"Payload is required for PUT method.\")\n        response[\"status\"] = 200\n        response[\"data\"] = {**payload, \"status\": \"Updated\"}\n        \n    elif method == \"DELETE\":\n        response[\"status\"] = 204\n        response[\"data\"] = {}\n    \n    return response\ndef simulate_high_load_tests(concurrent_requests: int) -> dict:\n    \"\"\"\n    Simulates high load testing on the Order Management API.\n    \n    :param concurrent_requests: The number of concurrent requests to simulate.\n    :return:\n        dict: A dictionary representing the test results with the following keys:\n            - success_rate (float): The percentage of successful requests.\n            - avg_response_time (float): The average response time in milliseconds.\n            - max_response_time (float): The maximum response time in milliseconds.\n    :raises ValueError: If the number of concurrent requests is invalid.\n    \"\"\"\n    if concurrent_requests <= 0:\n        raise ValueError(\"Number of concurrent requests must be greater than zero.\")\n    \n    # Simulate random success rates and response times for a high load test\n    success_count = random.randint(80, concurrent_requests)\n    response_times = [random.uniform(50, 1000) for _ in range(success_count)] + [random.uniform(1000, 5000) for _ in range(concurrent_requests - success_count)]\n    \n    return {\n        \"success_rate\": (success_count / concurrent_requests) * 100,\n        \"avg_response_time\": sum(response_times) / len(response_times) if response_times else 0,\n        \"max_response_time\": max(response_times) if response_times else 0\n    }", "user_query": "This is Sarah testing the Order Management API's `/orders` endpoint. Could you please execute a POST method to place a new order with payload: {\"customerId\": \"C-202\", \"items\": [{\"itemId\": \"I-403\", \"quantity\": 1}]} and provide the JSON response?", "checklist": {"functions": ["test_order_api"], "values": [{"status": 201, "data": {"customerId": "C-202", "items": [{"itemId": "I-403", "quantity": 1}], "orderId": "<random 4-digit integer>", "status": "Received"}, "headers": {"Content-Type": "application/json"}}]}}
